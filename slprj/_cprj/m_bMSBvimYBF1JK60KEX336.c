/* Include files */

#include "modelInterface.h"
#include "m_bMSBvimYBF1JK60KEX336.h"
#include <emmintrin.h>
#include <math.h>
#include <string.h>
#include "mwmathutil.h"

/* Type Definitions */

/* Named Constants */

/* Variable Declarations */

/* Variable Definitions */
static emlrtRSInfo emlrtRSI = { 47,    /* lineNo */
  "cameraIntrinsics",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\cameraIntrinsics.m"/* pathName */
};

static emlrtRSInfo b_emlrtRSI = { 1,   /* lineNo */
  "System",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\system\\coder\\+matlab\\+system\\+coder\\System.p"/* pathName */
};

static emlrtRSInfo c_emlrtRSI = { 1,   /* lineNo */
  "SystemProp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\system\\coder\\+matlab\\+system\\+coder\\SystemProp.p"/* pathName */
};

static emlrtRSInfo d_emlrtRSI = { 1,   /* lineNo */
  "SystemCore",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\system\\coder\\+matlab\\+system\\+coder\\SystemCore.p"/* pathName */
};

static emlrtRSInfo e_emlrtRSI = { 271, /* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo f_emlrtRSI = { 1,   /* lineNo */
  "SimulinkBusUtilities",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\blks\\+matlabshared\\+tracking\\+internal\\SimulinkBusUtilities.p"/* pathName */
};

static emlrtRSInfo g_emlrtRSI = { 1,   /* lineNo */
  "SimulinkBusPropagation",            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\blks\\+matlabshared\\+tracking\\+internal\\SimulinkBusPropagation."
  "p"                                  /* pathName */
};

static emlrtRSInfo h_emlrtRSI = { 1,   /* lineNo */
  "SensorBase",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\ssfsensorbase\\ssfsensorbase\\+matlabshared\\+scenario\\+SensorSimulation\\S"
  "ensorBase.m"                        /* pathName */
};

static emlrtRSInfo i_emlrtRSI = { 77,  /* lineNo */
  "",                                  /* fcnName */
  ""                                   /* pathName */
};

static emlrtRSInfo j_emlrtRSI = { 37,  /* lineNo */
  "",                                  /* fcnName */
  ""                                   /* pathName */
};

static emlrtRSInfo k_emlrtRSI = { 82,  /* lineNo */
  "",                                  /* fcnName */
  ""                                   /* pathName */
};

static emlrtRSInfo l_emlrtRSI = { 1037,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo m_emlrtRSI = { 1040,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo n_emlrtRSI = { 1064,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo o_emlrtRSI = { 1104,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo p_emlrtRSI = { 1105,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo q_emlrtRSI = { 1108,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo r_emlrtRSI = { 1111,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo s_emlrtRSI = { 1,   /* lineNo */
  "ProcessConstructorArguments",       /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\system\\coder\\+matlab\\+system\\+coder\\ProcessConstructorArguments.p"/* pathName */
};

static emlrtRSInfo t_emlrtRSI = { 728, /* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo u_emlrtRSI = { 723, /* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo v_emlrtRSI = { 85,  /* lineNo */
  "cameraIntrinsics",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\cameraIntrinsics.m"/* pathName */
};

static emlrtRSInfo w_emlrtRSI = { 25,  /* lineNo */
  "cameraIntrinsics",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+codegen\\cameraIntrinsics.m"/* pathName */
};

static emlrtRSInfo x_emlrtRSI = { 26,  /* lineNo */
  "cameraIntrinsics",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+codegen\\cameraIntrinsics.m"/* pathName */
};

static emlrtRSInfo y_emlrtRSI = { 79,  /* lineNo */
  "cameraIntrinsicsImpl",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\cameraIntrinsicsImpl.m"/* pathName */
};

static emlrtRSInfo ab_emlrtRSI = { 99, /* lineNo */
  "cameraIntrinsicsImpl",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\cameraIntrinsicsImpl.m"/* pathName */
};

static emlrtRSInfo bb_emlrtRSI = { 107,/* lineNo */
  "cameraIntrinsicsImpl",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\cameraIntrinsicsImpl.m"/* pathName */
};

static emlrtRSInfo cb_emlrtRSI = { 1,  /* lineNo */
  "cameraIntrinsicsBase",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\cameraIntrinsicsBase.m"/* pathName */
};

static emlrtRSInfo db_emlrtRSI = { 23, /* lineNo */
  "ImageTransformer",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+calibration\\ImageTransformer.m"/* pathName */
};

static emlrtRSInfo eb_emlrtRSI = { 43, /* lineNo */
  "ImageTransformerBase",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+calibration\\ImageTransformerBase.m"/* pathName */
};

static emlrtRSInfo fb_emlrtRSI = { 305,/* lineNo */
  "cameraIntrinsics",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+codegen\\cameraIntrinsics.m"/* pathName */
};

static emlrtRSInfo gb_emlrtRSI = { 34, /* lineNo */
  "cameraIntrinsicsArray",             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+codegen\\cameraIntrinsicsArray.m"/* pathName */
};

static emlrtRSInfo hb_emlrtRSI = { 2792,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ib_emlrtRSI = { 93, /* lineNo */
  "validateattributes",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\lang\\validateattributes.m"/* pathName */
};

static emlrtRSInfo jb_emlrtRSI = { 11, /* lineNo */
  "validatescalar",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatescalar.m"/* pathName */
};

static emlrtRSInfo kb_emlrtRSI = { 57, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo lb_emlrtRSI = { 53, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo mb_emlrtRSI = { 66, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo nb_emlrtRSI = { 70, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ob_emlrtRSI = { 71, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo pb_emlrtRSI = { 72, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo qb_emlrtRSI = { 73, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo rb_emlrtRSI = { 347,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo sb_emlrtRSI = { 6,  /* lineNo */
  "ValueCodegen",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\vision\\vision\\+vision\\+internal\\+enforcescalar\\ValueCodegen.m"/* pathName */
};

static emlrtRSInfo tb_emlrtRSI = { 99, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ub_emlrtRSI = { 2658,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vb_emlrtRSI = { 2659,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wb_emlrtRSI = { 120,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo xb_emlrtRSI = { 397,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo yb_emlrtRSI = { 181,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ac_emlrtRSI = { 182,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo bc_emlrtRSI = { 185,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo cc_emlrtRSI = { 309,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo dc_emlrtRSI = { 192,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ec_emlrtRSI = { 332,/* lineNo */
  "projective2d",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pathName */
};

static emlrtRSInfo fc_emlrtRSI = { 2671,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gc_emlrtRSI = { 2676,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hc_emlrtRSI = { 2076,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ic_emlrtRSI = { 2109,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jc_emlrtRSI = { 2110,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kc_emlrtRSI = { 2112,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lc_emlrtRSI = { 51, /* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo mc_emlrtRSI = { 2238,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo nc_emlrtRSI = { 113,/* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo oc_emlrtRSI = { 294,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo pc_emlrtRSI = { 164,/* lineNo */
  "rng",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\randfun\\rng.m"/* pathName */
};

static emlrtRSInfo qc_emlrtRSI = { 157,/* lineNo */
  "rng",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\randfun\\rng.m"/* pathName */
};

static emlrtRSInfo rc_emlrtRSI = { 711,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo sc_emlrtRSI = { 1123,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo tc_emlrtRSI = { 1139,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo uc_emlrtRSI = { 1140,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vc_emlrtRSI = { 1141,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wc_emlrtRSI = { 1146,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xc_emlrtRSI = { 1147,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo yc_emlrtRSI = { 1151,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ad_emlrtRSI = { 1154,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bd_emlrtRSI = { 1157,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cd_emlrtRSI = { 1158,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dd_emlrtRSI = { 1132,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ed_emlrtRSI = { 1126,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fd_emlrtRSI = { 2455,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gd_emlrtRSI = { 2466,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hd_emlrtRSI = { 2501,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo id_emlrtRSI = { 2504,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jd_emlrtRSI = { 2507,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kd_emlrtRSI = { 2515,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ld_emlrtRSI = { 2543,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo md_emlrtRSI = { 94, /* lineNo */
  "eml_mtimes_helper",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pathName */
};

static emlrtRSInfo nd_emlrtRSI = { 149,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo od_emlrtRSI = { 86, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo pd_emlrtRSI = { 2566,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qd_emlrtRSI = { 856,/* lineNo */
  "ComputationalGeometry",             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\Computati"
  "onalGeometry.m"                     /* pathName */
};

static emlrtRSInfo rd_emlrtRSI = { 53, /* lineNo */
  "div",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\div.m"/* pathName */
};

static emlrtRSInfo sd_emlrtRSI = { 78, /* lineNo */
  "div",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\div.m"/* pathName */
};

static emlrtRSInfo td_emlrtRSI = { 130,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ud_emlrtRSI = { 131,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo vd_emlrtRSI = { 132,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo wd_emlrtRSI = { 135,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo xd_emlrtRSI = { 160,/* lineNo */
  "projective2d",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pathName */
};

static emlrtRSInfo yd_emlrtRSI = { 69, /* lineNo */
  "eml_mtimes_helper",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pathName */
};

static emlrtRSInfo ae_emlrtRSI = { 80, /* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo be_emlrtRSI = { 204,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo ce_emlrtRSI = { 355,/* lineNo */
  "projective2d",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pathName */
};

static emlrtRSInfo de_emlrtRSI = { 31, /* lineNo */
  "inv",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\inv.m"/* pathName */
};

static emlrtRSInfo ee_emlrtRSI = { 42, /* lineNo */
  "inv",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\inv.m"/* pathName */
};

static emlrtRSInfo fe_emlrtRSI = { 46, /* lineNo */
  "inv",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\inv.m"/* pathName */
};

static emlrtRSInfo ge_emlrtRSI = { 84, /* lineNo */
  "",                                  /* fcnName */
  ""                                   /* pathName */
};

static emlrtRSInfo he_emlrtRSI = { 89, /* lineNo */
  "",                                  /* fcnName */
  ""                                   /* pathName */
};

static emlrtRSInfo ie_emlrtRSI = { 1171,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo je_emlrtRSI = { 379,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ke_emlrtRSI = { 1211,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo le_emlrtRSI = { 1212,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo me_emlrtRSI = { 1213,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ne_emlrtRSI = { 1215,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo oe_emlrtRSI = { 2943,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo pe_emlrtRSI = { 2944,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qe_emlrtRSI = { 1475,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo re_emlrtRSI = { 1483,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo se_emlrtRSI = { 1501,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo te_emlrtRSI = { 1505,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ue_emlrtRSI = { 1509,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ve_emlrtRSI = { 1512,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo we_emlrtRSI = { 1519,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xe_emlrtRSI = { 1520,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ye_emlrtRSI = { 1522,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo af_emlrtRSI = { 1525,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bf_emlrtRSI = { 1503,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cf_emlrtRSI = { 1358,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo df_emlrtRSI = { 1366,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ef_emlrtRSI = { 1406,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ff_emlrtRSI = { 1415,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gf_emlrtRSI = { 1430,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hf_emlrtRSI = { 1438,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo if_emlrtRSI = { 1446,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jf_emlrtRSI = { 1454,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kf_emlrtRSI = { 1277,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lf_emlrtRSI = { 1272,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mf_emlrtRSI = { 34, /* lineNo */
  "repmat",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\repmat.m"/* pathName */
};

static emlrtRSInfo nf_emlrtRSI = { 77, /* lineNo */
  "SensorBase",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\ssfsensorbase\\ssfsensorbase\\+matlabshared\\+scenario\\+SensorSimulation\\S"
  "ensorBase.m"                        /* pathName */
};

static emlrtRSInfo of_emlrtRSI = { 61, /* lineNo */
  "SensorBase",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\ssfsensorbase\\ssfsensorbase\\+matlabshared\\+scenario\\+SensorSimulation\\S"
  "ensorBase.m"                        /* pathName */
};

static emlrtRSInfo pf_emlrtRSI = { 1,  /* lineNo */
  "SensorSimCoder",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\ssfcodegen\\+matlabshared\\+scenario\\+SensorSimulation\\+coder\\SensorSimCo"
  "der.p"                              /* pathName */
};

static emlrtRSInfo qf_emlrtRSI = { 59, /* lineNo */
  "arrayfun",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\datatypes\\applyfuns\\arrayfun.m"/* pathName */
};

static emlrtRSInfo rf_emlrtRSI = { 120,/* lineNo */
  "arrayfun",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\datatypes\\applyfuns\\arrayfun.m"/* pathName */
};

static emlrtRSInfo sf_emlrtRSI = { 42, /* lineNo */
  "indexShapeCheck",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\indexShapeCheck.m"/* pathName */
};

static emlrtRSInfo tf_emlrtRSI = { 1038,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo uf_emlrtRSI = { 1046,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vf_emlrtRSI = { 1049,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wf_emlrtRSI = { 1054,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xf_emlrtRSI = { 1060,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo yf_emlrtRSI = { 1063,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ag_emlrtRSI = { 1069,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bg_emlrtRSI = { 1072,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cg_emlrtRSI = { 1087,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dg_emlrtRSI = { 1090,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo eg_emlrtRSI = { 1096,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fg_emlrtRSI = { 1099,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gg_emlrtRSI = { 1105,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hg_emlrtRSI = { 1108,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ig_emlrtRSI = { 1114,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jg_emlrtRSI = { 1117,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kg_emlrtRSI = { 1158,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lg_emlrtRSI = { 1166,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mg_emlrtRSI = { 48, /* lineNo */
  "unique",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\unique.m"/* pathName */
};

static emlrtRSInfo ng_emlrtRSI = { 1322,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo og_emlrtRSI = { 55, /* lineNo */
  "shiftdim",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\shiftdim.m"/* pathName */
};

static emlrtRSInfo pg_emlrtRSI = { 2935,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qg_emlrtRSI = { 2938,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rg_emlrtRSI = { 2983,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo sg_emlrtRSI = { 2995,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo tg_emlrtRSI = { 1746,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ug_emlrtRSI = { 1739,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vg_emlrtRSI = { 1738,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wg_emlrtRSI = { 1721,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xg_emlrtRSI = { 1694,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo yg_emlrtRSI = { 1654,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ah_emlrtRSI = { 1651,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bh_emlrtRSI = { 1635,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ch_emlrtRSI = { 1632,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dh_emlrtRSI = { 1624,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo eh_emlrtRSI = { 1618,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fh_emlrtRSI = { 1609,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gh_emlrtRSI = { 1604,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hh_emlrtRSI = { 1593,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ih_emlrtRSI = { 1589,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jh_emlrtRSI = { 1588,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kh_emlrtRSI = { 1564,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lh_emlrtRSI = { 1556,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mh_emlrtRSI = { 1553,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo nh_emlrtRSI = { 1550,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo oh_emlrtRSI = { 1545,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ph_emlrtRSI = { 1533,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qh_emlrtRSI = { 703,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rh_emlrtRSI = { 1335,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo sh_emlrtRSI = { 1235,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo th_emlrtRSI = { 1230,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo uh_emlrtRSI = { 1218,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vh_emlrtRSI = { 171,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo wh_emlrtRSI = { 290,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo xh_emlrtRSI = { 291,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo yh_emlrtRSI = { 230,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo ai_emlrtRSI = { 244,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo bi_emlrtRSI = { 18, /* lineNo */
  "isSymmetricPositiveSemiDefinite",   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\trackinglib\\+matlabshared\\+tracking\\+internal\\isSymmetricPosit"
  "iveSemiDefinite.m"                  /* pathName */
};

static emlrtRSInfo ci_emlrtRSI = { 20, /* lineNo */
  "isSymmetricPositiveSemiDefinite",   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\trackinglib\\+matlabshared\\+tracking\\+internal\\isSymmetricPosit"
  "iveSemiDefinite.m"                  /* pathName */
};

static emlrtRSInfo di_emlrtRSI = { 127,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo ei_emlrtRSI = { 135,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo fi_emlrtRSI = { 143,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo gi_emlrtRSI = { 13, /* lineNo */
  "eigHermitianStandard",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigHermitianStandard.m"/* pathName */
};

static emlrtRSInfo hi_emlrtRSI = { 40, /* lineNo */
  "eigHermitianStandard",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigHermitianStandard.m"/* pathName */
};

static emlrtRSInfo ii_emlrtRSI = { 8,  /* lineNo */
  "xsyheev",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xsyheev.m"/* pathName */
};

static emlrtRSInfo ji_emlrtRSI = { 27, /* lineNo */
  "xzsyheev",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyheev.m"/* pathName */
};

static emlrtRSInfo ki_emlrtRSI = { 28, /* lineNo */
  "xzsyheev",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyheev.m"/* pathName */
};

static emlrtRSInfo li_emlrtRSI = { 56, /* lineNo */
  "xzsyheev",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyheev.m"/* pathName */
};

static emlrtRSInfo mi_emlrtRSI = { 35, /* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo ni_emlrtRSI = { 103,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo oi_emlrtRSI = { 104,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo pi_emlrtRSI = { 118,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo qi_emlrtRSI = { 172,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo ri_emlrtRSI = { 173,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo si_emlrtRSI = { 188,/* lineNo */
  "xdsterf",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdsterf.m"/* pathName */
};

static emlrtRSInfo ti_emlrtRSI = { 24, /* lineNo */
  "xdlaev2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlaev2.m"/* pathName */
};

static emlrtRSInfo ui_emlrtRSI = { 26, /* lineNo */
  "xdlaev2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlaev2.m"/* pathName */
};

static emlrtRSInfo vi_emlrtRSI = { 29, /* lineNo */
  "xdlaev2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlaev2.m"/* pathName */
};

static emlrtRSInfo wi_emlrtRSI = { 10, /* lineNo */
  "eigSkewHermitianStandard",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigSkewHermitianStandard.m"/* pathName */
};

static emlrtRSInfo xi_emlrtRSI = { 19, /* lineNo */
  "eigRealSkewSymmetricStandard",      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigRealSkewSymmetricStandard.m"/* pathName */
};

static emlrtRSInfo yi_emlrtRSI = { 54, /* lineNo */
  "schur",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\schur.m"/* pathName */
};

static emlrtRSInfo aj_emlrtRSI = { 83, /* lineNo */
  "schur",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\schur.m"/* pathName */
};

static emlrtRSInfo bj_emlrtRSI = { 32, /* lineNo */
  "xhseqr",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xhseqr.m"/* pathName */
};

static emlrtRSInfo cj_emlrtRSI = { 22, /* lineNo */
  "xdhseqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhseqr.m"/* pathName */
};

static emlrtRSInfo dj_emlrtRSI = { 337,/* lineNo */
  "xdlahqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlahqr.m"/* pathName */
};

static emlrtRSInfo ej_emlrtRSI = { 172,/* lineNo */
  "xdlahqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlahqr.m"/* pathName */
};

static emlrtRSInfo fj_emlrtRSI = { 52, /* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo gj_emlrtRSI = { 81, /* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo hj_emlrtRSI = { 102,/* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo ij_emlrtRSI = { 103,/* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo jj_emlrtRSI = { 105,/* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo kj_emlrtRSI = { 133,/* lineNo */
  "xdlanv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlanv2.m"/* pathName */
};

static emlrtRSInfo lj_emlrtRSI = { 34, /* lineNo */
  "eigStandard",                       /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigStandard.m"/* pathName */
};

static emlrtRSInfo mj_emlrtRSI = { 45, /* lineNo */
  "eigStandard",                       /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigStandard.m"/* pathName */
};

static emlrtRSInfo nj_emlrtRSI = { 73, /* lineNo */
  "xdgeev",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdgeev.m"/* pathName */
};

static emlrtRSInfo oj_emlrtRSI = { 197,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo pj_emlrtRSI = { 188,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo qj_emlrtRSI = { 816,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rj_emlrtRSI = { 821,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo sj_emlrtRSI = { 826,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo tj_emlrtRSI = { 827,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo uj_emlrtRSI = { 829,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vj_emlrtRSI = { 832,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wj_emlrtRSI = { 833,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xj_emlrtRSI = { 884,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo yj_emlrtRSI = { 888,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ak_emlrtRSI = { 2305,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bk_emlrtRSI = { 2299,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ck_emlrtRSI = { 2281,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dk_emlrtRSI = { 2269,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ek_emlrtRSI = { 2249,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fk_emlrtRSI = { 55, /* lineNo */
  "backfaceCull",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "backfaceCull.m"                     /* pathName */
};

static emlrtRSInfo gk_emlrtRSI = { 30, /* lineNo */
  "isFacing",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "isFacing.m"                         /* pathName */
};

static emlrtRSInfo hk_emlrtRSI = { 38, /* lineNo */
  "isFacing",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "isFacing.m"                         /* pathName */
};

static emlrtRSInfo ik_emlrtRSI = { 45, /* lineNo */
  "isFacing",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "isFacing.m"                         /* pathName */
};

static emlrtRSInfo jk_emlrtRSI = { 55, /* lineNo */
  "faceNorm",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "faceNorm.m"                         /* pathName */
};

static emlrtRSInfo kk_emlrtRSI = { 53, /* lineNo */
  "faceNorm",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "faceNorm.m"                         /* pathName */
};

static emlrtRSInfo lk_emlrtRSI = { 40, /* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo mk_emlrtRSI = { 17, /* lineNo */
  "unitVector",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "unitVector.m"                       /* pathName */
};

static emlrtRSInfo nk_emlrtRSI = { 19, /* lineNo */
  "unitVector",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "unitVector.m"                       /* pathName */
};

static emlrtRSInfo ok_emlrtRSI = { 20, /* lineNo */
  "unitVector",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "unitVector.m"                       /* pathName */
};

static emlrtRSInfo pk_emlrtRSI = { 119,/* lineNo */
  "norm",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\norm.m"/* pathName */
};

static emlrtRSInfo qk_emlrtRSI = { 156,/* lineNo */
  "norm",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\norm.m"/* pathName */
};

static emlrtRSInfo rk_emlrtRSI = { 31, /* lineNo */
  "xgesvd",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xgesvd.m"/* pathName */
};

static emlrtRSInfo sk_emlrtRSI = { 58, /* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo tk_emlrtRSI = { 21, /* lineNo */
  "scaleVectorByRecip",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\scaleVectorByRecip.m"/* pathName */
};

static emlrtRSInfo uk_emlrtRSI = { 32, /* lineNo */
  "xrotg",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+refblas\\xrotg.m"/* pathName */
};

static emlrtRSInfo vk_emlrtRSI = { 13, /* lineNo */
  "colvecnorm",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "colvecnorm.m"                       /* pathName */
};

static emlrtRSInfo wk_emlrtRSI = { 125,/* lineNo */
  "splitFace",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m"                        /* pathName */
};

static emlrtRSInfo xk_emlrtRSI = { 92, /* lineNo */
  "splitFace",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m"                        /* pathName */
};

static emlrtRSInfo yk_emlrtRSI = { 58, /* lineNo */
  "minOrMax",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\minOrMax.m"/* pathName */
};

static emlrtRSInfo al_emlrtRSI = { 254,/* lineNo */
  "splitFace",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m"                        /* pathName */
};

static emlrtRSInfo bl_emlrtRSI = { 37, /* lineNo */
  "intersectLinesPlane",               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "intersectLinesPlane.m"              /* pathName */
};

static emlrtRSInfo cl_emlrtRSI = { 38, /* lineNo */
  "intersectLinesPlane",               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "intersectLinesPlane.m"              /* pathName */
};

static emlrtRSInfo dl_emlrtRSI = { 11, /* lineNo */
  "cart2sph",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cart2sph.m"/* pathName */
};

static emlrtRSInfo el_emlrtRSI = { 12, /* lineNo */
  "cart2sph",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cart2sph.m"/* pathName */
};

static emlrtRSInfo fl_emlrtRSI = { 13, /* lineNo */
  "cart2sph",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cart2sph.m"/* pathName */
};

static emlrtRSInfo gl_emlrtRSI = { 14, /* lineNo */
  "cart2sph",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cart2sph.m"/* pathName */
};

static emlrtRSInfo hl_emlrtRSI = { 32, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo il_emlrtRSI = { 27, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo jl_emlrtRSI = { 22, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo kl_emlrtRSI = { 18, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo ll_emlrtRSI = { 13, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo ml_emlrtRSI = { 12, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo nl_emlrtRSI = { 39, /* lineNo */
  "find",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\find.m"/* pathName */
};

static emlrtRSInfo ol_emlrtRSI = { 60, /* lineNo */
  "minOrMax",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\minOrMax.m"/* pathName */
};

static emlrtRSInfo pl_emlrtRSI = { 125,/* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo ql_emlrtRSI = { 73, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo rl_emlrtRSI = { 74, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo sl_emlrtRSI = { 21, /* lineNo */
  "qhullReject2D",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\private\\qhullReject2D.m"/* pathName */
};

static emlrtRSInfo tl_emlrtRSI = { 63, /* lineNo */
  "qhullReject2D",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\private\\qhullReject2D.m"/* pathName */
};

static emlrtRSInfo ul_emlrtRSI = { 68, /* lineNo */
  "qhullReject2D",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\private\\qhullReject2D.m"/* pathName */
};

static emlrtRSInfo vl_emlrtRSI = { 396,/* lineNo */
  "find",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\find.m"/* pathName */
};

static emlrtRSInfo wl_emlrtRSI = { 113,/* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo xl_emlrtRSI = { 41, /* lineNo */
  "introsort",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\introsort.m"/* pathName */
};

static emlrtRSInfo yl_emlrtRSI = { 319,/* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo am_emlrtRSI = { 2087,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bm_emlrtRSI = { 2101,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cm_emlrtRSI = { 77, /* lineNo */
  "padarray",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m"/* pathName */
};

static emlrtRSInfo dm_emlrtRSI = { 1981,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo em_emlrtRSI = { 1988,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fm_emlrtRSI = { 2008,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gm_emlrtRSI = { 2018,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hm_emlrtRSI = { 74, /* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo im_emlrtRSI = { 132,/* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo jm_emlrtRSI = { 131,/* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo km_emlrtRSI = { 130,/* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo lm_emlrtRSI = { 129,/* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo mm_emlrtRSI = { 128,/* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo nm_emlrtRSI = { 82, /* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo om_emlrtRSI = { 148,/* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo pm_emlrtRSI = { 295,/* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo qm_emlrtRSI = { 1780,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rm_emlrtRSI = { 683,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo sm_emlrtRSI = { 689,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo tm_emlrtRSI = { 107,/* lineNo */
  "rand",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\randfun\\rand.m"/* pathName */
};

static emlrtRSInfo um_emlrtRSI = { 45, /* lineNo */
  "eml_rand",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\randfun\\private\\eml_rand.m"/* pathName */
};

static emlrtRSInfo vm_emlrtRSI = { 23, /* lineNo */
  "eml_rand_mt19937ar_stateful",       /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\randfun\\private\\eml_rand_mt19937ar_stateful.m"/* pathName */
};

static emlrtRSInfo wm_emlrtRSI = { 51, /* lineNo */
  "eml_rand_mt19937ar",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+randfun\\eml_rand_mt19937ar.m"/* pathName */
};

static emlrtRSInfo xm_emlrtRSI = { 66, /* lineNo */
  "minOrMax",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\minOrMax.m"/* pathName */
};

static emlrtRSInfo ym_emlrtRSI = { 64, /* lineNo */
  "minOrMax",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\minOrMax.m"/* pathName */
};

static emlrtRSInfo an_emlrtRSI = { 1833,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bn_emlrtRSI = { 1876,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cn_emlrtRSI = { 2138,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dn_emlrtRSI = { 2141,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo en_emlrtRSI = { 1792,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fn_emlrtRSI = { 1905,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gn_emlrtRSI = { 923,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hn_emlrtRSI = { 924,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo in_emlrtRSI = { 935,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jn_emlrtRSI = { 947,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kn_emlrtRSI = { 950,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ln_emlrtRSI = { 953,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mn_emlrtRSI = { 962,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo nn_emlrtRSI = { 20, /* lineNo */
  "mrdivide_helper",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\mrdivide_helper.m"/* pathName */
};

static emlrtRSInfo on_emlrtRSI = { 20, /* lineNo */
  "mldivide",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\mldivide.m"/* pathName */
};

static emlrtRSInfo pn_emlrtRSI = { 42, /* lineNo */
  "mldivide",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\mldivide.m"/* pathName */
};

static emlrtRSInfo qn_emlrtRSI = { 210,/* lineNo */
  "lusolve",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\lusolve.m"/* pathName */
};

static emlrtRSInfo rn_emlrtRSI = { 90, /* lineNo */
  "lusolve",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\lusolve.m"/* pathName */
};

static emlrtRSInfo sn_emlrtRSI = { 22, /* lineNo */
  "inv",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\inv.m"/* pathName */
};

static emlrtRSInfo tn_emlrtRSI = { 109,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo un_emlrtRSI = { 117,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo vn_emlrtRSI = { 17, /* lineNo */
  "eigHermitianGeneralized",           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigHermitianGeneralized.m"/* pathName */
};

static emlrtRSInfo wn_emlrtRSI = { 33, /* lineNo */
  "eigHermitianGeneralized",           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigHermitianGeneralized.m"/* pathName */
};

static emlrtRSInfo xn_emlrtRSI = { 25, /* lineNo */
  "xzsyhegvd",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyhegvd.m"/* pathName */
};

static emlrtRSInfo yn_emlrtRSI = { 27, /* lineNo */
  "xzsyhegvd",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyhegvd.m"/* pathName */
};

static emlrtRSInfo ao_emlrtRSI = { 31, /* lineNo */
  "xzsyhegvd",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyhegvd.m"/* pathName */
};

static emlrtRSInfo bo_emlrtRSI = { 33, /* lineNo */
  "xzsyhegvd",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyhegvd.m"/* pathName */
};

static emlrtRSInfo co_emlrtRSI = { 99, /* lineNo */
  "trisolve",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\trisolve.m"/* pathName */
};

static emlrtRSInfo do_emlrtRSI = { 122,/* lineNo */
  "trisolve",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\trisolve.m"/* pathName */
};

static emlrtRSInfo eo_emlrtRSI = { 60, /* lineNo */
  "xzsyheev",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsyheev.m"/* pathName */
};

static emlrtRSInfo fo_emlrtRSI = { 46, /* lineNo */
  "xzsteqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsteqr.m"/* pathName */
};

static emlrtRSInfo go_emlrtRSI = { 125,/* lineNo */
  "xzsteqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsteqr.m"/* pathName */
};

static emlrtRSInfo ho_emlrtRSI = { 212,/* lineNo */
  "xzsteqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsteqr.m"/* pathName */
};

static emlrtRSInfo io_emlrtRSI = { 57, /* lineNo */
  "xdlaev2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlaev2.m"/* pathName */
};

static emlrtRSInfo jo_emlrtRSI = { 65, /* lineNo */
  "xdlaev2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlaev2.m"/* pathName */
};

static emlrtRSInfo ko_emlrtRSI = { 15, /* lineNo */
  "xzlartg",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzlartg.m"/* pathName */
};

static emlrtRSInfo lo_emlrtRSI = { 17, /* lineNo */
  "xzlartg",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzlartg.m"/* pathName */
};

static emlrtRSInfo mo_emlrtRSI = { 31, /* lineNo */
  "xzlartg",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzlartg.m"/* pathName */
};

static emlrtRSInfo no_emlrtRSI = { 40, /* lineNo */
  "xzlartg",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzlartg.m"/* pathName */
};

static emlrtRSInfo oo_emlrtRSI = { 26, /* lineNo */
  "eigGeneralized",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigGeneralized.m"/* pathName */
};

static emlrtRSInfo po_emlrtRSI = { 45, /* lineNo */
  "eigGeneralized",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigGeneralized.m"/* pathName */
};

static emlrtRSInfo qo_emlrtRSI = { 52, /* lineNo */
  "xggev",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xggev.m"/* pathName */
};

static emlrtRSInfo ro_emlrtRSI = { 81, /* lineNo */
  "xdggev",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdggev.m"/* pathName */
};

static emlrtRSInfo so_emlrtRSI = { 78, /* lineNo */
  "xdggev",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdggev.m"/* pathName */
};

static emlrtRSInfo to_emlrtRSI = { 77, /* lineNo */
  "xdggev",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdggev.m"/* pathName */
};

static emlrtRSInfo uo_emlrtRSI = { 66, /* lineNo */
  "xzgghrd",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzgghrd.m"/* pathName */
};

static emlrtRSInfo vo_emlrtRSI = { 75, /* lineNo */
  "xzgghrd",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzgghrd.m"/* pathName */
};

static emlrtRSInfo wo_emlrtRSI = { 23, /* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo xo_emlrtRSI = { 24, /* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo yo_emlrtRSI = { 147,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo ap_emlrtRSI = { 177,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo bp_emlrtRSI = { 188,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo cp_emlrtRSI = { 225,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo dp_emlrtRSI = { 292,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo ep_emlrtRSI = { 338,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo fp_emlrtRSI = { 342,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo gp_emlrtRSI = { 354,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo hp_emlrtRSI = { 381,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo ip_emlrtRSI = { 436,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo jp_emlrtRSI = { 460,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo kp_emlrtRSI = { 503,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo lp_emlrtRSI = { 657,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo mp_emlrtRSI = { 692,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo np_emlrtRSI = { 704,/* lineNo */
  "xdhgeqz",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhgeqz.m"/* pathName */
};

static emlrtRSInfo op_emlrtRSI = { 55, /* lineNo */
  "xzlanhs",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzlanhs.m"/* pathName */
};

static emlrtRSInfo pp_emlrtRSI = { 13, /* lineNo */
  "xdlag2",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlag2.m"/* pathName */
};

static emlrtRSInfo qp_emlrtRSI = { 71, /* lineNo */
  "xdlag2",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlag2.m"/* pathName */
};

static emlrtRSInfo rp_emlrtRSI = { 75, /* lineNo */
  "xdlag2",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlag2.m"/* pathName */
};

static emlrtRSInfo sp_emlrtRSI = { 78, /* lineNo */
  "xdlag2",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlag2.m"/* pathName */
};

static emlrtRSInfo tp_emlrtRSI = { 73, /* lineNo */
  "xdlasv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlasv2.m"/* pathName */
};

static emlrtRSInfo up_emlrtRSI = { 77, /* lineNo */
  "xdlasv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlasv2.m"/* pathName */
};

static emlrtRSInfo vp_emlrtRSI = { 91, /* lineNo */
  "xdlasv2",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlasv2.m"/* pathName */
};

static emlrtRSInfo wp_emlrtRSI = { 24, /* lineNo */
  "xdlapy3",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\xdlapy3.m"/* pathName */
};

static emlrtRSInfo xp_emlrtRSI = { 133,/* lineNo */
  "xdtgevc",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdtgevc.m"/* pathName */
};

static emlrtRSInfo yp_emlrtRSI = { 219,/* lineNo */
  "xdtgevc",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdtgevc.m"/* pathName */
};

static emlrtRSInfo aq_emlrtRSI = { 42, /* lineNo */
  "mrdivide_helper",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\mrdivide_helper.m"/* pathName */
};

static emlrtRSInfo bq_emlrtRSI = { 112,/* lineNo */
  "lusolve",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\lusolve.m"/* pathName */
};

static emlrtRSInfo cq_emlrtRSI = { 1906,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dq_emlrtRSI = { 125,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo eq_emlrtRSI = { 133,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo fq_emlrtRSI = { 141,/* lineNo */
  "eig",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\eig.m"/* pathName */
};

static emlrtRSInfo gq_emlrtRSI = { 27, /* lineNo */
  "eigHermitianStandard",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigHermitianStandard.m"/* pathName */
};

static emlrtRSInfo hq_emlrtRSI = { 10, /* lineNo */
  "xsyheev",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xsyheev.m"/* pathName */
};

static emlrtRSInfo iq_emlrtRSI = { 12, /* lineNo */
  "eigSkewHermitianStandard",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigSkewHermitianStandard.m"/* pathName */
};

static emlrtRSInfo jq_emlrtRSI = { 22, /* lineNo */
  "eigRealSkewSymmetricStandard",      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigRealSkewSymmetricStandard.m"/* pathName */
};

static emlrtRSInfo kq_emlrtRSI = { 69, /* lineNo */
  "schur",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\schur.m"/* pathName */
};

static emlrtRSInfo lq_emlrtRSI = { 70, /* lineNo */
  "schur",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\schur.m"/* pathName */
};

static emlrtRSInfo mq_emlrtRSI = { 21, /* lineNo */
  "xhseqr",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xhseqr.m"/* pathName */
};

static emlrtRSInfo nq_emlrtRSI = { 16, /* lineNo */
  "xdhseqr",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdhseqr.m"/* pathName */
};

static emlrtRSInfo oq_emlrtRSI = { 26, /* lineNo */
  "eigStandard",                       /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\private\\eigStandard.m"/* pathName */
};

static emlrtRSInfo pq_emlrtRSI = { 62, /* lineNo */
  "xdgeev",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdgeev.m"/* pathName */
};

static emlrtRSInfo qq_emlrtRSI = { 36, /* lineNo */
  "svd",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\svd.m"/* pathName */
};

static emlrtRSInfo rq_emlrtRSI = { 42, /* lineNo */
  "svd",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\svd.m"/* pathName */
};

static emlrtRSInfo sq_emlrtRSI = { 34, /* lineNo */
  "xgesvd",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+lapack\\xgesvd.m"/* pathName */
};

static emlrtRSInfo tq_emlrtRSI = { 431,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo uq_emlrtRSI = { 418,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo vq_emlrtRSI = { 404,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo wq_emlrtRSI = { 377,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo xq_emlrtRSI = { 358,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo yq_emlrtRSI = { 2328,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ar_emlrtRSI = { 2373,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo br_emlrtRSI = { 2374,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cr_emlrtRSI = { 2375,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dr_emlrtRSI = { 2378,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo er_emlrtRSI = { 2379,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fr_emlrtRSI = { 2394,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gr_emlrtRSI = { 2395,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hr_emlrtRSI = { 2398,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ir_emlrtRSI = { 2404,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jr_emlrtRSI = { 2405,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kr_emlrtRSI = { 26, /* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo lr_emlrtRSI = { 31, /* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo mr_emlrtRSI = { 232,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo nr_emlrtRSI = { 237,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo or_emlrtRSI = { 249,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo pr_emlrtRSI = { 336,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo qr_emlrtRSI = { 316,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo rr_emlrtRSI = { 319,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo sr_emlrtRSI = { 664,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo tr_emlrtRSI = { 667,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ur_emlrtRSI = { 1834,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vr_emlrtRSI = { 1856,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo wr_emlrtRSI = { 1857,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xr_emlrtRSI = { 1859,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo yr_emlrtRSI = { 1861,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo as_emlrtRSI = { 1862,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bs_emlrtRSI = { 1864,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo cs_emlrtRSI = { 1251,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ds_emlrtRSI = { 1222,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo es_emlrtRSI = { 1223,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo fs_emlrtRSI = { 1236,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gs_emlrtRSI = { 1238,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo hs_emlrtRSI = { 1275,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo is_emlrtRSI = { 289,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo js_emlrtRSI = { 179,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo ks_emlrtRSI = { 205,/* lineNo */
  "objectDetection",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\objectDetection.m"/* pathName */
};

static emlrtRSInfo ls_emlrtRSI = { 3183,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ms_emlrtRSI = { 3185,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ns_emlrtRSI = { 3187,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo os_emlrtRSI = { 3190,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ps_emlrtRSI = { 3193,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qs_emlrtRSI = { 3128,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rs_emlrtRSI = { 3220,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ss_emlrtRSI = { 3221,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ts_emlrtRSI = { 3223,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo us_emlrtRSI = { 3226,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo vs_emlrtRSI = { 3233,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ws_emlrtRSI = { 3246,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xs_emlrtRSI = { 3250,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ys_emlrtRSI = { 3038,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo at_emlrtRSI = { 3039,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo bt_emlrtRSI = { 3040,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ct_emlrtRSI = { 3046,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo dt_emlrtRSI = { 3051,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo et_emlrtRSI = { 3057,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ft_emlrtRSI = { 3072,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo gt_emlrtRSI = { 3073,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ht_emlrtRSI = { 3075,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo it_emlrtRSI = { 3076,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo jt_emlrtRSI = { 3087,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo kt_emlrtRSI = { 3093,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lt_emlrtRSI = { 2192,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mt_emlrtRSI = { 2201,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo nt_emlrtRSI = { 3456,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ot_emlrtRSI = { 1807,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo pt_emlrtRSI = { 1808,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qt_emlrtRSI = { 1816,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo rt_emlrtRSI = { 3491,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo st_emlrtRSI = { 74, /* lineNo */
  "fitSingleClothoid",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m"                /* pathName */
};

static emlrtRSInfo tt_emlrtRSI = { 63, /* lineNo */
  "fitSingleClothoid",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m"                /* pathName */
};

static emlrtRSInfo ut_emlrtRSI = { 50, /* lineNo */
  "fitSingleClothoid",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m"                /* pathName */
};

static emlrtRSInfo vt_emlrtRSI = { 34, /* lineNo */
  "fitSingleClothoid",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m"                /* pathName */
};

static emlrtRSInfo wt_emlrtRSI = { 38, /* lineNo */
  "clothoidG1fit",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "clothoidG1fit.m"                    /* pathName */
};

static emlrtRSInfo xt_emlrtRSI = { 39, /* lineNo */
  "clothoidG1fit",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "clothoidG1fit.m"                    /* pathName */
};

static emlrtRSInfo yt_emlrtRSI = { 76, /* lineNo */
  "clothoidG1fit",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "clothoidG1fit.m"                    /* pathName */
};

static emlrtRSInfo au_emlrtRSI = { 77, /* lineNo */
  "clothoidG1fit",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "clothoidG1fit.m"                    /* pathName */
};

static emlrtRSInfo bu_emlrtRSI = { 97, /* lineNo */
  "clothoidG1fit",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "clothoidG1fit.m"                    /* pathName */
};

static emlrtRSInfo cu_emlrtRSI = { 26, /* lineNo */
  "fresnel",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pathName */
};

static emlrtRSInfo du_emlrtRSI = { 40, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo eu_emlrtRSI = { 41, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo fu_emlrtRSI = { 42, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo gu_emlrtRSI = { 45, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo hu_emlrtRSI = { 46, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo iu_emlrtRSI = { 47, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo ju_emlrtRSI = { 49, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo ku_emlrtRSI = { 50, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo lu_emlrtRSI = { 51, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo mu_emlrtRSI = { 53, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo nu_emlrtRSI = { 60, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo ou_emlrtRSI = { 28, /* lineNo */
  "fresnel",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pathName */
};

static emlrtRSInfo pu_emlrtRSI = { 68, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo qu_emlrtRSI = { 108,/* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo ru_emlrtRSI = { 109,/* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo su_emlrtRSI = { 117,/* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo tu_emlrtRSI = { 28, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo uu_emlrtRSI = { 29, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo vu_emlrtRSI = { 30, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo wu_emlrtRSI = { 31, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo xu_emlrtRSI = { 43, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo yu_emlrtRSI = { 53, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo av_emlrtRSI = { 54, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo bv_emlrtRSI = { 57, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo cv_emlrtRSI = { 64, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo dv_emlrtRSI = { 68, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo ev_emlrtRSI = { 79, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo fv_emlrtRSI = { 92, /* lineNo */
  "fresnelgcp",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m"                       /* pathName */
};

static emlrtRSInfo gv_emlrtRSI = { 58, /* lineNo */
  "fresnelg",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pathName */
};

static emlrtRSInfo hv_emlrtRSI = { 40, /* lineNo */
  "dfresnelg",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "dfresnelg.m"                        /* pathName */
};

static emlrtRSInfo iv_emlrtRSI = { 41, /* lineNo */
  "dfresnelg",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "dfresnelg.m"                        /* pathName */
};

static emlrtRSInfo jv_emlrtRSI = { 42, /* lineNo */
  "dfresnelg",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "dfresnelg.m"                        /* pathName */
};

static emlrtRSInfo kv_emlrtRSI = { 3159,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lv_emlrtRSI = { 3156,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo mv_emlrtRSI = { 3150,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo nv_emlrtRSI = { 1356,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtMCInfo emlrtMCI = { 14,    /* lineNo */
  37,                                  /* colNo */
  "validatescalar",                    /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatescalar.m"/* pName */
};

static emlrtMCInfo b_emlrtMCI = { 382, /* lineNo */
  49,                                  /* colNo */
  "monoCamera",                        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pName */
};

static emlrtMCInfo c_emlrtMCI = { 381, /* lineNo */
  13,                                  /* colNo */
  "monoCamera",                        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pName */
};

static emlrtMCInfo d_emlrtMCI = { 14,  /* lineNo */
  37,                                  /* colNo */
  "validatefinite",                    /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatefinite.m"/* pName */
};

static emlrtMCInfo e_emlrtMCI = { 338, /* lineNo */
  13,                                  /* colNo */
  "projective2d",                      /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pName */
};

static emlrtMCInfo f_emlrtMCI = { 14,  /* lineNo */
  37,                                  /* colNo */
  "validatenonnan",                    /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatenonnan.m"/* pName */
};

static emlrtMCInfo g_emlrtMCI = { 80,  /* lineNo */
  13,                                  /* colNo */
  "reshapeSizeChecks",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pName */
};

static emlrtMCInfo h_emlrtMCI = { 85,  /* lineNo */
  23,                                  /* colNo */
  "reshapeSizeChecks",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pName */
};

static emlrtMCInfo i_emlrtMCI = { 87,  /* lineNo */
  23,                                  /* colNo */
  "reshapeSizeChecks",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pName */
};

static emlrtMCInfo j_emlrtMCI = { 13,  /* lineNo */
  9,                                   /* colNo */
  "sqrt",                              /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elfun\\sqrt.m"/* pName */
};

static emlrtMCInfo k_emlrtMCI = { 58,  /* lineNo */
  23,                                  /* colNo */
  "assertValidSizeArg",                /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pName */
};

static emlrtMCInfo l_emlrtMCI = { 53,  /* lineNo */
  15,                                  /* colNo */
  "bsxfun",                            /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\bsxfun.m"/* pName */
};

static emlrtMCInfo m_emlrtMCI = { 1,   /* lineNo */
  1,                                   /* colNo */
  "SystemCore",                        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\system\\coder\\+matlab\\+system\\+coder\\SystemCore.p"/* pName */
};

static emlrtMCInfo n_emlrtMCI = { 1143,/* lineNo */
  104,                                 /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtMCInfo o_emlrtMCI = { 1143,/* lineNo */
  122,                                 /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtMCInfo p_emlrtMCI = { 1143,/* lineNo */
  9,                                   /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtMCInfo q_emlrtMCI = { 13,  /* lineNo */
  27,                                  /* colNo */
  "assertCompatibleDims",              /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\assertCompatibleDims.m"/* pName */
};

static emlrtMCInfo r_emlrtMCI = { 14,  /* lineNo */
  15,                                  /* colNo */
  "scalexpCheck",                      /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\scalexpCheck.m"/* pName */
};

static emlrtMCInfo s_emlrtMCI = { 133, /* lineNo */
  17,                                  /* colNo */
  "monoCamera",                        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pName */
};

static emlrtMCInfo t_emlrtMCI = { 225, /* lineNo */
  27,                                  /* colNo */
  "cat",                               /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\cat.m"/* pName */
};

static emlrtMCInfo u_emlrtMCI = { 47,  /* lineNo */
  19,                                  /* colNo */
  "allOrAny",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\allOrAny.m"/* pName */
};

static emlrtMCInfo v_emlrtMCI = { 14,  /* lineNo */
  25,                                  /* colNo */
  "warning",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\warning.m"/* pName */
};

static emlrtMCInfo w_emlrtMCI = { 14,  /* lineNo */
  9,                                   /* colNo */
  "warning",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\warning.m"/* pName */
};

static emlrtMCInfo x_emlrtMCI = { 53,  /* lineNo */
  19,                                  /* colNo */
  "flt2str",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\flt2str.m"/* pName */
};

static emlrtMCInfo y_emlrtMCI = { 138, /* lineNo */
  23,                                  /* colNo */
  "eml_mtimes_helper",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pName */
};

static emlrtMCInfo ab_emlrtMCI = { 133,/* lineNo */
  23,                                  /* colNo */
  "eml_mtimes_helper",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pName */
};

static emlrtMCInfo bb_emlrtMCI = { 53, /* lineNo */
  5,                                   /* colNo */
  "repmat",                            /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\repmat.m"/* pName */
};

static emlrtMCInfo cb_emlrtMCI = { 1387,/* lineNo */
  9,                                   /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtMCInfo db_emlrtMCI = { 13, /* lineNo */
  37,                                  /* colNo */
  "validateinteger",                   /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validateinteger.m"/* pName */
};

static emlrtMCInfo eb_emlrtMCI = { 14, /* lineNo */
  37,                                  /* colNo */
  "validatepositive",                  /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatepositive.m"/* pName */
};

static emlrtMCInfo fb_emlrtMCI = { 49, /* lineNo */
  19,                                  /* colNo */
  "assertValidSizeArg",                /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pName */
};

static emlrtMCInfo gb_emlrtMCI = { 64, /* lineNo */
  15,                                  /* colNo */
  "assertValidSizeArg",                /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pName */
};

static emlrtMCInfo hb_emlrtMCI = { 122,/* lineNo */
  5,                                   /* colNo */
  "indexShapeCheck",                   /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\indexShapeCheck.m"/* pName */
};

static emlrtMCInfo ib_emlrtMCI = { 1057,/* lineNo */
  9,                                   /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtMCInfo jb_emlrtMCI = { 241,/* lineNo */
  1,                                   /* colNo */
  "unique",                            /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\unique.m"/* pName */
};

static emlrtMCInfo kb_emlrtMCI = { 46, /* lineNo */
  23,                                  /* colNo */
  "sumprod",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\datafun\\private\\sumprod.m"/* pName */
};

static emlrtMCInfo lb_emlrtMCI = { 82, /* lineNo */
  5,                                   /* colNo */
  "power",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\power.m"/* pName */
};

static emlrtMCInfo mb_emlrtMCI = { 24, /* lineNo */
  5,                                   /* colNo */
  "isSymmetricPositiveSemiDefinite",   /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\trackinglib\\+matlabshared\\+tracking\\+internal\\isSymmetricPosit"
  "iveSemiDefinite.m"                  /* pName */
};

static emlrtMCInfo nb_emlrtMCI = { 15, /* lineNo */
  1,                                   /* colNo */
  "xdlahqr",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xdlahqr.m"/* pName */
};

static emlrtMCInfo ob_emlrtMCI = { 804,/* lineNo */
  41,                                  /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtMCInfo pb_emlrtMCI = { 120,/* lineNo */
  9,                                   /* colNo */
  "reshapeSizeChecks",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pName */
};

static emlrtMCInfo qb_emlrtMCI = { 36, /* lineNo */
  19,                                  /* colNo */
  "cross",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cross.m"/* pName */
};

static emlrtMCInfo rb_emlrtMCI = { 49, /* lineNo */
  19,                                  /* colNo */
  "cross",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cross.m"/* pName */
};

static emlrtMCInfo sb_emlrtMCI = { 92, /* lineNo */
  23,                                  /* colNo */
  "norm",                              /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\norm.m"/* pName */
};

static emlrtMCInfo tb_emlrtMCI = { 111,/* lineNo */
  5,                                   /* colNo */
  "svd",                               /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\svd.m"/* pName */
};

static emlrtMCInfo ub_emlrtMCI = { 293,/* lineNo */
  13,                                  /* colNo */
  "xzsvdc",                            /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pName */
};

static emlrtMCInfo vb_emlrtMCI = { 90, /* lineNo */
  27,                                  /* colNo */
  "unaryMinOrMax",                     /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\unaryMinOrMax.m"/* pName */
};

static emlrtMCInfo wb_emlrtMCI = { 198,/* lineNo */
  27,                                  /* colNo */
  "unaryMinOrMax",                     /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\unaryMinOrMax.m"/* pName */
};

static emlrtMCInfo xb_emlrtMCI = { 14, /* lineNo */
  1,                                   /* colNo */
  "convhull",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pName */
};

static emlrtMCInfo yb_emlrtMCI = { 78, /* lineNo */
  5,                                   /* colNo */
  "convhull",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pName */
};

static emlrtMCInfo ac_emlrtMCI = { 87, /* lineNo */
  1,                                   /* colNo */
  "convhull",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pName */
};

static emlrtMCInfo bc_emlrtMCI = { 386,/* lineNo */
  1,                                   /* colNo */
  "find",                              /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\find.m"/* pName */
};

static emlrtMCInfo cc_emlrtMCI = { 62, /* lineNo */
  39,                                  /* colNo */
  "stack",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\stack.m"/* pName */
};

static emlrtMCInfo dc_emlrtMCI = { 82, /* lineNo */
  13,                                  /* colNo */
  "stack",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\stack.m"/* pName */
};

static emlrtMCInfo ec_emlrtMCI = { 419,/* lineNo */
  15,                                  /* colNo */
  "colon",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pName */
};

static emlrtMCInfo fc_emlrtMCI = { 12, /* lineNo */
  15,                                  /* colNo */
  "polyarea",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\polyarea.m"/* pName */
};

static emlrtMCInfo gc_emlrtMCI = { 85, /* lineNo */
  78,                                  /* colNo */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pName */
};

static emlrtMCInfo hc_emlrtMCI = { 88, /* lineNo */
  78,                                  /* colNo */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pName */
};

static emlrtMCInfo ic_emlrtMCI = { 125,/* lineNo */
  13,                                  /* colNo */
  "eml_rand_mt19937ar",                /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+randfun\\eml_rand_mt19937ar.m"/* pName */
};

static emlrtMCInfo jc_emlrtMCI = { 14, /* lineNo */
  23,                                  /* colNo */
  "inpolygon",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pName */
};

static emlrtMCInfo kc_emlrtMCI = { 261,/* lineNo */
  27,                                  /* colNo */
  "inpolygon",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pName */
};

static emlrtMCInfo lc_emlrtMCI = { 280,/* lineNo */
  31,                                  /* colNo */
  "inpolygon",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pName */
};

static emlrtMCInfo mc_emlrtMCI = { 14, /* lineNo */
  37,                                  /* colNo */
  "validatenonnegative",               /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatenonnegative.m"/* pName */
};

static emlrtMCInfo nc_emlrtMCI = { 15, /* lineNo */
  27,                                  /* colNo */
  "assertCompatibleDims",              /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\assertCompatibleDims.m"/* pName */
};

static emlrtECInfo emlrtECI = { -1,    /* nDims */
  2111,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo emlrtBCI = { -1,    /* iFirst */
  -1,                                  /* iLast */
  2487,                                /* lineNo */
  13,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo b_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  2498,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo c_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  2501,                                /* lineNo */
  63,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo d_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  2504,                                /* lineNo */
  62,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo e_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  2517,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo f_emlrtBCI = { 1,   /* iFirst */
  4,                                   /* iLast */
  2566,                                /* lineNo */
  162,                                 /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo emlrtDCI = { 2566,  /* lineNo */
  162,                                 /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtDCInfo b_emlrtDCI = { 2566,/* lineNo */
  145,                                 /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtECInfo b_emlrtECI = { -1,  /* nDims */
  855,                                 /* lineNo */
  17,                                  /* colNo */
  "ComputationalGeometry",             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\Computati"
  "onalGeometry.m"                     /* pName */
};

static emlrtECInfo c_emlrtECI = { -1,  /* nDims */
  856,                                 /* lineNo */
  17,                                  /* colNo */
  "ComputationalGeometry",             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\Computati"
  "onalGeometry.m"                     /* pName */
};

static emlrtECInfo d_emlrtECI = { -1,  /* nDims */
  160,                                 /* lineNo */
  25,                                  /* colNo */
  "projective2d",                      /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pName */
};

static emlrtDCInfo c_emlrtDCI = { 1483,/* lineNo */
  86,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo g_emlrtBCI = { 1,   /* iFirst */
  3,                                   /* iLast */
  1483,                                /* lineNo */
  86,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo d_emlrtDCI = { 1509,/* lineNo */
  71,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo h_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1520,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo i_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1520,                                /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo j_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1282,                                /* lineNo */
  42,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo k_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1283,                                /* lineNo */
  80,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo l_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1283,                                /* lineNo */
  36,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo m_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1290,                                /* lineNo */
  34,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo n_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1310,                                /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo o_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  3501,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo p_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  3501,                                /* lineNo */
  58,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo q_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  3501,                                /* lineNo */
  90,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo r_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  3501,                                /* lineNo */
  121,                                 /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo s_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1280,                                /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo t_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  3504,                                /* lineNo */
  16,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo u_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1287,                                /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo v_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1513,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo w_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1090,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo x_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1099,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo y_emlrtBCI = { -1,  /* iFirst */
  -1,                                  /* iLast */
  1869,                                /* lineNo */
  22,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ab_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1337,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1338,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo cb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1340,                                /* lineNo */
  47,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo db_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1049,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo eb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1063,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1072,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1108,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1117,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ib_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1340,                                /* lineNo */
  21,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo jb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1340,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo kb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1320,                                /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo lb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1320,                                /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo e_emlrtDCI = { 2929,/* lineNo */
  51,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo mb_emlrtBCI = { 1,  /* iFirst */
  500,                                 /* iLast */
  2929,                                /* lineNo */
  51,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo nb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3010,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ob_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3009,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo pb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3007,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3006,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo rb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2969,                                /* lineNo */
  40,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3013,                                /* lineNo */
  51,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo tb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3013,                                /* lineNo */
  20,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ub_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1733,                                /* lineNo */
  45,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1733,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1732,                                /* lineNo */
  41,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1732,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yb_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1731,                                /* lineNo */
  47,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ac_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1731,                                /* lineNo */
  45,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1730,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo cc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1730,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo dc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1690,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ec_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1690,                                /* lineNo */
  41,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1689,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1689,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1688,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ic_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1688,                                /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo jc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1680,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo kc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1679,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo lc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1687,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo mc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1687,                                /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo nc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1677,                                /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo oc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1675,                                /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo pc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1651,                                /* lineNo */
  54,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo e_emlrtECI = { -1,  /* nDims */
  1589,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo qc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1554,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo rc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1557,                                /* lineNo */
  51,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1651,                                /* lineNo */
  50,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo tc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1676,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo uc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1678,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1681,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1681,                                /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1682,                                /* lineNo */
  47,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yc_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1682,                                /* lineNo */
  30,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ad_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1723,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1724,                                /* lineNo */
  45,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo cd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1725,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo dd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1726,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ed_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  821,                                 /* lineNo */
  49,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  822,                                 /* lineNo */
  22,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  805,                                 /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  896,                                 /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo id_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  897,                                 /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo jd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  898,                                 /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo kd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  902,                                 /* lineNo */
  45,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ld_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  904,                                 /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo md_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  888,                                 /* lineNo */
  51,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo f_emlrtECI = { -1,  /* nDims */
  726,                                 /* lineNo */
  9,                                   /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtECInfo g_emlrtECI = { -1,  /* nDims */
  730,                                 /* lineNo */
  13,                                  /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtBCInfo nd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  725,                                 /* lineNo */
  48,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo od_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  729,                                 /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo pd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  730,                                 /* lineNo */
  20,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  858,                                 /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo h_emlrtECI = { -1,  /* nDims */
  2312,                                /* lineNo */
  25,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo rd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2312,                                /* lineNo */
  47,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sd_emlrtBCI = { 1,  /* iFirst */
  7,                                   /* iLast */
  2312,                                /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo td_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2305,                                /* lineNo */
  37,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ud_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2290,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2289,                                /* lineNo */
  40,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo i_emlrtECI = { -1,  /* nDims */
  2281,                                /* lineNo */
  23,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo j_emlrtECI = { -1,  /* nDims */
  2281,                                /* lineNo */
  10,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo k_emlrtECI = { -1,  /* nDims */
  2270,                                /* lineNo */
  17,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo wd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2270,                                /* lineNo */
  56,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2266,                                /* lineNo */
  44,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yd_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2294,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ae_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2317,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo be_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2318,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ce_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2302,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo de_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2307,                                /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ee_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2319,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fe_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2310,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ge_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2320,                                /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo he_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  71,                                  /* lineNo */
  5,                                   /* colNo */
  "",                                  /* aName */
  "backfaceCull",                      /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "backfaceCull.m",                    /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ie_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  41,                                  /* lineNo */
  6,                                   /* colNo */
  "",                                  /* aName */
  "isFacing",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "isFacing.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo l_emlrtECI = { 3,   /* nDims */
  51,                                  /* lineNo */
  14,                                  /* colNo */
  "faceNorm",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "faceNorm.m"                         /* pName */
};

static emlrtECInfo m_emlrtECI = { 3,   /* nDims */
  52,                                  /* lineNo */
  14,                                  /* colNo */
  "faceNorm",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "faceNorm.m"                         /* pName */
};

static emlrtDCInfo f_emlrtDCI = { 168, /* lineNo */
  17,                                  /* colNo */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo je_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  168,                                 /* lineNo */
  17,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo g_emlrtDCI = { 181, /* lineNo */
  22,                                  /* colNo */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo ke_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  181,                                 /* lineNo */
  22,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo n_emlrtECI = { -1,  /* nDims */
  250,                                 /* lineNo */
  1,                                   /* colNo */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m"                        /* pName */
};

static emlrtECInfo o_emlrtECI = { -1,  /* nDims */
  254,                                 /* lineNo */
  1,                                   /* colNo */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m"                        /* pName */
};

static emlrtBCInfo le_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  284,                                 /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo me_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  285,                                 /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ne_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  293,                                 /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo oe_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  294,                                 /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo pe_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  279,                                 /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qe_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  284,                                 /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo re_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  293,                                 /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo se_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  297,                                 /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo te_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  308,                                 /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ue_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  285,                                 /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ve_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  288,                                 /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo we_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  294,                                 /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xe_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  299,                                 /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ye_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  312,                                 /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "splitFace",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "splitFace.m",                       /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo af_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  42,                                  /* lineNo */
  1,                                   /* colNo */
  "",                                  /* aName */
  "intersectLinesPlane",               /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\+compgeo\\"
  "intersectLinesPlane.m",             /* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo h_emlrtDCI = { 48,  /* lineNo */
  63,                                  /* colNo */
  "stack",                             /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\stack.m",/* pName */
  4                                    /* checkKind */
};

static emlrtECInfo p_emlrtECI = { -1,  /* nDims */
  2646,                                /* lineNo */
  9,                                   /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo q_emlrtECI = { -1,  /* nDims */
  2650,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo bf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2649,                                /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo cf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2650,                                /* lineNo */
  20,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo df_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2111,                                /* lineNo */
  17,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ef_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2108,                                /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ff_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  709,                                 /* lineNo */
  19,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  715,                                 /* lineNo */
  19,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  730,                                 /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo if_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  730,                                 /* lineNo */
  19,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo jf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1965,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo kf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1966,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo lf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1970,                                /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo i_emlrtDCI = { 1973,/* lineNo */
  28,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo mf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1973,                                /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo j_emlrtDCI = { 1974,/* lineNo */
  28,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo nf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1974,                                /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo of_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1779,                                /* lineNo */
  32,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo pf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2001,                                /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2001,                                /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo rf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2006,                                /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1780,                                /* lineNo */
  36,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo k_emlrtDCI = { 1780,/* lineNo */
  36,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtBCInfo tf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1780,                                /* lineNo */
  43,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo uf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1781,                                /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  128,                                 /* lineNo */
  9,                                   /* colNo */
  "",                                  /* aName */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  129,                                 /* lineNo */
  9,                                   /* colNo */
  "",                                  /* aName */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  130,                                 /* lineNo */
  13,                                  /* colNo */
  "",                                  /* aName */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yf_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  131,                                 /* lineNo */
  13,                                  /* colNo */
  "",                                  /* aName */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ag_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  132,                                 /* lineNo */
  13,                                  /* colNo */
  "",                                  /* aName */
  "PolygonBooleanAPI",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bg_emlrtBCI = { 1,  /* iFirst */
  8,                                   /* iLast */
  940,                                 /* lineNo */
  17,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo r_emlrtECI = { -1,  /* nDims */
  2357,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo cg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2357,                                /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo s_emlrtECI = { -1,  /* nDims */
  2415,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo dg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2415,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo eg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2415,                                /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo t_emlrtECI = { -1,  /* nDims */
  2356,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo fg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2356,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo u_emlrtECI = { -1,  /* nDims */
  2414,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo gg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2414,                                /* lineNo */
  42,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2414,                                /* lineNo */
  32,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo v_emlrtECI = { -1,  /* nDims */
  2413,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo ig_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2413,                                /* lineNo */
  42,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo jg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2413,                                /* lineNo */
  32,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo w_emlrtECI = { -1,  /* nDims */
  2355,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo kg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2355,                                /* lineNo */
  30,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo x_emlrtECI = { -1,  /* nDims */
  2412,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo lg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2412,                                /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo mg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2412,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo y_emlrtECI = { -1,  /* nDims */
  2411,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo ng_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2411,                                /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo og_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2411,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo ab_emlrtECI = { -1, /* nDims */
  2354,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo pg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2354,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2373,                                /* lineNo */
  89,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo rg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2364,                                /* lineNo */
  67,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2364,                                /* lineNo */
  42,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo tg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2616,                                /* lineNo */
  32,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ug_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  2619,                                /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo bb_emlrtECI = { -1, /* nDims */
  2603,                                /* lineNo */
  9,                                   /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo cb_emlrtECI = { -1, /* nDims */
  2607,                                /* lineNo */
  13,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo vg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  769,                                 /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  772,                                 /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo db_emlrtECI = { -1, /* nDims */
  751,                                 /* lineNo */
  9,                                   /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtECInfo eb_emlrtECI = { -1, /* nDims */
  755,                                 /* lineNo */
  13,                                  /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtBCInfo xg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1251,                                /* lineNo */
  52,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yg_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1251,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ah_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1230,                                /* lineNo */
  53,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1235,                                /* lineNo */
  65,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ch_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1228,                                /* lineNo */
  34,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo dh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1855,                                /* lineNo */
  13,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo eh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  1241,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3189,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3190,                                /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo fb_emlrtECI = { -1, /* nDims */
  3246,                                /* lineNo */
  17,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo gb_emlrtECI = { -1, /* nDims */
  3250,                                /* lineNo */
  17,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo hh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3224,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ih_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3227,                                /* lineNo */
  47,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo hb_emlrtECI = { 2,  /* nDims */
  3097,                                /* lineNo */
  88,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo jh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3047,                                /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo kh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3048,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo lh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3052,                                /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo mh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3058,                                /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo ib_emlrtECI = { -1, /* nDims */
  3030,                                /* lineNo */
  9,                                   /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo jb_emlrtECI = { 2,  /* nDims */
  3203,                                /* lineNo */
  16,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtECInfo kb_emlrtECI = { 2,  /* nDims */
  3212,                                /* lineNo */
  19,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo nh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3448,                                /* lineNo */
  24,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo oh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3451,                                /* lineNo */
  23,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ph_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3455,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3456,                                /* lineNo */
  58,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo rh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3457,                                /* lineNo */
  58,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo sh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3456,                                /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo th_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  709,                                 /* lineNo */
  21,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo uh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  715,                                 /* lineNo */
  21,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  730,                                 /* lineNo */
  30,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  730,                                 /* lineNo */
  21,                                  /* colNo */
  "",                                  /* aName */
  "padarray",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\eml\\padarray.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  77,                                  /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yh_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  63,                                  /* lineNo */
  97,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ai_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  63,                                  /* lineNo */
  86,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  50,                                  /* lineNo */
  82,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ci_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  50,                                  /* lineNo */
  80,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo di_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  32,                                  /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ei_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  32,                                  /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  31,                                  /* lineNo */
  16,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo gi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  30,                                  /* lineNo */
  16,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  33,                                  /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ii_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  33,                                  /* lineNo */
  38,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ji_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  53,                                  /* lineNo */
  41,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ki_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  65,                                  /* lineNo */
  28,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo li_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  65,                                  /* lineNo */
  46,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo mi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  66,                                  /* lineNo */
  32,                                  /* colNo */
  "",                                  /* aName */
  "fitSingleClothoid",                 /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fitSingleClothoid.m",               /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo lb_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  43,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo mb_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  42,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo nb_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  41,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ob_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  40,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo pb_emlrtECI = { 2,  /* nDims */
  46,                                  /* lineNo */
  45,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo qb_emlrtECI = { 2,  /* nDims */
  46,                                  /* lineNo */
  44,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo rb_emlrtECI = { 2,  /* nDims */
  46,                                  /* lineNo */
  43,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo sb_emlrtECI = { 2,  /* nDims */
  46,                                  /* lineNo */
  42,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo tb_emlrtECI = { 2,  /* nDims */
  46,                                  /* lineNo */
  41,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ub_emlrtECI = { 2,  /* nDims */
  47,                                  /* lineNo */
  41,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo vb_emlrtECI = { 2,  /* nDims */
  47,                                  /* lineNo */
  40,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo wb_emlrtECI = { 2,  /* nDims */
  47,                                  /* lineNo */
  39,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo xb_emlrtECI = { 2,  /* nDims */
  47,                                  /* lineNo */
  38,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo yb_emlrtECI = { 2,  /* nDims */
  47,                                  /* lineNo */
  23,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ac_emlrtECI = { 2,  /* nDims */
  48,                                  /* lineNo */
  45,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo bc_emlrtECI = { 2,  /* nDims */
  48,                                  /* lineNo */
  44,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo cc_emlrtECI = { 2,  /* nDims */
  48,                                  /* lineNo */
  43,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo dc_emlrtECI = { 2,  /* nDims */
  48,                                  /* lineNo */
  42,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ec_emlrtECI = { 2,  /* nDims */
  48,                                  /* lineNo */
  41,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo fc_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  29,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo gc_emlrtECI = { 2,  /* nDims */
  45,                                  /* lineNo */
  13,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo hc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  27,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ic_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  26,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo jc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  25,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo kc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  24,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo lc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  23,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo mc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  22,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo nc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  21,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo oc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  20,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo pc_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  14,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo qc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  28,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo rc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  27,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo sc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  26,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo tc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  25,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo uc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  24,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo vc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  23,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo wc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  22,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo xc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  21,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo yc_emlrtECI = { 2,  /* nDims */
  56,                                  /* lineNo */
  20,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ad_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  28,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo bd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  27,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo cd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  26,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo dd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  25,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ed_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  24,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo fd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  23,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo gd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  22,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo hd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  21,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo id_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  20,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo jd_emlrtECI = { 2,  /* nDims */
  57,                                  /* lineNo */
  14,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo kd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  29,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ld_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  28,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo md_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  27,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo nd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  26,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo od_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  25,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo pd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  24,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo qd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  23,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo rd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  22,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo sd_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  21,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo td_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  20,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ud_emlrtECI = { 2,  /* nDims */
  55,                                  /* lineNo */
  6,                                   /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo vd_emlrtECI = { 2,  /* nDims */
  61,                                  /* lineNo */
  24,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo wd_emlrtECI = { -1, /* nDims */
  45,                                  /* lineNo */
  1,                                   /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo xd_emlrtECI = { -1, /* nDims */
  61,                                  /* lineNo */
  1,                                   /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo yd_emlrtECI = { -1, /* nDims */
  67,                                  /* lineNo */
  1,                                   /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtECInfo ae_emlrtECI = { -1, /* nDims */
  60,                                  /* lineNo */
  5,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtBCInfo ni_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  121,                                 /* lineNo */
  39,                                  /* colNo */
  "",                                  /* aName */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo be_emlrtECI = { -1, /* nDims */
  124,                                 /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo ce_emlrtECI = { -1, /* nDims */
  129,                                 /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo de_emlrtECI = { -1, /* nDims */
  136,                                 /* lineNo */
  17,                                  /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo ee_emlrtECI = { -1, /* nDims */
  136,                                 /* lineNo */
  13,                                  /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo fe_emlrtECI = { -1, /* nDims */
  141,                                 /* lineNo */
  5,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtBCInfo oi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  92,                                  /* lineNo */
  8,                                   /* colNo */
  "",                                  /* aName */
  "fresnelgcp",                        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelgcp.m",                      /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo ge_emlrtECI = { 2,  /* nDims */
  58,                                  /* lineNo */
  14,                                  /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtBCInfo pi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  60,                                  /* lineNo */
  7,                                   /* colNo */
  "",                                  /* aName */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo qi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  60,                                  /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m",                        /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo he_emlrtECI = { 2,  /* nDims */
  51,                                  /* lineNo */
  13,                                  /* colNo */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m"                          /* pName */
};

static emlrtBCInfo ri_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  42,                                  /* lineNo */
  9,                                   /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo si_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  47,                                  /* lineNo */
  26,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ti_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  45,                                  /* lineNo */
  18,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ui_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  45,                                  /* lineNo */
  3,                                   /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo vi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  52,                                  /* lineNo */
  19,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo wi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  61,                                  /* lineNo */
  3,                                   /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo xi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  61,                                  /* lineNo */
  69,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo yi_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  64,                                  /* lineNo */
  3,                                   /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo aj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  67,                                  /* lineNo */
  17,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo bj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  67,                                  /* lineNo */
  1,                                   /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo cj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  61,                                  /* lineNo */
  35,                                  /* colNo */
  "",                                  /* aName */
  "fresnel",                           /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnel.m",                         /* pName */
  0                                    /* checkKind */
};

static emlrtECInfo ie_emlrtECI = { 2,  /* nDims */
  95,                                  /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo je_emlrtECI = { 2,  /* nDims */
  92,                                  /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo ke_emlrtECI = { 2,  /* nDims */
  90,                                  /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo le_emlrtECI = { 2,  /* nDims */
  87,                                  /* lineNo */
  9,                                   /* colNo */
  "fresnelg",                          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "fresnelg.m"                         /* pName */
};

static emlrtECInfo me_emlrtECI = { 2,  /* nDims */
  44,                                  /* lineNo */
  14,                                  /* colNo */
  "dfresnelg",                         /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\motionmodel\\motionmodellib\\+matlabshared\\+tracking\\+internal\\+scenario\\"
  "dfresnelg.m"                        /* pName */
};

static emlrtECInfo ne_emlrtECI = { -1, /* nDims */
  3161,                                /* lineNo */
  9,                                   /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtBCInfo dj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3152,                                /* lineNo */
  27,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo ej_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3152,                                /* lineNo */
  25,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo fj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3156,                                /* lineNo */
  29,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtDCInfo l_emlrtDCI = { 3156,/* lineNo */
  29,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  1                                    /* checkKind */
};

static emlrtRTEInfo emlrtRTEI = { 1768,/* lineNo */
  17,                                  /* colNo */
  "AbstractDetectionGenerator",        /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pName */
};

static emlrtBCInfo gj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3013,                                /* lineNo */
  31,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtBCInfo hj_emlrtBCI = { -1, /* iFirst */
  -1,                                  /* iLast */
  3013,                                /* lineNo */
  33,                                  /* colNo */
  "",                                  /* aName */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m",/* pName */
  0                                    /* checkKind */
};

static emlrtECInfo oe_emlrtECI = { -1, /* nDims */
  3013,                                /* lineNo */
  17,                                  /* colNo */
  "visionDetectionGenerator",          /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pName */
};

static emlrtRTEInfo b_emlrtRTEI = { 19,/* lineNo */
  9,                                   /* colNo */
  "indexDivide",                       /* fName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\indexDivide.m"/* pName */
};

static emlrtRSInfo ov_emlrtRSI = { 87, /* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo pv_emlrtRSI = { 293,/* lineNo */
  "xzsvdc",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+reflapack\\xzsvdc.m"/* pathName */
};

static emlrtRSInfo qv_emlrtRSI = { 80, /* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo rv_emlrtRSI = { 46, /* lineNo */
  "sumprod",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\datafun\\private\\sumprod.m"/* pathName */
};

static emlrtRSInfo sv_emlrtRSI = { 14, /* lineNo */
  "validatefinite",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatefinite.m"/* pathName */
};

static emlrtRSInfo tv_emlrtRSI = { 13, /* lineNo */
  "sqrt",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elfun\\sqrt.m"/* pathName */
};

static emlrtRSInfo uv_emlrtRSI = { 14, /* lineNo */
  "validatenonnegative",               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatenonnegative.m"/* pathName */
};

static emlrtRSInfo vv_emlrtRSI = { 13, /* lineNo */
  "validateinteger",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validateinteger.m"/* pathName */
};

static emlrtRSInfo wv_emlrtRSI = { 804,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo xv_emlrtRSI = { 24, /* lineNo */
  "isSymmetricPositiveSemiDefinite",   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\trackinglib\\+matlabshared\\+tracking\\+internal\\isSymmetricPosit"
  "iveSemiDefinite.m"                  /* pathName */
};

static emlrtRSInfo yv_emlrtRSI = { 14, /* lineNo */
  "validatepositive",                  /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatepositive.m"/* pathName */
};

static emlrtRSInfo aw_emlrtRSI = { 14, /* lineNo */
  "validatenonnan",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatenonnan.m"/* pathName */
};

static emlrtRSInfo bw_emlrtRSI = { 14, /* lineNo */
  "validatescalar",                    /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+valattr\\validatescalar.m"/* pathName */
};

static emlrtRSInfo cw_emlrtRSI = { 261,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo dw_emlrtRSI = { 125,/* lineNo */
  "eml_rand_mt19937ar",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\+randfun\\eml_rand_mt19937ar.m"/* pathName */
};

static emlrtRSInfo ew_emlrtRSI = { 62, /* lineNo */
  "stack",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\stack.m"/* pathName */
};

static emlrtRSInfo fw_emlrtRSI = { 198,/* lineNo */
  "unaryMinOrMax",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\unaryMinOrMax.m"/* pathName */
};

static emlrtRSInfo gw_emlrtRSI = { 90, /* lineNo */
  "unaryMinOrMax",                     /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\unaryMinOrMax.m"/* pathName */
};

static emlrtRSInfo hw_emlrtRSI = { 15, /* lineNo */
  "assertCompatibleDims",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\assertCompatibleDims.m"/* pathName */
};

static emlrtRSInfo iw_emlrtRSI = { 280,/* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo jw_emlrtRSI = { 14, /* lineNo */
  "inpolygon",                         /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\inpolygon.m"/* pathName */
};

static emlrtRSInfo kw_emlrtRSI = { 13, /* lineNo */
  "assertCompatibleDims",              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\assertCompatibleDims.m"/* pathName */
};

static emlrtRSInfo lw_emlrtRSI = { 225,/* lineNo */
  "cat",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\cat.m"/* pathName */
};

static emlrtRSInfo mw_emlrtRSI = { 88, /* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo nw_emlrtRSI = { 85, /* lineNo */
  "PolygonBooleanAPI",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\tracking\\fusionlib\\+matlabshared\\+tracking\\+internal\\+fusion\\PolygonBo"
  "oleanAPI.m"                         /* pathName */
};

static emlrtRSInfo ow_emlrtRSI = { 85, /* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo pw_emlrtRSI = { 386,/* lineNo */
  "find",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\find.m"/* pathName */
};

static emlrtRSInfo qw_emlrtRSI = { 12, /* lineNo */
  "polyarea",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\polyarea.m"/* pathName */
};

static emlrtRSInfo rw_emlrtRSI = { 120,/* lineNo */
  "reshapeSizeChecks",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\reshapeSizeChecks.m"/* pathName */
};

static emlrtRSInfo sw_emlrtRSI = { 47, /* lineNo */
  "allOrAny",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\allOrAny.m"/* pathName */
};

static emlrtRSInfo tw_emlrtRSI = { 64, /* lineNo */
  "assertValidSizeArg",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pathName */
};

static emlrtRSInfo uw_emlrtRSI = { 49, /* lineNo */
  "assertValidSizeArg",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pathName */
};

static emlrtRSInfo vw_emlrtRSI = { 419,/* lineNo */
  "colon",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\colon.m"/* pathName */
};

static emlrtRSInfo ww_emlrtRSI = { 87, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo xw_emlrtRSI = { 78, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo yw_emlrtRSI = { 14, /* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

static emlrtRSInfo ax_emlrtRSI = { 14, /* lineNo */
  "scalexpCheck",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\scalexpCheck.m"/* pathName */
};

static emlrtRSInfo bx_emlrtRSI = { 53, /* lineNo */
  "bsxfun",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\elmat\\bsxfun.m"/* pathName */
};

static emlrtRSInfo cx_emlrtRSI = { 111,/* lineNo */
  "svd",                               /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\svd.m"/* pathName */
};

static emlrtRSInfo dx_emlrtRSI = { 92, /* lineNo */
  "norm",                              /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\matfun\\norm.m"/* pathName */
};

static emlrtRSInfo ex_emlrtRSI = { 49, /* lineNo */
  "cross",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cross.m"/* pathName */
};

static emlrtRSInfo fx_emlrtRSI = { 36, /* lineNo */
  "cross",                             /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\specfun\\cross.m"/* pathName */
};

static emlrtRSInfo gx_emlrtRSI = { 241,/* lineNo */
  "unique",                            /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\unique.m"/* pathName */
};

static emlrtRSInfo hx_emlrtRSI = { 1057,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo ix_emlrtRSI = { 122,/* lineNo */
  "indexShapeCheck",                   /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\indexShapeCheck.m"/* pathName */
};

static emlrtRSInfo jx_emlrtRSI = { 58, /* lineNo */
  "assertValidSizeArg",                /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\eml\\+coder\\+internal\\assertValidSizeArg.m"/* pathName */
};

static emlrtRSInfo kx_emlrtRSI = { 1387,/* lineNo */
  "AbstractDetectionGenerator",        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\+driving\\+internal\\AbstractDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo lx_emlrtRSI = { 133,/* lineNo */
  "eml_mtimes_helper",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pathName */
};

static emlrtRSInfo mx_emlrtRSI = { 138,/* lineNo */
  "eml_mtimes_helper",                 /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\ops\\eml_mtimes_helper.m"/* pathName */
};

static emlrtRSInfo nx_emlrtRSI = { 338,/* lineNo */
  "projective2d",                      /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\images\\images\\projective2d.m"/* pathName */
};

static emlrtRSInfo ox_emlrtRSI = { 133,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo px_emlrtRSI = { 1143,/* lineNo */
  "visionDetectionGenerator",          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\visionDetectionGenerator.m"/* pathName */
};

static emlrtRSInfo qx_emlrtRSI = { 382,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo rx_emlrtRSI = { 381,/* lineNo */
  "monoCamera",                        /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\driving\\driving\\monoCamera.m"/* pathName */
};

static emlrtRSInfo sx_emlrtRSI = { 14, /* lineNo */
  "warning",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\warning.m"/* pathName */
};

static emlrtRSInfo tx_emlrtRSI = { 53, /* lineNo */
  "flt2str",                           /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\shared\\coder\\coder\\lib\\+coder\\+internal\\flt2str.m"/* pathName */
};

static emlrtRSInfo ux_emlrtRSI = { 126,/* lineNo */
  "convhull",                          /* fcnName */
  "C:\\Program Files\\MATLAB\\R2024b\\toolbox\\eml\\lib\\matlab\\polyfun\\convhull.m"/* pathName */
};

/* Function Declarations */
static void cgxe_mdl_start(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance);
static void cgxe_mdl_initialize(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void cgxe_mdl_outputs(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void cgxe_mdl_update(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance);
static void cgxe_mdl_derivative(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void cgxe_mdl_enable(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance);
static void cgxe_mdl_disable(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void cgxe_mdl_terminate(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void mw__internal__system__init__fcn(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);
static void mw__internal__call__setup(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp);
static visionDetectionGenerator
  *visionDetectionGenerator_visionDetectionGenerator(const emlrtStack *sp,
  visionDetectionGenerator *obj);
static cameraIntrinsics *cameraIntrinsics_toCameraIntrinsics(cameraIntrinsics
  *iobj_0);
static boolean_T isequal(real_T varargin_1[2], real_T varargin_2[2]);
static void monoCamera_checkIntrinsics(const emlrtStack *sp, cameraIntrinsics
  *intrinsics);
static void visionDetectionGenerator_monoCameraInSensorFrame
  (visionDetectionGenerator *obj, cameraIntrinsics **monoCam_Intrinsics, real_T *
   monoCam_Height, real_T *monoCam_Pitch, real_T *monoCam_Yaw, real_T
   *monoCam_Roll, real_T monoCam_SensorLocation[2]);
static void monoCamera_rawTformToImage3D(cameraIntrinsics *this_Intrinsics,
  real_T this_Height, real_T this_Pitch, real_T this_Yaw, real_T this_Roll,
  real_T this_SensorLocation[2], real_T tform[12]);
static void monoCamera_horizonLine(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T *k, real_T *b_u0,
  real_T *v0);
static void validateattributes(const emlrtStack *sp, real_T a[9]);
static real_T det(real_T x[9]);
static boolean_T b_isequal(real_T varargin_1);
static void visionDetectionGenerator_getUpVectorInImageCoordinates(const
  emlrtStack *sp, visionDetectionGenerator *obj, real_T vUp[2]);
static void rotParentToChild(real_T roll, real_T pitch, real_T yaw, real_T R[9]);
static void rotChildToParent(real_T roll, real_T pitch, real_T yaw, real_T R[9]);
static void bsxfun(real_T a[6], real_T b[3], real_T c[6]);
static void visionDetectionGenerator_cameraToImageCoords(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T pos[6], real_T U[4]);
static void visionDetectionGenerator_getCameraMatrix(cameraIntrinsics
  *monoCam_Intrinsics, real_T monoCam_Height, real_T monoCam_Pitch, real_T
  monoCam_Yaw, real_T monoCam_Roll, real_T camMtx[12]);
static void padarray(real_T varargin_1[6], real_T b[8]);
static boolean_T vectorAny(boolean_T x_data[], int32_T x_size[2]);
static real_T b_norm(real_T x[2]);
static void b_bsxfun(real_T a[2], real_T b_data[], int32_T b_size[2], real_T
                     c_data[], int32_T c_size[2]);
static void power(real_T a_data[], int32_T a_size[2], real_T b_y_data[], int32_T
                  y_size[2]);
static real_T function_handle_parenReference(real_T varargin_1);
static void sum(real_T x_data[], int32_T x_size[2], real_T b_y_data[], int32_T
                y_size[2]);
static void sumMatrixColumns(real_T x_data[], int32_T x_size[2], real_T
  b_y_data[], int32_T y_size[2]);
static real_T sumColumnB(real_T x_data[], int32_T col);
static void b_sqrt(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                   real_T b_x_data[], int32_T b_x_size[2]);
static void assertValidSizeArg(const emlrtStack *sp, real_T varargin_1);
static void c_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void d_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void e_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2]);
static real_T c_norm(real_T x[2]);
static real_T minimum2(real_T x, real_T y);
static void rng(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance);
static void visionDetectionGenerator_setupImpl
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj);
static real_T b_sumColumnB(real_T x[2]);
static void visionDetectionGenerator_getGroundCoverageArea(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T xyCoverageArea_data[], int32_T
  xyCoverageArea_size[2]);
static void monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T imagePoints[200]);
static void monoCamera_tformToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T tform_T[9]);
static void mtimes(real_T A[300], real_T B[9], real_T C[300]);
static void visionDetectionGenerator_isAbove(visionDetectionGenerator *obj,
  real_T pts[200], real_T r0[2], boolean_T flag[100]);
static void f_bsxfun(real_T a[200], real_T b[2], real_T c[200]);
static int32_T combineVectorElements(boolean_T x[100]);
static void g_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2]);
static void b_mtimes(real_T A[4], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2]);
static void b_abs(coder_array_real_T_2D *x, coder_array_real_T_2D *y);
static void c_mtimes(real_T A[4], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2]);
static void h_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2]);
static void i_bsxfun(coder_array_real_T_2D *a, real_T b[2],
                     coder_array_real_T_2D *c);
static void d_mtimes(real_T A_data[], int32_T A_size[2], real_T B[2], real_T
                     C_data[], int32_T C_size[1]);
static void j_bsxfun(real_T a[2], real_T b[2], real_T c[2]);
static void k_bsxfun(real_T a[2], real_T b[2], real_T c[2]);
static void visionDetectionGenerator_getClosestRegionIntersection(const
  emlrtStack *sp, real_T uvSeg[4], real_T uvRegion[8], real_T uvInt[2]);
static void ComputationalGeometry_intersectLines2D(const emlrtStack *sp, real_T
  x1In[2], real_T x2In[2], real_T y1In[2], real_T y2In[2], real_T xi[2], real_T *
  s);
static void assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2]);
static void l_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[1],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void b_visionDetectionGenerator_isAbove(visionDetectionGenerator *obj,
  real_T pts[8], real_T r0[2], boolean_T flag[4]);
static void mean(real_T x_data[], int32_T x_size[2], real_T y[2]);
static real_T c_sumColumnB(real_T x_data[], int32_T x_size[2], int32_T col,
  int32_T vlen);
static void b_atan2(const emlrtStack *sp, real_T b_y_data[], int32_T y_size[1],
                    real_T x_data[], int32_T x_size[1], real_T r_data[], int32_T
                    r_size[1]);
static void monoCamera_imageToVehicle(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T imagePoints_data[],
  int32_T imagePoints_size[2], real_T vehiclePoints_data[], int32_T
  vehiclePoints_size[2]);
static boolean_T any(const emlrtStack *sp, boolean_T x_data[], int32_T x_size[1]);
static void monoCamera_get_ImageToVehicleTransform(const emlrtStack *sp,
  cameraIntrinsics *this_Intrinsics, real_T this_Height, real_T this_Pitch,
  real_T this_Yaw, real_T this_Roll, real_T this_SensorLocation[2], real_T
  tform_T[9]);
static real_T d_norm(real_T x[9]);
static void warning(const emlrtStack *sp);
static void b_warning(const emlrtStack *sp, char_T varargin_1[14]);
static void dynamic_size_checks(const emlrtStack *sp, int32_T a_size[2], int32_T
  innerDimA);
static void e_mtimes(real_T A_data[], int32_T A_size[2], real_T B[9], real_T
                     C_data[], int32_T C_size[2]);
static void repmat(real_T a_data[], int32_T a_size[1], real_T b_data[], int32_T
                   b_size[2]);
static void b_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2]);
static void SystemCore_checkTunablePropChange(const emlrtStack *sp,
  visionDetectionGenerator *obj);
static void mw__internal__call__reset(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp);
static void mw__internal__call__step(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, real_T u0_NumActors, real_T u0_Time,
  BusVehiclePose u0_Actors[3], real_T u1_NumLaneBoundaries, real_T u1_Time,
  BusLaneBoundary u1_LaneBoundaries[500], real_T *y0_NumDetections, boolean_T
  *y0_IsValidTime, BusObjectDetections1Detections y0_Detections[50], real_T
  *y1_Time, boolean_T *y1_IsValidTime, real_T *y1_SensorIndex, real_T
  *y1_NumLaneBoundaries, BusLaneDetections1LaneBoundaries y1_LaneBoundaries[4]);
static void SystemCore_step(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance,
  const emlrtStack *sp, visionDetectionGenerator *obj, real_T
  varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], real_T varargin_2_NumLaneBoundaries, real_T
  varargin_2_Time, BusLaneBoundary varargin_2_LaneBoundaries[500], real_T
  *varargout_1_NumDetections, boolean_T *varargout_1_IsValidTime,
  BusObjectDetections1Detections varargout_1_Detections[50], real_T
  *varargout_2_Time, boolean_T *varargout_2_IsValidTime, real_T
  *varargout_2_SensorIndex, real_T *varargout_2_NumLaneBoundaries,
  BusLaneDetections1LaneBoundaries varargout_2_LaneBoundaries[4]);
static void visionDetectionGenerator_stepImpl
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T varargin_1_NumActors, real_T
   varargin_1_Time, BusVehiclePose varargin_1_Actors[3], real_T
   varargin_2_NumLaneBoundaries, real_T varargin_2_Time, BusLaneBoundary
   varargin_2_LaneBoundaries[500], real_T *varargout_1_NumDetections, boolean_T *
   varargout_1_IsValidTime, BusObjectDetections1Detections
   varargout_1_Detections[50], real_T *varargout_2_Time, boolean_T
   *varargout_2_IsValidTime, real_T *varargout_2_SensorIndex, real_T
   *varargout_2_NumLaneBoundaries, BusLaneDetections1LaneBoundaries
   varargout_2_LaneBoundaries[4]);
static void visionDetectionGenerator_parseSensorAndLaneInput(const emlrtStack
  *sp, real_T varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], real_T varargin_2_NumLaneBoundaries, real_T
  varargin_2_Time, BusLaneBoundary varargin_2_LaneBoundaries[500],
  syCnTpqdknhOEQKNq30nf4E b_actors_data[], int32_T actors_size[1], real_T
  *adettime, coder_array_s_CP1nqD0d6aDeTm14G *lanebounds, real_T *ldettime);
static void visionDetectionGenerator_parseSensorInput(const emlrtStack *sp,
  real_T varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], syCnTpqdknhOEQKNq30nf4E actorPoses_data[], int32_T
  actorPoses_size[1], real_T *b_time);
static void AbstractDetectionGenerator_checkActorBus(const emlrtStack *sp,
  real_T bus_NumActors, real_T bus_Time, BusVehiclePose bus_Actors[3]);
static void b_validateattributes(const emlrtStack *sp, real_T a);
static void c_validateattributes(const emlrtStack *sp, real_T a);
static void visionDetectionGenerator_defaultActorsCodeGenStruct(const emlrtStack
  *sp, real_T numActors, syCnTpqdknhOEQKNq30nf4E actorsCgStruct_data[], int32_T
  actorsCgStruct_size[1]);
static void b_assertValidSizeArg(const emlrtStack *sp, real_T varargin_1);
static boolean_T SensorBase_get_ConnectedToScenario(void);
static matlabshared_scenario_SensorSimulation_coder_SensorSimCoder
  *SensorBase_get_SensorSim
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *iobj_0);
static void arrayfun(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
                     varargin_1_data[], int32_T varargin_1_size[1], real_T
                     varargout_1_data[], int32_T varargout_1_size[1]);
static void indexShapeCheck(const emlrtStack *sp, int32_T matrixSize, int32_T
  indexSize[2]);
static void errOrWarnIf(const emlrtStack *sp, boolean_T c);
static void d_validateattributes(const emlrtStack *sp, real_T a);
static void AbstractDetectionGenerator_assembleActors(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E b_actors_data[], int32_T actors_size[1],
  syCnTpqdknhOEQKNq30nf4E actorsOut_data[], int32_T actorsOut_size[1]);
static void b_repmat(const emlrtStack *sp, real_T varargin_1,
                     syCnTpqdknhOEQKNq30nf4E b_data[], int32_T b_size[1]);
static void e_validateattributes(const emlrtStack *sp, real_T a);
static void AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[2]);
static void shiftdim(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                     real_T b_data[], int32_T b_size[2]);
static void unique_vector(const emlrtStack *sp, real_T a_data[], int32_T a_size
  [2], real_T b_data[], int32_T b_size[2]);
static void sortIdx(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
                    int32_T idx_size[2]);
static void findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx);
static void f_validateattributes(const emlrtStack *sp, real_T a[3]);
static void b_findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx);
static void g_validateattributes(const emlrtStack *sp, real_T a[3]);
static void h_validateattributes(const emlrtStack *sp, real_T a);
static void c_findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx);
static void i_validateattributes(const emlrtStack *sp, real_T a[3]);
static void visionDetectionGenerator_parseLaneBoundaryInput(const emlrtStack *sp,
  real_T varargin_1_NumLaneBoundaries, real_T varargin_1_Time, BusLaneBoundary
  varargin_1_LaneBoundaries[500], coder_array_s_CP1nqD0d6aDeTm14G *lanebounds,
  real_T *dettime);
static void visionDetectionGenerator_assembleLanes(const emlrtStack *sp,
  coder_array_BusLaneBoundary_2D *lanebounds, coder_array_s_CP1nqD0d6aDeTm14G
  *lanesOut);
static void visionDetectionGenerator_detectObjects
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], real_T b_time, objectDetection b_detectionsGen[50],
   real_T *numDets, boolean_T *validUpdateTime);
static void AbstractDetectionGenerator_initializeDetections(const emlrtStack *sp,
  objectDetection detections[50]);
static void j_validateattributes(const emlrtStack *sp, real_T a[36]);
static void isSymmetricPositiveSemiDefinite(const emlrtStack *sp, real_T
  b_value[36]);
static real_T xnrm2(int32_T n, real_T x[36], int32_T ix0);
static void c_warning(const emlrtStack *sp);
static void eigSkewHermitianStandard(const emlrtStack *sp, real_T A[36], creal_T
  V[6]);
static real_T b_xnrm2(int32_T n, real_T x[3]);
static void d_warning(const emlrtStack *sp);
static real_T maximum2(real_T x, real_T y);
static void k_validateattributes(void);
static void AbstractDetectionGenerator_actorsFacesInSensorCoords(const
  emlrtStack *sp, visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E
  b_actors_data[], int32_T actors_size[1], coder_array_real_T_4D *facesSen,
  real_T xSen_data[], int32_T xSen_size[2], real_T tgtIDs_data[], int32_T
  tgtIDs_size[2], real_T classIDs_data[], int32_T classIDs_size[2]);
static real_T AbstractDetectionGenerator_lookupProfileIndex(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T actorID);
static void b_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[3]);
static void b_shiftdim(const emlrtStack *sp, real_T x_data[], int32_T x_size[3],
  real_T b_data[], int32_T b_size[3]);
static void c_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[3]);
static void AbstractDetectionGenerator_actorsFaces(const emlrtStack *sp,
  visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
  int32_T actors_size[1], coder_array_real_T_4D *faces);
static void ComputationalGeometry_cuboid(real_T dims[3], real_T cube[72]);
static void m_bsxfun(real_T a[72], real_T b[3], real_T c[72]);
static void n_bsxfun(real_T a[72], real_T b[3], real_T c[72]);
static void o_bsxfun(real_T a[72], real_T b[3], real_T c[72]);
static void AbstractDetectionGenerator_egoToSensor(const emlrtStack *sp, real_T
  detEgo_data[], int32_T detEgo_size[2], real_T detSen_data[], int32_T
  detSen_size[2]);
static void p_bsxfun(coder_array_real_T_2D *a, coder_array_real_T_2D *c);
static void f_mtimes(coder_array_real_T_2D *B, coder_array_real_T_2D *C);
static int32_T computeDimsData(const emlrtStack *sp, int32_T nx);
static void b_AbstractDetectionGenerator_egoToSensor(const emlrtStack *sp,
  coder_array_real_T_2D *detEgo, coder_array_real_T_2D *detSen);
static void AbstractDetectionGenerator_isSensorInsideActor(const emlrtStack *sp,
  coder_array_real_T_4D *facesSen, boolean_T *isInsideAny, coder_array_real_T_2D
  *actorIdx);
static void e_warning(const emlrtStack *sp, real_T varargin_2);
static void visionDetectionGenerator_findVisibleTargetFaces
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_4D *facesSen, real_T xSen_data[], int32_T xSen_size[2],
   real_T tgtIDs_data[], int32_T tgtIDs_size[2], real_T classIDs_data[], int32_T
   classIDs_size[2], real_T g_facesVis_data[], int32_T facesVis_size[3], real_T
   b_xSen_data[], int32_T b_xSen_size[2], real_T b_tgtIDs_data[], int32_T
   b_tgtIDs_size[2], real_T b_classIDs_data[], int32_T b_classIDs_size[2]);
static void backfaceCull(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance,
  const emlrtStack *sp, coder_array_real_T_4D *polys, coder_array_real_T_4D
  *vispolys);
static void isFacing(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp, coder_array_real_T_4D *polys, boolean_T
                     tf_data[], int32_T tf_size[2]);
static boolean_T all(const emlrtStack *sp, boolean_T x_data[], int32_T x_size[1]);
static void faceNorm(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp, coder_array_real_T_4D *face,
                     coder_array_real_T_3D *n);
static void cross(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                  real_T b_data[], int32_T b_size[2], real_T c_data[], int32_T
                  c_size[2]);
static void unitVector(const emlrtStack *sp, coder_array_real_T_3D *v,
  coder_array_real_T_3D *u);
static real_T e_norm(const emlrtStack *sp, coder_array_real_T_3D *x);
static real_T mat2norm(const emlrtStack *sp, coder_array_real_T_3D *x);
static void svd(const emlrtStack *sp, coder_array_real_T_3D *A, real_T b_U_data[],
                int32_T U_size[1]);
static void ceval_xgesvd(coder_array_real_T_3D *A, real_T S_data[], int32_T
  S_size[1], int32_T *info);
static real_T vecpnorm(coder_array_real_T_3D *x);
static void colvecnorm(coder_array_real_T_3D *vec, coder_array_real_T_3D *nm);
static void b_power(coder_array_real_T_3D *a, coder_array_real_T_3D *y);
static real_T b_function_handle_parenReference(real_T varargin_1);
static void b_sum(coder_array_real_T_3D *x, coder_array_real_T_3D *y);
static void b_sumMatrixColumns(coder_array_real_T_3D *x, coder_array_real_T_3D
  *y);
static real_T d_sumColumnB(coder_array_real_T_3D *x, int32_T col);
static void c_sqrt(coder_array_real_T_3D *x, coder_array_real_T_3D *b_x);
static void q_bsxfun(const emlrtStack *sp, coder_array_real_T_3D *a,
                     coder_array_real_T_3D *b, coder_array_real_T_3D *c);
static void c_sum(coder_array_real_T_4D *x, real_T b_y_data[], int32_T y_size[4]);
static void colMajorFlatIter(coder_array_real_T_4D *x, real_T b_y_data[],
  int32_T y_size[4]);
static void d_sum(coder_array_real_T_2D *x, coder_array_real_T_2D *y);
static void c_sumMatrixColumns(coder_array_real_T_2D *x, coder_array_real_T_2D
  *y);
static real_T e_sumColumnB(coder_array_real_T_2D *x, int32_T col);
static void squeeze(const emlrtStack *sp, coder_array_real_T_2D *a,
                    coder_array_real_T_2D *b);
static void splitFace(const emlrtStack *sp, real_T face[12], real_T
                      infront_data[], int32_T infront_size[2]);
static void r_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void g_mtimes(real_T A_data[], real_T C_data[], int32_T C_size[1]);
static void intersectionDetection(const emlrtStack *sp, real_T fmat_data[],
  real_T sgndist_data[], real_T rEdges_data[], int32_T rEdges_size[2], real_T
  vEdges_data[], int32_T vEdges_size[2]);
static real_T b_mod(real_T x);
static int32_T b_combineVectorElements(boolean_T x_data[], int32_T x_size[2]);
static void c_abs(real_T x_data[], real_T b_y_data[], int32_T y_size[1]);
static void maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                    real_T *ex, int32_T *idx);
static void assembleHalves(const emlrtStack *sp, real_T fmat_data[], real_T
  sgndist_data[], boolean_T hasIntersection_data[], real_T rEdges_data[], real_T
  vEdges_data[], real_T fmatInfront_data[], int32_T fmatInfront_size[2], real_T
  fmatBehind_data[], int32_T fmatBehind_size[2]);
static void intersectLinesPlane(const emlrtStack *sp, real_T r_data[], int32_T
  r_size[2], real_T b_v_data[], int32_T v_size[2], real_T pts_data[], int32_T
  pts_size[2]);
static void dotprod(real_T b_data[], int32_T b_size[2], real_T dp_data[],
                    int32_T dp_size[2]);
static void cart2sph(const emlrtStack *sp, coder_array_real_T_2D *x,
                     coder_array_real_T_2D *y, coder_array_real_T_2D *z,
                     coder_array_real_T_2D *az, coder_array_real_T_2D *elev);
static void b_hypot(const emlrtStack *sp, coder_array_real_T_2D *x,
                    coder_array_real_T_2D *y, coder_array_real_T_2D *r);
static void c_atan2(const emlrtStack *sp, coder_array_real_T_2D *y,
                    coder_array_real_T_2D *x, coder_array_real_T_2D *r);
static void b_isfinite(real_T x[30], boolean_T b[30]);
static int32_T c_combineVectorElements(boolean_T x[30]);
static boolean_T b_all(coder_array_real_T_2D *a);
static void convhull(const emlrtStack *sp, real_T varargin_1_data[], int32_T
                     varargin_1_size[2], real_T varargin_2_data[], int32_T
                     varargin_2_size[2], real_T varargout_1_data[], int32_T
                     varargout_1_size[1]);
static void parseOptions(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T varargin_2_data[], int32_T varargin_2_size[2],
  real_T opts_pts_data[], int32_T opts_pts_size[2], boolean_T *opts_simplify);
static void qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1],
  boolean_T *ptsAreCollinear);
static void minimum(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                    real_T *ex, int32_T *idx);
static void getFarthestPoints(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], real_T pt1, real_T pt2, real_T farthestNorth_data[], int32_T
  farthestNorth_size[2], real_T farthestSouth_data[], int32_T
  farthestSouth_size[2], boolean_T northPts_data[], int32_T northPts_size[1],
  boolean_T linePts_data[], int32_T linePts_size[1], boolean_T *collinearPts);
static void markPtsInTria(real_T pts_data[], int32_T pts_size[2], real_T a_data[],
  real_T b_data[], real_T c_data[], boolean_T ptsInTria_data[], int32_T
  ptsInTria_size[1]);
static void eml_find(const emlrtStack *sp, coder_array_boolean_T *x,
                     coder_array_int32_T *i);
static void b_qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1]);
static void c_qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1]);
static void orient(const emlrtStack *sp, real_T pts_data[], int32_T pts_size[2],
                   real_T orientedPts_data[], int32_T orientedPts_size[2],
                   real_T orientPerm_data[], int32_T orientPerm_size[1]);
static void stack_stack(const emlrtStack *sp, int32_T n, sBaHy6MF1FZJsDHxMqvBaiH
  this_d_data[], int32_T this_d_size[1], int32_T *this_n);
static void eml_float_colon(const emlrtStack *sp, real_T a, real_T b,
  coder_array_real_T_2D *y);
static void assert_pmaxsize(const emlrtStack *sp, boolean_T p);
static void grahamComputeHull(real_T pts_data[], int32_T pts_size[2], int32_T
  traversalOrder_data[], int32_T hull_data[], int32_T hull_size[2]);
static void visionDetectionGenerator_sensorToCamera
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T detSen_data[], int32_T detSen_size[2],
   real_T detCam_data[], int32_T detCam_size[2]);
static void h_mtimes(real_T A[9], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2]);
static void s_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[3], real_T
                     c_data[], int32_T c_size[2]);
static void b_visionDetectionGenerator_sensorToCamera
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T detSen_data[], int32_T detSen_size[2],
   real_T detCam_data[], int32_T detCam_size[2]);
static void b_visionDetectionGenerator_cameraToImageCoords
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T b_pos_data[], int32_T pos_size[2],
   real_T b_U_data[], int32_T U_size[2]);
static void b_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], coder_array_real_T_2D *b);
static void c_repmat(const emlrtStack *sp, real_T varargin_1[2],
                     coder_array_real_T_2D *b);
static void c_assertValidSizeArg(const emlrtStack *sp, real_T varargin_1[2]);
static void i_mtimes(coder_array_real_T_2D *A, real_T B[12], real_T C_data[],
                     int32_T C_size[2]);
static boolean_T b_any(const emlrtStack *sp, boolean_T x_data[], int32_T x_size
  [2]);
static int32_T b_computeDimsData(const emlrtStack *sp, int32_T nx, real_T
  varargin_3);
static void c_power(real_T a_data[], int32_T a_size[2], real_T b_y_data[],
                    int32_T y_size[2]);
static real_T c_function_handle_parenReference(real_T varargin_1);
static void visionDetectionGenerator_indexTarget(const emlrtStack *sp, real_T
  iTgt, coder_array_real_T_3D *Uall, real_T tgtRngs_data[], int32_T
  tgtRngs_size[2], coder_array_real_T_2D *Utgt, real_T *rgTgt,
  coder_array_real_T_3D *Uothers, real_T rgOthers_data[], int32_T rgOthers_size
  [2]);
static boolean_T visionDetectionGenerator_computeOccludedView
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_2D *Utgt, real_T rgTgt, coder_array_real_T_3D *Uothers,
   real_T rgOthers_data[], int32_T rgOthers_size[2], real_T imagSz[2]);
static real_T polyarea(const emlrtStack *sp, coder_array_real_T_2D *x,
  coder_array_real_T_2D *y);
static void PolygonBooleanAPI_polybool(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, real_T b_x1_data[], int32_T x1_size[2],
  real_T y1_data[], int32_T y1_size[2], real_T x2[4], real_T y2[4],
  coder_array_real_T_2D *rxOut, coder_array_real_T_2D *ryOut);
static void eml_integer_colon_dispatcher(const emlrtStack *sp, int32_T b,
  coder_array_int32_T_2D *y);
static int32_T c_computeDimsData(int32_T nx);
static void b_eml_find(const emlrtStack *sp, coder_array_boolean_T_2D *x,
  coder_array_int32_T_2D *i);
static void b_PolygonBooleanAPI_polybool(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, coder_array_real_T_2D *x1,
  coder_array_real_T_2D *c_y1, real_T b_x2_data[], int32_T x2_size[2], real_T
  y2_data[], int32_T y2_size[2], coder_array_real_T_2D *rxOut,
  coder_array_real_T_2D *ryOut);
static void polyBgen(const emlrtStack *sp, coder_array_real_T_2D *x1,
                     coder_array_real_T_2D *c_y1, real_T b_x2_data[], int32_T
                     x2_size[2], real_T y2_data[], int32_T y2_size[2],
                     coder_array_real_T *rx, coder_array_real_T *ry,
                     coder_array_real_T_2D *mp);
static real_T b_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp);
static void visionDetectionGenerator_estimateImageLocation(const emlrtStack *sp,
  visionDetectionGenerator *obj, coder_array_real_T_2D *Utgt, real_T U[2],
  real_T B[2]);
static void b_mean(coder_array_real_T_2D *x, real_T y[2]);
static void j_mtimes(real_T A[4], coder_array_real_T_2D *B,
                     coder_array_real_T_2D *C);
static real_T b_minimum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2]);
static real_T b_maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2]);
static real_T diff(real_T x[2]);
static real_T c_mean(real_T x[2]);
static void k_mtimes(real_T A[4], real_T B[2], real_T C[2]);
static void t_bsxfun(real_T a[2], real_T b[2], real_T c[2]);
static boolean_T c_visionDetectionGenerator_isAbove(visionDetectionGenerator
  *obj, real_T pts[2], real_T r0[2]);
static void visionDetectionGenerator_imag2cam(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T U[2], real_T vel[3], real_T X[2], real_T
  R[4], real_T V[2]);
static void visionDetectionGenerator_computeImageVelocity(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T Uimg[2], real_T Xvel[3], real_T Uvel[2]);
static void visionDetectionGenerator_kalmanFilterModel(const emlrtStack *sp,
  real_T R1[4], real_T R[4], real_T Rv[4]);
static void AbstractDetectionGenerator_steadyStateKalmanCovariance(const
  emlrtStack *sp, real_T A[16], real_T Q[16], real_T H[8], real_T R[4], real_T
  PpOut[16], real_T Ps[16]);
static void mldivide(const emlrtStack *sp, real_T A[4], real_T B[8], real_T Y[8]);
static void inv(const emlrtStack *sp, real_T x[16], real_T y[16]);
static real_T f_norm(real_T x[16]);
static void eig(const emlrtStack *sp, real_T A[64], real_T B[64], creal_T V[64],
                creal_T D[64]);
static boolean_T ishermitian(real_T A[64]);
static void eigHermitianGeneralized(const emlrtStack *sp, real_T A[64], real_T
  B[64], creal_T V[64], creal_T D[64]);
static void xsyhegvd(real_T A[64], real_T B[64], int32_T *info, creal_T W[8],
                     creal_T V[64]);
static real_T c_xnrm2(int32_T n, real_T x[64], int32_T ix0);
static void xzlartg(const emlrtStack *sp, real_T f, real_T g, real_T *cs, real_T
                    *sn, real_T *r);
static void eigGeneralized(const emlrtStack *sp, real_T A[64], real_T B[64],
  creal_T V[64], creal_T D[64]);
static void xggev(const emlrtStack *sp, real_T A[64], real_T B[64], int32_T
                  *info, creal_T W[8], creal_T VR[64]);
static real_T xzlanhs(const emlrtStack *sp, real_T A[64], int32_T ilo, int32_T
                      ihi);
static void xdlag2(const emlrtStack *sp, real_T a[64], int32_T ia0, real_T b[64],
                   int32_T ib0, real_T safmin, real_T *scale1, real_T *scale2,
                   real_T *wr1, real_T *wr2, real_T *wi);
static void b_xzlartg(const emlrtStack *sp, real_T f, real_T g, real_T *cs,
                      real_T *sn);
static int32_T b_minimum2(int32_T x, int32_T y);
static void xdlasv2(const emlrtStack *sp, real_T f, real_T g, real_T h, real_T
                    *ssmin, real_T *ssmax, real_T *snr, real_T *csr, real_T *snl,
                    real_T *csl);
static real_T xdlapy3(const emlrtStack *sp, real_T x1, real_T x2, real_T x3);
static void xdladiv(real_T a, real_T b, real_T c, real_T d, real_T *p, real_T *q);
static void dladiv1(real_T a, real_T b, real_T c, real_T d, real_T *p, real_T *q);
static void mrdiv(const emlrtStack *sp, creal_T A[16], creal_T B[16], creal_T Y
                  [16]);
static void ensureSymmetricPositiveSemidefinite(const emlrtStack *sp, real_T
  Pin[16], real_T Pout[16]);
static void b_eig(const emlrtStack *sp, real_T A[16], creal_T V[16], creal_T D
                  [16]);
static real_T d_xnrm2(int32_T n, real_T x[16], int32_T ix0);
static void b_eigSkewHermitianStandard(const emlrtStack *sp, real_T A[16],
  creal_T V[16], creal_T D[16]);
static real_T xzlangeM(real_T x[16]);
static void b_svd(const emlrtStack *sp, real_T A[16], real_T U[16], real_T b_S
                  [16], real_T V[16]);
static void xzsvdc(const emlrtStack *sp, real_T A[16], real_T U[16], real_T b_S
                   [4], real_T V[16]);
static real_T e_xnrm2(int32_T n, real_T x[16], int32_T ix0);
static real_T xdotc(int32_T n, real_T x[16], int32_T ix0, real_T y[16], int32_T
                    iy0);
static real_T f_xnrm2(int32_T n, real_T x[4], int32_T ix0);
static real_T c_maximum(real_T x[4]);
static void b_maximum2(real_T x[4], real_T y, real_T ex[4]);
static void visionDetectionGenerator_addFalsePositives
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T dets_data[], int32_T dets_size[2],
   coder_array_real_T_3D *covmats, real_T tgtIDs_data[], int32_T tgtIDs_size[2],
   real_T classIDs_data[], int32_T classIDs_size[2], real_T detsOut_data[],
   int32_T detsOut_size[2], coder_array_real_T_3D *covmatsOut, real_T
   tgtIDsOut_data[], int32_T tgtIDsOut_size[2], real_T classIDsOut_data[],
   int32_T classIDsOut_size[2]);
static real_T c_minimum(const emlrtStack *sp, coder_array_real_T *x);
static real_T d_maximum(const emlrtStack *sp, coder_array_real_T *x);
static boolean_T inpolygon(const emlrtStack *sp, real_T x, real_T y,
  coder_array_real_T *xv, coder_array_real_T *yv);
static void checkRange(const emlrtStack *sp, real_T minxv, real_T maxxv, real_T
  minyv, real_T maxyv);
static void f_warning(const emlrtStack *sp);
static void g_warning(const emlrtStack *sp);
static void contrib(real_T x1, real_T c_y1, real_T x2, real_T y2, int8_T quad1,
                    int8_T quad2, real_T scale, int8_T *diffQuad, boolean_T *onj);
static real_T c_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp);
static void b_monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T vehiclePoints[2],
  real_T imagePoints[2]);
static real_T visionDetectionGenerator_distFromHorizon(visionDetectionGenerator *
  obj, real_T uvPt[2]);
static void c_monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T vehiclePoints_data[],
  real_T imagePoints_data[], int32_T imagePoints_size[2]);
static void b_visionDetectionGenerator_imag2cam(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T b_U_data[], real_T X_data[], int32_T
  X_size[2], real_T R_data[], int32_T R_size[3]);
static void c_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T b_data[], int32_T b_size[2]);
static void c_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[1],
  int32_T y_size[1]);
static void d_power(real_T a_data[], real_T b_y_data[], int32_T y_size[1]);
static real_T d_function_handle_parenReference(real_T varargin_1);
static void b_visionDetectionGenerator_kalmanFilterModel(const emlrtStack *sp,
  real_T R1_data[], real_T R_data[], int32_T R_size[3], real_T Rv_data[],
  int32_T Rv_size[3]);
static void AbstractDetectionGenerator_rand(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, visionDetectionGenerator *obj, real_T
  val_data[], int32_T val_size[1]);
static void d_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                   emlrtStack *sp, real_T r_data[], int32_T r_size[1]);
static void sort(real_T x_data[], int32_T x_size[2], real_T b_x_data[], int32_T
                 b_x_size[2], int32_T idx_data[], int32_T idx_size[2]);
static void b_sortIdx(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
                      int32_T idx_size[2], real_T b_x_data[], int32_T b_x_size[2]);
static void merge_pow2_block(int32_T idx_data[], int32_T idx_size[2], real_T
  x_data[], int32_T x_size[2], int32_T offset, int32_T b_idx_data[], int32_T
  b_idx_size[2], real_T b_x_data[], int32_T b_x_size[2]);
static void visionDetectionGenerator_cameraToSensor(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T detCam_data[], int32_T detCam_size[2],
  real_T covCam_data[], int32_T covCam_size[3], real_T detSen_data[], int32_T
  detSen_size[2], real_T covSen_data[], int32_T covSen_size[3]);
static void u_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[3], real_T
                     c_data[], int32_T c_size[2]);
static void AbstractDetectionGenerator_sensorToEgo(const emlrtStack *sp, real_T
  detCart_data[], int32_T detCart_size[2], real_T covCart_data[], int32_T
  covCart_size[3], real_T detEgo_data[], int32_T detEgo_size[2], real_T
  covEgo_data[], int32_T covEgo_size[3]);
static void v_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void visionDetectionGenerator_assembleDetections(const emlrtStack *sp,
  real_T b_time, real_T dets_data[], int32_T dets_size[2], real_T covmats_data[],
  int32_T covmats_size[3], real_T attribs_f2_data[], int32_T attribs_f2_size[2],
  real_T classIDs_data[], int32_T classIDs_size[2], objectDetection
  detections_data[], int32_T detections_size[1]);
static void d_repmat(const emlrtStack *sp, objectDetection a[1], real_T
                     varargin_1, objectDetection b_data[], int32_T b_size[1]);
static void visionDetectionGenerator_detectOccludedLanes
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], coder_array_s_CP1nqD0d6aDeTm14G *lanebounds, real_T
   ldettime, real_T *lanesGen_Time, BusLaneDetections1LaneBoundaries
   lanesGen_LaneBoundaries[4], real_T *lanesGen_SensorIndex, real_T *numLaneDets,
   boolean_T *validLaneUpdateTime);
static void visionDetectionGenerator_initializeLaneDetections(const emlrtStack
  *sp, real_T numDets, BusLaneDetections1LaneBoundaries laneDets_data[], int32_T
  laneDets_size[1]);
static void visionDetectionGenerator_getActorFacesInImageCoords
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], real_T Ufaces_data[], int32_T Ufaces_size[3]);
static void b_visionDetectionGenerator_findVisibleTargetFaces
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_4D *facesSen, int32_T xSen_size[2], int32_T tgtIDs_size[2],
   int32_T classIDs_size[2], real_T g_facesVis_data[], int32_T facesVis_size[3]);
static void visionDetectionGenerator_detectLane
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T lb_Coordinates_data[], int32_T
   lb_Coordinates_size[2], uint8_T lb_BoundaryType, real_T lb_Strength, real_T
   lb_Length, real_T lb_Width, real_T b_UfacesComb_data[], int32_T
   UfacesComb_size[3], real_T *ldet_Curvature, real_T *ldet_CurvatureDerivative,
   real_T *ldet_CurveLength, real_T *ldet_HeadingAngle, real_T
   *ldet_LateralOffset, uint8_T *ldet_BoundaryType, real_T *ldet_Strength,
   real_T *ldet_Width);
static void visionDetectionGenerator_egoPosToSensor(const emlrtStack *sp, real_T
  detEgo_data[], int32_T detEgo_size[2], real_T detSen_data[], int32_T
  detSen_size[2]);
static void w_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2]);
static void visionDetectionGenerator_cameraToImageCoordsWithGain(const
  emlrtStack *sp, visionDetectionGenerator *obj, real_T b_pos_data[], int32_T
  pos_size[2], real_T b_U_data[], int32_T U_size[2], real_T Ugain_data[],
  int32_T Ugain_size[2]);
static void visionDetectionGenerator_isInFieldOfView(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T imgCoords_data[], int32_T
  imgCoords_size[2], boolean_T flag_data[], int32_T flag_size[2]);
static void visionDetectionGenerator_isLaneMarkingBigEnough(const emlrtStack *sp,
  uint8_T lb_BoundaryType, real_T lb_Length, real_T lb_Width, real_T
  lbcGain_data[], int32_T lbcGain_size[2], boolean_T flag_data[], int32_T
  flag_size[2]);
static void isVisibleBoundaryPoint(const emlrtStack *sp, real_T lbcImage_data[],
  int32_T lbcImage_size[2], real_T Uall_data[], int32_T Uall_size[3], boolean_T
  isVisible_data[], int32_T isVisible_size[2]);
static int32_T d_combineVectorElements(boolean_T x_data[], int32_T x_size[1]);
static void visionDetectionGenerator_imageCoordsToCameraWithTol(const emlrtStack
  *sp, visionDetectionGenerator *obj, real_T b_U_data[], int32_T U_size[2],
  real_T X_data[], int32_T X_size[2], real_T tol_data[], int32_T tol_size[1]);
static void d_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T b_data[], int32_T b_size[2]);
static void b_visionDetectionGenerator_cameraToSensor(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T detCam_data[], int32_T detCam_size[2],
  real_T detSen_data[], int32_T detSen_size[2]);
static void b_AbstractDetectionGenerator_sensorToEgo(const emlrtStack *sp,
  real_T detCart_data[], int32_T detCart_size[2], real_T detEgo_data[], int32_T
  detEgo_size[2]);
static void fitSingleClothoid(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T tol_data[], int32_T tol_size[1], real_T *heading, real_T
  *lateralOffset, real_T *curvature, real_T *derivativeCurvature, real_T
  *curveLength);
static void clothoidG1fit(const emlrtStack *sp, creal_T z0, real_T theta0,
  creal_T z1, real_T theta1, real_T *k0, real_T *k1, real_T *l);
static creal_T fresnelr(const emlrtStack *sp, real_T x);
static void c_eml_find(boolean_T x, int32_T i_data[], int32_T i_size[2]);
static void d_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2]);
static void b_exp(creal_T x_data[], int32_T x_size[2], creal_T b_x_data[],
                  int32_T b_x_size[2]);
static void e_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2]);
static creal_T e_power(creal_T a);
static creal_T fresnelg(const emlrtStack *sp, real_T dk, real_T k, real_T theta);
static void l_validateattributes(const emlrtStack *sp, real_T a);
static void m_validateattributes(const emlrtStack *sp, real_T a);
static void n_validateattributes(const emlrtStack *sp, real_T a);
static creal_T fresnelgsma(real_T x, real_T dk, real_T k, real_T theta);
static void fresnelgzero(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
  real_T dk, real_T k, real_T theta, creal_T z_data[], int32_T z_size[1]);
static void f_power(coder_array_real_T *a, coder_array_real_T *y);
static void e_repmat(coder_array_creal_T *a, coder_array_creal_T_2D *b);
static void x_bsxfun(coder_array_creal_T_2D *a, coder_array_creal_T_2D *c);
static void useConstantDim(coder_array_creal_T_2D *varargin_2,
  coder_array_creal_T_2D *varargout_1);
static creal_T dfresnelgsma1(real_T a, real_T d, real_T c);
static void fresnelgcp(const emlrtStack *sp, creal_T z_data[], int32_T z_size[2],
  real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0, creal_T
  zcp_data[], int32_T zcp_size[2], real_T x_data[], int32_T x_size[2], real_T
  d_data[], int32_T d_size[2]);
static void fresnelgcp_impl(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0,
  creal_T zcp_data[], int32_T zcp_size[2], real_T x_data[], int32_T x_size[2],
  real_T d_data[], int32_T d_size[2]);
static void o_validateattributes(const emlrtStack *sp, coder_array_real_T_2D *a);
static void initializeGuess(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0,
  real_T x_data[], int32_T x_size[2]);
static void b_fresnelg(const emlrtStack *sp, coder_array_real_T_2D *x, real_T dk,
  real_T k, real_T theta, coder_array_creal_T_2D *z);
static void fresnel(const emlrtStack *sp, coder_array_real_T_2D *x,
                    coder_array_creal_T_2D *z);
static void f_assertCompatibleDims(const emlrtStack *sp, coder_array_real_T_2D
  *x, coder_array_real_T_2D *y);
static void c_exp(coder_array_creal_T_2D *x, coder_array_creal_T_2D *b_x);
static void g_assertCompatibleDims(const emlrtStack *sp, coder_array_creal_T_2D *
  x, coder_array_real_T_2D *y);
static void b_fresnelgsma(const emlrtStack *sp, coder_array_real_T_2D *x, real_T
  dk, real_T k, real_T theta, coder_array_creal_T_2D *z);
static void y_bsxfun(coder_array_creal_T_2D *a, creal_T b_data[], int32_T
                     b_size[1], coder_array_creal_T_2D *c);
static void d_abs(coder_array_creal_T_2D *x, coder_array_real_T_2D *y);
static void d_minimum(const emlrtStack *sp, coder_array_real_T_2D *x, real_T
                      ex_data[], int32_T ex_size[1], int32_T idx_data[], int32_T
                      idx_size[1]);
static void b_indexShapeCheck(const emlrtStack *sp, int32_T matrixSize[2],
  int32_T indexSize);
static void dfresnelg(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                      real_T dk, real_T k, real_T theta, creal_T dz_data[],
                      int32_T dz_size[2]);
static void e_abs(coder_array_creal_T_2D *x, coder_array_real_T_2D *y);
static void e_maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                      real_T *ex, int32_T *idx);
static void b_fresnelgcp(const emlrtStack *sp, creal_T z, real_T dk, real_T k,
  real_T theta, coder_array_real_T_2D *x0, creal_T *zcp, real_T *x);
static creal_T c_fresnelg(const emlrtStack *sp, real_T x, real_T dk, real_T k,
  real_T theta);
static void visionDetectionGenerator_limitMaxNumLanes(const emlrtStack *sp,
  BusLaneDetections1LaneBoundaries lbdets_data[], int32_T lbdets_size[1],
  BusLaneDetections1LaneBoundaries lbdetOut[4], real_T *numLaneDets);
static void d_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  BusLaneDetections1LaneBoundaries s_data[], int32_T s_size[1], real_T
  vals_data[], int32_T vals_size[2]);
static void b_sort(real_T x_data[], int32_T x_size[2], real_T b_x_data[],
                   int32_T b_x_size[2]);
static void c_indexShapeCheck(const emlrtStack *sp, int32_T matrixSize);
static void nullify(real_T *out_Time, real_T out_Measurement[6], real_T
                    out_MeasurementNoise[36], real_T *out_SensorIndex, real_T
                    *out_ObjectClassID, drivingCoordinateFrameType
                    *out_MeasurementParameters_Frame, real_T
                    out_MeasurementParameters_OriginPosition[3], real_T
                    out_MeasurementParameters_Orientation[9], boolean_T
                    *out_MeasurementParameters_HasVelocity, real_T
                    *out_ObjectAttributes_TargetIndex);
static void visionDetectionGenerator_sendToBus(const emlrtStack *sp,
  objectDetection dets[50], real_T numDets, boolean_T isValidTime, real_T
  *out_NumDetections, boolean_T *out_IsValidTime, BusObjectDetections1Detections
  out_Detections[50]);
static const mxArray *emlrt_marshallOut(const emlrtStack *sp, const char_T u[40]);
static const mxArray *b_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [30]);
static const mxArray *c_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [39]);
static void emlrt_marshallIn(const emlrtStack *sp, const mxArray
  *a__output_of_sprintf_, const char_T *identifier, char_T y[14]);
static void b_emlrt_marshallIn(const emlrtStack *sp, const mxArray *u, const
  emlrtMsgIdentifier *parentId, char_T y[14]);
static const mxArray *d_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [36]);
static const mxArray *message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location);
static const mxArray *getString(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location);
static void error(const emlrtStack *sp, const mxArray *m, const mxArray *m1,
                  emlrtMCInfo *location);
static const mxArray *num2str(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location);
static void coder_internal_warningIf(const emlrtStack *sp, const mxArray *m,
  const mxArray *m1, const mxArray *m2, emlrtMCInfo *location);
static const mxArray *b_message(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location);
static const mxArray *c_message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, emlrtMCInfo *location);
static void coder_internal_errorIf(const emlrtStack *sp, const mxArray *m, const
  mxArray *m1, const mxArray *m2, const mxArray *m3, emlrtMCInfo *location);
static const mxArray *feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location);
static void b_feval(const emlrtStack *sp, const mxArray *m, const mxArray *m1,
                    emlrtMCInfo *location);
static const mxArray *b_sprintf(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location);
static const mxArray *c_feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, emlrtMCInfo *location);
static const mxArray *d_message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, const mxArray *m4, emlrtMCInfo *location);
static const mxArray *d_feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, const mxArray *m4, emlrtMCInfo *location);
static void c_emlrt_marshallIn(const emlrtStack *sp, const mxArray *src, const
  emlrtMsgIdentifier *msgId, char_T ret[14]);
static void d_sqrt(const emlrtStack *sp, real_T *x);
static void c_sort(real_T x_data[], int32_T x_size[1], int32_T idx_data[],
                   int32_T idx_size[1]);
static void c_sortIdx(real_T x_data[], int32_T x_size[1], int32_T idx_data[],
                      int32_T idx_size[1]);
static void b_merge_pow2_block(int32_T idx_data[], real_T x_data[], int32_T
  offset);
static void merge_block(int32_T idx_data[], real_T x_data[], int32_T offset,
  int32_T n, int32_T preSortLevel, int32_T iwork_data[], real_T xwork_data[]);
static void merge(int32_T idx_data[], real_T x_data[], int32_T offset, int32_T
                  np, int32_T nq, int32_T iwork_data[], real_T xwork_data[]);
static void visionDetectionGenerator_copyStructField2D(const emlrtStack *sp,
  coder_array_BusLaneBoundary_2D *s1, coder_array_s_CP1nqD0d6aDeTm14G *b_s2);
static void xzlarf(int32_T n, int32_T iv0, real_T tau, real_T C[36], int32_T ic0,
                   real_T work[6]);
static void b_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[36],
                     int32_T ic0, real_T work[6]);
static int32_T xhseqr(const emlrtStack *sp, real_T h[36]);
static real_T xzlarfg(int32_T n, real_T *alpha1, real_T x[3]);
static void xdlanv2(const emlrtStack *sp, real_T *a, real_T *b, real_T *c,
                    real_T *d, real_T *rt1r, real_T *rt1i, real_T *rt2r, real_T *
                    rt2i, real_T *cs, real_T *sn);
static void objectDetection_set_Measurement(const emlrtStack *sp,
  objectDetection *detection, real_T b_value[6]);
static void xrotg(real_T *a, real_T *b, real_T *c, real_T *s);
static void introsort(const emlrtStack *sp, real_T x_data[], int32_T b_xstart,
                      int32_T b_xend, real_T cmp_workspace_pts_data[], int32_T
                      cmp_workspace_pts_size[2]);
static void insertionsort(real_T x_data[], int32_T b_xstart, int32_T b_xend,
  real_T cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2]);
static void b_heapsort(real_T x_data[], int32_T b_xstart, int32_T b_xend, real_T
  cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2]);
static void heapify(real_T x_data[], int32_T idx, int32_T b_xstart, int32_T
                    b_xend, real_T cmp_workspace_pts_data[], int32_T
                    cmp_workspace_pts_size[2]);
static int32_T sortpartition(real_T x_data[], int32_T b_xstart, int32_T b_xend,
  real_T cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2]);
static real_T eml_rand_mt19937ar(const emlrtStack *sp, uint32_T e_state[625]);
static void xzlascl(real_T cfrom, real_T cto, real_T A[64]);
static void c_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[64],
                     int32_T ic0, real_T work[8]);
static void b_xzlascl(real_T cfrom, real_T cto, real_T A[8]);
static void xzggbal(real_T A[64], real_T B[64], int32_T *ilo, int32_T *ihi,
                    int32_T rscale[8]);
static void xzgeqr2(real_T A[64], int32_T ijmin, int32_T imax, real_T tau[8]);
static void xzgghrd(const emlrtStack *sp, int32_T ilo, int32_T ihi, real_T A[64],
                    real_T B[64], real_T Z[64]);
static void xdhgeqz(const emlrtStack *sp, real_T h[64], real_T t[64], int32_T
                    ilo, int32_T ihi, real_T z[64], int32_T *info, real_T
                    alphar[8], real_T alphai[8], real_T beta[8]);
static void xrot(int32_T n, real_T x[64], int32_T ix0, int32_T iy0, real_T c,
                 real_T s);
static void b_xrot(int32_T n, real_T x[64], int32_T ix0, int32_T iy0, real_T c,
                   real_T s);
static void c_xrot(real_T x[64], int32_T ix0, int32_T iy0, real_T c, real_T s);
static real_T b_xzlarfg(real_T *alpha1, real_T x[3]);
static int32_T xdtgevc(const emlrtStack *sp, real_T s[64], real_T p[64], real_T
  vr[64]);
static void xdlaln2(int32_T na, int32_T nw, real_T smin, real_T ca, real_T A[64],
                    int32_T ia0, real_T d1, real_T d2, real_T B[48], int32_T ib0,
                    real_T wr, real_T wi, real_T X[4], real_T *scale, real_T
                    *xnorm);
static void d_sort(real_T x[8], int32_T idx[8]);
static void b_merge(int32_T idx[8], real_T x[8], int32_T offset, int32_T np,
                    int32_T nq, int32_T iwork[8], real_T xwork[8]);
static void xgetrf(creal_T A[16], int32_T ipiv[4], int32_T *info);
static void c_xzlascl(real_T cfrom, real_T cto, real_T A[16]);
static void xscal(int32_T n, real_T a, real_T x[16], int32_T ix0);
static void d_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[16],
                     int32_T ic0, real_T work[4]);
static void d_xzlascl(real_T cfrom, real_T cto, real_T A[4]);
static void xswap(real_T x[16], int32_T ix0, int32_T iy0);
static void e_xzlarf(int32_T n, int32_T iv0, real_T tau, real_T C[16], int32_T
                     ic0, real_T work[4]);
static int32_T b_xhseqr(const emlrtStack *sp, real_T h[16], real_T z[16]);
static void b_xscal(real_T a, real_T x[16], int32_T ix0);
static void d_xrot(real_T x[16], int32_T ix0, int32_T iy0, real_T c, real_T s);
static void xaxpy(int32_T n, real_T a, int32_T ix0, real_T y[16], int32_T iy0);
static void c_xscal(int32_T n, real_T a, real_T x[4], int32_T ix0);
static void b_xaxpy(int32_T n, real_T a, real_T x[16], int32_T ix0, real_T y[4],
                    int32_T iy0);
static void c_xaxpy(int32_T n, real_T a, real_T x[4], int32_T ix0, real_T y[16],
                    int32_T iy0);
static void skipNaNs(const emlrtStack *sp, int32_T *k, coder_array_real_T *xv,
                     coder_array_real_T *yv, int32_T nx);
static void b_merge_block(int32_T idx_data[], int32_T idx_size[2], real_T
  x_data[], int32_T x_size[2], int32_T offset, int32_T n, int32_T preSortLevel,
  int32_T iwork_data[], real_T xwork_data[], int32_T b_idx_data[], int32_T
  b_idx_size[2], real_T b_x_data[], int32_T b_x_size[2]);
static void c_merge(int32_T idx_data[], int32_T idx_size[2], real_T x_data[],
                    int32_T x_size[2], int32_T offset, int32_T np, int32_T nq,
                    int32_T iwork_data[], real_T xwork_data[], int32_T
                    b_idx_data[], int32_T b_idx_size[2], real_T b_x_data[],
                    int32_T b_x_size[2]);
static void b_skipNaNs(const emlrtStack *sp, int32_T *k, real_T xv_data[],
  real_T yv_data[], int32_T nx);
static void d_exp(creal_T *x);
static void findA(const emlrtStack *sp, real_T *a, real_T c, real_T d);
static void e_sqrt(creal_T *x);
static void binary_expand_op(real_T in1_data[], int32_T in1_size[2], real_T in2
  [2], int32_T in3_size[2], real_T in4_data[], int32_T in4_size[2]);
static void binary_expand_op_1(real_T in1_data[], int32_T in1_size[2], real_T
  in2[2], int32_T in3_size[2], real_T in4, int32_T in5_size[2]);
static void rdivide(real_T in1_data[], int32_T in1_size[2], real_T in2_data[],
                    int32_T in2_size[2]);
static void binary_expand_op_2(coder_array_real_T_2D *in1, coder_array_real_T_3D
  *in2, real_T in3_data[], int32_T in3_size[4]);
static void binary_expand_op_7(real_T in1_data[], int32_T in1_size[1], real_T
  in2_data[], int32_T in2_size[2], real_T in3_data[], int32_T in3_size[2]);
static void minus(creal_T in1_data[], int32_T in1_size[2], creal_T in2_data[],
                  int32_T in2_size[2], creal_T in3_data[], int32_T in3_size[2]);
static void binary_expand_op_8(real_T in1_data[], int32_T in1_size[2], real_T
  in2_data[], int32_T in2_size[2]);
static void b_rdivide(real_T in1_data[], int32_T in1_size[2], real_T in2_data[],
                      int32_T in2_size[2]);
static void binary_expand_op_9(real_T in1_data[], int32_T in1_size[2], cuint8_T
  in2, creal_T in3_data[], int32_T in3_size[2], real_T in4_data[], int32_T
  in4_size[2], real_T in5);
static void times(creal_T in1_data[], int32_T in1_size[2], creal_T in2_data[],
                  int32_T in2_size[2]);
static void array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray, int32_T size0, int32_T size1);
static void array_real_T_2D_SetSize(coder_array_real_T_2D *coderArray, int32_T
  size0, int32_T size1);
static void array_char_T_2D_SetSize(coder_array_char_T_2D *coderArray, int32_T
  size0, int32_T size1);
static void array_BusLaneBoundary_2D_SetSiz(coder_array_BusLaneBoundary_2D
  *coderArray, int32_T size0, int32_T size1);
static void array_s_CP1nqD0d6aDeTm14G2mGp_S(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray, int32_T size0);
static void array_s_CP1nqD0d6aDeTm14G2mGp_C(s_CP1nqD0d6aDeTm14G2mGp *pStruct);
static void array_real_T_100x3_Constructor(coder_array_real_T_100x3 *pArray);
static void array_real_T_3D_SetSize(coder_array_real_T_3D *coderArray, int32_T
  size0, int32_T size1, int32_T size2);
static void array_real_T_4D_SetSize(coder_array_real_T_4D *coderArray, int32_T
  size0, int32_T size1, int32_T size2, int32_T size3);
static void array_boolean_T_SetSize(coder_array_boolean_T *coderArray, int32_T
  size0);
static void array_boolean_T_2D_SetSize(coder_array_boolean_T_2D *coderArray,
  int32_T size0, int32_T size1);
static void array_int32_T_SetSize(coder_array_int32_T *coderArray, int32_T size0);
static void array_int32_T_2D_SetSize(coder_array_int32_T_2D *coderArray, int32_T
  size0, int32_T size1);
static void array_real_T_SetSize(coder_array_real_T *coderArray, int32_T size0);
static void array_creal_T_SetSize(coder_array_creal_T *coderArray, int32_T size0);
static void array_creal_T_2D_SetSize(coder_array_creal_T_2D *coderArray, int32_T
  size0, int32_T size1);
static void array_cameraIntrinsics_Construc(cameraIntrinsics *pStruct);
static void b_array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray);
static void c_array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray);
static void array_cameraIntrinsics_Destruct(cameraIntrinsics *pStruct);
static void array_real_T_2D_Reserve(coder_array_real_T_2D *coderArray, int32_T
  b_numel);
static void array_real_T_2D_Constructor(coder_array_real_T_2D *coderArray);
static void array_real_T_2D_Destructor(coder_array_real_T_2D *coderArray);
static void b_array_s_CP1nqD0d6aDeTm14G2mGp_C(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray);
static void array_s_CP1nqD0d6aDeTm14G2mGp_D(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray);
static void array_matlabshared_scenario_Sen
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *pStruct);
static void array_char_T_2D_Constructor(coder_array_char_T_2D *coderArray);
static void array_char_T_2D_Destructor(coder_array_char_T_2D *coderArray);
static void b_array_matlabshared_scenario_Sen
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *pStruct);
static void array_BusLaneBoundary_2D_Constr(coder_array_BusLaneBoundary_2D
  *coderArray);
static void array_BusLaneBoundary_2D_Destru(coder_array_BusLaneBoundary_2D
  *coderArray);
static void array_real_T_3D_Reserve(coder_array_real_T_3D *coderArray, int32_T
  b_numel);
static void array_real_T_3D_Constructor(coder_array_real_T_3D *coderArray);
static void array_real_T_4D_Constructor(coder_array_real_T_4D *coderArray);
static void array_real_T_3D_Destructor(coder_array_real_T_3D *coderArray);
static void array_real_T_4D_Destructor(coder_array_real_T_4D *coderArray);
static void array_boolean_T_Reserve(coder_array_boolean_T *coderArray, int32_T
  b_numel);
static void array_boolean_T_2D_Constructor(coder_array_boolean_T_2D *coderArray);
static void array_boolean_T_Constructor(coder_array_boolean_T *coderArray);
static void array_boolean_T_2D_Destructor(coder_array_boolean_T_2D *coderArray);
static void array_boolean_T_Destructor(coder_array_boolean_T *coderArray);
static void array_int32_T_Constructor(coder_array_int32_T *coderArray);
static void array_int32_T_Destructor(coder_array_int32_T *coderArray);
static void array_int32_T_2D_Constructor(coder_array_int32_T_2D *coderArray);
static void array_real_T_Constructor(coder_array_real_T *coderArray);
static void array_int32_T_2D_Destructor(coder_array_int32_T_2D *coderArray);
static void array_real_T_Destructor(coder_array_real_T *coderArray);
static void array_creal_T_2D_Constructor(coder_array_creal_T_2D *coderArray);
static void array_creal_T_Constructor(coder_array_creal_T *coderArray);
static void array_creal_T_2D_Destructor(coder_array_creal_T_2D *coderArray);
static void array_creal_T_Destructor(coder_array_creal_T *coderArray);
static int32_T div_nzp_s32_floor(int32_T numerator, int32_T denominator);
static int32_T div_s32(const emlrtStack *sp, int32_T numerator, int32_T
  denominator);
static int32_T div_nzp_s32(int32_T numerator, int32_T denominator);
static void init_simulink_io_address(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance);

/* Function Definitions */
static void cgxe_mdl_start(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance)
{
  emlrtStack st = { NULL,              /* site */
    NULL,                              /* tls */
    NULL                               /* prev */
  };

  init_simulink_io_address(moduleInstance);
  st.tls = moduleInstance->emlrtRootTLSGlobal;
  cgxertSetSimStateCompliance(moduleInstance->S, 4);
  cgxertSetGcb(moduleInstance->S, -1, -1);
  mw__internal__system__init__fcn(moduleInstance);
  mw__internal__call__setup(moduleInstance, &st);
  cgxertRestoreGcb(moduleInstance->S, -1, -1);
}

static void cgxe_mdl_initialize(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  emlrtStack st = { NULL,              /* site */
    NULL,                              /* tls */
    NULL                               /* prev */
  };

  st.tls = moduleInstance->emlrtRootTLSGlobal;
  emlrtLicenseCheckR2022a(&st, "EMLRT:runTime:MexFunctionNeedsLicense",
    "automated_driving_toolbox", 2);
  emlrtLicenseCheckR2022a(&st, "EMLRT:runTime:MexFunctionNeedsLicense",
    "video_and_image_blockset", 2);
  emlrtLicenseCheckR2022a(&st, "EMLRT:runTime:MexFunctionNeedsLicense",
    "image_toolbox", 2);
  cgxertSetGcb(moduleInstance->S, -1, -1);
  mw__internal__call__reset(moduleInstance, &st);
  cgxertRestoreGcb(moduleInstance->S, -1, -1);
}

static void cgxe_mdl_outputs(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  BusLaneDetections1LaneBoundaries rv2[4];
  BusVehiclePose rv1[3];
  emlrtStack st = { NULL,              /* site */
    NULL,                              /* tls */
    NULL                               /* prev */
  };

  int32_T i;
  int32_T i1;
  int32_T i2;
  st.tls = moduleInstance->emlrtRootTLSGlobal;
  cgxertSetGcb(moduleInstance->S, -1, -1);
  for (i = 0; i < 1; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      rv1[i1].ActorID = *(real_T *)&((char_T *)(BusVehiclePose *)&((char_T *)
        (BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])[104 *
        (int32_T)i1])[0];
      rv1[i1].Roll = *(real_T *)&((char_T *)(BusVehiclePose *)&((char_T *)
        (BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])[104 *
        (int32_T)i1])[56];
      rv1[i1].Pitch = *(real_T *)&((char_T *)(BusVehiclePose *)&((char_T *)
        (BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])[104 *
        (int32_T)i1])[64];
      rv1[i1].Yaw = *(real_T *)&((char_T *)(BusVehiclePose *)&((char_T *)
        (BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])[104 *
        (int32_T)i1])[72];
      for (i2 = 0; i2 < 3; i2++) {
        rv1[i1].Position[i2] = (*(real_T (*)[3])&((char_T *)(BusVehiclePose *)
          &((char_T *)(BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])
          [104 * (int32_T)i1])[8])[i2];
        rv1[i1].Velocity[i2] = (*(real_T (*)[3])&((char_T *)(BusVehiclePose *)
          &((char_T *)(BusVehiclePose (*)[3])&((char_T *)moduleInstance->u0)[16])
          [104 * (int32_T)i1])[32])[i2];
        rv1[i1].AngularVelocity[i2] = (*(real_T (*)[3])&((char_T *)
          (BusVehiclePose *)&((char_T *)(BusVehiclePose (*)[3])&((char_T *)
          moduleInstance->u0)[16])[104 * (int32_T)i1])[80])[i2];
      }
    }
  }

  for (i = 0; i < 500; i++) {
    for (i1 = 0; i1 < 1; i1++) {
      for (i2 = 0; i2 < 300; i2++) {
        moduleInstance->rv3[i].Coordinates[i2] = (*(real_T (*)[300])&((char_T *)
          (BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&((char_T *)
          moduleInstance->u1)[16])[4056 * (int32_T)i])[0])[i2];
      }

      for (i2 = 0; i2 < 100; i2++) {
        moduleInstance->rv3[i].Curvature[i2] = (*(real_T (*)[100])&((char_T *)
          (BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&((char_T *)
          moduleInstance->u1)[16])[4056 * (int32_T)i])[2400])[i2];
        moduleInstance->rv3[i].CurvatureDerivative[i2] = (*(real_T (*)[100])&
          ((char_T *)(BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&
          ((char_T *)moduleInstance->u1)[16])[4056 * (int32_T)i])[3200])[i2];
      }

      moduleInstance->rv3[i].HeadingAngle = *(real_T *)&((char_T *)
        (BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&((char_T *)
        moduleInstance->u1)[16])[4056 * (int32_T)i])[4000];
      moduleInstance->rv3[i].LateralOffset = *(real_T *)&((char_T *)
        (BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&((char_T *)
        moduleInstance->u1)[16])[4056 * (int32_T)i])[4008];
      moduleInstance->rv3[i].BoundaryType = *(uint8_T *)&((char_T *)
        (BusLaneBoundary *)&((char_T *)(BusLaneBoundary (*)[500])&((char_T *)
        moduleInstance->u1)[16])[4056 * (int32_T)i])[4016];
      moduleInstance->rv3[i].Strength = *(real_T *)&((char_T *)(BusLaneBoundary *)
        &((char_T *)(BusLaneBoundary (*)[500])&((char_T *)moduleInstance->u1)[16])
        [4056 * (int32_T)i])[4024];
      moduleInstance->rv3[i].Width = *(real_T *)&((char_T *)(BusLaneBoundary *)
        &((char_T *)(BusLaneBoundary (*)[500])&((char_T *)moduleInstance->u1)[16])
        [4056 * (int32_T)i])[4032];
      moduleInstance->rv3[i].Length = *(real_T *)&((char_T *)(BusLaneBoundary *)
        &((char_T *)(BusLaneBoundary (*)[500])&((char_T *)moduleInstance->u1)[16])
        [4056 * (int32_T)i])[4040];
      moduleInstance->rv3[i].Space = *(real_T *)&((char_T *)(BusLaneBoundary *)
        &((char_T *)(BusLaneBoundary (*)[500])&((char_T *)moduleInstance->u1)[16])
        [4056 * (int32_T)i])[4048];
    }
  }

  mw__internal__call__step(moduleInstance, &st, *(real_T *)&((char_T *)
    moduleInstance->u0)[0], *(real_T *)&((char_T *)moduleInstance->u0)[8], rv1, *
    (real_T *)&((char_T *)moduleInstance->u1)[0], *(real_T *)&((char_T *)
    moduleInstance->u1)[8], moduleInstance->rv3, (real_T *)&((char_T *)
    moduleInstance->b_y0)[0], (boolean_T *)&((char_T *)moduleInstance->b_y0)[8],
    moduleInstance->rv, (real_T *)&((char_T *)moduleInstance->b_y1)[0],
    (boolean_T *)&((char_T *)moduleInstance->b_y1)[8], (real_T *)&((char_T *)
    moduleInstance->b_y1)[16], (real_T *)&((char_T *)moduleInstance->b_y1)[24],
    rv2);
  for (i = 0; i < 1; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[0] = rv2[i1].Curvature;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[8] = rv2[i1].
        CurvatureDerivative;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[16] = rv2[i1].CurveLength;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[24] = rv2[i1].HeadingAngle;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[32] = rv2[i1].
        LateralOffset;
      *(uint8_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[40] = rv2[i1].BoundaryType;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[48] = rv2[i1].Strength;
      *(real_T *)&((char_T *)(BusLaneDetections1LaneBoundaries *)&((char_T *)
        (BusLaneDetections1LaneBoundaries (*)[4])&((char_T *)
        moduleInstance->b_y1)[32])[64 * (int32_T)i1])[56] = rv2[i1].Width;
    }

    for (i1 = 0; i1 < 50; i1++) {
      *(real_T *)&((char_T *)(BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[0] = moduleInstance->rv[i1].Time;
      for (i2 = 0; i2 < 6; i2++) {
        (*(real_T (*)[6])&((char_T *)(BusObjectDetections1Detections *)&((char_T
            *)(BusObjectDetections1Detections (*)[50])&((char_T *)
            moduleInstance->b_y0)[16])[480 * (int32_T)i1])[8])[i2] =
          moduleInstance->rv[i1].Measurement[i2];
      }

      for (i2 = 0; i2 < 36; i2++) {
        (*(real_T (*)[36])&((char_T *)(BusObjectDetections1Detections *)
                            &((char_T *)(BusObjectDetections1Detections (*)[50])
                              &((char_T *)moduleInstance->b_y0)[16])[480 *
                            (int32_T)i1])[56])[i2] = moduleInstance->rv[i1].
          MeasurementNoise[i2];
      }

      *(real_T *)&((char_T *)(BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[344] = moduleInstance->rv[i1].SensorIndex;
      *(real_T *)&((char_T *)(BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[352] = moduleInstance->rv[i1].ObjectClassID;
      *(drivingCoordinateFrameType *)&((char_T *)
        (BusVisionDetectionsMeasurementParameters *)&((char_T *)
        (BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[360])[0] = moduleInstance->rv[i1].
        MeasurementParameters.Frame;
      for (i2 = 0; i2 < 3; i2++) {
        (*(real_T (*)[3])&((char_T *)(BusVisionDetectionsMeasurementParameters *)
                           &((char_T *)(BusObjectDetections1Detections *)
                             &((char_T *)(BusObjectDetections1Detections (*)[50])
            &((char_T *)moduleInstance->b_y0)[16])[480 * (int32_T)i1])[360])[8])
          [i2] = moduleInstance->rv[i1].MeasurementParameters.OriginPosition[i2];
      }

      for (i2 = 0; i2 < 9; i2++) {
        (*(real_T (*)[9])&((char_T *)(BusVisionDetectionsMeasurementParameters *)
                           &((char_T *)(BusObjectDetections1Detections *)
                             &((char_T *)(BusObjectDetections1Detections (*)[50])
            &((char_T *)moduleInstance->b_y0)[16])[480 * (int32_T)i1])[360])[32])
          [i2] = moduleInstance->rv[i1].MeasurementParameters.Orientation[i2];
      }

      *(boolean_T *)&((char_T *)(BusVisionDetectionsMeasurementParameters *)
                      &((char_T *)(BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[360])[104] = moduleInstance->rv[i1].
        MeasurementParameters.HasVelocity;
      *(real_T *)&((char_T *)(BusVisionDetectionsObjectAttributes *)&((char_T *)
        (BusObjectDetections1Detections *)&((char_T *)
        (BusObjectDetections1Detections (*)[50])&((char_T *)moduleInstance->b_y0)
        [16])[480 * (int32_T)i1])[472])[0] = moduleInstance->rv[i1].
        ObjectAttributes.TargetIndex;
    }
  }

  cgxertRestoreGcb(moduleInstance->S, -1, -1);
}

static void cgxe_mdl_update(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance)
{
  (void)moduleInstance;
}

static void cgxe_mdl_derivative(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  (void)moduleInstance;
}

static void cgxe_mdl_enable(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance)
{
  (void)moduleInstance;
}

static void cgxe_mdl_disable(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  (void)moduleInstance;
}

static void cgxe_mdl_terminate(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  cgxertSetGcb(moduleInstance->S, -1, -1);
  cgxertRestoreGcb(moduleInstance->S, -1, -1);
}

static void mw__internal__system__init__fcn(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  static uint32_T uv[625] = { 5489U, 1301868182U, 2938499221U, 2950281878U,
    1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U, 219885934U,
    2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U, 3418470598U,
    951210697U, 3693558366U, 2923482051U, 1793174584U, 2982310801U, 1586906132U,
    1951078751U, 1808158765U, 1733897588U, 431328322U, 4202539044U, 530658942U,
    1714810322U, 3025256284U, 3342585396U, 1937033938U, 2640572511U, 1654299090U,
    3692403553U, 4233871309U, 3497650794U, 862629010U, 2943236032U, 2426458545U,
    1603307207U, 1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U,
    761573964U, 3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U,
    3295982469U, 1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,
    699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,
    1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U, 3570962471U,
    4287636090U, 4087307012U, 3603343627U, 202242161U, 2995682783U, 1620962684U,
    3704723357U, 371613603U, 2814834333U, 2111005706U, 624778151U, 2094172212U,
    4284947003U, 1211977835U, 991917094U, 1570449747U, 2962370480U, 1259410321U,
    170182696U, 146300961U, 2836829791U, 619452428U, 2723670296U, 1881399711U,
    1161269684U, 1675188680U, 4132175277U, 780088327U, 3409462821U, 1036518241U,
    1834958505U, 3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U,
    1924681712U, 3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,
    3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U, 2339662006U,
    501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U, 3393774360U,
    1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U, 819755096U,
    2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U, 1029741190U,
    2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U, 2701024045U,
    4117700889U, 759495121U, 3332270341U, 2313004527U, 2277067795U, 4131855432U,
    2722057515U, 1264804546U, 3848622725U, 2211267957U, 4100593547U, 959123777U,
    2130745407U, 3194437393U, 486673947U, 1377371204U, 17472727U, 352317554U,
    3955548058U, 159652094U, 1232063192U, 3835177280U, 49423123U, 3083993636U,
    733092U, 2120519771U, 2573409834U, 1112952433U, 3239502554U, 761045320U,
    1087580692U, 2540165110U, 641058802U, 1792435497U, 2261799288U, 1579184083U,
    627146892U, 2165744623U, 2200142389U, 2167590760U, 2381418376U, 1793358889U,
    3081659520U, 1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,
    3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,
    3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,
    354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,
    1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U, 1684529556U,
    1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U, 171579916U,
    3878728600U, 2475806724U, 2030324028U, 3331164912U, 1708711359U, 1970023127U,
    2859691344U, 2588476477U, 2748146879U, 136111222U, 2967685492U, 909517429U,
    2835297809U, 3206906216U, 3186870716U, 341264097U, 2542035121U, 3353277068U,
    548223577U, 3170936588U, 1678403446U, 297435620U, 2337555430U, 466603495U,
    1132321815U, 1208589219U, 696392160U, 894244439U, 2562678859U, 470224582U,
    3306867480U, 201364898U, 2075966438U, 1767227936U, 2929737987U, 3674877796U,
    2654196643U, 3692734598U, 3528895099U, 2796780123U, 3048728353U, 842329300U,
    191554730U, 2922459673U, 3489020079U, 3979110629U, 1022523848U, 2202932467U,
    3583655201U, 3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U,
    396426791U, 3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,
    3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,
    2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U, 1521001832U,
    3605886097U, 2802786495U, 2728923319U, 3996284304U, 903417639U, 1171249804U,
    1020374987U, 2824535874U, 423621996U, 1988534473U, 2493544470U, 1008604435U,
    1756003503U, 1488867287U, 1386808992U, 732088248U, 1780630732U, 2482101014U,
    976561178U, 1543448953U, 2602866064U, 2021139923U, 1952599828U, 2360242564U,
    2117959962U, 2753061860U, 2388623612U, 4138193781U, 2962920654U, 2284970429U,
    766920861U, 3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,
    3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U, 686850534U,
    1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U, 4195430425U,
    607905174U, 3902331779U, 2454067926U, 1708133115U, 1170874362U, 2008609376U,
    3260320415U, 2211196135U, 433538229U, 2728786374U, 2189520818U, 262554063U,
    1182318347U, 3710237267U, 1221022450U, 715966018U, 2417068910U, 2591870721U,
    2870691989U, 3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,
    4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U, 1123218514U,
    551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U, 422862282U,
    3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U, 1324564878U,
    1928816105U, 1786535431U, 2878099422U, 3290185549U, 539474248U, 1657512683U,
    552370646U, 1671741683U, 3655312128U, 1552739510U, 2605208763U, 1441755014U,
    181878989U, 3124053868U, 1447103986U, 3183906156U, 1728556020U, 3502241336U,
    3055466967U, 1013272474U, 818402132U, 1715099063U, 2900113506U, 397254517U,
    4194863039U, 1009068739U, 232864647U, 2540223708U, 2608288560U, 2415367765U,
    478404847U, 3455100648U, 3182600021U, 2115988978U, 434269567U, 4117179324U,
    3461774077U, 887256537U, 3545801025U, 286388911U, 3451742129U, 1981164769U,
    786667016U, 3310123729U, 3097811076U, 2224235657U, 2959658883U, 3370969234U,
    2514770915U, 3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,
    4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U, 1477814055U,
    4043852216U, 1876372354U, 3133294443U, 3871104810U, 3177020907U, 2074304428U,
    3479393793U, 759562891U, 164128153U, 1839069216U, 2114162633U, 3989947309U,
    3611054956U, 1333547922U, 835429831U, 494987340U, 171987910U, 1252001001U,
    370809172U, 3508925425U, 2535703112U, 1276855041U, 1922855120U, 835673414U,
    3030664304U, 613287117U, 171219893U, 3423096126U, 3376881639U, 2287770315U,
    1658692645U, 1262815245U, 3957234326U, 1168096164U, 2968737525U, 2655813712U,
    2132313144U, 3976047964U, 326516571U, 353088456U, 3679188938U, 3205649712U,
    2654036126U, 1249024881U, 880166166U, 691800469U, 2229503665U, 1673458056U,
    4032208375U, 1851778863U, 2563757330U, 376742205U, 1794655231U, 340247333U,
    1505873033U, 396524441U, 879666767U, 3335579166U, 3260764261U, 3335999539U,
    506221798U, 4214658741U, 975887814U, 2080536343U, 3360539560U, 571586418U,
    138896374U, 4234352651U, 2737620262U, 3928362291U, 1516365296U, 38056726U,
    3599462320U, 3585007266U, 3850961033U, 471667319U, 1536883193U, 2310166751U,
    1861637689U, 2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,
    2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,
    643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U, 3285177704U,
    1948416081U, 1311525291U, 1183517742U, 1739192232U, 3979815115U, 2567840007U,
    4116821529U, 213304419U, 4125718577U, 1473064925U, 2442436592U, 1893310111U,
    4195361916U, 3747569474U, 828465101U, 2991227658U, 750582866U, 1205170309U,
    1409813056U, 678418130U, 1171531016U, 3821236156U, 354504587U, 4202874632U,
    3882511497U, 1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U,
    3725758099U, 831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U,
    3358210805U, 4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U,
    190157081U, 3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,
    2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,
    453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U, 3541393095U,
    4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U, 1795580598U,
    2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U, 705213300U,
    363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U, 2199989172U,
    1987356470U, 4026755612U, 2147252133U, 270400031U, 1367820199U, 2369854699U,
    2844269403U, 79981964U, 624U };

  emlrtStack st;
  int32_T i;
  for (i = 0; i < 625; i++) {
    moduleInstance->state[i] = uv[i];
  }

  st.site = NULL;
  moduleInstance->seed = 0U;
  moduleInstance->seed_not_empty = true;
  st.site = NULL;
  moduleInstance->method = 7U;
  moduleInstance->method_not_empty = true;
  st.site = NULL;
  moduleInstance->state_not_empty = true;
  st.site = NULL;
  for (i = 0; i < 2; i++) {
    moduleInstance->b_state[i] = 158852560U * (uint32_T)i + 362436069U;
  }

  moduleInstance->b_state_not_empty = true;
  st.site = NULL;
  moduleInstance->c_state = 1144108930U;
  moduleInstance->c_state_not_empty = true;
  st.site = NULL;
  moduleInstance->b_method = 0U;
  moduleInstance->b_method_not_empty = true;
  for (i = 0; i < 2; i++) {
    moduleInstance->d_state[i] = 158852560U * (uint32_T)i + 362436069U;
  }

  moduleInstance->d_state_not_empty = true;
}

static void mw__internal__call__setup(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 51 };

  static const int32_T iv1[2] = { 1, 51 };

  static const int32_T iv2[2] = { 1, 5 };

  static char_T b_u[51] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'y', 's',
    't', 'e', 'm', ':', 'm', 'e', 't', 'h', 'o', 'd', 'C', 'a', 'l', 'l', 'e',
    'd', 'W', 'h', 'e', 'n', 'L', 'o', 'c', 'k', 'e', 'd', 'R', 'e', 'l', 'e',
    'a', 's', 'e', 'd', 'C', 'o', 'd', 'e', 'g', 'e', 'n' };

  static char_T d_u[5] = { 's', 'e', 't', 'u', 'p' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[51];
  char_T c_u[5];
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (!moduleInstance->sysobj_not_empty) {
    st.site = &i_emlrtRSI;
    b_st.site = &emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &c_emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &d_emlrtRSI;
    st.site = &j_emlrtRSI;
    visionDetectionGenerator_visionDetectionGenerator(&st,
      &moduleInstance->sysobj);
    moduleInstance->sysobj_not_empty = true;
  }

  st.site = &k_emlrtRSI;
  if (moduleInstance->sysobj.isInitialized != 0) {
    for (i = 0; i < 51; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 51, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 51; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 51, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 5; i++) {
      c_u[i] = d_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 5, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &d_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &m_emlrtMCI),
           &m_emlrtMCI), &m_emlrtMCI);
  }

  moduleInstance->sysobj.isInitialized = 1;
  b_st.site = &d_emlrtRSI;
  visionDetectionGenerator_setupImpl(moduleInstance, &b_st,
    &moduleInstance->sysobj);
  b_st.site = &d_emlrtRSI;
  SystemCore_checkTunablePropChange(&b_st, &moduleInstance->sysobj);
  moduleInstance->sysobj.TunablePropsChanged = false;
}

static visionDetectionGenerator
  *visionDetectionGenerator_visionDetectionGenerator(const emlrtStack *sp,
  visionDetectionGenerator *obj)
{
  static const int32_T iv[2] = { 1, 46 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 10 };

  static const int32_T iv4[2] = { 1, 28 };

  static char_T b_u[46] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'S', 'c', 'a', 'l', 'a', 'r' };

  static char_T c_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'S', 'c', 'a', 'l', 'a', 'r' };

  static char_T g_u[28] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'm', 'o',
    'n', 'o', 'C', 'a', 'm', 'e', 'r', 'a', ':', 'h', 'i', 'g', 'h', 'P', 'i',
    't', 'c', 'h' };

  static char_T e_u[10] = { 'I', 'n', 't', 'r', 'i', 'n', 's', 'i', 'c', 's' };

  static int8_T iv3[3] = { 0, 0, 1 };

  b_vision_internal_codegen_cameraIntrinsicsArray r;
  cameraIntrinsics camObj;
  cameraIntrinsics *monoCamSen_Intrinsics;
  cameraIntrinsics *r1;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack f_st;
  emlrtStack g_st;
  emlrtStack h_st;
  emlrtStack i_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  visionDetectionGenerator *b_obj;
  real_T intrinsicMat[9];
  real_T monoCamSen_SensorLocation[2];
  real_T t22_SensorLocation[2];
  real_T b_u0;
  real_T k;
  real_T monoCamSen_Height;
  real_T monoCamSen_Pitch;
  real_T monoCamSen_Roll;
  real_T monoCamSen_Yaw;
  real_T v0;
  int32_T i;
  char_T u[46];
  char_T f_u[28];
  char_T d_u[10];
  boolean_T n;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  e_st.prev = &d_st;
  e_st.tls = d_st.tls;
  f_st.prev = &e_st;
  f_st.tls = e_st.tls;
  g_st.prev = &f_st;
  g_st.tls = f_st.tls;
  h_st.prev = &g_st;
  h_st.tls = g_st.tls;
  i_st.prev = &c_st;
  i_st.tls = c_st.tls;
  array_cameraIntrinsics_Construc(&camObj);
  b_obj = obj;
  st.site = &l_emlrtRSI;
  b_st.site = &e_emlrtRSI;
  c_st.site = &f_emlrtRSI;
  d_st.site = &b_emlrtRSI;
  e_st.site = &c_emlrtRSI;
  d_st.site = &b_emlrtRSI;
  b_obj->TunablePropsChanged = false;
  e_st.site = &d_emlrtRSI;
  b_obj->isInitialized = 0;
  c_st.site = &f_emlrtRSI;
  d_st.site = &g_emlrtRSI;
  st.site = &m_emlrtRSI;
  b_st.site = &h_emlrtRSI;
  st.site = &n_emlrtRSI;
  b_st.site = &c_emlrtRSI;
  c_st.site = &s_emlrtRSI;
  d_st.site = &s_emlrtRSI;
  e_st.site = &u_emlrtRSI;
  cameraIntrinsics_toCameraIntrinsics(&camObj);
  e_st.site = &t_emlrtRSI;
  f_st.site = &hb_emlrtRSI;
  g_st.site = &ib_emlrtRSI;
  h_st.site = &jb_emlrtRSI;
  n = (camObj.cameraIntrinsicsArrayData.size[0] *
       camObj.cameraIntrinsicsArrayData.size[1] == 1);
  if (!n) {
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&g_st, 46, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      u[i] = c_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&g_st, 46, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 10; i++) {
      d_u[i] = e_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&g_st, 10, m, &d_u[0]);
    emlrtAssign(&c_y, m);
    h_st.site = &bw_emlrtRSI;
    error(&h_st, y, getString(&h_st, message(&h_st, b_y, c_y, &emlrtMCI),
           &emlrtMCI), &emlrtMCI);
  }

  st.site = &o_emlrtRSI;
  b_st.site = &w_emlrtRSI;
  c_st.site = &y_emlrtRSI;
  d_st.site = &cb_emlrtRSI;
  for (i = 0; i < 2; i++) {
    b_obj->_pobj1.FocalLength[i] = 800.0;
  }

  for (i = 0; i < 2; i++) {
    b_obj->_pobj1.PrincipalPoint[i] = -80.0 * (real_T)i + 320.0;
  }

  for (i = 0; i < 2; i++) {
    b_obj->_pobj1.ImageSize[i] = 160.0 * (real_T)i + 480.0;
  }

  for (i = 0; i < 2; i++) {
    b_obj->_pobj1.RadialDistortion[i] = 0.0;
  }

  for (i = 0; i < 2; i++) {
    b_obj->_pobj1.TangentialDistortion[i] = 0.0;
  }

  b_obj->_pobj1.Skew = 0.0;
  c_st.site = &ab_emlrtRSI;
  intrinsicMat[0] = b_obj->_pobj1.FocalLength[0];
  intrinsicMat[3] = b_obj->_pobj1.Skew;
  intrinsicMat[6] = b_obj->_pobj1.PrincipalPoint[0];
  intrinsicMat[1] = 0.0;
  intrinsicMat[4] = b_obj->_pobj1.FocalLength[1];
  intrinsicMat[7] = b_obj->_pobj1.PrincipalPoint[1];
  for (i = 0; i < 3; i++) {
    intrinsicMat[3 * i + 2] = (real_T)iv3[i];
  }

  for (i = 0; i < 9; i++) {
    b_obj->_pobj1.K[i] = intrinsicMat[i];
  }

  c_st.site = &bb_emlrtRSI;
  d_st.site = &db_emlrtRSI;
  e_st.site = &eb_emlrtRSI;
  b_st.site = &x_emlrtRSI;
  c_st.site = &fb_emlrtRSI;
  r.__dummy = 0;
  d_st.site = &gb_emlrtRSI;
  array_vision_internal_codegen_c(&b_obj->_pobj1.cameraIntrinsicsArrayData, 1, 1);
  b_obj->_pobj1.cameraIntrinsicsArrayData.vector.data[0] = r;
  st.site = &o_emlrtRSI;
  b_st.site = &kb_emlrtRSI;
  monoCamera_checkIntrinsics(&b_st, &b_obj->_pobj1);
  b_st.site = &lb_emlrtRSI;
  c_st.site = &sb_emlrtRSI;
  b_st.site = &mb_emlrtRSI;
  b_st.site = &nb_emlrtRSI;
  c_st.site = &tb_emlrtRSI;
  d_y = NULL;
  m = emlrtCreateLogicalScalar(false);
  emlrtAssign(&d_y, m);
  for (i = 0; i < 28; i++) {
    f_u[i] = g_u[i];
  }

  e_y = NULL;
  m = emlrtCreateCharArray(2, &iv4[0]);
  emlrtInitCharArrayR2013a(&c_st, 28, m, &f_u[0]);
  emlrtAssign(&e_y, m);
  f_y = NULL;
  m = emlrtCreateDoubleScalar(1.0);
  emlrtAssign(&f_y, m);
  d_st.site = &rx_emlrtRSI;
  i_st.site = &qx_emlrtRSI;
  coder_internal_warningIf(&d_st, d_y, e_y, num2str(&i_st, f_y, &b_emlrtMCI),
    &c_emlrtMCI);
  b_st.site = &ob_emlrtRSI;
  b_st.site = &pb_emlrtRSI;
  b_st.site = &qb_emlrtRSI;
  b_obj->pCameraConfiguration.Intrinsics = &b_obj->_pobj1;
  b_obj->pCameraConfiguration.Height = 1.1;
  b_obj->pCameraConfiguration.Pitch = 1.0;
  b_obj->pCameraConfiguration.Yaw = 0.0;
  b_obj->pCameraConfiguration.Roll = 0.0;
  for (i = 0; i < 2; i++) {
    b_obj->pCameraConfiguration.SensorLocation[i] = 0.0;
  }

  st.site = &p_emlrtRSI;
  visionDetectionGenerator_monoCameraInSensorFrame(b_obj, &r1,
    &monoCamSen_Height, &monoCamSen_Pitch, &monoCamSen_Yaw, &monoCamSen_Roll,
    monoCamSen_SensorLocation);
  monoCamSen_Intrinsics = r1;
  for (i = 0; i < 2; i++) {
    t22_SensorLocation[i] = monoCamSen_SensorLocation[i];
  }

  b_obj->pMonoCameraInSensorFrame.Intrinsics = monoCamSen_Intrinsics;
  b_obj->pMonoCameraInSensorFrame.Height = monoCamSen_Height;
  b_obj->pMonoCameraInSensorFrame.Pitch = monoCamSen_Pitch;
  b_obj->pMonoCameraInSensorFrame.Yaw = monoCamSen_Yaw;
  b_obj->pMonoCameraInSensorFrame.Roll = monoCamSen_Roll;
  for (i = 0; i < 2; i++) {
    b_obj->pMonoCameraInSensorFrame.SensorLocation[i] = t22_SensorLocation[i];
  }

  st.site = &q_emlrtRSI;
  monoCamera_horizonLine(&st, monoCamSen_Intrinsics, monoCamSen_Height,
    monoCamSen_Pitch, monoCamSen_Yaw, monoCamSen_Roll, monoCamSen_SensorLocation,
    &k, &b_u0, &v0);
  b_obj->pHorizonLine[0] = k;
  b_obj->pHorizonLine[1] = b_u0;
  b_obj->pHorizonLine[2] = v0;
  st.site = &r_emlrtRSI;
  visionDetectionGenerator_getUpVectorInImageCoordinates(&st, b_obj,
    monoCamSen_SensorLocation);
  for (i = 0; i < 2; i++) {
    b_obj->puvUp[i] = monoCamSen_SensorLocation[i];
  }

  array_cameraIntrinsics_Destruct(&camObj);
  return b_obj;
}

static cameraIntrinsics *cameraIntrinsics_toCameraIntrinsics(cameraIntrinsics
  *iobj_0)
{
  static int8_T iv[3] = { 0, 0, 1 };

  b_vision_internal_codegen_cameraIntrinsicsArray r;
  cameraIntrinsics *val;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack st;
  real_T intrinsicMat[9];
  int32_T i;
  st.site = &v_emlrtRSI;
  b_st.site = &w_emlrtRSI;
  c_st.site = &y_emlrtRSI;
  d_st.site = &cb_emlrtRSI;
  for (i = 0; i < 2; i++) {
    iobj_0->FocalLength[i] = 800.0;
  }

  for (i = 0; i < 2; i++) {
    iobj_0->PrincipalPoint[i] = -80.0 * (real_T)i + 320.0;
  }

  for (i = 0; i < 2; i++) {
    iobj_0->ImageSize[i] = 160.0 * (real_T)i + 480.0;
  }

  for (i = 0; i < 2; i++) {
    iobj_0->RadialDistortion[i] = 0.0;
  }

  for (i = 0; i < 2; i++) {
    iobj_0->TangentialDistortion[i] = 0.0;
  }

  iobj_0->Skew = 0.0;
  c_st.site = &ab_emlrtRSI;
  intrinsicMat[0] = iobj_0->FocalLength[0];
  intrinsicMat[3] = iobj_0->Skew;
  intrinsicMat[6] = iobj_0->PrincipalPoint[0];
  intrinsicMat[1] = 0.0;
  intrinsicMat[4] = iobj_0->FocalLength[1];
  intrinsicMat[7] = iobj_0->PrincipalPoint[1];
  for (i = 0; i < 3; i++) {
    intrinsicMat[3 * i + 2] = (real_T)iv[i];
  }

  for (i = 0; i < 9; i++) {
    iobj_0->K[i] = intrinsicMat[i];
  }

  c_st.site = &bb_emlrtRSI;
  d_st.site = &db_emlrtRSI;
  e_st.site = &eb_emlrtRSI;
  b_st.site = &x_emlrtRSI;
  val = iobj_0;
  c_st.site = &fb_emlrtRSI;
  r.__dummy = 0;
  d_st.site = &gb_emlrtRSI;
  array_vision_internal_codegen_c(&iobj_0->cameraIntrinsicsArrayData, 1, 1);
  iobj_0->cameraIntrinsicsArrayData.vector.data[0] = r;
  return val;
}

static boolean_T isequal(real_T varargin_1[2], real_T varargin_2[2])
{
  int32_T k;
  boolean_T b_p;
  boolean_T exitg1;
  boolean_T p;
  p = false;
  b_p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 2)) {
    if (!(varargin_1[k] == varargin_2[k])) {
      b_p = false;
      exitg1 = true;
    } else {
      k++;
    }
  }

  if (b_p) {
    p = true;
  }

  return p;
}

static void monoCamera_checkIntrinsics(const emlrtStack *sp, cameraIntrinsics
  *intrinsics)
{
  static const int32_T iv[2] = { 1, 32 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 10 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'S', 'c', 'a', 'l', 'a', 'r' };

  static char_T b_u[32] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'm', 'o', 'n',
    'o', 'C', 'a', 'm', 'e', 'r', 'a', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e',
    'd', 'S', 'c', 'a', 'l', 'a', 'r' };

  static char_T f_u[10] = { 'i', 'n', 't', 'r', 'i', 'n', 's', 'i', 'c', 's' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[32];
  char_T e_u[10];
  boolean_T n;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &rb_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &ib_emlrtRSI;
  c_st.site = &jb_emlrtRSI;
  n = (intrinsics->cameraIntrinsicsArrayData.size[0] *
       intrinsics->cameraIntrinsicsArrayData.size[1] == 1);
  if (!n) {
    for (i = 0; i < 32; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 32, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 10; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 10, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    c_st.site = &bw_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, b_y, c_y, &emlrtMCI),
           &emlrtMCI), &emlrtMCI);
  }
}

static void visionDetectionGenerator_monoCameraInSensorFrame
  (visionDetectionGenerator *obj, cameraIntrinsics **monoCam_Intrinsics, real_T *
   monoCam_Height, real_T *monoCam_Pitch, real_T *monoCam_Yaw, real_T
   *monoCam_Roll, real_T monoCam_SensorLocation[2])
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  monoCamera r;
  int32_T i;
  r = obj->pCameraConfiguration;
  *monoCam_Intrinsics = r.Intrinsics;
  *monoCam_Height = r.Height;
  *monoCam_Pitch = r.Pitch;
  *monoCam_Roll = r.Roll;
  st.site = &ub_emlrtRSI;
  b_st.site = &wb_emlrtRSI;
  c_st.site = &xb_emlrtRSI;
  d_st.site = &ib_emlrtRSI;
  for (i = 0; i < 2; i++) {
    monoCam_SensorLocation[i] = 0.0;
  }

  st.site = &vb_emlrtRSI;
  *monoCam_Yaw = 0.0;
}

static void monoCamera_rawTformToImage3D(cameraIntrinsics *this_Intrinsics,
  real_T this_Height, real_T this_Pitch, real_T this_Yaw, real_T this_Roll,
  real_T this_SensorLocation[2], real_T tform[12])
{
  static real_T h_a[9] = { -6.123233995736766E-17, -1.0, -7.498798913309288E-33,
    -1.0, 6.123233995736766E-17, -1.2246467991473532E-16, 1.2246467991473532E-16,
    0.0, -1.0 };

  static int8_T iv[3] = { 0, 0, 1 };

  static int8_T iv1[3] = { 1, 0, 0 };

  emlrtStack st;
  real_T j_a[12];
  real_T b[9];
  real_T b_dv[9];
  real_T dv1[9];
  real_T dv2[9];
  real_T dv3[9];
  real_T dv4[9];
  real_T g_a[9];
  real_T i_a[9];
  real_T b_this_SensorLocation[3];
  real_T c_this_SensorLocation[3];
  real_T a;
  real_T b_a;
  real_T c_a;
  real_T d_a;
  real_T e_a;
  real_T f_a;
  int32_T i;
  int32_T i1;
  int32_T i2;
  st.site = &yb_emlrtRSI;
  a = 0.017453292519943295 * -this_Yaw;
  b_a = 0.017453292519943295 * (90.0 - this_Pitch);
  c_a = 0.017453292519943295 * this_Roll;
  st.site = &ac_emlrtRSI;
  d_a = 0.017453292519943295 * -this_Yaw;
  e_a = 0.017453292519943295 * (90.0 - this_Pitch);
  f_a = 0.017453292519943295 * this_Roll;
  st.site = &bc_emlrtRSI;
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b[i1 + 3 * i] = this_Intrinsics->K[i + 3 * i1];
    }
  }

  b_dv[0] = muDoubleScalarCos(d_a);
  b_dv[3] = -muDoubleScalarSin(d_a);
  b_dv[6] = 0.0;
  b_dv[1] = muDoubleScalarSin(d_a);
  b_dv[4] = muDoubleScalarCos(d_a);
  b_dv[7] = 0.0;
  for (i = 0; i < 3; i++) {
    b_dv[3 * i + 2] = (real_T)iv[i];
  }

  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      g_a[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        g_a[i + 3 * i1] += h_a[i + 3 * i2] * b_dv[i2 + 3 * i1];
      }
    }

    dv1[3 * i] = (real_T)iv1[i];
  }

  dv1[1] = 0.0;
  dv1[4] = muDoubleScalarCos(e_a);
  dv1[7] = -muDoubleScalarSin(e_a);
  dv1[2] = 0.0;
  dv1[5] = muDoubleScalarSin(e_a);
  dv1[8] = muDoubleScalarCos(e_a);
  b_dv[0] = muDoubleScalarCos(f_a);
  b_dv[3] = -muDoubleScalarSin(f_a);
  b_dv[6] = 0.0;
  b_dv[1] = muDoubleScalarSin(f_a);
  b_dv[4] = muDoubleScalarCos(f_a);
  b_dv[7] = 0.0;
  dv2[0] = muDoubleScalarCos(a);
  dv2[3] = -muDoubleScalarSin(a);
  dv2[6] = 0.0;
  dv2[1] = muDoubleScalarSin(a);
  dv2[4] = muDoubleScalarCos(a);
  dv2[7] = 0.0;
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      i_a[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        i_a[i + 3 * i1] += g_a[i + 3 * i2] * dv1[i2 + 3 * i1];
      }
    }

    b_dv[3 * i + 2] = (real_T)iv[i];
    dv2[3 * i + 2] = (real_T)iv[i];
    dv3[3 * i] = (real_T)iv1[i];
  }

  dv3[1] = 0.0;
  dv3[4] = muDoubleScalarCos(b_a);
  dv3[7] = -muDoubleScalarSin(b_a);
  dv3[2] = 0.0;
  dv3[5] = muDoubleScalarSin(b_a);
  dv3[8] = muDoubleScalarCos(b_a);
  dv4[0] = muDoubleScalarCos(c_a);
  dv4[3] = -muDoubleScalarSin(c_a);
  dv4[6] = 0.0;
  dv4[1] = muDoubleScalarSin(c_a);
  dv4[4] = muDoubleScalarCos(c_a);
  dv4[7] = 0.0;
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      dv1[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        dv1[i + 3 * i1] += dv2[i + 3 * i2] * dv3[i2 + 3 * i1];
      }
    }

    dv4[3 * i + 2] = (real_T)iv[i];
  }

  b_this_SensorLocation[0] = this_SensorLocation[1];
  b_this_SensorLocation[1] = this_SensorLocation[0];
  b_this_SensorLocation[2] = this_Height;
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      dv2[i + 3 * i1] = 0.0;
      g_a[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        dv2[i + 3 * i1] += dv1[i + 3 * i2] * dv4[i2 + 3 * i1];
        g_a[i + 3 * i1] += i_a[i + 3 * i2] * b_dv[i2 + 3 * i1];
      }
    }
  }

  for (i = 0; i < 3; i++) {
    c_this_SensorLocation[i] = 0.0;
    for (i1 = 0; i1 < 3; i1++) {
      j_a[i1 + (i << 2)] = g_a[i1 + 3 * i];
      c_this_SensorLocation[i] += b_this_SensorLocation[i1] * dv2[i1 + 3 * i];
    }

    j_a[(i << 2) + 3] = c_this_SensorLocation[i];
  }

  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      tform[i + (i1 << 2)] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        tform[i + (i1 << 2)] += j_a[i + (i2 << 2)] * b[i2 + 3 * i1];
      }
    }
  }
}

static void monoCamera_horizonLine(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T *k, real_T *b_u0,
  real_T *v0)
{
  static const int32_T iv[2] = { 1, 44 };

  static const int32_T iv1[2] = { 1, 44 };

  static char_T b_u[44] = { 'i', 'm', 'a', 'g', 'e', 's', ':', 'g', 'e', 'o',
    't', 'r', 'a', 'n', 's', ':', 's', 'i', 'n', 'g', 'u', 'l', 'a', 'r', 'T',
    'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', 'M', 'a',
    't', 'r', 'i', 'x' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T camMatrix[12];
  real_T tform2D[9];
  int32_T i;
  char_T u[44];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &cc_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &dc_emlrtRSI;
  monoCamera_rawTformToImage3D(this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, camMatrix);
  for (i = 0; i < 3; i++) {
    tform2D[3 * i] = camMatrix[i << 2];
    tform2D[3 * i + 1] = camMatrix[(i << 2) + 1];
    tform2D[3 * i + 2] = camMatrix[(i << 2) + 3];
  }

  b_st.site = &ec_emlrtRSI;
  validateattributes(&b_st, tform2D);
  if (b_isequal(det(tform2D))) {
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &u[0]);
    emlrtAssign(&b_y, m);
    b_st.site = &nx_emlrtRSI;
    error(&b_st, y, getString(&b_st, b_message(&b_st, b_y, &e_emlrtMCI),
           &e_emlrtMCI), &e_emlrtMCI);
  }

  *k = rtNaN;
  *b_u0 = rtNaN;
  *v0 = rtNaN;
  if ((this_Pitch <= -90.0) || (this_Pitch >= 90.0)) {
  } else if (this_Roll == 0.0) {
    if (muDoubleScalarAbs(tform2D[6]) < 2.2204460492503131E-16) {
    } else {
      *k = 0.0;
      *b_u0 = tform2D[0] / tform2D[6];
      *v0 = tform2D[3] / tform2D[6];
    }
  } else if ((muDoubleScalarAbs(tform2D[6]) < 2.2204460492503131E-16) ||
             (muDoubleScalarAbs(tform2D[1] * tform2D[6] - tform2D[0] * tform2D[7])
              < 2.2204460492503131E-16)) {
  } else {
    *k = (tform2D[4] * tform2D[6] - tform2D[3] * tform2D[7]) / (tform2D[1] *
      tform2D[6] - tform2D[0] * tform2D[7]);
    *b_u0 = tform2D[0] / tform2D[6];
    *v0 = tform2D[3] / tform2D[6];
  }
}

static void validateattributes(const emlrtStack *sp, real_T a[9])
{
  static const int32_T iv[2] = { 1, 40 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 40 };

  static const int32_T iv3[2] = { 1, 46 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'N', 'o', 'n', 'N', 'a', 'N' };

  static char_T b_u[40] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'p', 'r', 'o',
    'j', 'e', 'c', 't', 'i', 'v', 'e', '2', 'd', ':', 's', 'e', 't', ':', 'T',
    ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T e_u[40] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'p', 'r', 'o',
    'j', 'e', 'c', 't', 'i', 'v', 'e', '2', 'd', ':', 's', 'e', 't', ':', 'T',
    ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'N', 'o', 'n', 'N', 'a', 'N' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  int32_T k;
  char_T c_u[46];
  char_T u[40];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 9)) {
    if ((!muDoubleScalarIsInf(a[k])) && (!muDoubleScalarIsNaN(a[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 40; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 40, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    d_y = NULL;
    m = emlrtCreateString1R2022a(&st, 'T');
    emlrtAssign(&d_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, d_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &ib_emlrtRSI;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 9)) {
    if (!muDoubleScalarIsNaN(a[k])) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 40; k++) {
      u[k] = e_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 40, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = f_u[k];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&e_y, m);
    f_y = NULL;
    m = emlrtCreateString1R2022a(&st, 'T');
    emlrtAssign(&f_y, m);
    b_st.site = &aw_emlrtRSI;
    error(&b_st, c_y, getString(&b_st, message(&b_st, e_y, f_y, &f_emlrtMCI),
           &f_emlrtMCI), &f_emlrtMCI);
  }
}

static real_T det(real_T x[9])
{
  __m128d r;
  real_T A[9];
  real_T smax;
  real_T y;
  int32_T c;
  int32_T i;
  int32_T i1;
  int32_T ijA;
  int32_T ix;
  int32_T iy;
  int32_T j;
  int32_T jy;
  int32_T k;
  int8_T ipiv[3];
  boolean_T isodd;
  memcpy(&A[0], &x[0], 9U * sizeof(real_T));
  for (i = 0; i < 3; i++) {
    ipiv[i] = (int8_T)(i + 1);
  }

  for (j = 0; j < 2; j++) {
    c = j << 2;
    iy = 4 - j;
    jy = 1;
    ix = c;
    smax = muDoubleScalarAbs(A[c]);
    for (k = 2; k < iy; k++) {
      ix++;
      y = muDoubleScalarAbs(A[ix]);
      if (y > smax) {
        jy = k;
        smax = y;
      }
    }

    if (A[(c + jy) - 1] != 0.0) {
      if (jy - 1 != 0) {
        ipiv[j] = (int8_T)(j + jy);
        ix = j;
        iy = (j + jy) - 1;
        for (k = 0; k < 3; k++) {
          smax = A[ix];
          A[ix] = A[iy];
          A[iy] = smax;
          ix += 3;
          iy += 3;
        }
      }

      i = c - j;
      iy = (((i - c) + 2) / 2 * 2 + c) + 2;
      jy = iy - 2;
      for (k = c + 2; k <= jy; k += 2) {
        r = _mm_loadu_pd(&A[k - 1]);
        _mm_storeu_pd(&A[k - 1], _mm_div_pd(r, _mm_set1_pd(A[c])));
      }

      for (k = iy; k <= i + 3; k++) {
        A[k - 1] /= A[c];
      }
    }

    iy = c;
    jy = c + 3;
    i = 1 - j;
    for (k = 0; k <= i; k++) {
      smax = A[jy];
      if (A[jy] != 0.0) {
        ix = c;
        i1 = iy - j;
        for (ijA = iy + 5; ijA <= i1 + 6; ijA++) {
          A[ijA - 1] += A[ix + 1] * -smax;
          ix++;
        }
      }

      jy += 3;
      iy += 3;
    }
  }

  y = A[0];
  isodd = false;
  for (k = 0; k < 2; k++) {
    y *= A[(k + 3 * (k + 1)) + 1];
    if (ipiv[k] > k + 1) {
      isodd = !isodd;
    }
  }

  if (isodd) {
    y = -y;
  }

  return y;
}

static boolean_T b_isequal(real_T varargin_1)
{
  boolean_T p;
  p = false;
  if (varargin_1 == 0.0) {
    p = true;
  }

  return p;
}

static void visionDetectionGenerator_getUpVectorInImageCoordinates(const
  emlrtStack *sp, visionDetectionGenerator *obj, real_T vUp[2])
{
  static real_T detSen[6] = { 0.0, 0.0, -1.1, 0.0, 0.0, -0.10000000000000009 };

  static real_T dv6[3] = { 1.0, 0.0, 0.0 };

  static int8_T iv[3] = { 0, 0, 1 };

  static int8_T iv1[3] = { 0, 1, 0 };

  static int8_T iv2[3] = { 1, 0, 0 };

  __m128d r1;
  emlrtStack st;
  monoCamera r;
  real_T b_dv[9];
  real_T dv1[9];
  real_T dv2[9];
  real_T dv3[9];
  real_T dv4[6];
  real_T dv5[6];
  real_T posCam[6];
  real_T uvUpCam[4];
  real_T d_y1[3];
  real_T c_y1[2];
  real_T monoCamSen_SensorLocation[2];
  real_T a;
  real_T b_a;
  real_T c_a;
  int32_T ix;
  int32_T iy;
  int32_T s;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &fc_emlrtRSI;
  r = obj->pMonoCameraInSensorFrame;
  for (ix = 0; ix < 2; ix++) {
    c_y1[ix] = r.SensorLocation[ix];
  }

  for (ix = 0; ix < 2; ix++) {
    monoCamSen_SensorLocation[ix] = c_y1[ix];
  }

  a = 0.017453292519943295 * r.Yaw;
  b_a = 0.017453292519943295 * r.Pitch;
  c_a = 0.017453292519943295 * r.Roll;
  b_dv[0] = muDoubleScalarCos(a);
  b_dv[3] = -muDoubleScalarSin(a);
  b_dv[6] = 0.0;
  b_dv[1] = muDoubleScalarSin(a);
  b_dv[4] = muDoubleScalarCos(a);
  b_dv[7] = 0.0;
  dv1[0] = muDoubleScalarCos(b_a);
  dv1[3] = 0.0;
  dv1[6] = muDoubleScalarSin(b_a);
  for (ix = 0; ix < 3; ix++) {
    b_dv[3 * ix + 2] = (real_T)iv[ix];
    dv1[3 * ix + 1] = (real_T)iv1[ix];
  }

  dv1[2] = -muDoubleScalarSin(b_a);
  dv1[5] = 0.0;
  dv1[8] = muDoubleScalarCos(b_a);
  for (ix = 0; ix < 3; ix++) {
    for (iy = 0; iy < 3; iy++) {
      dv2[ix + 3 * iy] = 0.0;
      for (s = 0; s < 3; s++) {
        dv2[ix + 3 * iy] += b_dv[ix + 3 * s] * dv1[s + 3 * iy];
      }
    }

    dv3[3 * ix] = (real_T)iv2[ix];
  }

  dv3[1] = 0.0;
  dv3[4] = muDoubleScalarCos(c_a);
  dv3[7] = -muDoubleScalarSin(c_a);
  dv3[2] = 0.0;
  dv3[5] = muDoubleScalarSin(c_a);
  dv3[8] = muDoubleScalarCos(c_a);
  for (ix = 0; ix < 3; ix++) {
    for (iy = 0; iy < 3; iy++) {
      b_dv[ix + 3 * iy] = 0.0;
      for (s = 0; s < 3; s++) {
        b_dv[ix + 3 * iy] += dv2[ix + 3 * s] * dv3[s + 3 * iy];
      }
    }

    for (iy = 0; iy < 2; iy++) {
      dv4[ix + 3 * iy] = 0.0;
      for (s = 0; s < 3; s++) {
        dv4[ix + 3 * iy] += b_dv[ix + 3 * s] * detSen[s + 3 * iy];
      }
    }
  }

  for (ix = 0; ix < 2; ix++) {
    d_y1[ix] = monoCamSen_SensorLocation[ix];
  }

  d_y1[2] = r.Height;
  bsxfun(dv4, d_y1, posCam);
  ix = 0;
  iy = 0;
  for (s = 0; s < 3; s++) {
    d_y1[iy] = posCam[ix + 3] - posCam[ix];
    ix++;
    iy++;
  }

  for (ix = 0; ix < 3; ix++) {
    dv4[ix] = 0.0;
    dv4[ix + 3] = d_y1[ix];
  }

  bsxfun(dv4, dv6, dv5);
  st.site = &gc_emlrtRSI;
  visionDetectionGenerator_cameraToImageCoords(&st, obj, dv5, uvUpCam);
  ix = 0;
  iy = 0;
  for (s = 0; s < 2; s++) {
    c_y1[iy] = uvUpCam[ix + 2] - uvUpCam[ix];
    ix++;
    iy++;
  }

  a = c_norm(c_y1);
  for (ix = 0; ix <= 0; ix += 2) {
    r1 = _mm_loadu_pd(&c_y1[0]);
    _mm_storeu_pd(&vUp[0], _mm_div_pd(r1, _mm_set1_pd(a)));
  }
}

static void rotParentToChild(real_T roll, real_T pitch, real_T yaw, real_T R[9])
{
  static int8_T iv[3] = { 0, 0, 1 };

  static int8_T iv1[3] = { 0, 1, 0 };

  static int8_T iv2[3] = { 1, 0, 0 };

  real_T b_dv[9];
  real_T dv1[9];
  real_T dv2[9];
  real_T dv3[9];
  real_T a;
  real_T b_a;
  real_T c_a;
  int32_T i;
  int32_T i1;
  int32_T i2;
  a = 0.017453292519943295 * yaw;
  b_a = 0.017453292519943295 * pitch;
  c_a = 0.017453292519943295 * roll;
  b_dv[0] = muDoubleScalarCos(a);
  b_dv[3] = -muDoubleScalarSin(a);
  b_dv[6] = 0.0;
  b_dv[1] = muDoubleScalarSin(a);
  b_dv[4] = muDoubleScalarCos(a);
  b_dv[7] = 0.0;
  dv1[0] = muDoubleScalarCos(b_a);
  dv1[3] = 0.0;
  dv1[6] = muDoubleScalarSin(b_a);
  for (i = 0; i < 3; i++) {
    b_dv[3 * i + 2] = (real_T)iv[i];
    dv1[3 * i + 1] = (real_T)iv1[i];
  }

  dv1[2] = -muDoubleScalarSin(b_a);
  dv1[5] = 0.0;
  dv1[8] = muDoubleScalarCos(b_a);
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      dv2[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        dv2[i + 3 * i1] += b_dv[i + 3 * i2] * dv1[i2 + 3 * i1];
      }
    }

    dv3[3 * i] = (real_T)iv2[i];
  }

  dv3[1] = 0.0;
  dv3[4] = muDoubleScalarCos(c_a);
  dv3[7] = -muDoubleScalarSin(c_a);
  dv3[2] = 0.0;
  dv3[5] = muDoubleScalarSin(c_a);
  dv3[8] = muDoubleScalarCos(c_a);
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      R[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        R[i + 3 * i1] += dv2[i1 + 3 * i2] * dv3[i2 + 3 * i];
      }
    }
  }
}

static void rotChildToParent(real_T roll, real_T pitch, real_T yaw, real_T R[9])
{
  static int8_T iv[3] = { 0, 0, 1 };

  static int8_T iv1[3] = { 0, 1, 0 };

  static int8_T iv2[3] = { 1, 0, 0 };

  real_T b_dv[9];
  real_T dv1[9];
  real_T dv2[9];
  real_T dv3[9];
  real_T a;
  real_T b_a;
  real_T c_a;
  int32_T i;
  int32_T i1;
  int32_T i2;
  a = 0.017453292519943295 * yaw;
  b_a = 0.017453292519943295 * pitch;
  c_a = 0.017453292519943295 * roll;
  b_dv[0] = muDoubleScalarCos(a);
  b_dv[3] = -muDoubleScalarSin(a);
  b_dv[6] = 0.0;
  b_dv[1] = muDoubleScalarSin(a);
  b_dv[4] = muDoubleScalarCos(a);
  b_dv[7] = 0.0;
  dv1[0] = muDoubleScalarCos(b_a);
  dv1[3] = 0.0;
  dv1[6] = muDoubleScalarSin(b_a);
  for (i = 0; i < 3; i++) {
    b_dv[3 * i + 2] = (real_T)iv[i];
    dv1[3 * i + 1] = (real_T)iv1[i];
  }

  dv1[2] = -muDoubleScalarSin(b_a);
  dv1[5] = 0.0;
  dv1[8] = muDoubleScalarCos(b_a);
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      dv2[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        dv2[i + 3 * i1] += b_dv[i + 3 * i2] * dv1[i2 + 3 * i1];
      }
    }

    dv3[3 * i] = (real_T)iv2[i];
  }

  dv3[1] = 0.0;
  dv3[4] = muDoubleScalarCos(c_a);
  dv3[7] = -muDoubleScalarSin(c_a);
  dv3[2] = 0.0;
  dv3[5] = muDoubleScalarSin(c_a);
  dv3[8] = muDoubleScalarCos(c_a);
  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      R[i + 3 * i1] = 0.0;
      for (i2 = 0; i2 < 3; i2++) {
        R[i + 3 * i1] += dv2[i + 3 * i2] * dv3[i2 + 3 * i1];
      }
    }
  }
}

static void bsxfun(real_T a[6], real_T b[3], real_T c[6])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T k;
  for (k = 0; k < 2; k++) {
    for (b_k = 0; b_k <= 0; b_k += 2) {
      r = _mm_loadu_pd(&a[3 * k]);
      r1 = _mm_loadu_pd(&b[0]);
      _mm_storeu_pd(&c[3 * k], _mm_add_pd(r, r1));
    }

    for (b_k = 2; b_k < 3; b_k++) {
      c[3 * k + 2] = a[3 * k + 2] + b[2];
    }
  }
}

static void visionDetectionGenerator_cameraToImageCoords(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T pos[6], real_T U[4])
{
  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 40 };

  static const int32_T iv3[2] = { 1, 39 };

  static const int32_T iv4[2] = { 1, 40 };

  static int32_T iv[2] = { 1, 2 };

  static char_T d_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T c_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  __m128d r1;
  emlrtStack b_st;
  emlrtStack st;
  monoCamera r;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T d_tmp_data[4200];
  real_T i_tmp_data[4200];
  real_T e_tmp_data[2100];
  real_T f_tmp_data[2100];
  real_T camMtx[12];
  real_T b_dv[8];
  real_T Uprime[6];
  real_T b_vec_data[4];
  real_T horzCoeffs[3];
  real_T bigNum_data[2];
  real_T g_tmp_data[2];
  real_T wp[2];
  real_T bigNum;
  int32_T U_size[2];
  int32_T bigNum_size[2];
  int32_T tmp_size[2];
  int32_T vec_size[2];
  int32_T b_i;
  int32_T i;
  int32_T n;
  int32_T nz;
  int32_T trueCount;
  char_T b_u[40];
  char_T u[39];
  int8_T c_tmp_data[2];
  int8_T h_tmp_data[2];
  boolean_T isBehind[2];
  boolean_T b_isBehind;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  r = obj->pMonoCameraInSensorFrame;
  st.site = &hc_emlrtRSI;
  visionDetectionGenerator_getCameraMatrix(r.Intrinsics, r.Height, r.Pitch,
    r.Yaw, r.Roll, camMtx);
  for (i = 0; i < 3; i++) {
    for (b_i = 0; b_i < 2; b_i++) {
      Uprime[b_i + (i << 1)] = pos[i + 3 * b_i];
    }
  }

  padarray(Uprime, b_dv);
  for (i = 0; i < 3; i++) {
    for (b_i = 0; b_i < 2; b_i++) {
      Uprime[i + 3 * b_i] = 0.0;
      for (n = 0; n < 4; n++) {
        Uprime[i + 3 * b_i] += b_dv[b_i + (n << 1)] * camMtx[n + (i << 2)];
      }
    }
  }

  for (i = 0; i < 2; i++) {
    bigNum = Uprime[3 * i + 2];
    U[i << 1] = Uprime[3 * i] / bigNum;
    U[(i << 1) + 1] = Uprime[3 * i + 1] / bigNum;
    isBehind[i] = (bigNum < 0.0);
  }

  if (vectorAny(isBehind, iv)) {
    nz = (int32_T)isBehind[0] + (int32_T)isBehind[1];
    bigNum = 10.0 * b_norm(r.Intrinsics->ImageSize);
    for (i = 0; i < 3; i++) {
      horzCoeffs[i] = obj->pHorizonLine[i];
    }

    for (i = 0; i < 2; i++) {
      wp[i] = horzCoeffs[i + 1];
    }

    trueCount = 0;
    n = 0;
    for (b_i = 0; b_i < 2; b_i++) {
      b_isBehind = isBehind[b_i];
      if (b_isBehind) {
        trueCount++;
        c_tmp_data[n] = (int8_T)b_i;
        n++;
      }
    }

    U_size[0] = 2;
    U_size[1] = trueCount;
    for (i = 0; i < trueCount; i++) {
      for (b_i = 0; b_i < 2; b_i++) {
        b_vec_data[b_i + (i << 1)] = U[b_i + (c_tmp_data[i] << 1)];
      }
    }

    b_bsxfun(wp, b_vec_data, U_size, d_tmp_data, tmp_size);
    vec_size[0] = 2;
    vec_size[1] = tmp_size[1];
    n = tmp_size[0] * tmp_size[1];
    if (n - 1 >= 0) {
      memcpy(&b_vec_data[0], &d_tmp_data[0], (uint32_T)n * sizeof(real_T));
    }

    power(b_vec_data, vec_size, d_tmp_data, tmp_size);
    sum(d_tmp_data, tmp_size, e_tmp_data, U_size);
    st.site = &ic_emlrtRSI;
    b_sqrt(&st, e_tmp_data, U_size, f_tmp_data, tmp_size);
    n = tmp_size[0] * tmp_size[1];
    if (n - 1 >= 0) {
      memcpy(&g_tmp_data[0], &f_tmp_data[0], (uint32_T)n * sizeof(real_T));
    }

    st.site = &lc_emlrtRSI;
    b_st.site = &nc_emlrtRSI;
    assertValidSizeArg(&b_st, (real_T)nz);
    n = 1;
    if (tmp_size[1] > 1) {
      n = 2;
    }

    if (nz > muIntScalarMax_sint32(tmp_size[1], n)) {
      for (i = 0; i < 39; i++) {
        u[i] = c_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 39; i++) {
        u[i] = c_u[i];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
      emlrtAssign(&c_y, m);
      st.site = &qv_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, c_y, &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (nz != tmp_size[1]) {
      for (i = 0; i < 40; i++) {
        b_u[i] = d_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &b_u[0]);
      emlrtAssign(&b_y, m);
      for (i = 0; i < 40; i++) {
        b_u[i] = d_u[i];
      }

      d_y = NULL;
      m = emlrtCreateCharArray(2, &iv4[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &b_u[0]);
      emlrtAssign(&d_y, m);
      st.site = &ov_emlrtRSI;
      error(&st, b_y, getString(&st, b_message(&st, d_y, &i_emlrtMCI),
             &i_emlrtMCI), &i_emlrtMCI);
    }

    U_size[0] = 1;
    U_size[1] = nz;
    st.site = &jc_emlrtRSI;
    c_bsxfun(&st, b_vec_data, vec_size, g_tmp_data, U_size, d_tmp_data, tmp_size);
    vec_size[0] = 2;
    vec_size[1] = tmp_size[1];
    n = tmp_size[0] * tmp_size[1];
    if (n - 1 >= 0) {
      memcpy(&b_vec_data[0], &d_tmp_data[0], (uint32_T)n * sizeof(real_T));
    }

    trueCount = 0;
    n = 0;
    for (b_i = 0; b_i < 2; b_i++) {
      b_isBehind = isBehind[b_i];
      if (b_isBehind) {
        trueCount++;
        h_tmp_data[n] = (int8_T)b_i;
        n++;
      }
    }

    bigNum_size[0] = 1;
    bigNum_size[1] = nz;
    n = nz / 2 * 2;
    b_i = n - 2;
    for (i = 0; i <= b_i; i += 2) {
      r1 = _mm_loadu_pd(&g_tmp_data[0]);
      _mm_storeu_pd(&bigNum_data[0], _mm_add_pd(_mm_set1_pd(bigNum), r1));
    }

    for (i = n; i < nz; i++) {
      bigNum_data[i] = bigNum + g_tmp_data[i];
    }

    st.site = &kc_emlrtRSI;
    d_bsxfun(&st, b_vec_data, vec_size, bigNum_data, bigNum_size, d_tmp_data,
             tmp_size);
    e_bsxfun(d_tmp_data, tmp_size, wp, i_tmp_data, U_size);
    vec_size[0] = 2;
    vec_size[1] = U_size[1];
    n = U_size[0] * U_size[1];
    if (n - 1 >= 0) {
      memcpy(&b_vec_data[0], &i_tmp_data[0], (uint32_T)n * sizeof(real_T));
    }

    U_size[0] = 2;
    U_size[1] = trueCount;
    emlrtSubAssignSizeCheckR2012b(&U_size[0], 2, &vec_size[0], 2, &emlrtECI,
      (void *)sp);
    for (i = 0; i < trueCount; i++) {
      for (b_i = 0; b_i < 2; b_i++) {
        U[b_i + (h_tmp_data[i] << 1)] = b_vec_data[b_i + (i << 1)];
      }
    }
  }
}

static void visionDetectionGenerator_getCameraMatrix(cameraIntrinsics
  *monoCam_Intrinsics, real_T monoCam_Height, real_T monoCam_Pitch, real_T
  monoCam_Yaw, real_T monoCam_Roll, real_T camMtx[12])
{
  static real_T a[9] = { -6.123233995736766E-17, -1.0, -7.498798913309288E-33,
    -1.0, 6.123233995736766E-17, -1.2246467991473532E-16, 1.2246467991473532E-16,
    0.0, -1.0 };

  emlrtStack st;
  real_T b_R[12];
  real_T R[9];
  real_T b_I[9];
  real_T b_intrinMtx[9];
  real_T c_I[9];
  real_T intrinMtx[9];
  real_T T[3];
  real_T b_dv[3];
  real_T ca;
  real_T sa;
  int32_T i;
  int32_T i1;
  int32_T k;
  sa = 0.017453292519943295 * monoCam_Yaw;
  for (k = 0; k < 9; k++) {
    intrinMtx[k] = 0.0;
  }

  for (k = 0; k < 3; k++) {
    intrinMtx[k + 3 * k] = 1.0;
  }

  ca = muDoubleScalarCos(sa);
  sa = muDoubleScalarSin(sa);
  intrinMtx[0] = ca;
  intrinMtx[3] = -sa;
  intrinMtx[1] = sa;
  intrinMtx[4] = ca;
  sa = 0.017453292519943295 * (90.0 - monoCam_Pitch);
  for (k = 0; k < 9; k++) {
    b_I[k] = 0.0;
  }

  for (k = 0; k < 3; k++) {
    b_I[k + 3 * k] = 1.0;
  }

  ca = muDoubleScalarCos(sa);
  sa = muDoubleScalarSin(sa);
  b_I[4] = ca;
  b_I[7] = -sa;
  b_I[5] = sa;
  b_I[8] = ca;
  sa = 0.017453292519943295 * monoCam_Roll;
  for (k = 0; k < 9; k++) {
    c_I[k] = 0.0;
  }

  for (k = 0; k < 3; k++) {
    c_I[k + 3 * k] = 1.0;
  }

  ca = muDoubleScalarCos(sa);
  sa = muDoubleScalarSin(sa);
  c_I[0] = ca;
  c_I[3] = -sa;
  c_I[1] = sa;
  c_I[4] = ca;
  for (k = 0; k < 3; k++) {
    for (i = 0; i < 3; i++) {
      b_intrinMtx[k + 3 * i] = 0.0;
      for (i1 = 0; i1 < 3; i1++) {
        b_intrinMtx[k + 3 * i] += intrinMtx[k + 3 * i1] * b_I[i1 + 3 * i];
      }
    }

    for (i = 0; i < 3; i++) {
      R[k + 3 * i] = 0.0;
      for (i1 = 0; i1 < 3; i1++) {
        R[k + 3 * i] += b_intrinMtx[k + 3 * i1] * c_I[i1 + 3 * i];
      }
    }
  }

  b_dv[0] = 0.0;
  b_dv[1] = 0.0;
  b_dv[2] = monoCam_Height;
  for (k = 0; k < 3; k++) {
    T[k] = 0.0;
    for (i = 0; i < 3; i++) {
      intrinMtx[k + 3 * i] = 0.0;
      for (i1 = 0; i1 < 3; i1++) {
        intrinMtx[k + 3 * i] += a[k + 3 * i1] * R[i1 + 3 * i];
      }

      T[k] += b_dv[i] * R[i + 3 * k];
    }
  }

  memcpy(&R[0], &intrinMtx[0], 9U * sizeof(real_T));
  st.site = &mc_emlrtRSI;
  for (k = 0; k < 3; k++) {
    for (i = 0; i < 3; i++) {
      intrinMtx[i + 3 * k] = monoCam_Intrinsics->K[k + 3 * i];
    }
  }

  for (k = 0; k < 3; k++) {
    for (i = 0; i < 3; i++) {
      b_R[i + (k << 2)] = R[i + 3 * k];
    }

    b_R[(k << 2) + 3] = T[k];
  }

  for (k = 0; k < 4; k++) {
    for (i = 0; i < 3; i++) {
      camMtx[k + (i << 2)] = 0.0;
      for (i1 = 0; i1 < 3; i1++) {
        camMtx[k + (i << 2)] += b_R[k + (i1 << 2)] * intrinMtx[i1 + 3 * i];
      }
    }
  }
}

static void padarray(real_T varargin_1[6], real_T b[8])
{
  int32_T i;
  int32_T j;
  for (i = 0; i < 2; i++) {
    b[i + 6] = 1.0;
  }

  for (j = 0; j < 3; j++) {
    for (i = 0; i < 2; i++) {
      b[i + (j << 1)] = varargin_1[i + (j << 1)];
    }
  }
}

static boolean_T vectorAny(boolean_T x_data[], int32_T x_size[2])
{
  int32_T k;
  boolean_T exitg1;
  boolean_T y;
  y = false;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= x_size[1] - 1)) {
    if (x_data[k]) {
      y = true;
      exitg1 = true;
    } else {
      k++;
    }
  }

  return y;
}

static real_T b_norm(real_T x[2])
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  y = 0.0;
  scale = 3.3121686421112381E-170;
  for (k = 0; k < 2; k++) {
    absxk = muDoubleScalarAbs(x[k]);
    if (absxk > scale) {
      t = scale / absxk;
      y = y * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }
  }

  return scale * muDoubleScalarSqrt(y);
}

static void b_bsxfun(real_T a[2], real_T b_data[], int32_T b_size[2], real_T
                     c_data[], int32_T c_size[2])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T bcoef;
  int32_T i;
  int32_T ib;
  int32_T k;
  c_size[0] = 2;
  c_size[1] = (int16_T)b_size[1];
  if ((int16_T)b_size[1] != 0) {
    c_size[0] = 2;
    bcoef = (b_size[1] != 1);
    i = (int16_T)b_size[1];
    for (k = 0; k < i; k++) {
      ib = bcoef * k;
      c_size[0] = 2;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 2;
        r = _mm_loadu_pd(&a[0]);
        r1 = _mm_loadu_pd(&b_data[ib << 1]);
        _mm_storeu_pd(&c_data[k << 1], _mm_sub_pd(r, r1));
      }
    }
  }
}

static void power(real_T a_data[], int32_T a_size[2], real_T b_y_data[], int32_T
                  y_size[2])
{
  int32_T i;
  int32_T loop_ub;
  y_size[0] = 2;
  y_size[1] = a_size[1];
  loop_ub = a_size[1] << 1;
  for (i = 0; i < loop_ub; i++) {
    b_y_data[i] = function_handle_parenReference(a_data[i]);
  }
}

static real_T function_handle_parenReference(real_T varargin_1)
{
  return varargin_1 * varargin_1;
}

static void sum(real_T x_data[], int32_T x_size[2], real_T b_y_data[], int32_T
                y_size[2])
{
  if (x_size[1] == 0) {
    y_size[0] = 1;
    y_size[1] = 0;
  } else {
    sumMatrixColumns(x_data, x_size, b_y_data, y_size);
  }
}

static void sumMatrixColumns(real_T x_data[], int32_T x_size[2], real_T
  b_y_data[], int32_T y_size[2])
{
  int32_T col;
  int32_T i;
  y_size[0] = 1;
  y_size[1] = (int16_T)x_size[1];
  i = x_size[1];
  for (col = 0; col < i; col++) {
    b_y_data[col] = sumColumnB(x_data, col + 1);
  }
}

static real_T sumColumnB(real_T x_data[], int32_T col)
{
  real_T y;
  int32_T i0;
  int32_T k;
  i0 = (col - 1) << 1;
  y = x_data[i0];
  for (k = 0; k < 1; k++) {
    y += x_data[i0 + 1];
  }

  return y;
}

static void b_sqrt(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                   real_T b_x_data[], int32_T b_x_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static const int32_T iv2[2] = { 1, 4 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'E', 'l', 'F', 'u', 'n', 'D', 'o', 'm', 'a', 'i', 'n',
    'E', 'r', 'r', 'o', 'r' };

  static char_T d_u[4] = { 's', 'q', 'r', 't' };

  __m128d r;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  real_T c_x_data;
  int32_T i;
  int32_T k;
  int32_T loop_ub;
  int32_T vectorUB;
  char_T u[30];
  char_T c_u[4];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  b_x_size[1] = x_size[1];
  loop_ub = x_size[1];
  p = false;
  for (k = 0; k < loop_ub; k++) {
    c_x_data = x_data[k];
    if (p || (c_x_data < 0.0)) {
      p = true;
    } else {
      p = false;
    }

    b_x_data[k] = c_x_data;
  }

  if (p) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 4; i++) {
      c_u[i] = d_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 4, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    st.site = &tv_emlrtRSI;
    error(&st, y, getString(&st, message(&st, b_y, c_y, &j_emlrtMCI),
           &j_emlrtMCI), &j_emlrtMCI);
  }

  b_x_size[0] = 1;
  i = x_size[1];
  loop_ub = x_size[1] / 2 * 2;
  vectorUB = loop_ub - 2;
  for (k = 0; k <= vectorUB; k += 2) {
    r = _mm_loadu_pd(&b_x_data[k]);
    _mm_storeu_pd(&b_x_data[k], _mm_sqrt_pd(r));
  }

  for (k = loop_ub; k < i; k++) {
    b_x_data[k] = muDoubleScalarSqrt(b_x_data[k]);
  }
}

static void assertValidSizeArg(const emlrtStack *sp, real_T varargin_1)
{
  static const int32_T iv[2] = { 1, 28 };

  static const int32_T iv1[2] = { 1, 28 };

  static char_T b_u[28] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'N', 'o', 'n', 'I', 'n', 't', 'e', 'g', 'e', 'r', 'I', 'n',
    'p', 'u', 't' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[28];
  st.prev = sp;
  st.tls = sp->tls;
  if ((varargin_1 != varargin_1) || muDoubleScalarIsInf(varargin_1)) {
    for (i = 0; i < 28; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 28; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
    emlrtAssign(&b_y, m);
    c_y = NULL;
    m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
    *(int32_T *)emlrtMxGetData(m) = MIN_int32_T;
    emlrtAssign(&c_y, m);
    d_y = NULL;
    m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
    *(int32_T *)emlrtMxGetData(m) = MAX_int32_T;
    emlrtAssign(&d_y, m);
    st.site = &jx_emlrtRSI;
    error(&st, y, getString(&st, c_message(&st, b_y, c_y, d_y, &k_emlrtMCI),
           &k_emlrtMCI), &k_emlrtMCI);
  }
}

static void c_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static const int32_T iv[2] = { 1, 38 };

  static const int32_T iv1[2] = { 1, 38 };

  static char_T b_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'b', 's', 'x',
    'f', 'u', 'n', ':', 'a', 'r', 'r', 'a', 'y', 'D', 'i', 'm', 'e', 'n', 's',
    'i', 'o', 'n', 's', 'M', 'u', 's', 't', 'M', 'a', 't', 'c', 'h' };

  __m128d r;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T acoef;
  int32_T b_k;
  int32_T bcoef;
  int32_T i;
  int32_T ib;
  int32_T k;
  int32_T sck;
  char_T u[38];
  st.prev = sp;
  st.tls = sp->tls;
  if (b_size[1] == 1) {
    sck = a_size[1];
  } else if (a_size[1] == 1) {
    sck = b_size[1];
  } else if (a_size[1] == b_size[1]) {
    sck = a_size[1];
  } else {
    if (b_size[1] < a_size[1]) {
      sck = b_size[1];
    } else {
      sck = a_size[1];
    }

    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &bx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &l_emlrtMCI), &l_emlrtMCI),
          &l_emlrtMCI);
  }

  c_size[0] = 2;
  c_size[1] = (int16_T)sck;
  if ((int16_T)sck != 0) {
    c_size[0] = 2;
    acoef = (a_size[1] != 1);
    bcoef = (b_size[1] != 1);
    i = (int16_T)sck;
    for (k = 0; k < i; k++) {
      sck = acoef * k;
      ib = bcoef * k;
      c_size[0] = 2;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 2;
        r = _mm_loadu_pd(&a_data[sck << 1]);
        _mm_storeu_pd(&c_data[k << 1], _mm_div_pd(r, _mm_set1_pd(b_data[ib])));
      }
    }
  }
}

static void d_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static const int32_T iv[2] = { 1, 38 };

  static const int32_T iv1[2] = { 1, 38 };

  static char_T b_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'b', 's', 'x',
    'f', 'u', 'n', ':', 'a', 'r', 'r', 'a', 'y', 'D', 'i', 'm', 'e', 'n', 's',
    'i', 'o', 'n', 's', 'M', 'u', 's', 't', 'M', 'a', 't', 'c', 'h' };

  __m128d r;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T acoef;
  int32_T b_k;
  int32_T bcoef;
  int32_T i;
  int32_T ib;
  int32_T k;
  int32_T sck;
  char_T u[38];
  st.prev = sp;
  st.tls = sp->tls;
  if (b_size[1] == 1) {
    sck = a_size[1];
  } else if (a_size[1] == 1) {
    sck = b_size[1];
  } else if (a_size[1] == b_size[1]) {
    sck = a_size[1];
  } else {
    if (b_size[1] < a_size[1]) {
      sck = b_size[1];
    } else {
      sck = a_size[1];
    }

    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &bx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &l_emlrtMCI), &l_emlrtMCI),
          &l_emlrtMCI);
  }

  c_size[0] = 2;
  c_size[1] = (int16_T)sck;
  if ((int16_T)sck != 0) {
    c_size[0] = 2;
    acoef = (a_size[1] != 1);
    bcoef = (b_size[1] != 1);
    i = (int16_T)sck;
    for (k = 0; k < i; k++) {
      sck = acoef * k;
      ib = bcoef * k;
      c_size[0] = 2;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 2;
        r = _mm_loadu_pd(&a_data[sck << 1]);
        _mm_storeu_pd(&c_data[k << 1], _mm_mul_pd(r, _mm_set1_pd(b_data[ib])));
      }
    }
  }
}

static void e_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2])
{
  __m128d r;
  __m128d r1;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 2;
  c_size[1] = (int16_T)a_size[1];
  if ((int16_T)a_size[1] != 0) {
    c_size[0] = 2;
    acoef = (a_size[1] != 1);
    i = (int16_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 2;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 2;
        r = _mm_loadu_pd(&a_data[ia << 1]);
        r1 = _mm_loadu_pd(&b[0]);
        _mm_storeu_pd(&c_data[k << 1], _mm_add_pd(r, r1));
      }
    }
  }
}

static real_T c_norm(real_T x[2])
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  y = 0.0;
  scale = 3.3121686421112381E-170;
  for (k = 0; k < 2; k++) {
    absxk = muDoubleScalarAbs(x[k]);
    if (absxk > scale) {
      t = scale / absxk;
      y = y * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }
  }

  return scale * muDoubleScalarSqrt(y);
}

static real_T minimum2(real_T x, real_T y)
{
  return muDoubleScalarMin(x, y);
}

static void rng(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance)
{
  emlrtStack st;
  int32_T mti;
  uint32_T r;
  moduleInstance->seed = 5489U;
  st.site = &qc_emlrtRSI;
  r = 5489U;
  moduleInstance->state[0] = 5489U;
  for (mti = 0; mti < 623; mti++) {
    r = ((r ^ r >> 30U) * 1812433253U + (uint32_T)mti) + 1U;
    moduleInstance->state[mti + 1] = r;
  }

  moduleInstance->state[624] = 624U;
  st.site = &pc_emlrtRSI;
  moduleInstance->b_method = 0U;
}

static void visionDetectionGenerator_setupImpl
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj)
{
  static sH79YtbsHrUKNl3jXbBnQ5F r = { 0.0,/* ActorID */
    0.0,                               /* ClassID */
    4.7,                               /* Length */
    1.8,                               /* Width */
    1.4,                               /* Height */

    { 0.0, 0.0, 0.0 },                 /* MeshVertices */

    { 0.0, 0.0, 0.0 },                 /* MeshFaces */

    { -1.35, 0.0, 0.0 },               /* OriginOffset */

    { 10.0, 10.0, 10.0, 10.0 },        /* RCSPattern */

    { -180.0, 180.0 },                 /* RCSAzimuthAngles */

    { -90.0, 90.0 }                    /* RCSElevationAngles */
  };

  static real_T dv2[6] = { -0.93346405029296875, 0.93346405029296875,
    -1.8284912109375, 1.8284912109375, -0.0022508502006530762,
    1.4126434326171875 };

  static real_T dv4[6] = { -1.1249923706054688, 1.1249923706054688,
    -2.3805389404296875, 2.3805389404296875, -0.0029814839363098145,
    1.7718353271484375 };

  static real_T dv7[6] = { -0.9688912034034729, 0.96889108419418335,
    -2.2848658561706543, 2.2707424163818359, 0.0005556643009185791,
    1.4543800354003906 };

  static real_T b_dv[3] = { -1.2491042613983154, 0.0, 0.0 };

  static real_T dv1[3] = { 0.043137254901960784, 0.34509803921568627, 1.0 };

  static real_T dv3[3] = { -1.3378446102142334, 0.0, 0.0 };

  static real_T dv5[3] = { -1.3294646739959717, 0.0, 0.0 };

  static real_T dv6[3] = { 0.33333333333333331, 0.0, 1.0 };

  static real_T dv8[3] = { 0.50196078431372548, 0.0, 0.0 };

  static const int32_T iv[2] = { 1, 28 };

  static const int32_T iv1[2] = { 1, 28 };

  static const int32_T iv2[2] = { 1, 44 };

  static const int32_T iv3[2] = { 1, 44 };

  static const int32_T iv4[2] = { 1, 64 };

  static char_T f_u[64] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'a', 'b',
    's', 't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n',
    'G', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'c', 'a', 'm', 'e', 'r',
    'a', 'N', 'o', 'V', 'a', 'l', 'i', 'd', 'H', 'o', 'r', 'i', 'z', 'o', 'n',
    'R', 'o', 'l', 'l', 'P', 'i', 't', 'c', 'h' };

  static char_T d_u[44] = { 'i', 'm', 'a', 'g', 'e', 's', ':', 'g', 'e', 'o',
    't', 'r', 'a', 'n', 's', ':', 's', 'i', 'n', 'g', 'u', 'l', 'a', 'r', 'T',
    'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', 'M', 'a',
    't', 'r', 'i', 'x' };

  static char_T b_u[28] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'm', 'o',
    'n', 'o', 'C', 'a', 'm', 'e', 'r', 'a', ':', 'h', 'i', 'g', 'h', 'P', 'i',
    't', 'c', 'h' };

  cameraIntrinsics *camIntrin;
  cameraIntrinsics *r1;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack f_st;
  emlrtStack g_st;
  emlrtStack st;
  const mxArray *b_m;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *y;
  sH79YtbsHrUKNl3jXbBnQ5F assembledProfiles[4];
  sKK34u6phUgyUK2V5nAMy1F s[4];
  real_T d_tmp_data[212];
  real_T camMatrix[12];
  real_T tform2D[9];
  real_T b_k[3];
  real_T camConfig_SensorLocation[2];
  real_T t10_SensorLocation[2];
  real_T b_u0;
  real_T camConfig_Height;
  real_T camConfig_Pitch;
  real_T camConfig_Roll;
  real_T camConfig_Yaw;
  real_T k;
  real_T v0;
  int32_T tmp_size[2];
  int32_T i;
  int32_T m;
  char_T e_u[64];
  char_T c_u[44];
  char_T u[28];
  boolean_T c_tmp_data[3];
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  e_st.prev = &c_st;
  e_st.tls = c_st.tls;
  f_st.prev = &b_st;
  f_st.tls = b_st.tls;
  r.ActorID = rtNaN;
  st.site = &sc_emlrtRSI;
  obj->pUseRandSeed = true;
  b_st.site = &oc_emlrtRSI;
  rng(moduleInstance);
  obj->pActorIDMatchRequired = true;
  for (m = 0; m < 4; m++) {
    assembledProfiles[m] = r;
    s[0].ActorID = 1.0;
    s[0].ClassID = 1.0;
    s[0].Length = 3.656982421875;
    s[0].Width = 1.8669281005859375;
    s[0].Height = 1.4126434326171875;
    s[0].FrontOverhang = 0.65814268589019775;
    s[0].RearOverhang = 0.57938694953918457;
    for (i = 0; i < 3; i++) {
      s[0].OriginOffset[i] = b_dv[i];
      s[0].Color[i] = dv1[i];
    }

    for (i = 0; i < 6; i++) {
      s[0].bbx[i] = dv2[i];
    }

    s[1].ActorID = 2.0;
    s[1].ClassID = 1.0;
    s[1].Length = 4.761077880859375;
    s[1].Width = 2.2499847412109375;
    s[1].Height = 1.7718353271484375;
    s[1].FrontOverhang = 0.84619772434234619;
    s[1].RearOverhang = 1.0426943302154541;
    for (i = 0; i < 3; i++) {
      s[1].OriginOffset[i] = dv3[i];
      s[1].Color[i] = 0.35294117647058826;
    }

    for (i = 0; i < 6; i++) {
      s[1].bbx[i] = dv4[i];
    }

    s[2].ActorID = 3.0;
    s[2].ClassID = 1.0;
    s[2].Length = 4.55560827255249;
    s[2].Width = 1.9377822875976562;
    s[2].Height = 1.4543800354003906;
    s[2].FrontOverhang = 0.893956184387207;
    s[2].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[2].OriginOffset[i] = dv5[i];
      s[2].Color[i] = dv6[i];
    }

    for (i = 0; i < 6; i++) {
      s[2].bbx[i] = dv7[i];
    }

    s[3].ActorID = 4.0;
    s[3].ClassID = 1.0;
    s[3].Length = 4.55560827255249;
    s[3].Width = 1.9377822875976562;
    s[3].Height = 1.4543800354003906;
    s[3].FrontOverhang = 0.893956184387207;
    s[3].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[3].OriginOffset[i] = dv5[i];
      s[3].Color[i] = dv8[i];
    }

    for (i = 0; i < 6; i++) {
      s[3].bbx[i] = dv7[i];
    }

    assembledProfiles[m].ActorID = s[m].ActorID;
    assembledProfiles[m].ClassID = 1.0;
  }

  for (m = 0; m < 4; m++) {
    s[0].ActorID = 1.0;
    s[0].ClassID = 1.0;
    s[0].Length = 3.656982421875;
    s[0].Width = 1.8669281005859375;
    s[0].Height = 1.4126434326171875;
    s[0].FrontOverhang = 0.65814268589019775;
    s[0].RearOverhang = 0.57938694953918457;
    for (i = 0; i < 3; i++) {
      s[0].OriginOffset[i] = b_dv[i];
      s[0].Color[i] = dv1[i];
    }

    for (i = 0; i < 6; i++) {
      s[0].bbx[i] = dv2[i];
    }

    s[1].ActorID = 2.0;
    s[1].ClassID = 1.0;
    s[1].Length = 4.761077880859375;
    s[1].Width = 2.2499847412109375;
    s[1].Height = 1.7718353271484375;
    s[1].FrontOverhang = 0.84619772434234619;
    s[1].RearOverhang = 1.0426943302154541;
    for (i = 0; i < 3; i++) {
      s[1].OriginOffset[i] = dv3[i];
      s[1].Color[i] = 0.35294117647058826;
    }

    for (i = 0; i < 6; i++) {
      s[1].bbx[i] = dv4[i];
    }

    s[2].ActorID = 3.0;
    s[2].ClassID = 1.0;
    s[2].Length = 4.55560827255249;
    s[2].Width = 1.9377822875976562;
    s[2].Height = 1.4543800354003906;
    s[2].FrontOverhang = 0.893956184387207;
    s[2].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[2].OriginOffset[i] = dv5[i];
      s[2].Color[i] = dv6[i];
    }

    for (i = 0; i < 6; i++) {
      s[2].bbx[i] = dv7[i];
    }

    s[3].ActorID = 4.0;
    s[3].ClassID = 1.0;
    s[3].Length = 4.55560827255249;
    s[3].Width = 1.9377822875976562;
    s[3].Height = 1.4543800354003906;
    s[3].FrontOverhang = 0.893956184387207;
    s[3].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[3].OriginOffset[i] = dv5[i];
      s[3].Color[i] = dv8[i];
    }

    for (i = 0; i < 6; i++) {
      s[3].bbx[i] = dv7[i];
    }

    assembledProfiles[m].Length = s[m].Length;
  }

  for (m = 0; m < 4; m++) {
    s[0].ActorID = 1.0;
    s[0].ClassID = 1.0;
    s[0].Length = 3.656982421875;
    s[0].Width = 1.8669281005859375;
    s[0].Height = 1.4126434326171875;
    s[0].FrontOverhang = 0.65814268589019775;
    s[0].RearOverhang = 0.57938694953918457;
    for (i = 0; i < 3; i++) {
      s[0].OriginOffset[i] = b_dv[i];
      s[0].Color[i] = dv1[i];
    }

    for (i = 0; i < 6; i++) {
      s[0].bbx[i] = dv2[i];
    }

    s[1].ActorID = 2.0;
    s[1].ClassID = 1.0;
    s[1].Length = 4.761077880859375;
    s[1].Width = 2.2499847412109375;
    s[1].Height = 1.7718353271484375;
    s[1].FrontOverhang = 0.84619772434234619;
    s[1].RearOverhang = 1.0426943302154541;
    for (i = 0; i < 3; i++) {
      s[1].OriginOffset[i] = dv3[i];
      s[1].Color[i] = 0.35294117647058826;
    }

    for (i = 0; i < 6; i++) {
      s[1].bbx[i] = dv4[i];
    }

    s[2].ActorID = 3.0;
    s[2].ClassID = 1.0;
    s[2].Length = 4.55560827255249;
    s[2].Width = 1.9377822875976562;
    s[2].Height = 1.4543800354003906;
    s[2].FrontOverhang = 0.893956184387207;
    s[2].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[2].OriginOffset[i] = dv5[i];
      s[2].Color[i] = dv6[i];
    }

    for (i = 0; i < 6; i++) {
      s[2].bbx[i] = dv7[i];
    }

    s[3].ActorID = 4.0;
    s[3].ClassID = 1.0;
    s[3].Length = 4.55560827255249;
    s[3].Width = 1.9377822875976562;
    s[3].Height = 1.4543800354003906;
    s[3].FrontOverhang = 0.893956184387207;
    s[3].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[3].OriginOffset[i] = dv5[i];
      s[3].Color[i] = dv8[i];
    }

    for (i = 0; i < 6; i++) {
      s[3].bbx[i] = dv7[i];
    }

    assembledProfiles[m].Width = s[m].Width;
  }

  for (m = 0; m < 4; m++) {
    s[0].ActorID = 1.0;
    s[0].ClassID = 1.0;
    s[0].Length = 3.656982421875;
    s[0].Width = 1.8669281005859375;
    s[0].Height = 1.4126434326171875;
    s[0].FrontOverhang = 0.65814268589019775;
    s[0].RearOverhang = 0.57938694953918457;
    for (i = 0; i < 3; i++) {
      s[0].OriginOffset[i] = b_dv[i];
      s[0].Color[i] = dv1[i];
    }

    for (i = 0; i < 6; i++) {
      s[0].bbx[i] = dv2[i];
    }

    s[1].ActorID = 2.0;
    s[1].ClassID = 1.0;
    s[1].Length = 4.761077880859375;
    s[1].Width = 2.2499847412109375;
    s[1].Height = 1.7718353271484375;
    s[1].FrontOverhang = 0.84619772434234619;
    s[1].RearOverhang = 1.0426943302154541;
    for (i = 0; i < 3; i++) {
      s[1].OriginOffset[i] = dv3[i];
      s[1].Color[i] = 0.35294117647058826;
    }

    for (i = 0; i < 6; i++) {
      s[1].bbx[i] = dv4[i];
    }

    s[2].ActorID = 3.0;
    s[2].ClassID = 1.0;
    s[2].Length = 4.55560827255249;
    s[2].Width = 1.9377822875976562;
    s[2].Height = 1.4543800354003906;
    s[2].FrontOverhang = 0.893956184387207;
    s[2].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[2].OriginOffset[i] = dv5[i];
      s[2].Color[i] = dv6[i];
    }

    for (i = 0; i < 6; i++) {
      s[2].bbx[i] = dv7[i];
    }

    s[3].ActorID = 4.0;
    s[3].ClassID = 1.0;
    s[3].Length = 4.55560827255249;
    s[3].Width = 1.9377822875976562;
    s[3].Height = 1.4543800354003906;
    s[3].FrontOverhang = 0.893956184387207;
    s[3].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[3].OriginOffset[i] = dv5[i];
      s[3].Color[i] = dv8[i];
    }

    for (i = 0; i < 6; i++) {
      s[3].bbx[i] = dv7[i];
    }

    assembledProfiles[m].Height = s[m].Height;
  }

  for (m = 0; m < 4; m++) {
    s[0].ActorID = 1.0;
    s[0].ClassID = 1.0;
    s[0].Length = 3.656982421875;
    s[0].Width = 1.8669281005859375;
    s[0].Height = 1.4126434326171875;
    s[0].FrontOverhang = 0.65814268589019775;
    s[0].RearOverhang = 0.57938694953918457;
    for (i = 0; i < 3; i++) {
      s[0].OriginOffset[i] = b_dv[i];
      s[0].Color[i] = dv1[i];
    }

    for (i = 0; i < 6; i++) {
      s[0].bbx[i] = dv2[i];
    }

    s[1].ActorID = 2.0;
    s[1].ClassID = 1.0;
    s[1].Length = 4.761077880859375;
    s[1].Width = 2.2499847412109375;
    s[1].Height = 1.7718353271484375;
    s[1].FrontOverhang = 0.84619772434234619;
    s[1].RearOverhang = 1.0426943302154541;
    for (i = 0; i < 3; i++) {
      s[1].OriginOffset[i] = dv3[i];
      s[1].Color[i] = 0.35294117647058826;
    }

    for (i = 0; i < 6; i++) {
      s[1].bbx[i] = dv4[i];
    }

    s[2].ActorID = 3.0;
    s[2].ClassID = 1.0;
    s[2].Length = 4.55560827255249;
    s[2].Width = 1.9377822875976562;
    s[2].Height = 1.4543800354003906;
    s[2].FrontOverhang = 0.893956184387207;
    s[2].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[2].OriginOffset[i] = dv5[i];
      s[2].Color[i] = dv6[i];
    }

    for (i = 0; i < 6; i++) {
      s[2].bbx[i] = dv7[i];
    }

    s[3].ActorID = 4.0;
    s[3].ClassID = 1.0;
    s[3].Length = 4.55560827255249;
    s[3].Width = 1.9377822875976562;
    s[3].Height = 1.4543800354003906;
    s[3].FrontOverhang = 0.893956184387207;
    s[3].RearOverhang = 0.94833946228027344;
    for (i = 0; i < 3; i++) {
      s[3].OriginOffset[i] = dv5[i];
      s[3].Color[i] = dv8[i];
    }

    for (i = 0; i < 6; i++) {
      s[3].bbx[i] = dv7[i];
    }

    for (i = 0; i < 3; i++) {
      assembledProfiles[m].OriginOffset[i] = s[m].OriginOffset[i];
    }
  }

  for (i = 0; i < 4; i++) {
    obj->pActorProfiles[i] = assembledProfiles[i];
  }

  st.site = &ed_emlrtRSI;
  b_st.site = &rc_emlrtRSI;
  c_st.site = &emlrtRSI;
  d_st.site = &b_emlrtRSI;
  g_st.site = &c_emlrtRSI;
  d_st.site = &b_emlrtRSI;
  g_st.site = &d_emlrtRSI;
  st.site = &ed_emlrtRSI;
  camIntrin = cameraIntrinsics_toCameraIntrinsics(&obj->_pobj0);
  st.site = &dd_emlrtRSI;
  b_st.site = &kb_emlrtRSI;
  monoCamera_checkIntrinsics(&b_st, camIntrin);
  b_st.site = &lb_emlrtRSI;
  c_st.site = &sb_emlrtRSI;
  b_st.site = &mb_emlrtRSI;
  b_st.site = &nb_emlrtRSI;
  c_st.site = &tb_emlrtRSI;
  y = NULL;
  b_m = emlrtCreateLogicalScalar(false);
  emlrtAssign(&y, b_m);
  for (i = 0; i < 28; i++) {
    u[i] = b_u[i];
  }

  b_y = NULL;
  b_m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a(&c_st, 28, b_m, &u[0]);
  emlrtAssign(&b_y, b_m);
  c_y = NULL;
  b_m = emlrtCreateDoubleScalar(0.0);
  emlrtAssign(&c_y, b_m);
  d_st.site = &rx_emlrtRSI;
  e_st.site = &qx_emlrtRSI;
  coder_internal_warningIf(&d_st, y, b_y, num2str(&e_st, c_y, &b_emlrtMCI),
    &c_emlrtMCI);
  b_st.site = &ob_emlrtRSI;
  b_st.site = &pb_emlrtRSI;
  b_st.site = &qb_emlrtRSI;
  for (i = 0; i < 2; i++) {
    camConfig_SensorLocation[i] = 0.0;
  }

  st.site = &tc_emlrtRSI;
  b_st.site = &tb_emlrtRSI;
  d_y = NULL;
  b_m = emlrtCreateLogicalScalar(false);
  emlrtAssign(&d_y, b_m);
  for (i = 0; i < 28; i++) {
    u[i] = b_u[i];
  }

  e_y = NULL;
  b_m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a(&b_st, 28, b_m, &u[0]);
  emlrtAssign(&e_y, b_m);
  f_y = NULL;
  b_m = emlrtCreateDoubleScalar(-0.0);
  emlrtAssign(&f_y, b_m);
  c_st.site = &rx_emlrtRSI;
  f_st.site = &qx_emlrtRSI;
  coder_internal_warningIf(&c_st, d_y, e_y, num2str(&f_st, f_y, &b_emlrtMCI),
    &c_emlrtMCI);
  st.site = &uc_emlrtRSI;
  st.site = &vc_emlrtRSI;
  b_st.site = &cc_emlrtRSI;
  c_st.site = &dc_emlrtRSI;
  monoCamera_rawTformToImage3D(camIntrin, 1.1, -0.0, 0.0, 0.0,
    camConfig_SensorLocation, camMatrix);
  for (i = 0; i < 3; i++) {
    tform2D[3 * i] = camMatrix[i << 2];
    tform2D[3 * i + 1] = camMatrix[(i << 2) + 1];
    tform2D[3 * i + 2] = camMatrix[(i << 2) + 3];
  }

  c_st.site = &ec_emlrtRSI;
  validateattributes(&c_st, tform2D);
  if (b_isequal(det(tform2D))) {
    for (i = 0; i < 44; i++) {
      c_u[i] = d_u[i];
    }

    g_y = NULL;
    b_m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 44, b_m, &c_u[0]);
    emlrtAssign(&g_y, b_m);
    for (i = 0; i < 44; i++) {
      c_u[i] = d_u[i];
    }

    i_y = NULL;
    b_m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&b_st, 44, b_m, &c_u[0]);
    emlrtAssign(&i_y, b_m);
    c_st.site = &nx_emlrtRSI;
    error(&c_st, g_y, getString(&c_st, b_message(&c_st, i_y, &e_emlrtMCI),
           &e_emlrtMCI), &e_emlrtMCI);
  }

  k = rtNaN;
  b_u0 = rtNaN;
  v0 = rtNaN;
  if (!(muDoubleScalarAbs(tform2D[6]) < 2.2204460492503131E-16)) {
    k = 0.0;
    b_u0 = tform2D[0] / tform2D[6];
    v0 = tform2D[3] / tform2D[6];
  }

  h_y = NULL;
  b_k[0] = k;
  b_k[1] = b_u0;
  b_k[2] = v0;
  tmp_size[0] = 1;
  tmp_size[1] = 3;
  for (i = 0; i < 3; i++) {
    c_tmp_data[i] = muDoubleScalarIsNaN(b_k[i]);
  }

  b_m = emlrtCreateLogicalScalar(vectorAny(c_tmp_data, tmp_size));
  emlrtAssign(&h_y, b_m);
  memcpy(&e_u[0], &f_u[0], sizeof(char_T) << 6);
  j_y = NULL;
  b_m = emlrtCreateCharArray(2, &iv4[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 64, b_m, &e_u[0]);
  emlrtAssign(&j_y, b_m);
  k_y = NULL;
  b_m = emlrtCreateDoubleScalar(0.0);
  emlrtAssign(&k_y, b_m);
  l_y = NULL;
  b_m = emlrtCreateDoubleScalar(0.0);
  emlrtAssign(&l_y, b_m);
  st.site = &px_emlrtRSI;
  coder_internal_errorIf(&st, h_y, j_y, num2str(&st, k_y, &n_emlrtMCI), num2str(
    &st, l_y, &o_emlrtMCI), &p_emlrtMCI);
  st.site = &wc_emlrtRSI;
  st.site = &xc_emlrtRSI;
  obj->pCameraConfiguration.Intrinsics = camIntrin;
  obj->pCameraConfiguration.Height = 1.1;
  obj->pCameraConfiguration.Pitch = -0.0;
  obj->pCameraConfiguration.Yaw = 0.0;
  obj->pCameraConfiguration.Roll = 0.0;
  for (i = 0; i < 2; i++) {
    obj->pCameraConfiguration.SensorLocation[i] = 0.0;
  }

  st.site = &yc_emlrtRSI;
  visionDetectionGenerator_monoCameraInSensorFrame(obj, &r1, &camConfig_Height,
    &camConfig_Pitch, &camConfig_Yaw, &camConfig_Roll, camConfig_SensorLocation);
  camIntrin = r1;
  for (i = 0; i < 2; i++) {
    t10_SensorLocation[i] = camConfig_SensorLocation[i];
  }

  obj->pMonoCameraInSensorFrame.Intrinsics = camIntrin;
  obj->pMonoCameraInSensorFrame.Height = camConfig_Height;
  obj->pMonoCameraInSensorFrame.Pitch = camConfig_Pitch;
  obj->pMonoCameraInSensorFrame.Yaw = camConfig_Yaw;
  obj->pMonoCameraInSensorFrame.Roll = camConfig_Roll;
  for (i = 0; i < 2; i++) {
    obj->pMonoCameraInSensorFrame.SensorLocation[i] = t10_SensorLocation[i];
  }

  st.site = &ad_emlrtRSI;
  monoCamera_horizonLine(&st, camIntrin, camConfig_Height, camConfig_Pitch,
    camConfig_Yaw, camConfig_Roll, camConfig_SensorLocation, &k, &b_u0, &v0);
  obj->pHorizonLine[0] = k;
  obj->pHorizonLine[1] = b_u0;
  obj->pHorizonLine[2] = v0;
  st.site = &bd_emlrtRSI;
  visionDetectionGenerator_getUpVectorInImageCoordinates(&st, obj,
    camConfig_SensorLocation);
  for (i = 0; i < 2; i++) {
    obj->puvUp[i] = camConfig_SensorLocation[i];
  }

  st.site = &cd_emlrtRSI;
  visionDetectionGenerator_getGroundCoverageArea(&st, obj, d_tmp_data, tmp_size);
  array_real_T_2D_SetSize(&obj->pxyCoverageArea, tmp_size[0], tmp_size[1]);
  m = tmp_size[0] * tmp_size[1];
  for (i = 0; i < m; i++) {
    obj->pxyCoverageArea.vector.data[i] = d_tmp_data[i];
  }
}

static real_T b_sumColumnB(real_T x[2])
{
  real_T y;
  int32_T k;
  y = x[0];
  for (k = 0; k < 1; k++) {
    y += x[1];
  }

  return y;
}

static void visionDetectionGenerator_getGroundCoverageArea(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T xyCoverageArea_data[], int32_T
  xyCoverageArea_size[2])
{
  coder_array_real_T_2D c_uvCntrRot_data;
  coder_array_real_T_2D c_uvCntr_data;
  coder_array_real_T_2D r1;
  coder_array_real_T_2D r2;
  emlrtStack st;
  monoCamera r;
  real_T b_y_data[300];
  real_T uvTmp_data[212];
  real_T uvValidRegion_data[212];
  real_T b_uvCntr_data[200];
  real_T uvCntrRot_data[200];
  real_T uvCntr_data[200];
  real_T uvMaxRng[200];
  real_T ang_data[106];
  real_T b_uvTmp_data[106];
  real_T c_uvTmp_data[106];
  real_T b_uvCntrRot_data[100];
  real_T mag_data[100];
  real_T b_uvBox[8];
  real_T uvBox[8];
  real_T rot[4];
  real_T horzCoeffs[3];
  real_T imagSz[2];
  real_T monoCamSen_SensorLocation[2];
  real_T uvVanish[2];
  real_T vUp[2];
  int32_T iidx_data[300];
  int32_T b_uvCntrRot_size[2];
  int32_T uvCntrRot_size[2];
  int32_T uvMaxRng_size[2];
  int32_T uvTmp_size[2];
  int32_T uvValidRegion_size[2];
  int32_T b_uvTmp_size[1];
  int32_T c_uvTmp_size[1];
  int32_T mag_size[1];
  int32_T y_size[1];
  int32_T i;
  int32_T loop_ub;
  int32_T partialTrueCount;
  int32_T trueCount;
  int32_T uvCntr_size_idx_0;
  int8_T c_tmp_data[100];
  int8_T d_tmp_data[100];
  int8_T e_tmp_data[4];
  boolean_T belowHorz[100];
  boolean_T bv[4];
  boolean_T bv1[4];
  boolean_T b;
  boolean_T b_belowHorz;
  st.prev = sp;
  st.tls = sp->tls;
  r = obj->pMonoCameraInSensorFrame;
  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = r.SensorLocation[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvVanish[partialTrueCount] = imagSz[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = uvVanish[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvVanish[partialTrueCount] = imagSz[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = uvVanish[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvVanish[partialTrueCount] = imagSz[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = uvVanish[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvVanish[partialTrueCount] = imagSz[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = uvVanish[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    monoCamSen_SensorLocation[partialTrueCount] = imagSz[partialTrueCount];
  }

  for (i = 0; i < 2; i++) {
    vUp[i] = obj->puvUp[i];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    imagSz[partialTrueCount] = r.Intrinsics->ImageSize[partialTrueCount];
  }

  uvBox[0] = 1.0;
  uvBox[4] = imagSz[0];
  uvBox[1] = imagSz[1];
  uvBox[5] = imagSz[0];
  uvBox[2] = imagSz[1];
  uvBox[6] = 1.0;
  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvBox[(partialTrueCount << 2) + 3] = 1.0;
  }

  st.site = &fd_emlrtRSI;
  monoCamera_vehicleToImage(&st, r.Intrinsics, r.Height, r.Pitch, r.Yaw, r.Roll,
    monoCamSen_SensorLocation, uvMaxRng);
  for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
    horzCoeffs[partialTrueCount] = obj->pHorizonLine[partialTrueCount];
  }

  for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
    uvVanish[partialTrueCount] = horzCoeffs[partialTrueCount + 1];
  }

  for (partialTrueCount = 0; partialTrueCount < 100; partialTrueCount++) {
    for (i = 0; i < 2; i++) {
      uvCntrRot_data[i + (partialTrueCount << 1)] = uvMaxRng[partialTrueCount +
        100 * i];
    }
  }

  st.site = &gd_emlrtRSI;
  visionDetectionGenerator_isAbove(obj, uvCntrRot_data, uvVanish, belowHorz);
  for (partialTrueCount = 0; partialTrueCount < 100; partialTrueCount++) {
    belowHorz[partialTrueCount] = ((uvMaxRng[partialTrueCount] >= 1.0) &&
      (uvMaxRng[partialTrueCount] <= imagSz[1]) && (uvMaxRng[partialTrueCount +
      100] >= 1.0) && (uvMaxRng[partialTrueCount + 100] <= imagSz[0]) &&
      (!belowHorz[partialTrueCount]));
  }

  if (combineVectorElements(belowHorz) > 1) {
    rot[0] = -vUp[1];
    rot[1] = vUp[0];
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      rot[partialTrueCount + 2] = vUp[partialTrueCount];
    }

    trueCount = 0;
    partialTrueCount = 0;
    for (i = 0; i < 100; i++) {
      b_belowHorz = belowHorz[i];
      if (b_belowHorz) {
        trueCount++;
        c_tmp_data[partialTrueCount] = (int8_T)i;
        partialTrueCount++;
      }
    }

    uvMaxRng_size[0] = trueCount;
    uvMaxRng_size[1] = 2;
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      for (i = 0; i < trueCount; i++) {
        uvCntrRot_data[i + trueCount * partialTrueCount] = uvMaxRng[c_tmp_data[i]
          + 100 * partialTrueCount];
      }
    }

    g_bsxfun(uvCntrRot_data, uvMaxRng_size, uvVanish, uvTmp_data, uvTmp_size);
    st.site = &md_emlrtRSI;
    b_mtimes(rot, uvTmp_data, uvTmp_size, uvCntrRot_data, uvMaxRng_size);
    loop_ub = uvMaxRng_size[1];
    for (partialTrueCount = 0; partialTrueCount < loop_ub; partialTrueCount++) {
      b_uvCntrRot_data[partialTrueCount] = uvCntrRot_data[(partialTrueCount << 1)
        + 1];
    }

    c_uvCntrRot_data.vector.data = &b_uvCntrRot_data[0];
    c_uvCntrRot_data.vector.numel = uvMaxRng_size[1];
    c_uvCntrRot_data.vector.allocated = uvMaxRng_size[1];
    c_uvCntrRot_data.vector.owner = false;
    c_uvCntrRot_data.size[0] = 1;
    c_uvCntrRot_data.size[1] = uvMaxRng_size[1];
    array_real_T_2D_Constructor(&r1);
    b_abs(&c_uvCntrRot_data, &r1);
    loop_ub = r1.size[1];
    trueCount = 0;
    partialTrueCount = 0;
    for (i = 0; i < loop_ub; i++) {
      if (r1.vector.data[i] < 0.1) {
        trueCount++;
      }

      if (r1.vector.data[i] < 0.1) {
        d_tmp_data[partialTrueCount] = (int8_T)i;
        partialTrueCount++;
      }
    }

    array_real_T_2D_Destructor(&r1);
    for (partialTrueCount = 0; partialTrueCount < trueCount; partialTrueCount++)
    {
      uvCntrRot_data[1 + (emlrtDynamicBoundsCheckR2012b((int32_T)
        d_tmp_data[partialTrueCount], 0, uvMaxRng_size[1] - 1, &emlrtBCI,
        (emlrtConstCTX)sp) << 1)] = -0.1;
    }

    uvCntrRot_size[0] = 2;
    uvCntrRot_size[1] = uvMaxRng_size[1];
    loop_ub = uvMaxRng_size[1];
    for (partialTrueCount = 0; partialTrueCount < loop_ub; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        uvMaxRng[i + (partialTrueCount << 1)] = uvCntrRot_data[i +
          (partialTrueCount << 1)];
      }
    }

    st.site = &md_emlrtRSI;
    c_mtimes(rot, uvMaxRng, uvCntrRot_size, uvCntrRot_data, uvMaxRng_size);
    b_uvCntrRot_size[0] = uvMaxRng_size[1];
    b_uvCntrRot_size[1] = 2;
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      loop_ub = uvMaxRng_size[1];
      for (i = 0; i < loop_ub; i++) {
        uvMaxRng[i + b_uvCntrRot_size[0] * partialTrueCount] =
          uvCntrRot_data[partialTrueCount + (i << 1)];
      }
    }

    h_bsxfun(uvMaxRng, b_uvCntrRot_size, uvVanish, uvCntr_data, uvMaxRng_size);
    loop_ub = uvMaxRng_size[0];
    for (partialTrueCount = 0; partialTrueCount < loop_ub; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        b_uvCntr_data[i + (partialTrueCount << 1)] =
          uvCntr_data[partialTrueCount + uvMaxRng_size[0] * i];
      }
    }

    c_uvCntr_data.vector.data = &b_uvCntr_data[0];
    c_uvCntr_data.vector.numel = uvMaxRng_size[0] << 1;
    c_uvCntr_data.vector.allocated = c_uvCntr_data.vector.numel;
    c_uvCntr_data.vector.owner = false;
    c_uvCntr_data.size[0] = 2;
    c_uvCntr_data.size[1] = uvMaxRng_size[0];
    array_real_T_2D_Constructor(&r2);
    i_bsxfun(&c_uvCntr_data, uvVanish, &r2);
    imagSz[0] = vUp[1];
    imagSz[1] = -vUp[0];
    array_real_T_2D_Reserve(&r2, 200);
    st.site = &md_emlrtRSI;
    d_mtimes((real_T *)r2.vector.data, r2.size, imagSz, mag_data, mag_size);
    array_real_T_2D_SetSize(&r2, r2.size[0], r2.size[1]);
    array_real_T_2D_Destructor(&r2);
    y_size[0] = mag_size[0];
    if (mag_size[0] - 1 >= 0) {
      memcpy(&b_y_data[0], &mag_data[0], (uint32_T)mag_size[0] * sizeof(real_T));
    }

    c_sort(b_y_data, y_size, iidx_data, mag_size);
    uvCntr_size_idx_0 = mag_size[0];
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      loop_ub = mag_size[0];
      for (i = 0; i < loop_ub; i++) {
        uvCntrRot_data[i + uvCntr_size_idx_0 * partialTrueCount] = uvCntr_data
          [(emlrtDynamicBoundsCheckR2012b(iidx_data[i], 1, uvMaxRng_size[0],
             &b_emlrtBCI, (emlrtConstCTX)sp) + uvMaxRng_size[0] *
            partialTrueCount) - 1];
      }
    }

    loop_ub = mag_size[0] << 1;
    if (loop_ub - 1 >= 0) {
      memcpy(&uvCntr_data[0], &uvCntrRot_data[0], (uint32_T)loop_ub * sizeof
             (real_T));
    }

    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        rot[i + (partialTrueCount << 1)] = uvCntr_data
          [(emlrtDynamicBoundsCheckR2012b(i + 1, 1, mag_size[0], &c_emlrtBCI,
             (emlrtConstCTX)sp) + uvCntr_size_idx_0 * partialTrueCount) - 1];
      }
    }

    st.site = &hd_emlrtRSI;
    visionDetectionGenerator_getClosestRegionIntersection(&st, rot, uvBox, vUp);
    uvMaxRng_size[0] = emlrtDynamicBoundsCheckR2012b(mag_size[0], 1, mag_size[0],
      &d_emlrtBCI, (emlrtConstCTX)sp) - 1;
    uvMaxRng_size[1] = emlrtDynamicBoundsCheckR2012b(mag_size[0] - 1, 1,
      mag_size[0], &d_emlrtBCI, (emlrtConstCTX)sp) - 1;
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        rot[i + (partialTrueCount << 1)] = uvCntr_data[uvMaxRng_size[i] +
          uvCntr_size_idx_0 * partialTrueCount];
      }
    }

    st.site = &id_emlrtRSI;
    visionDetectionGenerator_getClosestRegionIntersection(&st, rot, uvBox,
      imagSz);
    for (partialTrueCount = 0; partialTrueCount < 4; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        b_uvBox[i + (partialTrueCount << 1)] = uvBox[partialTrueCount + (i << 2)];
      }
    }

    st.site = &jd_emlrtRSI;
    b_visionDetectionGenerator_isAbove(obj, b_uvBox, vUp, bv);
    for (partialTrueCount = 0; partialTrueCount < 4; partialTrueCount++) {
      for (i = 0; i < 2; i++) {
        b_uvBox[i + (partialTrueCount << 1)] = uvBox[partialTrueCount + (i << 2)];
      }

      bv[partialTrueCount] = !bv[partialTrueCount];
    }

    st.site = &jd_emlrtRSI;
    b_visionDetectionGenerator_isAbove(obj, b_uvBox, imagSz, bv1);
    for (partialTrueCount = 0; partialTrueCount < 4; partialTrueCount++) {
      bv1[partialTrueCount] = !bv1[partialTrueCount];
    }

    trueCount = 0;
    partialTrueCount = 0;
    for (i = 0; i < 4; i++) {
      b_belowHorz = bv1[i];
      b = bv[i];
      if (b && b_belowHorz) {
        trueCount++;
      }

      if (b && b_belowHorz) {
        e_tmp_data[partialTrueCount] = (int8_T)i;
        partialTrueCount++;
      }
    }

    uvValidRegion_size[0] = (trueCount + mag_size[0]) + 2;
    uvValidRegion_size[1] = 2;
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      for (i = 0; i < trueCount; i++) {
        uvValidRegion_data[i + uvValidRegion_size[0] * partialTrueCount] =
          uvBox[e_tmp_data[i] + (partialTrueCount << 2)];
      }
    }

    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      uvValidRegion_data[trueCount + uvValidRegion_size[0] * partialTrueCount] =
        vUp[partialTrueCount];
    }

    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      uvValidRegion_data[(trueCount + uvValidRegion_size[0] * partialTrueCount)
        + 1] = imagSz[partialTrueCount];
    }

    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      for (i = 0; i < uvCntr_size_idx_0; i++) {
        uvValidRegion_data[((i + trueCount) + uvValidRegion_size[0] *
                            partialTrueCount) + 2] = uvCntr_data[i +
          uvCntr_size_idx_0 * partialTrueCount];
      }
    }

    mean(uvValidRegion_data, uvValidRegion_size, vUp);
    g_bsxfun(uvValidRegion_data, uvValidRegion_size, vUp, uvTmp_data, uvTmp_size);
    b_uvTmp_size[0] = uvTmp_size[0];
    loop_ub = uvTmp_size[0];
    c_uvTmp_size[0] = uvTmp_size[0];
    if (uvTmp_size[0] - 1 >= 0) {
      memcpy(&c_uvTmp_data[0], &uvTmp_data[0], (uint32_T)uvTmp_size[0] * sizeof
             (real_T));
    }

    for (partialTrueCount = 0; partialTrueCount < loop_ub; partialTrueCount++) {
      b_uvTmp_data[partialTrueCount] = uvTmp_data[partialTrueCount + uvTmp_size
        [0]];
    }

    st.site = &kd_emlrtRSI;
    b_atan2(&st, b_uvTmp_data, b_uvTmp_size, c_uvTmp_data, c_uvTmp_size,
            ang_data, mag_size);
    y_size[0] = mag_size[0];
    if (mag_size[0] - 1 >= 0) {
      memcpy(&b_y_data[0], &ang_data[0], (uint32_T)mag_size[0] * sizeof(real_T));
    }

    c_sort(b_y_data, y_size, iidx_data, mag_size);
    for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
      loop_ub = mag_size[0];
      for (i = 0; i < loop_ub; i++) {
        uvTmp_data[i + mag_size[0] * partialTrueCount] = uvValidRegion_data
          [(emlrtDynamicBoundsCheckR2012b(iidx_data[i], 1, uvValidRegion_size[0],
             &e_emlrtBCI, (emlrtConstCTX)sp) + uvValidRegion_size[0] *
            partialTrueCount) - 1];
      }
    }

    uvValidRegion_size[0] = mag_size[0];
    uvValidRegion_size[1] = 2;
    loop_ub = mag_size[0] << 1;
    if (loop_ub - 1 >= 0) {
      memcpy(&uvValidRegion_data[0], &uvTmp_data[0], (uint32_T)loop_ub * sizeof
             (real_T));
    }
  } else if (r.Pitch < 0.0) {
    uvValidRegion_size[0] = 0;
    uvValidRegion_size[1] = 2;
  } else {
    uvValidRegion_size[0] = 4;
    uvValidRegion_size[1] = 2;
    memcpy(&uvValidRegion_data[0], &uvBox[0], sizeof(real_T) << 3);
  }

  if (uvValidRegion_size[0] == 0) {
    xyCoverageArea_size[0] = 0;
    xyCoverageArea_size[1] = 0;
  } else {
    st.site = &ld_emlrtRSI;
    monoCamera_imageToVehicle(&st, r.Intrinsics, r.Height, r.Pitch, r.Yaw,
      r.Roll, monoCamSen_SensorLocation, uvValidRegion_data, uvValidRegion_size,
      uvTmp_data, uvTmp_size);
    xyCoverageArea_size[0] = uvTmp_size[0];
    xyCoverageArea_size[1] = 2;
    loop_ub = uvTmp_size[0] * uvTmp_size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&xyCoverageArea_data[0], &uvTmp_data[0], (uint32_T)loop_ub * sizeof
             (real_T));
    }
  }
}

static void monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T imagePoints[200])
{
  static real_T a[300] = { -150.0, -149.69800147078266, -148.7932219246193,
    -147.28930458940602, -145.19230520945345, -142.51066766114181,
    -139.25518995241092, -135.43898074299318, -131.07740656046775,
    -126.1880299246772, -120.7905386296588, -114.90666646784669,
    -108.56010571576053, -101.77641173356986, -94.582900062678377,
    -87.0085364356797, -79.083820141575373, -70.840661215902387,
    -62.312251950283013, -53.532933238780792, -44.538056299241255,
    -35.363840326414106, -26.047226650039544, -16.625729985151647,
    -7.1372873735613753, 2.3798945752211895, 11.887493528518233,
    21.347225740992766, 30.721000209778598, 39.971072053505246,
    49.060194497613232, 57.951768853969284, 66.609991890866112,
    74.999999999999986, 83.088009579916545, 90.84145307065, 98.229110091792748,
    105.22123315594818, 111.7896674513632, 117.90796421141813,
    123.55148721447492, 128.69751198524654, 133.32531729823853,
    137.41626861481043, 140.95389311788625, 143.92394604217461,
    146.31446803281105, 148.11583330145913, 149.32078838596269,
    149.92448135747776, 149.92448135747776, 149.32078838596269,
    148.11583330145913, 146.31446803281105, 143.92394604217461,
    140.95389311788625, 137.41626861481043, 133.32531729823853,
    128.69751198524654, 123.55148721447492, 117.90796421141813,
    111.7896674513632, 105.22123315594818, 98.229110091792748, 90.84145307065,
    83.088009579916545, 74.999999999999986, 66.609991890866112,
    57.951768853969284, 49.060194497613232, 39.971072053505246,
    30.721000209778598, 21.347225740992766, 11.887493528518233,
    2.3798945752211895, -7.1372873735613753, -16.625729985151647,
    -26.047226650039544, -35.363840326414106, -44.538056299241255,
    -53.532933238780792, -62.312251950283013, -70.840661215902387,
    -79.083820141575373, -87.0085364356797, -94.582900062678377,
    -101.77641173356986, -108.56010571576053, -114.90666646784669,
    -120.7905386296588, -126.1880299246772, -131.07740656046775,
    -135.43898074299318, -139.25518995241092, -142.51066766114181,
    -145.19230520945345, -147.28930458940602, -148.7932219246193,
    -149.69800147078266, -150.0, -1.8369701987210297E-14, -9.5135879484846591,
    -18.988868036062406, -28.387686654061511, -37.672198077161895,
    -46.805016854773044, -55.749368349049071, -64.469236813375716,
    -72.929510415070311, -81.096122618339621, -88.93618935819606,
    -96.418141452980919, -103.51185172231679, -110.18875629862997,
    -116.42196964376352, -122.18639280755036, -127.45881449242714,
    -132.2180045171373, -136.44479930317775, -140.122179039766,
    -143.23533621661107, -145.77173524853126, -147.72116295183119,
    -149.07576966918811, -149.8301008774512, -149.98111915108126,
    -149.52821639279136, -148.4732162821399, -146.82036693221681,
    -144.57632378399131, -141.75012280720026, -138.35314411568723,
    -134.39906614370037, -129.9038105676658, -124.88547819521571,
    -119.36427607962482, -113.36243615313874, -106.90412570682943,
    -100.01535007744374, -92.723847933090781, -85.0589795794156,
    -77.051608736010962, -68.733978259111566, -60.139580310992059,
    -51.303021498850313, -42.259883526214452, -33.0465799179811,
    -23.700209396002489, -14.2584064956274, -4.7591900247101471,
    4.7591900247101471, 14.2584064956274, 23.700209396002489, 33.0465799179811,
    42.259883526214452, 51.303021498850313, 60.139580310992059,
    68.733978259111566, 77.051608736010962, 85.0589795794156, 92.723847933090781,
    100.01535007744374, 106.90412570682943, 113.36243615313874,
    119.36427607962482, 124.88547819521571, 129.9038105676658,
    134.39906614370037, 138.35314411568723, 141.75012280720026,
    144.57632378399131, 146.82036693221681, 148.4732162821399,
    149.52821639279136, 149.98111915108126, 149.8301008774512,
    149.07576966918811, 147.72116295183119, 145.77173524853126,
    143.23533621661107, 140.122179039766, 136.44479930317775, 132.2180045171373,
    127.45881449242714, 122.18639280755036, 116.42196964376352,
    110.18875629862997, 103.51185172231679, 96.418141452980919,
    88.93618935819606, 81.096122618339621, 72.929510415070311,
    64.469236813375716, 55.749368349049071, 46.805016854773044,
    37.672198077161895, 28.387686654061511, 18.988868036062406,
    9.5135879484846591, 1.8369701987210297E-14, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0 };

  __m128d r;
  __m128d r1;
  emlrtStack b_st;
  emlrtStack st;
  real_T X[300];
  real_T b[200];
  real_T self_T[9];
  int32_T i;
  int32_T jtilecol;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &nd_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &od_emlrtRSI;
  monoCamera_tformToImage(&b_st, this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, self_T);
  st.site = &md_emlrtRSI;
  mtimes(a, self_T, X);
  for (jtilecol = 0; jtilecol < 2; jtilecol++) {
    memcpy(&b[jtilecol * 100], &X[200], 100U * sizeof(real_T));
  }

  for (jtilecol = 0; jtilecol < 2; jtilecol++) {
    for (i = 0; i <= 98; i += 2) {
      r = _mm_loadu_pd(&X[i + 100 * jtilecol]);
      r1 = _mm_loadu_pd(&b[i + 100 * jtilecol]);
      _mm_storeu_pd(&X[i + 100 * jtilecol], _mm_div_pd(r, r1));
      r = _mm_loadu_pd(&X[i + 100 * jtilecol]);
      _mm_storeu_pd(&imagePoints[i + 100 * jtilecol], r);
    }
  }
}

static void monoCamera_tformToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T tform_T[9])
{
  static const int32_T iv[2] = { 1, 44 };

  static const int32_T iv1[2] = { 1, 44 };

  static char_T b_u[44] = { 'i', 'm', 'a', 'g', 'e', 's', ':', 'g', 'e', 'o',
    't', 'r', 'a', 'n', 's', ':', 's', 'i', 'n', 'g', 'u', 'l', 'a', 'r', 'T',
    'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', 'M', 'a',
    't', 'r', 'i', 'x' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T camMatrix[12];
  int32_T i;
  char_T u[44];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &dc_emlrtRSI;
  monoCamera_rawTformToImage3D(this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, camMatrix);
  for (i = 0; i < 3; i++) {
    tform_T[3 * i] = camMatrix[i << 2];
    tform_T[3 * i + 1] = camMatrix[(i << 2) + 1];
    tform_T[3 * i + 2] = camMatrix[(i << 2) + 3];
  }

  st.site = &ec_emlrtRSI;
  validateattributes(&st, tform_T);
  if (b_isequal(det(tform_T))) {
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &nx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &e_emlrtMCI), &e_emlrtMCI),
          &e_emlrtMCI);
  }
}

static void mtimes(real_T A[300], real_T B[9], real_T C[300])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  TRANSB1 = 'N';
  TRANSA1 = 'N';
  alpha1 = 1.0;
  beta1 = 0.0;
  m_t = (ptrdiff_t)100;
  n_t = (ptrdiff_t)3;
  k_t = (ptrdiff_t)3;
  lda_t = (ptrdiff_t)100;
  ldb_t = (ptrdiff_t)3;
  ldc_t = (ptrdiff_t)100;
  dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t, &B[0],
        &ldb_t, &beta1, &C[0], &ldc_t);
}

static void visionDetectionGenerator_isAbove(visionDetectionGenerator *obj,
  real_T pts[200], real_T r0[2], boolean_T flag[100])
{
  real_T b_dv[200];
  real_T b_vUp[100];
  real_T vUp[2];
  int32_T b_i;
  int32_T i;
  for (i = 0; i < 2; i++) {
    vUp[i] = obj->puvUp[i];
  }

  f_bsxfun(pts, r0, b_dv);
  for (i = 0; i < 100; i++) {
    b_vUp[i] = 0.0;
    for (b_i = 0; b_i < 2; b_i++) {
      b_vUp[i] += vUp[b_i] * b_dv[b_i + (i << 1)];
    }

    flag[i] = (muDoubleScalarRound(b_vUp[i] * 1.0E+6) > 0.0);
  }
}

static void f_bsxfun(real_T a[200], real_T b[2], real_T c[200])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T k;
  for (k = 0; k < 100; k++) {
    for (b_k = 0; b_k <= 0; b_k += 2) {
      r = _mm_loadu_pd(&a[k << 1]);
      r1 = _mm_loadu_pd(&b[0]);
      _mm_storeu_pd(&c[k << 1], _mm_sub_pd(r, r1));
    }
  }
}

static int32_T combineVectorElements(boolean_T x[100])
{
  int32_T k;
  int32_T y;
  y = (int32_T)x[0];
  for (k = 0; k < 99; k++) {
    y += (int32_T)x[k + 1];
  }

  return y;
}

static void g_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2])
{
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T k;
  int8_T csz_idx_0;
  csz_idx_0 = (int8_T)a_size[0];
  c_size[0] = (int8_T)a_size[0];
  c_size[1] = 2;
  if ((int8_T)a_size[0] != 0) {
    c_size[1] = 2;
    for (k = 0; k < 2; k++) {
      c_size[1] = 2;
      acoef = (a_size[0] != 1);
      i = csz_idx_0;
      for (b_k = 0; b_k < i; b_k++) {
        c_size[1] = 2;
        c_data[b_k + csz_idx_0 * k] = a_data[acoef * b_k + a_size[0] * k] - b[k];
      }
    }
  }
}

static void b_mtimes(real_T A[4], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  if (B_size[0] == 0) {
    C_size[0] = 2;
    C_size[1] = 0;
  } else {
    TRANSB1 = 'T';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)2;
    n_t = (ptrdiff_t)B_size[0];
    k_t = (ptrdiff_t)2;
    lda_t = (ptrdiff_t)2;
    ldb_t = (ptrdiff_t)B_size[0];
    ldc_t = (ptrdiff_t)2;
    C_size[0] = 2;
    C_size[1] = B_size[0];
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t, &B_data
          [0], &ldb_t, &beta1, &C_data[0], &ldc_t);
  }
}

static void b_abs(coder_array_real_T_2D *x, coder_array_real_T_2D *y)
{
  int32_T k;
  int32_T nx;
  nx = x->size[1];
  array_real_T_2D_SetSize(y, 1, x->size[1]);
  for (k = 0; k < nx; k++) {
    y->vector.data[k] = muDoubleScalarAbs(x->vector.data[k]);
  }
}

static void c_mtimes(real_T A[4], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  if (B_size[1] == 0) {
    C_size[0] = 2;
    C_size[1] = 0;
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'T';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)2;
    n_t = (ptrdiff_t)B_size[1];
    k_t = (ptrdiff_t)2;
    lda_t = (ptrdiff_t)2;
    ldb_t = (ptrdiff_t)2;
    ldc_t = (ptrdiff_t)2;
    C_size[0] = 2;
    C_size[1] = B_size[1];
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t, &B_data
          [0], &ldb_t, &beta1, &C_data[0], &ldc_t);
  }
}

static void h_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[2], real_T
                     c_data[], int32_T c_size[2])
{
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T k;
  int8_T csz_idx_0;
  csz_idx_0 = (int8_T)a_size[0];
  c_size[0] = (int8_T)a_size[0];
  c_size[1] = 2;
  if ((int8_T)a_size[0] != 0) {
    c_size[1] = 2;
    for (k = 0; k < 2; k++) {
      c_size[1] = 2;
      acoef = (a_size[0] != 1);
      i = csz_idx_0;
      for (b_k = 0; b_k < i; b_k++) {
        c_size[1] = 2;
        c_data[b_k + csz_idx_0 * k] = a_data[acoef * b_k + a_size[0] * k] + b[k];
      }
    }
  }
}

static void i_bsxfun(coder_array_real_T_2D *a, real_T b[2],
                     coder_array_real_T_2D *c)
{
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  array_real_T_2D_SetSize(c, 2, (int32_T)(int16_T)a->size[1]);
  if (c->size[1] != 0) {
    array_real_T_2D_SetSize(c, 2, c->size[1]);
    acoef = (a->size[1] != 1);
    i = c->size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      array_real_T_2D_SetSize(c, 2, c->size[1]);
      for (b_k = 0; b_k < 2; b_k++) {
        array_real_T_2D_SetSize(c, 2, c->size[1]);
        c->vector.data[b_k + (k << 1)] = a->vector.data[b_k + (ia << 1)] - b[b_k];
      }
    }
  }
}

static void d_mtimes(real_T A_data[], int32_T A_size[2], real_T B[2], real_T
                     C_data[], int32_T C_size[1])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  if (A_size[1] == 0) {
    C_size[0] = 0;
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'T';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)A_size[1];
    n_t = (ptrdiff_t)1;
    k_t = (ptrdiff_t)2;
    lda_t = (ptrdiff_t)2;
    ldb_t = (ptrdiff_t)2;
    ldc_t = (ptrdiff_t)A_size[1];
    C_size[0] = A_size[1];
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A_data[0], &lda_t, &B
          [0], &ldb_t, &beta1, &C_data[0], &ldc_t);
  }
}

static void j_bsxfun(real_T a[2], real_T b[2], real_T c[2])
{
  __m128d r;
  __m128d r1;
  int32_T k;
  for (k = 0; k <= 0; k += 2) {
    r = _mm_loadu_pd(&a[0]);
    r1 = _mm_loadu_pd(&b[0]);
    _mm_storeu_pd(&c[0], _mm_mul_pd(r, r1));
  }
}

static void k_bsxfun(real_T a[2], real_T b[2], real_T c[2])
{
  __m128d r;
  __m128d r1;
  int32_T k;
  for (k = 0; k <= 0; k += 2) {
    r = _mm_loadu_pd(&a[0]);
    r1 = _mm_loadu_pd(&b[0]);
    _mm_storeu_pd(&c[0], _mm_sub_pd(r, r1));
  }
}

static void visionDetectionGenerator_getClosestRegionIntersection(const
  emlrtStack *sp, real_T uvSeg[4], real_T uvRegion[8], real_T uvInt[2])
{
  emlrtStack st;
  real_T b_uvInt[8];
  real_T dInt[4];
  real_T b_dv[2];
  real_T b_uvRegion[2];
  real_T b_uvSeg[2];
  real_T c_uvRegion[2];
  real_T c_uvSeg[2];
  real_T ex;
  int32_T b_r;
  int32_T i;
  int32_T k;
  int32_T r;
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  for (k = 0; k < 4; k++) {
    if (k == 0) {
      r = 0;
    } else {
      r = k;
    }

    r = (int32_T)emlrtIntegerCheckR2012b((real_T)r + 1.0, &b_emlrtDCI,
      (emlrtConstCTX)sp);
    i = (int32_T)emlrtIntegerCheckR2012b(muDoubleScalarRem((real_T)k + 1.0, 4.0)
      + 1.0, &emlrtDCI, (emlrtConstCTX)sp);
    b_r = emlrtDynamicBoundsCheckR2012b(i, 1, 4, &f_emlrtBCI, (emlrtConstCTX)sp);
    for (i = 0; i < 2; i++) {
      b_uvSeg[i] = uvSeg[i << 1];
      c_uvSeg[i] = uvSeg[(i << 1) + 1];
      b_uvRegion[i] = uvRegion[(r + (i << 2)) - 1];
      c_uvRegion[i] = uvRegion[(b_r + (i << 2)) - 1];
    }

    st.site = &pd_emlrtRSI;
    ComputationalGeometry_intersectLines2D(&st, b_uvSeg, c_uvSeg, b_uvRegion,
      c_uvRegion, b_dv, &ex);
    for (i = 0; i < 2; i++) {
      b_uvInt[k + (i << 2)] = b_dv[i];
    }

    dInt[k] = ex;
  }

  for (k = 0; k < 4; k++) {
    dInt[k] = muDoubleScalarAbs(dInt[k]);
  }

  if (!muDoubleScalarIsNaN(dInt[0])) {
    b_r = 1;
  } else {
    b_r = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!muDoubleScalarIsNaN(dInt[k - 1])) {
        b_r = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (b_r != 0) {
    ex = dInt[b_r - 1];
    r = b_r;
    for (k = b_r + 1; k < 5; k++) {
      if (ex > dInt[k - 1]) {
        ex = dInt[k - 1];
        r = k;
      }
    }

    b_r = r - 1;
  }

  for (i = 0; i < 2; i++) {
    uvInt[i] = b_uvInt[b_r + (i << 2)];
  }
}

static void ComputationalGeometry_intersectLines2D(const emlrtStack *sp, real_T
  x1In[2], real_T x2In[2], real_T y1In[2], real_T y2In[2], real_T xi[2], real_T *
  s)
{
  __m128d r;
  __m128d r1;
  emlrtStack st;
  real_T z_data[2100];
  real_T b_dv[2];
  real_T d_tmp_data[2];
  real_T n2[2];
  real_T v1[2];
  real_T v2[2];
  real_T c_tmp_data[1];
  real_T den_data[1];
  real_T d;
  real_T den;
  int32_T b_tmp_size[2];
  int32_T c_tmp_size[2];
  int32_T d_tmp_size[2];
  int32_T den_size[2];
  int32_T f_tmp_size[2];
  int32_T tmp_size[2];
  int32_T v1_size[2];
  int32_T z_size[2];
  int32_T e_tmp_size[1];
  int32_T b_i;
  int32_T b_trueCount;
  int32_T c_trueCount;
  int32_T i;
  int32_T trueCount;
  boolean_T iGd;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i <= 0; i += 2) {
    r = _mm_loadu_pd(&x2In[0]);
    r1 = _mm_loadu_pd(&x1In[0]);
    _mm_storeu_pd(&v1[0], _mm_sub_pd(r, r1));
    r = _mm_loadu_pd(&y2In[0]);
    r1 = _mm_loadu_pd(&y1In[0]);
    _mm_storeu_pd(&v2[0], _mm_sub_pd(r, r1));
  }

  n2[0] = -v2[1];
  n2[1] = v2[0];
  *s = rtNaN;
  for (b_i = 0; b_i < 2; b_i++) {
    xi[b_i] = rtNaN;
  }

  j_bsxfun(n2, v1, b_dv);
  den = b_sumColumnB(b_dv);
  iGd = (muDoubleScalarAbs(muDoubleScalarRound(den / 1.0E-6)) > 0.0);
  if (iGd) {
    k_bsxfun(y1In, x1In, b_dv);
    j_bsxfun(n2, b_dv, v2);
    trueCount = 0;
    tmp_size[0] = 1;
    for (b_i = 0; b_i < 1; b_i++) {
      trueCount++;
    }

    tmp_size[1] = trueCount;
    b_trueCount = 0;
    b_tmp_size[0] = 1;
    for (b_i = 0; b_i < 1; b_i++) {
      b_trueCount++;
    }

    b_tmp_size[1] = b_trueCount;
    c_trueCount = 0;
    for (b_i = 0; b_i < 1; b_i++) {
      c_trueCount++;
    }

    b_sumColumnB(v2);
    c_tmp_size[0] = 1;
    c_tmp_size[1] = trueCount;
    den_size[0] = 1;
    den_size[1] = b_trueCount;
    st.site = &rd_emlrtRSI;
    assertCompatibleDims(&st, c_tmp_size, den_size);
    if (trueCount == b_trueCount) {
      d = b_sumColumnB(v2);
      z_size[1] = trueCount;
      for (i = 0; i < trueCount; i++) {
        z_data[0] = d / den;
      }
    } else {
      binary_expand_op_1(z_data, z_size, v2, tmp_size, den, b_tmp_size);
    }

    emlrtSubAssignSizeCheck1dR2017a(c_trueCount, z_size[1], &b_emlrtECI,
      (emlrtConstCTX)sp);
    den_data[0] = rtNaN;
    b_i = z_size[1];
    for (i = 0; i < b_i; i++) {
      den_data[0] = z_data[0];
    }

    *s = den_data[0];
    trueCount = 0;
    d_tmp_size[0] = 1;
    for (b_i = 0; b_i < 1; b_i++) {
      trueCount++;
    }

    d_tmp_size[1] = trueCount;
    b_trueCount = 0;
    for (b_i = 0; b_i < 1; b_i++) {
      b_trueCount++;
    }

    e_tmp_size[0] = b_trueCount;
    v1_size[0] = 2;
    v1_size[1] = b_trueCount;
    for (i = 0; i < b_trueCount; i++) {
      c_tmp_data[0] = den_data[0];
      for (b_i = 0; b_i < 2; b_i++) {
        n2[b_i] = v1[b_i];
      }
    }

    st.site = &qd_emlrtRSI;
    l_bsxfun(&st, c_tmp_data, e_tmp_size, n2, v1_size, v2, tmp_size);
    b_trueCount = 0;
    for (b_i = 0; b_i < 1; b_i++) {
      b_trueCount++;
    }

    if (trueCount == tmp_size[1]) {
      f_tmp_size[0] = 2;
      f_tmp_size[1] = trueCount;
      for (i = 0; i < trueCount; i++) {
        for (b_i = 0; b_i <= 0; b_i += 2) {
          r = _mm_loadu_pd(&x1In[0]);
          r1 = _mm_loadu_pd(&v2[0]);
          _mm_storeu_pd(&d_tmp_data[0], _mm_add_pd(r, r1));
        }
      }
    } else {
      binary_expand_op(d_tmp_data, f_tmp_size, x1In, d_tmp_size, v2, tmp_size);
    }

    tmp_size[0] = 2;
    tmp_size[1] = b_trueCount;
    emlrtSubAssignSizeCheckR2012b(&tmp_size[0], 2, &f_tmp_size[0], 2,
      &c_emlrtECI, (void *)sp);
    for (i = 0; i < b_trueCount; i++) {
      for (b_i = 0; b_i < 2; b_i++) {
        xi[b_i] = d_tmp_data[b_i];
      }
    }
  }
}

static void assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'i', 'z',
    'e', 'D', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', 's', 'M', 'u', 's', 't',
    'M', 'a', 't', 'c', 'h' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[1] == 1) || (y_size[1] == 1) || (x_size[1] == y_size[1])) {
  } else {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &kw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &q_emlrtMCI), &q_emlrtMCI),
          &q_emlrtMCI);
  }
}

static void l_bsxfun(const emlrtStack *sp, real_T a_data[], int32_T a_size[1],
                     real_T b_data[], int32_T b_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static const int32_T iv[2] = { 1, 38 };

  static const int32_T iv1[2] = { 1, 38 };

  static char_T b_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'b', 's', 'x',
    'f', 'u', 'n', ':', 'a', 'r', 'r', 'a', 'y', 'D', 'i', 'm', 'e', 'n', 's',
    'i', 'o', 'n', 's', 'M', 'u', 's', 't', 'M', 'a', 't', 'c', 'h' };

  __m128d r;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T b_k;
  int32_T k;
  char_T u[38];
  st.prev = sp;
  st.tls = sp->tls;
  if (a_size[0] != 1) {
    for (k = 0; k < 38; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 38; k++) {
      u[k] = b_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &bx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &l_emlrtMCI), &l_emlrtMCI),
          &l_emlrtMCI);
  }

  c_size[0] = 2;
  c_size[1] = (int8_T)b_size[1];
  if ((int8_T)b_size[1] != 0) {
    c_size[0] = 2;
    for (k = 0; k < 1; k++) {
      c_size[0] = 2;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 2;
        r = _mm_loadu_pd(&b_data[0]);
        _mm_storeu_pd(&c_data[0], _mm_mul_pd(_mm_set1_pd(a_data[0]), r));
      }
    }
  }
}

static void b_visionDetectionGenerator_isAbove(visionDetectionGenerator *obj,
  real_T pts[8], real_T r0[2], boolean_T flag[4])
{
  real_T vTst[8];
  real_T b_vUp[4];
  real_T vUp[2];
  int32_T i;
  int32_T k;
  for (i = 0; i < 2; i++) {
    vUp[i] = obj->puvUp[i];
  }

  for (i = 0; i < 4; i++) {
    b_vUp[i] = 0.0;
    for (k = 0; k < 2; k++) {
      vTst[k + (i << 1)] = pts[k + (i << 1)] - r0[k];
      b_vUp[i] += vUp[k] * vTst[k + (i << 1)];
    }

    flag[i] = (muDoubleScalarRound(b_vUp[i] * 1.0E+6) > 0.0);
  }
}

static void mean(real_T x_data[], int32_T x_size[2], real_T y[2])
{
  real_T b_y;
  int32_T col;
  for (col = 0; col < 2; col++) {
    b_y = c_sumColumnB(x_data, x_size, col + 1, x_size[0]);
    b_y /= (real_T)x_size[0];
    y[col] = b_y;
  }
}

static real_T c_sumColumnB(real_T x_data[], int32_T x_size[2], int32_T col,
  int32_T vlen)
{
  real_T y;
  int32_T i;
  int32_T i0;
  int32_T k;
  i0 = (col - 1) * x_size[0];
  y = x_data[i0];
  i = (uint8_T)(vlen - 1);
  for (k = 0; k < i; k++) {
    y += x_data[(i0 + k) + 1];
  }

  return y;
}

static void b_atan2(const emlrtStack *sp, real_T b_y_data[], int32_T y_size[1],
                    real_T x_data[], int32_T x_size[1], real_T r_data[], int32_T
                    r_size[1])
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T c;
  int32_T k;
  char_T u[15];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  if (y_size[0] <= x_size[0]) {
    c = y_size[0];
  } else {
    c = x_size[0];
  }

  p = true;
  if ((int8_T)c == y_size[0]) {
    if ((int8_T)c == x_size[0]) {
    } else {
      p = false;
    }
  } else {
    p = false;
  }

  if (!p) {
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&y, m);
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &ax_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &r_emlrtMCI), &r_emlrtMCI),
          &r_emlrtMCI);
  }

  if (y_size[0] <= x_size[0]) {
    c = y_size[0];
  } else {
    c = x_size[0];
  }

  r_size[0] = (int8_T)c;
  c = (int8_T)c;
  for (k = 0; k < c; k++) {
    r_data[k] = muDoubleScalarAtan2(b_y_data[k], x_data[k]);
  }
}

static void monoCamera_imageToVehicle(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T imagePoints_data[],
  int32_T imagePoints_size[2], real_T vehiclePoints_data[], int32_T
  vehiclePoints_size[2])
{
  static const int32_T iv[2] = { 1, 37 };

  static const int32_T iv1[2] = { 1, 37 };

  static const int32_T iv2[2] = { 1, 39 };

  static const int32_T iv3[2] = { 1, 39 };

  static const int32_T iv4[2] = { 1, 39 };

  static const int32_T iv5[2] = { 1, 39 };

  static char_T d_u[39] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'a', 't',
    'e', 'n', 'a', 't', 'e', ':', 'm', 'a', 't', 'r', 'i', 'x', 'D', 'i', 'm',
    'e', 'n', 's', 'i', 'o', 'n', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h' };

  static char_T b_u[37] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'm', 'o',
    'n', 'o', 'C', 'a', 'm', 'e', 'r', 'a', ':', 'i', 'n', 'v', 'a', 'l', 'i',
    'd', 'I', 'm', 'a', 'g', 'e', 'P', 'o', 'i', 'n', 't', 's' };

  __m128d r;
  __m128d r1;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  real_T X_data[318];
  real_T b_U_data[318];
  real_T b_y_data[212];
  real_T x_data[212];
  real_T b_X_data[106];
  real_T self_T[9];
  real_T b_this_Intrinsics;
  int32_T U_size[2];
  int32_T X_size[2];
  int32_T x_size[2];
  int32_T b_X_size[1];
  int32_T b_imagePoints_size[1];
  int32_T c_imagePoints_size[1];
  int32_T d_imagePoints_size[1];
  int32_T i;
  int32_T i1;
  int32_T imagePoints_idx_0;
  int32_T loop_ub;
  int32_T result;
  char_T c_u[39];
  char_T u[37];
  boolean_T b_imagePoints_data[212];
  boolean_T c_imagePoints_data[106];
  boolean_T empty_non_axis_sizes;
  boolean_T guard1;
  st.prev = sp;
  st.tls = sp->tls;
  imagePoints_idx_0 = imagePoints_size[0] << 1;
  b_imagePoints_size[0] = imagePoints_idx_0;
  for (i = 0; i < imagePoints_idx_0; i++) {
    b_imagePoints_data[i] = (imagePoints_data[i] < 0.5);
  }

  st.site = &td_emlrtRSI;
  guard1 = false;
  if (any(&st, b_imagePoints_data, b_imagePoints_size)) {
    guard1 = true;
  } else {
    b_this_Intrinsics = this_Intrinsics->ImageSize[1] + 0.5;
    c_imagePoints_size[0] = imagePoints_size[0];
    loop_ub = imagePoints_size[0];
    for (i = 0; i < loop_ub; i++) {
      c_imagePoints_data[i] = (imagePoints_data[i] > b_this_Intrinsics);
    }

    st.site = &ud_emlrtRSI;
    if (any(&st, c_imagePoints_data, c_imagePoints_size)) {
      guard1 = true;
    } else {
      b_this_Intrinsics = this_Intrinsics->ImageSize[0] + 0.5;
      d_imagePoints_size[0] = imagePoints_size[0];
      loop_ub = imagePoints_size[0];
      for (i = 0; i < loop_ub; i++) {
        c_imagePoints_data[i] = (imagePoints_data[i + imagePoints_size[0]] >
          b_this_Intrinsics);
      }

      st.site = &vd_emlrtRSI;
      if (any(&st, c_imagePoints_data, d_imagePoints_size)) {
        guard1 = true;
      }
    }
  }

  if (guard1) {
    for (i = 0; i < 37; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 37; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &ox_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &s_emlrtMCI), &s_emlrtMCI),
          &s_emlrtMCI);
  }

  st.site = &wd_emlrtRSI;
  monoCamera_get_ImageToVehicleTransform(&st, this_Intrinsics, this_Height,
    this_Pitch, this_Yaw, this_Roll, this_SensorLocation, self_T);
  if (imagePoints_size[0] != 0) {
    imagePoints_idx_0 = imagePoints_size[0];
  } else {
    imagePoints_idx_0 = 0;
  }

  if ((imagePoints_size[0] == imagePoints_idx_0) || (imagePoints_size[0] == 0))
  {
  } else {
    for (i = 0; i < 39; i++) {
      c_u[i] = d_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 39; i++) {
      c_u[i] = d_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
    emlrtAssign(&e_y, m);
    st.site = &lw_emlrtRSI;
    error(&st, c_y, getString(&st, b_message(&st, e_y, &t_emlrtMCI), &t_emlrtMCI),
          &t_emlrtMCI);
  }

  if ((imagePoints_size[0] == imagePoints_idx_0) || (imagePoints_size[0] == 0))
  {
  } else {
    for (i = 0; i < 39; i++) {
      c_u[i] = d_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 39; i++) {
      c_u[i] = d_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
    emlrtAssign(&f_y, m);
    st.site = &lw_emlrtRSI;
    error(&st, d_y, getString(&st, b_message(&st, f_y, &t_emlrtMCI), &t_emlrtMCI),
          &t_emlrtMCI);
  }

  empty_non_axis_sizes = (imagePoints_idx_0 == 0);
  if (empty_non_axis_sizes || (imagePoints_size[0] != 0)) {
    result = 2;
  } else {
    result = 0;
  }

  if (empty_non_axis_sizes || (imagePoints_size[0] != 0)) {
    loop_ub = 1;
  } else {
    loop_ub = 0;
  }

  U_size[0] = imagePoints_idx_0;
  U_size[1] = result + loop_ub;
  for (i = 0; i < result; i++) {
    for (i1 = 0; i1 < imagePoints_idx_0; i1++) {
      b_U_data[i1 + imagePoints_idx_0 * i] = imagePoints_data[i1 +
        imagePoints_idx_0 * i];
    }
  }

  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < imagePoints_idx_0; i1++) {
      b_U_data[i1 + imagePoints_idx_0 * result] = 1.0;
    }
  }

  st.site = &yd_emlrtRSI;
  dynamic_size_checks(&st, U_size, U_size[1]);
  st.site = &md_emlrtRSI;
  e_mtimes(b_U_data, U_size, self_T, X_data, X_size);
  if (X_size[0] == 0) {
    vehiclePoints_size[0] = 0;
    vehiclePoints_size[1] = 2;
  } else {
    x_size[0] = X_size[0];
    x_size[1] = 2;
    for (i = 0; i < 2; i++) {
      loop_ub = X_size[0];
      for (i1 = 0; i1 < loop_ub; i1++) {
        x_data[i1 + x_size[0] * i] = X_data[i1 + X_size[0] * i];
      }
    }

    b_X_size[0] = X_size[0];
    loop_ub = X_size[0];
    for (i = 0; i < loop_ub; i++) {
      b_X_data[i] = X_data[i + (X_size[0] << 1)];
    }

    st.site = &xd_emlrtRSI;
    repmat(b_X_data, b_X_size, b_y_data, U_size);
    st.site = &rd_emlrtRSI;
    b_assertCompatibleDims(&st, x_size, U_size);
    if (X_size[0] == U_size[0]) {
      loop_ub = (X_size[0] << 1) - 1;
      x_size[1] = 2;
      imagePoints_idx_0 = (loop_ub + 1) / 2 * 2;
      result = imagePoints_idx_0 - 2;
      for (i = 0; i <= result; i += 2) {
        r = _mm_loadu_pd(&x_data[i]);
        r1 = _mm_loadu_pd(&b_y_data[i]);
        _mm_storeu_pd(&x_data[i], _mm_div_pd(r, r1));
      }

      for (i = imagePoints_idx_0; i <= loop_ub; i++) {
        x_data[i] /= b_y_data[i];
      }
    } else {
      rdivide(x_data, x_size, b_y_data, U_size);
    }

    U_size[0] = X_size[0];
    U_size[1] = 2;
    emlrtSubAssignSizeCheckR2012b(&U_size[0], 2, &x_size[0], 2, &d_emlrtECI,
      (void *)sp);
    imagePoints_idx_0 = X_size[0];
    for (i = 0; i < 2; i++) {
      for (i1 = 0; i1 < imagePoints_idx_0; i1++) {
        X_data[i1 + X_size[0] * i] = x_data[i1 + x_size[0] * i];
      }
    }

    vehiclePoints_size[0] = X_size[0];
    vehiclePoints_size[1] = 2;
    for (i = 0; i < 2; i++) {
      loop_ub = X_size[0];
      for (i1 = 0; i1 < loop_ub; i1++) {
        vehiclePoints_data[i1 + vehiclePoints_size[0] * i] = X_data[i1 + X_size
          [0] * i];
      }
    }
  }
}

static boolean_T any(const emlrtStack *sp, boolean_T x_data[], int32_T x_size[1])
{
  static const int32_T iv[2] = { 1, 51 };

  static const int32_T iv1[2] = { 1, 51 };

  static char_T b_u[51] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'a', 'l', 'l', '_', 'o', 'r', '_',
    'a', 'n', 'y', '_', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T ix;
  char_T u[51];
  boolean_T exitg1;
  boolean_T y;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (x_size[0] != 1)) {
  } else {
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &sw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &u_emlrtMCI), &u_emlrtMCI),
          &u_emlrtMCI);
  }

  y = false;
  ix = 0;
  exitg1 = false;
  while ((!exitg1) && (ix + 1 <= x_size[0])) {
    if (x_data[ix]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

static void monoCamera_get_ImageToVehicleTransform(const emlrtStack *sp,
  cameraIntrinsics *this_Intrinsics, real_T this_Height, real_T this_Pitch,
  real_T this_Yaw, real_T this_Roll, real_T this_SensorLocation[2], real_T
  tform_T[9])
{
  static const int32_T iv[2] = { 1, 6 };

  static const int32_T iv1[2] = { 1, 44 };

  static const int32_T iv2[2] = { 1, 44 };

  static char_T b_u[44] = { 'i', 'm', 'a', 'g', 'e', 's', ':', 'g', 'e', 'o',
    't', 'r', 'a', 'n', 's', ':', 's', 'i', 'n', 'g', 'u', 'l', 'a', 'r', 'T',
    'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', 'M', 'a',
    't', 'r', 'i', 'x' };

  static char_T b_rfmt[6] = { '%', '1', '4', '.', '6', 'e' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T vehicleToImageTform_T[9];
  real_T x[9];
  real_T absx11;
  real_T absx21;
  real_T absx31;
  int32_T itmp;
  int32_T p1;
  int32_T p2;
  int32_T p3;
  char_T u[44];
  char_T str[14];
  char_T rfmt[6];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ae_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  e_st.prev = &d_st;
  e_st.tls = d_st.tls;
  b_st.site = &be_emlrtRSI;
  monoCamera_tformToImage(&b_st, this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, vehicleToImageTform_T);
  b_st.site = &ce_emlrtRSI;
  memcpy(&x[0], &vehicleToImageTform_T[0], 9U * sizeof(real_T));
  p1 = 1;
  p2 = 3;
  p3 = 6;
  absx11 = muDoubleScalarAbs(vehicleToImageTform_T[0]);
  absx21 = muDoubleScalarAbs(vehicleToImageTform_T[1]);
  absx31 = muDoubleScalarAbs(vehicleToImageTform_T[2]);
  if ((absx21 > absx11) && (absx21 > absx31)) {
    p1 = 4;
    p2 = 0;
    x[0] = vehicleToImageTform_T[1];
    x[1] = vehicleToImageTform_T[0];
    x[3] = vehicleToImageTform_T[4];
    x[4] = vehicleToImageTform_T[3];
    x[6] = vehicleToImageTform_T[7];
    x[7] = vehicleToImageTform_T[6];
  } else if (absx31 > absx11) {
    p1 = 7;
    p3 = 0;
    x[0] = vehicleToImageTform_T[2];
    x[2] = vehicleToImageTform_T[0];
    x[3] = vehicleToImageTform_T[5];
    x[5] = vehicleToImageTform_T[3];
    x[6] = vehicleToImageTform_T[8];
    x[8] = vehicleToImageTform_T[6];
  }

  absx11 = x[1] / x[0];
  x[1] /= x[0];
  absx21 = x[2] / x[0];
  x[2] /= x[0];
  x[4] -= x[3] * absx11;
  x[5] -= x[3] * absx21;
  x[7] -= x[6] * absx11;
  x[8] -= x[6] * absx21;
  if (muDoubleScalarAbs(x[5]) > muDoubleScalarAbs(x[4])) {
    itmp = p2;
    p2 = p3;
    p3 = itmp;
    x[1] = absx21;
    x[2] = absx11;
    absx11 = x[4];
    x[4] = x[5];
    x[5] = absx11;
    absx11 = x[7];
    x[7] = x[8];
    x[8] = absx11;
  }

  absx11 = x[5] / x[4];
  x[5] /= x[4];
  x[8] -= x[7] * absx11;
  absx11 = (x[1] * x[5] - x[2]) / x[8];
  absx21 = -(x[1] + x[7] * absx11) / x[4];
  tform_T[p1 - 1] = ((1.0 - x[3] * absx21) - x[6] * absx11) / x[0];
  tform_T[p1] = absx21;
  tform_T[p1 + 1] = absx11;
  absx11 = -x[5] / x[8];
  absx21 = (1.0 - x[7] * absx11) / x[4];
  tform_T[p2] = -(x[3] * absx21 + x[6] * absx11) / x[0];
  tform_T[p2 + 1] = absx21;
  tform_T[p2 + 2] = absx11;
  absx11 = 1.0 / x[8];
  absx21 = -x[7] * absx11 / x[4];
  tform_T[p3] = -(x[3] * absx21 + x[6] * absx11) / x[0];
  tform_T[p3 + 1] = absx21;
  tform_T[p3 + 2] = absx11;
  c_st.site = &de_emlrtRSI;
  absx11 = d_norm(vehicleToImageTform_T);
  absx21 = d_norm(tform_T);
  absx31 = 1.0 / (absx11 * absx21);
  if ((absx11 == 0.0) || (absx21 == 0.0) || (absx31 == 0.0)) {
    d_st.site = &ee_emlrtRSI;
    warning(&d_st);
  } else if (muDoubleScalarIsNaN(absx31) || (absx31 < 2.2204460492503131E-16)) {
    d_st.site = &fe_emlrtRSI;
    for (p1 = 0; p1 < 6; p1++) {
      rfmt[p1] = b_rfmt[p1];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&d_st, 6, m, &rfmt[0]);
    emlrtAssign(&y, m);
    c_y = NULL;
    m = emlrtCreateDoubleScalar(absx31);
    emlrtAssign(&c_y, m);
    e_st.site = &tx_emlrtRSI;
    emlrt_marshallIn(&e_st, b_sprintf(&e_st, y, c_y, &x_emlrtMCI),
                     "<output of sprintf>", str);
    d_st.site = &fe_emlrtRSI;
    b_warning(&d_st, str);
  }

  b_st.site = &ec_emlrtRSI;
  validateattributes(&b_st, tform_T);
  if (b_isequal(det(tform_T))) {
    for (p1 = 0; p1 < 44; p1++) {
      u[p1] = b_u[p1];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (p1 = 0; p1 < 44; p1++) {
      u[p1] = b_u[p1];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &u[0]);
    emlrtAssign(&d_y, m);
    b_st.site = &nx_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, b_message(&b_st, d_y, &e_emlrtMCI),
           &e_emlrtMCI), &e_emlrtMCI);
  }
}

static real_T d_norm(real_T x[9])
{
  real_T s;
  real_T y;
  int32_T i;
  int32_T j;
  boolean_T exitg1;
  y = 0.0;
  j = 0;
  exitg1 = false;
  while ((!exitg1) && (j < 3)) {
    s = 0.0;
    for (i = 0; i < 3; i++) {
      s += muDoubleScalarAbs(x[i + 3 * j]);
    }

    if (muDoubleScalarIsNaN(s)) {
      y = rtNaN;
      exitg1 = true;
    } else {
      if (s > y) {
        y = s;
      }

      j++;
    }
  }

  return y;
}

static void warning(const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 21 };

  static char_T b_msgID[21] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'i', 'n',
    'g', 'u', 'l', 'a', 'r', 'M', 'a', 't', 'r', 'i', 'x' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[21];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 21; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 21, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, feval(&st, b_y, c_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void b_warning(const emlrtStack *sp, char_T varargin_1[14])
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 33 };

  static const int32_T iv3[2] = { 1, 14 };

  static char_T b_msgID[33] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'i', 'l', 'l', 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
    'e', 'd', 'M', 'a', 't', 'r', 'i', 'x' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[33];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 33; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 33, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  d_y = NULL;
  m = emlrtCreateCharArray(2, &iv3[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 14, m, &varargin_1[0]);
  emlrtAssign(&d_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, c_feval(&st, b_y, c_y, d_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void dynamic_size_checks(const emlrtStack *sp, int32_T a_size[2], int32_T
  innerDimA)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 45 };

  static const int32_T iv2[2] = { 1, 15 };

  static const int32_T iv3[2] = { 1, 45 };

  static char_T d_u[45] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'm', 't', 'i', 'm', 'e', 's', '_', 'n', 'o', 'D', 'y',
    'n', 'a', 'm', 'i', 'c', 'S', 'c', 'a', 'l', 'a', 'r', 'E', 'x', 'p', 'a',
    'n', 's', 'i', 'o', 'n' };

  static char_T c_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'n',
    'e', 'r', 'd', 'i', 'm' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T b_u[45];
  char_T u[15];
  st.prev = sp;
  st.tls = sp->tls;
  if (innerDimA != 3) {
    if ((a_size[0] == 1) && (a_size[1] == 1)) {
      for (i = 0; i < 45; i++) {
        b_u[i] = d_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 45, m, &b_u[0]);
      emlrtAssign(&b_y, m);
      for (i = 0; i < 45; i++) {
        b_u[i] = d_u[i];
      }

      d_y = NULL;
      m = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 45, m, &b_u[0]);
      emlrtAssign(&d_y, m);
      st.site = &lx_emlrtRSI;
      error(&st, b_y, getString(&st, b_message(&st, d_y, &ab_emlrtMCI),
             &ab_emlrtMCI), &ab_emlrtMCI);
    } else {
      for (i = 0; i < 15; i++) {
        u[i] = c_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 15; i++) {
        u[i] = c_u[i];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
      emlrtAssign(&c_y, m);
      st.site = &mx_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, c_y, &y_emlrtMCI), &y_emlrtMCI),
            &y_emlrtMCI);
    }
  }
}

static void e_mtimes(real_T A_data[], int32_T A_size[2], real_T B[9], real_T
                     C_data[], int32_T C_size[2])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  int32_T i;
  int32_T loop_ub;
  char_T TRANSA1;
  char_T TRANSB1;
  if ((A_size[0] == 0) || (A_size[1] == 0)) {
    C_size[0] = A_size[0];
    C_size[1] = 3;
    loop_ub = A_size[0] * 3;
    for (i = 0; i < loop_ub; i++) {
      C_data[i] = 0.0;
    }
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)A_size[0];
    n_t = (ptrdiff_t)3;
    k_t = (ptrdiff_t)3;
    lda_t = (ptrdiff_t)A_size[0];
    ldb_t = (ptrdiff_t)3;
    ldc_t = (ptrdiff_t)A_size[0];
    C_size[0] = A_size[0];
    C_size[1] = 3;
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A_data[0], &lda_t, &B
          [0], &ldb_t, &beta1, &C_data[0], &ldc_t);
  }
}

static void repmat(real_T a_data[], int32_T a_size[1], real_T b_data[], int32_T
                   b_size[2])
{
  int32_T ibtile;
  int32_T jtilecol;
  int32_T k;
  int32_T nrows;
  b_size[0] = (int8_T)a_size[0];
  b_size[1] = 2;
  nrows = a_size[0];
  for (jtilecol = 0; jtilecol < 2; jtilecol++) {
    ibtile = jtilecol * nrows - 1;
    for (k = 0; k < nrows; k++) {
      b_data[(ibtile + k) + 1] = a_data[k];
    }
  }
}

static void b_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'i', 'z',
    'e', 'D', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', 's', 'M', 'u', 's', 't',
    'M', 'a', 't', 'c', 'h' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (y_size[0] == 1) || (x_size[0] == y_size[0])) {
  } else {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &kw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &q_emlrtMCI), &q_emlrtMCI),
          &q_emlrtMCI);
  }
}

static void SystemCore_checkTunablePropChange(const emlrtStack *sp,
  visionDetectionGenerator *obj)
{
  static const int32_T iv[2] = { 1, 44 };

  static const int32_T iv1[2] = { 1, 44 };

  static char_T b_u[44] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'y', 's',
    't', 'e', 'm', ':', 'i', 'n', 'v', 'a', 'l', 'i', 'd', 'T', 'u', 'n', 'a',
    'b', 'l', 'e', 'M', 'o', 'd', 'A', 'c', 'c', 'e', 's', 's', 'C', 'o', 'd',
    'e', 'g', 'e', 'n' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[44];
  st.prev = sp;
  st.tls = sp->tls;
  if (obj->TunablePropsChanged) {
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &d_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &m_emlrtMCI), &m_emlrtMCI),
          &m_emlrtMCI);
  }
}

static void mw__internal__call__reset(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 45 };

  static const int32_T iv1[2] = { 1, 44 };

  static const int32_T iv2[2] = { 1, 45 };

  static const int32_T iv3[2] = { 1, 44 };

  static const int32_T iv4[2] = { 1, 5 };

  static char_T b_u[45] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'y', 's',
    't', 'e', 'm', ':', 'm', 'e', 't', 'h', 'o', 'd', 'C', 'a', 'l', 'l', 'e',
    'd', 'W', 'h', 'e', 'n', 'R', 'e', 'l', 'e', 'a', 's', 'e', 'd', 'C', 'o',
    'd', 'e', 'g', 'e', 'n' };

  static char_T d_u[44] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'y', 's',
    't', 'e', 'm', ':', 'i', 'n', 'v', 'a', 'l', 'i', 'd', 'T', 'u', 'n', 'a',
    'b', 'l', 'e', 'M', 'o', 'd', 'A', 'c', 'c', 'e', 's', 's', 'C', 'o', 'd',
    'e', 'g', 'e', 'n' };

  static char_T f_u[5] = { 'r', 'e', 's', 'e', 't' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[45];
  char_T c_u[44];
  char_T e_u[5];
  boolean_T tunablePropChangedBeforeResetImpl;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (!moduleInstance->sysobj_not_empty) {
    st.site = &i_emlrtRSI;
    b_st.site = &emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &c_emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &d_emlrtRSI;
    st.site = &j_emlrtRSI;
    visionDetectionGenerator_visionDetectionGenerator(&st,
      &moduleInstance->sysobj);
    moduleInstance->sysobj_not_empty = true;
  }

  st.site = &ge_emlrtRSI;
  if (moduleInstance->sysobj.isInitialized == 2) {
    for (i = 0; i < 45; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 45, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 45; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 45, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 5; i++) {
      e_u[i] = f_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 5, m, &e_u[0]);
    emlrtAssign(&e_y, m);
    b_st.site = &d_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, c_y, e_y, &m_emlrtMCI),
           &m_emlrtMCI), &m_emlrtMCI);
  }

  tunablePropChangedBeforeResetImpl = moduleInstance->sysobj.TunablePropsChanged;
  if (moduleInstance->sysobj.isInitialized == 1) {
    b_st.site = &d_emlrtRSI;
    c_st.site = &ie_emlrtRSI;
    moduleInstance->sysobj.pHasFirstUpdate = false;
    moduleInstance->sysobj.pTimeLastUpdate = 0.0;
    if (moduleInstance->sysobj.pUseRandSeed) {
      d_st.site = &je_emlrtRSI;
      rng(moduleInstance);
    }

    moduleInstance->sysobj.pHasFirstLaneUpdate = false;
    moduleInstance->sysobj.pTimeLastLaneUpdate = 0.0;
  }

  if ((int32_T)tunablePropChangedBeforeResetImpl != (int32_T)
      moduleInstance->sysobj.TunablePropsChanged) {
    for (i = 0; i < 44; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 44; i++) {
      c_u[i] = d_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 44, m, &c_u[0]);
    emlrtAssign(&d_y, m);
    b_st.site = &d_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, b_message(&b_st, d_y, &m_emlrtMCI),
           &m_emlrtMCI), &m_emlrtMCI);
  }
}

static void mw__internal__call__step(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, real_T u0_NumActors, real_T u0_Time,
  BusVehiclePose u0_Actors[3], real_T u1_NumLaneBoundaries, real_T u1_Time,
  BusLaneBoundary u1_LaneBoundaries[500], real_T *y0_NumDetections, boolean_T
  *y0_IsValidTime, BusObjectDetections1Detections y0_Detections[50], real_T
  *y1_Time, boolean_T *y1_IsValidTime, real_T *y1_SensorIndex, real_T
  *y1_NumLaneBoundaries, BusLaneDetections1LaneBoundaries y1_LaneBoundaries[4])
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  real_T d;
  real_T d1;
  real_T d2;
  real_T d3;
  boolean_T b;
  boolean_T b1;
  st.prev = sp;
  st.tls = sp->tls;
  if (!moduleInstance->sysobj_not_empty) {
    st.site = &i_emlrtRSI;
    b_st.site = &emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &c_emlrtRSI;
    c_st.site = &b_emlrtRSI;
    d_st.site = &d_emlrtRSI;
    st.site = &j_emlrtRSI;
    visionDetectionGenerator_visionDetectionGenerator(&st,
      &moduleInstance->sysobj);
    moduleInstance->sysobj_not_empty = true;
  }

  st.site = &he_emlrtRSI;
  SystemCore_step(moduleInstance, &st, &moduleInstance->sysobj, u0_NumActors,
                  u0_Time, u0_Actors, u1_NumLaneBoundaries, u1_Time,
                  u1_LaneBoundaries, &d, &b, y0_Detections, &d1, &b1, &d2, &d3,
                  y1_LaneBoundaries);
  *y1_NumLaneBoundaries = d3;
  *y1_SensorIndex = d2;
  *y1_IsValidTime = b1;
  *y1_Time = d1;
  *y0_IsValidTime = b;
  *y0_NumDetections = d;
}

static void SystemCore_step(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance,
  const emlrtStack *sp, visionDetectionGenerator *obj, real_T
  varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], real_T varargin_2_NumLaneBoundaries, real_T
  varargin_2_Time, BusLaneBoundary varargin_2_LaneBoundaries[500], real_T
  *varargout_1_NumDetections, boolean_T *varargout_1_IsValidTime,
  BusObjectDetections1Detections varargout_1_Detections[50], real_T
  *varargout_2_Time, boolean_T *varargout_2_IsValidTime, real_T
  *varargout_2_SensorIndex, real_T *varargout_2_NumLaneBoundaries,
  BusLaneDetections1LaneBoundaries varargout_2_LaneBoundaries[4])
{
  static const int32_T iv[2] = { 1, 51 };

  static const int32_T iv1[2] = { 1, 51 };

  static const int32_T iv2[2] = { 1, 5 };

  static char_T b_u[51] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'y', 's',
    't', 'e', 'm', ':', 'm', 'e', 't', 'h', 'o', 'd', 'C', 'a', 'l', 'l', 'e',
    'd', 'W', 'h', 'e', 'n', 'L', 'o', 'c', 'k', 'e', 'd', 'R', 'e', 'l', 'e',
    'a', 's', 'e', 'd', 'C', 'o', 'd', 'e', 'g', 'e', 'n' };

  static char_T d_u[5] = { 's', 'e', 't', 'u', 'p' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  real_T d;
  real_T d1;
  real_T d2;
  real_T d3;
  int32_T i;
  char_T u[51];
  char_T c_u[5];
  boolean_T b;
  boolean_T b1;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  if (obj->isInitialized != 1) {
    st.site = &d_emlrtRSI;
    b_st.site = &d_emlrtRSI;
    if (obj->isInitialized != 0) {
      for (i = 0; i < 51; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a(&b_st, 51, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 51; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a(&b_st, 51, m, &u[0]);
      emlrtAssign(&b_y, m);
      for (i = 0; i < 5; i++) {
        c_u[i] = d_u[i];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(&b_st, 5, m, &c_u[0]);
      emlrtAssign(&c_y, m);
      c_st.site = &d_emlrtRSI;
      error(&c_st, y, getString(&c_st, message(&c_st, b_y, c_y, &m_emlrtMCI),
             &m_emlrtMCI), &m_emlrtMCI);
    }

    obj->isInitialized = 1;
    c_st.site = &d_emlrtRSI;
    visionDetectionGenerator_setupImpl(moduleInstance, &c_st, obj);
    c_st.site = &d_emlrtRSI;
    SystemCore_checkTunablePropChange(&c_st, obj);
    obj->TunablePropsChanged = false;
    b_st.site = &d_emlrtRSI;
    c_st.site = &ie_emlrtRSI;
    obj->pHasFirstUpdate = false;
    obj->pTimeLastUpdate = 0.0;
    if (obj->pUseRandSeed) {
      d_st.site = &je_emlrtRSI;
      rng(moduleInstance);
    }

    obj->pHasFirstLaneUpdate = false;
    obj->pTimeLastLaneUpdate = 0.0;
  }

  st.site = &d_emlrtRSI;
  if (obj->TunablePropsChanged) {
    obj->TunablePropsChanged = false;
  }

  st.site = &d_emlrtRSI;
  visionDetectionGenerator_stepImpl(moduleInstance, &st, obj,
    varargin_1_NumActors, varargin_1_Time, varargin_1_Actors,
    varargin_2_NumLaneBoundaries, varargin_2_Time, varargin_2_LaneBoundaries, &d,
    &b, varargout_1_Detections, &d1, &b1, &d2, &d3, varargout_2_LaneBoundaries);
  *varargout_2_NumLaneBoundaries = d3;
  *varargout_2_SensorIndex = d2;
  *varargout_2_IsValidTime = b1;
  *varargout_2_Time = d1;
  *varargout_1_IsValidTime = b;
  *varargout_1_NumDetections = d;
  st.site = &d_emlrtRSI;
  SystemCore_checkTunablePropChange(&st, obj);
}

static void visionDetectionGenerator_stepImpl
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T varargin_1_NumActors, real_T
   varargin_1_Time, BusVehiclePose varargin_1_Actors[3], real_T
   varargin_2_NumLaneBoundaries, real_T varargin_2_Time, BusLaneBoundary
   varargin_2_LaneBoundaries[500], real_T *varargout_1_NumDetections, boolean_T *
   varargout_1_IsValidTime, BusObjectDetections1Detections
   varargout_1_Detections[50], real_T *varargout_2_Time, boolean_T
   *varargout_2_IsValidTime, real_T *varargout_2_SensorIndex, real_T
   *varargout_2_NumLaneBoundaries, BusLaneDetections1LaneBoundaries
   varargout_2_LaneBoundaries[4])
{
  coder_array_s_CP1nqD0d6aDeTm14G lanebounds;
  emlrtStack st;
  real_T adettime;
  real_T d;
  real_T d1;
  real_T ldettime;
  real_T numDets;
  int32_T actors_size[1];
  boolean_T b;
  boolean_T b1;
  boolean_T validUpdateTime;
  st.prev = sp;
  st.tls = sp->tls;
  b_array_s_CP1nqD0d6aDeTm14G2mGp_C(&lanebounds);
  st.site = &ke_emlrtRSI;
  visionDetectionGenerator_parseSensorAndLaneInput(&st, varargin_1_NumActors,
    varargin_1_Time, varargin_1_Actors, varargin_2_NumLaneBoundaries,
    varargin_2_Time, varargin_2_LaneBoundaries, moduleInstance->actors_data,
    actors_size, &adettime, &lanebounds, &ldettime);
  st.site = &le_emlrtRSI;
  visionDetectionGenerator_detectObjects(moduleInstance, &st, obj,
    moduleInstance->actors_data, actors_size, adettime,
    moduleInstance->detectionsGen, &numDets, &validUpdateTime);
  st.site = &me_emlrtRSI;
  visionDetectionGenerator_detectOccludedLanes(moduleInstance, &st, obj,
    moduleInstance->actors_data, actors_size, &lanebounds, ldettime, &d,
    varargout_2_LaneBoundaries, &adettime, &d1, &b);
  *varargout_2_IsValidTime = b;
  *varargout_2_NumLaneBoundaries = d1;
  *varargout_2_Time = d;
  array_s_CP1nqD0d6aDeTm14G2mGp_D(&lanebounds);
  st.site = &ne_emlrtRSI;
  visionDetectionGenerator_sendToBus(&st, moduleInstance->detectionsGen, numDets,
    validUpdateTime, &ldettime, &b1, varargout_1_Detections);
  *varargout_1_IsValidTime = b1;
  *varargout_1_NumDetections = ldettime;
  *varargout_2_SensorIndex = 4.0;
}

static void visionDetectionGenerator_parseSensorAndLaneInput(const emlrtStack
  *sp, real_T varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], real_T varargin_2_NumLaneBoundaries, real_T
  varargin_2_Time, BusLaneBoundary varargin_2_LaneBoundaries[500],
  syCnTpqdknhOEQKNq30nf4E b_actors_data[], int32_T actors_size[1], real_T
  *adettime, coder_array_s_CP1nqD0d6aDeTm14G *lanebounds, real_T *ldettime)
{
  emlrtStack st;
  real_T b_adettime;
  real_T b_ldettime;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &oe_emlrtRSI;
  visionDetectionGenerator_parseSensorInput(&st, varargin_1_NumActors,
    varargin_1_Time, varargin_1_Actors, b_actors_data, actors_size, &b_adettime);
  st.site = &pe_emlrtRSI;
  visionDetectionGenerator_parseLaneBoundaryInput(&st,
    varargin_2_NumLaneBoundaries, varargin_2_Time, varargin_2_LaneBoundaries,
    lanebounds, &b_ldettime);
  *adettime = b_adettime;
  *ldettime = b_ldettime;
}

static void visionDetectionGenerator_parseSensorInput(const emlrtStack *sp,
  real_T varargin_1_NumActors, real_T varargin_1_Time, BusVehiclePose
  varargin_1_Actors[3], syCnTpqdknhOEQKNq30nf4E actorPoses_data[], int32_T
  actorPoses_size[1], real_T *b_time)
{
  static ssfcg_ActorPose r1 = { 1.8446744073709552E+19,/* ActorID */
    0.0,                               /* ClassID */

    { 0.0, 0.0, 0.0 },                 /* Position */

    { 0.0, 0.0, 0.0 },                 /* Velocity */
    0.0,                               /* Pitch */
    0.0,                               /* Roll */
    0.0,                               /* Yaw */

    { 0.0, 0.0, 0.0 }                  /* AngularVelocity */
  };

  coder_array_char_T_2D r;
  emlrtStack b_st;
  emlrtStack st;
  matlabshared_scenario_SensorSimulation_coder_SensorSimCoder sensorSim;
  ssfcg_ActorPose b_tgts[300];
  syCnTpqdknhOEQKNq30nf4E b_tempActors_data[300];
  syCnTpqdknhOEQKNq30nf4E tempActors_data[300];
  syCnTpqdknhOEQKNq30nf4E destActors_data[3];
  syCnTpqdknhOEQKNq30nf4E b_expl_temp;
  syCnTpqdknhOEQKNq30nf4E expl_temp;
  real_T x_data[300];
  real_T filterIDs;
  int32_T iidx_data[300];
  int32_T iv[2];
  int32_T b_tempActors_size[1];
  int32_T iidx_size[1];
  int32_T tempActors_size[1];
  int32_T x_size[1];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T left;
  int32_T mid;
  int32_T right;
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  array_matlabshared_scenario_Sen(&sensorSim);
  if (varargin_1_NumActors > 0.0) {
    st.site = &qe_emlrtRSI;
    AbstractDetectionGenerator_checkActorBus(&st, varargin_1_NumActors,
      varargin_1_Time, varargin_1_Actors);
  }

  *b_time = varargin_1_Time;
  if (varargin_1_NumActors > 0.0) {
    if (varargin_1_NumActors < 1.0) {
      i = 0;
    } else {
      i = (int32_T)emlrtIntegerCheckR2012b(varargin_1_NumActors, &c_emlrtDCI,
        (emlrtConstCTX)sp);
      i = emlrtDynamicBoundsCheckR2012b(i, 1, 3, &g_emlrtBCI, (emlrtConstCTX)sp);
    }

    st.site = &re_emlrtRSI;
    b_st.site = &kf_emlrtRSI;
    visionDetectionGenerator_defaultActorsCodeGenStruct(&b_st, (real_T)i,
      tempActors_data, tempActors_size);
    left = tempActors_size[0];
    if (tempActors_size[0] - 1 >= 0) {
      memcpy(&destActors_data[0], &tempActors_data[0], (uint32_T)
             tempActors_size[0] * sizeof(syCnTpqdknhOEQKNq30nf4E));
    }

    for (mid = 0; mid < i; mid++) {
      if (varargin_1_Actors[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i,
           &s_emlrtBCI, &st) - 1].ActorID < 1.7976931348623157E+308) {
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        destActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left,
          &l_emlrtBCI, &st) - 1].ActorID =
          varargin_1_Actors[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i,
          &k_emlrtBCI, &st) - 1].ActorID;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left, &l_emlrtBCI, &st)
          - 1;
        for (i2 = 0; i2 < 3; i2++) {
          destActors_data[right].Position[i2] = varargin_1_Actors[i1]
            .Position[i2];
        }

        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left, &l_emlrtBCI, &st)
          - 1;
        for (i2 = 0; i2 < 3; i2++) {
          destActors_data[right].Velocity[i2] = varargin_1_Actors[i1]
            .Velocity[i2];
        }

        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        destActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left,
          &l_emlrtBCI, &st) - 1].Yaw =
          varargin_1_Actors[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i,
          &k_emlrtBCI, &st) - 1].Yaw;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        destActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left,
          &l_emlrtBCI, &st) - 1].Pitch =
          varargin_1_Actors[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i,
          &k_emlrtBCI, &st) - 1].Pitch;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        destActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left,
          &l_emlrtBCI, &st) - 1].Roll =
          varargin_1_Actors[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i,
          &k_emlrtBCI, &st) - 1].Roll;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left, &l_emlrtBCI, &st)
          - 1;
        for (i2 = 0; i2 < 3; i2++) {
          destActors_data[right].AngularVelocity[i2] = varargin_1_Actors[i1].
            AngularVelocity[i2];
        }
      } else {
        expl_temp.ActorID = 1.8446744073709552E+19;
        expl_temp.Yaw = 0.0;
        expl_temp.Pitch = 0.0;
        expl_temp.Roll = 0.0;
        for (i1 = 0; i1 < 3; i1++) {
          expl_temp.Position[i1] = 0.0;
          expl_temp.Velocity[i1] = 0.0;
          expl_temp.AngularVelocity[i1] = 0.0;
        }

        destActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1, left,
          &u_emlrtBCI, &st) - 1] = expl_temp;
      }

      emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &m_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &n_emlrtBCI, &st);
    }

    if (tempActors_size[0] - 1 >= 0) {
      memcpy(&tempActors_data[0], &destActors_data[0], (uint32_T)
             tempActors_size[0] * sizeof(syCnTpqdknhOEQKNq30nf4E));
    }
  } else {
    tempActors_size[0] = 0;
  }

  st.site = &se_emlrtRSI;
  if (SensorBase_get_ConnectedToScenario()) {
    st.site = &bf_emlrtRSI;
    SensorBase_get_SensorSim(&sensorSim);
    st.site = &te_emlrtRSI;
    filterIDs = -1.0;
    for (i = 0; i < 300; i++) {
      b_tgts[i] = r1;
    }

    array_char_T_2D_Constructor(&r);
    array_char_T_2D_SetSize(&r, 1, sensorSim.UniqueID.size[1]);
    left = sensorSim.UniqueID.size[1];
    for (i = 0; i < left; i++) {
      r.vector.data[i] = sensorSim.UniqueID.vector.data[i];
    }

    ssfcg_GetTargetPosesinLOS(&r.vector.data[0], 4U, &filterIDs, 0.0, &b_tgts[0]);
    array_char_T_2D_Destructor(&r);
    if (varargin_1_NumActors < 1.0) {
      i = 0;
    } else {
      i = (int32_T)emlrtIntegerCheckR2012b(varargin_1_NumActors, &d_emlrtDCI,
        (emlrtConstCTX)sp);
    }

    st.site = &ue_emlrtRSI;
    b_st.site = &kf_emlrtRSI;
    visionDetectionGenerator_defaultActorsCodeGenStruct(&b_st, (real_T)i,
      tempActors_data, tempActors_size);
    for (mid = 0; mid < i; mid++) {
      i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &s_emlrtBCI, &st);
      if (b_tgts[i1 - 1].ActorID < 1.7976931348623157E+308) {
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st);
        tempActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1,
          tempActors_size[0], &l_emlrtBCI, &st) - 1].ActorID = b_tgts[i1 - 1].
          ActorID;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, tempActors_size[0],
          &l_emlrtBCI, &st) - 1;
        for (i2 = 0; i2 < 3; i2++) {
          tempActors_data[right].Position[i2] = b_tgts[i1].Position[i2];
        }

        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, tempActors_size[0],
          &l_emlrtBCI, &st) - 1;
        for (i2 = 0; i2 < 3; i2++) {
          tempActors_data[right].Velocity[i2] = b_tgts[i1].Velocity[i2];
        }

        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st);
        tempActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1,
          tempActors_size[0], &l_emlrtBCI, &st) - 1].Yaw = b_tgts[i1 - 1].Yaw;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st);
        tempActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1,
          tempActors_size[0], &l_emlrtBCI, &st) - 1].Pitch = b_tgts[i1 - 1].
          Pitch;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st);
        tempActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1,
          tempActors_size[0], &l_emlrtBCI, &st) - 1].Roll = b_tgts[i1 - 1].Roll;
        emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &j_emlrtBCI, &st);
        i1 = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &k_emlrtBCI, &st) - 1;
        right = emlrtDynamicBoundsCheckR2012b(mid + 1, 1, tempActors_size[0],
          &l_emlrtBCI, &st) - 1;
        for (i2 = 0; i2 < 3; i2++) {
          tempActors_data[right].AngularVelocity[i2] = b_tgts[i1].
            AngularVelocity[i2];
        }
      } else {
        b_expl_temp.ActorID = 1.8446744073709552E+19;
        b_expl_temp.Yaw = 0.0;
        b_expl_temp.Pitch = 0.0;
        b_expl_temp.Roll = 0.0;
        for (i1 = 0; i1 < 3; i1++) {
          b_expl_temp.Position[i1] = 0.0;
          b_expl_temp.Velocity[i1] = 0.0;
          b_expl_temp.AngularVelocity[i1] = 0.0;
        }

        tempActors_data[emlrtDynamicBoundsCheckR2012b(mid + 1, 1,
          tempActors_size[0], &u_emlrtBCI, &st) - 1] = b_expl_temp;
      }

      emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &m_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(mid + 1, 1, i, &n_emlrtBCI, &st);
    }

    st.site = &ve_emlrtRSI;
    arrayfun(&st, tempActors_data, tempActors_size, x_data, x_size);
    c_sort(x_data, x_size, iidx_data, iidx_size);
    left = iidx_size[0];
    for (i = 0; i < left; i++) {
      b_tempActors_data[i] = tempActors_data[emlrtDynamicBoundsCheckR2012b
        (iidx_data[i], 1, tempActors_size[0], &v_emlrtBCI, (emlrtConstCTX)sp) -
        1];
    }

    tempActors_size[0] = iidx_size[0];
    if (iidx_size[0] - 1 >= 0) {
      memcpy(&tempActors_data[0], &b_tempActors_data[0], (uint32_T)iidx_size[0] *
             sizeof(syCnTpqdknhOEQKNq30nf4E));
    }
  }

  st.site = &we_emlrtRSI;
  left = 1;
  right = tempActors_size[0];
  exitg1 = false;
  while ((!exitg1) && (left <= right)) {
    mid = (int32_T)muDoubleScalarCeil((real_T)(left + right) / 2.0);
    emlrtDynamicBoundsCheckR2012b(mid, 1, tempActors_size[0], &o_emlrtBCI, &st);
    emlrtDynamicBoundsCheckR2012b(mid, 1, tempActors_size[0], &p_emlrtBCI, &st);
    emlrtDynamicBoundsCheckR2012b(mid, 1, tempActors_size[0], &q_emlrtBCI, &st);
    emlrtDynamicBoundsCheckR2012b(mid, 1, tempActors_size[0], &r_emlrtBCI, &st);
    if (muDoubleScalarIsInf(tempActors_data[mid - 1].ActorID) ||
        muDoubleScalarIsNaN(tempActors_data[mid - 1].ActorID)) {
      exitg1 = true;
    } else if (tempActors_data[emlrtDynamicBoundsCheckR2012b(mid, 1,
                tempActors_size[0], &t_emlrtBCI, &st) - 1].ActorID < 10001.0) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  if (right < 1) {
    left = 0;
  } else {
    emlrtDynamicBoundsCheckR2012b(1, 1, tempActors_size[0], &h_emlrtBCI,
      (emlrtConstCTX)sp);
    left = emlrtDynamicBoundsCheckR2012b(right, 1, tempActors_size[0],
      &i_emlrtBCI, (emlrtConstCTX)sp);
  }

  iv[0] = 1;
  iv[1] = left;
  st.site = &xe_emlrtRSI;
  indexShapeCheck(&st, tempActors_size[0], iv);
  st.site = &ye_emlrtRSI;
  d_validateattributes(&st, varargin_1_Time);
  b_tempActors_size[0] = left;
  if (left - 1 >= 0) {
    memcpy(&b_tempActors_data[0], &tempActors_data[0], (uint32_T)left * sizeof
           (syCnTpqdknhOEQKNq30nf4E));
  }

  st.site = &af_emlrtRSI;
  AbstractDetectionGenerator_assembleActors(&st, b_tempActors_data,
    b_tempActors_size, actorPoses_data, actorPoses_size);
  b_array_matlabshared_scenario_Sen(&sensorSim);
}

static void AbstractDetectionGenerator_checkActorBus(const emlrtStack *sp,
  real_T bus_NumActors, real_T bus_Time, BusVehiclePose bus_Actors[3])
{
  static const int32_T iv[2] = { 1, 46 };

  static const int32_T iv1[2] = { 1, 48 };

  static const int32_T iv10[2] = { 1, 46 };

  static const int32_T iv11[2] = { 1, 46 };

  static const int32_T iv12[2] = { 1, 46 };

  static const int32_T iv13[2] = { 1, 46 };

  static const int32_T iv14[2] = { 1, 22 };

  static const int32_T iv15[2] = { 1, 46 };

  static const int32_T iv16[2] = { 1, 46 };

  static const int32_T iv17[2] = { 1, 17 };

  static const int32_T iv18[2] = { 1, 46 };

  static const int32_T iv19[2] = { 1, 19 };

  static const int32_T iv2[2] = { 1, 46 };

  static const int32_T iv20[2] = { 1, 18 };

  static const int32_T iv3[2] = { 1, 48 };

  static const int32_T iv4[2] = { 1, 46 };

  static const int32_T iv5[2] = { 1, 8 };

  static const int32_T iv6[2] = { 1, 13 };

  static const int32_T iv7[2] = { 1, 46 };

  static const int32_T iv8[2] = { 1, 46 };

  static const int32_T iv9[2] = { 1, 22 };

  static char_T d_u[48] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'a', 'b',
    's', 't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n',
    'G', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 't', 'o', 'o', 'M', 'a',
    'n', 'y', 'A', 'c', 't', 'o', 'r', 's' };

  static char_T c_u[46] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T e_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T k_u[22] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'P', 'o', 's', 'i', 't', 'i', 'o', 'n' };

  static char_T l_u[22] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'V', 'e', 'l', 'o', 'c', 'i', 't', 'y' };

  static char_T p_u[19] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'P', 'i', 't', 'c', 'h' };

  static char_T r_u[18] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'R', 'o', 'l', 'l' };

  static char_T n_u[17] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'Y', 'a', 'w' };

  static char_T i_u[13] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')' };

  static char_T h_u[8] = { 'B', 'u', 's', '.', 'T', 'i', 'm', 'e' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *m_y;
  const mxArray *n_y;
  const mxArray *o_y;
  const mxArray *p_y;
  const mxArray *q_y;
  const mxArray *r_y;
  const mxArray *s_y;
  const mxArray *t_y;
  const mxArray *u_y;
  const mxArray *v_y;
  const mxArray *w_y;
  const mxArray *y;
  int32_T k;
  char_T b_u[48];
  char_T u[46];
  char_T j_u[22];
  char_T o_u[19];
  char_T q_u[18];
  char_T m_u[17];
  char_T g_u[13];
  char_T f_u[8];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &cf_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_validateattributes(&st, bus_NumActors);
  st.site = &df_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(bus_Time)) || (!!muDoubleScalarIsNaN(bus_Time))) {
    p = false;
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (k = 0; k < 8; k++) {
      f_u[k] = h_u[k];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&b_st, 8, m, &f_u[0]);
    emlrtAssign(&f_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, c_y, f_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  if (bus_NumActors > 3.0) {
    for (k = 0; k < 48; k++) {
      b_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 48, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 48; k++) {
      b_u[k] = d_u[k];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 48, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    for (k = 0; k < 13; k++) {
      g_u[k] = i_u[k];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 13, m, &g_u[0]);
    emlrtAssign(&g_y, m);
    i_y = NULL;
    m = emlrtCreateDoubleScalar(3.0);
    emlrtAssign(&i_y, m);
    k_y = NULL;
    m = emlrtCreateDoubleScalar(bus_NumActors);
    emlrtAssign(&k_y, m);
    st.site = &kx_emlrtRSI;
    error(&st, b_y, getString(&st, d_message(&st, d_y, g_y, i_y, k_y,
            &cb_emlrtMCI), &cb_emlrtMCI), &cb_emlrtMCI);
  }

  st.site = &ef_emlrtRSI;
  c_validateattributes(&st, bus_Actors[0].ActorID);
  st.site = &ff_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 3)) {
    if ((!muDoubleScalarIsInf(bus_Actors[0].Position[k])) &&
        (!muDoubleScalarIsNaN(bus_Actors[0].Position[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&e_y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&h_y, m);
    for (k = 0; k < 22; k++) {
      j_u[k] = k_u[k];
    }

    l_y = NULL;
    m = emlrtCreateCharArray(2, &iv9[0]);
    emlrtInitCharArrayR2013a(&b_st, 22, m, &j_u[0]);
    emlrtAssign(&l_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, e_y, getString(&c_st, message(&c_st, h_y, l_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &gf_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 3)) {
    if ((!muDoubleScalarIsInf(bus_Actors[0].Velocity[k])) &&
        (!muDoubleScalarIsNaN(bus_Actors[0].Velocity[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    j_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&j_y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    n_y = NULL;
    m = emlrtCreateCharArray(2, &iv11[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&n_y, m);
    for (k = 0; k < 22; k++) {
      j_u[k] = l_u[k];
    }

    q_y = NULL;
    m = emlrtCreateCharArray(2, &iv14[0]);
    emlrtInitCharArrayR2013a(&b_st, 22, m, &j_u[0]);
    emlrtAssign(&q_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, j_y, getString(&c_st, message(&c_st, n_y, q_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &hf_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(bus_Actors[0].Yaw)) || (!!muDoubleScalarIsNaN
       (bus_Actors[0].Yaw))) {
    p = false;
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    m_y = NULL;
    m = emlrtCreateCharArray(2, &iv10[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&m_y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    p_y = NULL;
    m = emlrtCreateCharArray(2, &iv13[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&p_y, m);
    for (k = 0; k < 17; k++) {
      m_u[k] = n_u[k];
    }

    t_y = NULL;
    m = emlrtCreateCharArray(2, &iv17[0]);
    emlrtInitCharArrayR2013a(&b_st, 17, m, &m_u[0]);
    emlrtAssign(&t_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, m_y, getString(&c_st, message(&c_st, p_y, t_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &if_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(bus_Actors[0].Pitch)) || (!!muDoubleScalarIsNaN
       (bus_Actors[0].Pitch))) {
    p = false;
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    o_y = NULL;
    m = emlrtCreateCharArray(2, &iv12[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&o_y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    s_y = NULL;
    m = emlrtCreateCharArray(2, &iv16[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&s_y, m);
    for (k = 0; k < 19; k++) {
      o_u[k] = p_u[k];
    }

    v_y = NULL;
    m = emlrtCreateCharArray(2, &iv19[0]);
    emlrtInitCharArrayR2013a(&b_st, 19, m, &o_u[0]);
    emlrtAssign(&v_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, o_y, getString(&c_st, message(&c_st, s_y, v_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &jf_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(bus_Actors[0].Roll)) || (!!muDoubleScalarIsNaN
       (bus_Actors[0].Roll))) {
    p = false;
  }

  if (!p) {
    for (k = 0; k < 46; k++) {
      u[k] = c_u[k];
    }

    r_y = NULL;
    m = emlrtCreateCharArray(2, &iv15[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&r_y, m);
    for (k = 0; k < 46; k++) {
      u[k] = e_u[k];
    }

    u_y = NULL;
    m = emlrtCreateCharArray(2, &iv18[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &u[0]);
    emlrtAssign(&u_y, m);
    for (k = 0; k < 18; k++) {
      q_u[k] = r_u[k];
    }

    w_y = NULL;
    m = emlrtCreateCharArray(2, &iv20[0]);
    emlrtInitCharArrayR2013a(&b_st, 18, m, &q_u[0]);
    emlrtAssign(&w_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, r_y, getString(&c_st, message(&c_st, u_y, w_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void b_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 47 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 47 };

  static const int32_T iv3[2] = { 1, 46 };

  static const int32_T iv4[2] = { 1, 13 };

  static const int32_T iv5[2] = { 1, 13 };

  static char_T b_u[47] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T e_u[47] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T d_u[46] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T g_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T h_u[13] = { 'B', 'u', 's', '.', 'N', 'u', 'm', 'A', 'c', 't',
    'o', 'r', 's' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[47];
  char_T c_u[46];
  char_T f_u[13];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!muDoubleScalarIsInf(a)) && (!muDoubleScalarIsNaN(a)) &&
      (muDoubleScalarFloor(a) == a)) {
  } else {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 47; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 47, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 47; i++) {
      u[i] = e_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 47, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 13; i++) {
      f_u[i] = h_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 13, m, &f_u[0]);
    emlrtAssign(&e_y, m);
    b_st.site = &vv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, c_y, e_y, &db_emlrtMCI),
           &db_emlrtMCI), &db_emlrtMCI);
  }

  st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = g_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 13; i++) {
      f_u[i] = h_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&st, 13, m, &f_u[0]);
    emlrtAssign(&f_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, message(&b_st, d_y, f_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void c_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 48 };

  static const int32_T iv1[2] = { 1, 47 };

  static const int32_T iv2[2] = { 1, 48 };

  static const int32_T iv3[2] = { 1, 47 };

  static const int32_T iv4[2] = { 1, 21 };

  static const int32_T iv5[2] = { 1, 21 };

  static char_T b_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'P', 'o', 's', 'i', 't', 'i', 'v', 'e' };

  static char_T e_u[48] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'P', 'o', 's', 'i', 't', 'i', 'v', 'e' };

  static char_T d_u[47] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T g_u[47] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T h_u[21] = { 'B', 'u', 's', '.', 'A', 'c', 't', 'o', 'r', 's',
    '(', ':', ')', '.', 'A', 'c', 't', 'o', 'r', 'I', 'D' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[48];
  char_T c_u[47];
  char_T f_u[21];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if (a <= 0.0) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 48; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 48; i++) {
      u[i] = e_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 21; i++) {
      f_u[i] = h_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 21, m, &f_u[0]);
    emlrtAssign(&e_y, m);
    b_st.site = &yv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, c_y, e_y, &eb_emlrtMCI),
           &eb_emlrtMCI), &eb_emlrtMCI);
  }

  st.site = &ib_emlrtRSI;
  p = true;
  if ((!muDoubleScalarIsInf(a)) && (!muDoubleScalarIsNaN(a)) &&
      (muDoubleScalarFloor(a) == a)) {
  } else {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 47; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 47, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 47; i++) {
      c_u[i] = g_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 47, m, &c_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 21; i++) {
      f_u[i] = h_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&st, 21, m, &f_u[0]);
    emlrtAssign(&f_y, m);
    b_st.site = &vv_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, message(&b_st, d_y, f_y, &db_emlrtMCI),
           &db_emlrtMCI), &db_emlrtMCI);
  }
}

static void visionDetectionGenerator_defaultActorsCodeGenStruct(const emlrtStack
  *sp, real_T numActors, syCnTpqdknhOEQKNq30nf4E actorsCgStruct_data[], int32_T
  actorsCgStruct_size[1])
{
  static syCnTpqdknhOEQKNq30nf4E r = { 1.8446744073709552E+19,/* ActorID */
    { 0.0, 0.0, 0.0 },                 /* Position */

    { 0.0, 0.0, 0.0 },                 /* Velocity */
    0.0,                               /* Yaw */
    0.0,                               /* Pitch */
    0.0,                               /* Roll */

    { 0.0, 0.0, 0.0 }                  /* AngularVelocity */
  };

  emlrtStack b_st;
  emlrtStack st;
  int32_T i;
  int32_T outsize_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &lf_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &mf_emlrtRSI;
  b_assertValidSizeArg(&b_st, numActors);
  outsize_idx_0 = (int32_T)numActors;
  actorsCgStruct_size[0] = (int32_T)numActors;
  for (i = 0; i < outsize_idx_0; i++) {
    actorsCgStruct_data[i] = r;
  }
}

static void b_assertValidSizeArg(const emlrtStack *sp, real_T varargin_1)
{
  static const int32_T iv[2] = { 1, 28 };

  static const int32_T iv1[2] = { 1, 28 };

  static char_T b_u[28] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'N', 'o', 'n', 'I', 'n', 't', 'e', 'g', 'e', 'r', 'I', 'n',
    'p', 'u', 't' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[28];
  st.prev = sp;
  st.tls = sp->tls;
  if ((varargin_1 != varargin_1) || muDoubleScalarIsInf(varargin_1)) {
    for (i = 0; i < 28; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 28; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
    emlrtAssign(&b_y, m);
    c_y = NULL;
    m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
    *(int32_T *)emlrtMxGetData(m) = MIN_int32_T;
    emlrtAssign(&c_y, m);
    d_y = NULL;
    m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
    *(int32_T *)emlrtMxGetData(m) = MAX_int32_T;
    emlrtAssign(&d_y, m);
    st.site = &jx_emlrtRSI;
    error(&st, y, getString(&st, c_message(&st, b_y, c_y, d_y, &k_emlrtMCI),
           &k_emlrtMCI), &k_emlrtMCI);
  }
}

static boolean_T SensorBase_get_ConnectedToScenario(void)
{
  static char_T cv[14] = { 'A', 'D', 'C', '_', 'R', 'o', 'a', 'd', 'R', 'u', 'n',
    'n', 'e', 'r' };

  emlrtStack st;
  int32_T i;
  char_T c_tmp_data[15];
  st.site = &nf_emlrtRSI;
  for (i = 0; i < 14; i++) {
    c_tmp_data[i] = cv[i];
  }

  c_tmp_data[14] = '\x00';
  return ssfcg_IsConnectedToScenario(&c_tmp_data[0]);
}

static matlabshared_scenario_SensorSimulation_coder_SensorSimCoder
  *SensorBase_get_SensorSim
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *iobj_0)
{
  static char_T cv[14] = { 'A', 'D', 'C', '_', 'R', 'o', 'a', 'd', 'R', 'u', 'n',
    'n', 'e', 'r' };

  emlrtStack b_st;
  emlrtStack st;
  matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *sensorSim;
  int32_T i;
  st.site = &of_emlrtRSI;
  b_st.site = &pf_emlrtRSI;
  b_st.site = &pf_emlrtRSI;
  sensorSim = iobj_0;
  array_char_T_2D_SetSize(&iobj_0->UniqueID, 1, 15);
  for (i = 0; i < 14; i++) {
    iobj_0->UniqueID.vector.data[i] = cv[i];
  }

  iobj_0->UniqueID.vector.data[14] = '\x00';
  return sensorSim;
}

static void arrayfun(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
                     varargin_1_data[], int32_T varargin_1_size[1], real_T
                     varargout_1_data[], int32_T varargout_1_size[1])
{
  static const int32_T iv[2] = { 1, 21 };

  static const int32_T iv1[2] = { 1, 21 };

  static char_T b_u[21] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'p', 'm', 'a', 'x', 's', 'i', 'z', 'e' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T n;
  int32_T i;
  int32_T k;
  int16_T varargin_1[2];
  int16_T b_varargin_1;
  char_T u[21];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &qf_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  b_st.site = &rf_emlrtRSI;
  varargin_1[0] = (int16_T)varargin_1_size[0];
  varargin_1[1] = 1;
  c_st.site = &mf_emlrtRSI;
  n = 1.0;
  for (k = 0; k < 2; k++) {
    b_varargin_1 = varargin_1[k];
    if (b_varargin_1 <= 0) {
      n = 0.0;
    } else {
      n *= (real_T)b_varargin_1;
    }
  }

  if (!(n <= 2.147483647E+9)) {
    for (i = 0; i < 21; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&c_st, 21, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 21; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&c_st, 21, m, &u[0]);
    emlrtAssign(&b_y, m);
    d_st.site = &tw_emlrtRSI;
    error(&d_st, y, getString(&d_st, b_message(&d_st, b_y, &gb_emlrtMCI),
           &gb_emlrtMCI), &gb_emlrtMCI);
  }

  varargout_1_size[0] = (int16_T)varargin_1_size[0];
  i = varargin_1_size[0];
  for (k = 0; k < i; k++) {
    varargout_1_data[k] = varargin_1_data[k].ActorID;
  }
}

static void indexShapeCheck(const emlrtStack *sp, int32_T matrixSize, int32_T
  indexSize[2])
{
  emlrtStack st;
  boolean_T c;
  st.prev = sp;
  st.tls = sp->tls;
  if ((matrixSize == 1) && (indexSize[1] != 1)) {
    c = true;
  } else {
    c = false;
  }

  st.site = &sf_emlrtRSI;
  errOrWarnIf(&st, c);
}

static void errOrWarnIf(const emlrtStack *sp, boolean_T c)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'F', 'E', ':', 'P',
    'o', 't', 'e', 'n', 't', 'i', 'a', 'l', 'V', 'e', 'c', 't', 'o', 'r', 'V',
    'e', 'c', 't', 'o', 'r' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  if (c) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &ix_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &hb_emlrtMCI), &hb_emlrtMCI),
          &hb_emlrtMCI);
  }
}

static void d_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 46 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 4 };

  static char_T b_u[46] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'v', 'i', 's',
    'i', 'o', 'n', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G', 'e', 'n',
    'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T c_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T e_u[4] = { 't', 'i', 'm', 'e' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[46];
  char_T d_u[4];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      u[i] = c_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 4; i++) {
      d_u[i] = e_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 4, m, &d_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void AbstractDetectionGenerator_assembleActors(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E b_actors_data[], int32_T actors_size[1],
  syCnTpqdknhOEQKNq30nf4E actorsOut_data[], int32_T actorsOut_size[1])
{
  static const int32_T iv[2] = { 1, 59 };

  static const int32_T iv1[2] = { 1, 59 };

  static const int32_T iv2[2] = { 1, 48 };

  static const int32_T iv3[2] = { 1, 46 };

  static const int32_T iv4[2] = { 1, 48 };

  static const int32_T iv5[2] = { 1, 14 };

  static const int32_T iv6[2] = { 1, 46 };

  static const int32_T iv7[2] = { 1, 16 };

  static char_T b_u[59] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'a', 'b',
    's', 't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n',
    'G', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c',
    't', 'U', 'n', 'i', 'q', 'u', 'e', 'A', 'c', 't', 'o', 'r', 'I', 'D', 'A',
    'c', 't', 'o', 'r' };

  static char_T d_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T j_u[16] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'P', 'i', 't', 'c', 'h' };

  static char_T h_u[14] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'Y', 'a', 'w' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *m;
  const mxArray *y;
  real_T ids_data[300];
  real_T uIds_data[300];
  real_T c_idx;
  int32_T ids_size[2];
  int32_T uIds_size[2];
  int32_T b_idx;
  int32_T b_m;
  int32_T i;
  int32_T idx;
  char_T u[59];
  char_T c_u[48];
  char_T e_u[46];
  char_T i_u[16];
  char_T g_u[14];
  boolean_T cond;
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tf_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_repmat(&st, (real_T)actors_size[0], actorsOut_data, actorsOut_size);
  if (actors_size[0] != 0) {
    st.site = &uf_emlrtRSI;
    cond = false;
    idx = -1;
    b_idx = 0;
    exitg1 = false;
    while ((!exitg1) && (b_idx <= actors_size[0] - 1)) {
      idx = b_idx;
      emlrtDynamicBoundsCheckR2012b(b_idx + 1, 1, actors_size[0], &y_emlrtBCI,
        &st);
      if ((b_actors_data[b_idx].ActorID > 0.0) && (muDoubleScalarRem
           (b_actors_data[b_idx].ActorID, 1.0) == 0.0) && ((!muDoubleScalarIsInf
            (b_actors_data[b_idx].ActorID)) && (!muDoubleScalarIsNaN
            (b_actors_data[b_idx].ActorID)))) {
        cond = true;
      } else {
        cond = false;
      }

      cond = !cond;
      if (cond) {
        exitg1 = true;
      } else {
        b_idx++;
      }
    }

    if (cond) {
      st.site = &vf_emlrtRSI;
      e_validateattributes(&st, b_actors_data[emlrtDynamicBoundsCheckR2012b(idx
        + 1, 1, actors_size[0], &db_emlrtBCI, (emlrtConstCTX)sp) - 1].ActorID);
    }

    st.site = &wf_emlrtRSI;
    AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data, actors_size,
      ids_data, ids_size);
    st.site = &mg_emlrtRSI;
    unique_vector(&st, ids_data, ids_size, uIds_data, uIds_size);
    if (ids_size[1] != uIds_size[1]) {
      for (b_idx = 0; b_idx < 59; b_idx++) {
        u[b_idx] = b_u[b_idx];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 59, m, &u[0]);
      emlrtAssign(&y, m);
      for (b_idx = 0; b_idx < 59; b_idx++) {
        u[b_idx] = b_u[b_idx];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 59, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &hx_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &ib_emlrtMCI),
             &ib_emlrtMCI), &ib_emlrtMCI);
    }

    st.site = &xf_emlrtRSI;
    findFirstInvalid(&st, b_actors_data, actors_size, &cond, &c_idx);
    if (cond) {
      st.site = &yf_emlrtRSI;
      f_validateattributes(&st, b_actors_data[emlrtDynamicBoundsCheckR2012b
                           ((int32_T)c_idx, 1, actors_size[0], &eb_emlrtBCI,
                            (emlrtConstCTX)sp) - 1].Position);
    }

    st.site = &ag_emlrtRSI;
    b_findFirstInvalid(&st, b_actors_data, actors_size, &cond, &c_idx);
    if (cond) {
      st.site = &bg_emlrtRSI;
      g_validateattributes(&st, b_actors_data[emlrtDynamicBoundsCheckR2012b
                           ((int32_T)c_idx, 1, actors_size[0], &fb_emlrtBCI,
                            (emlrtConstCTX)sp) - 1].Velocity);
    }

    st.site = &cg_emlrtRSI;
    cond = false;
    idx = -1;
    b_idx = 0;
    exitg1 = false;
    while ((!exitg1) && (b_idx <= actors_size[0] - 1)) {
      idx = b_idx;
      emlrtDynamicBoundsCheckR2012b(b_idx + 1, 1, actors_size[0], &y_emlrtBCI,
        &st);
      cond = (muDoubleScalarIsInf(b_actors_data[b_idx].Yaw) ||
              muDoubleScalarIsNaN(b_actors_data[b_idx].Yaw));
      if (cond) {
        exitg1 = true;
      } else {
        b_idx++;
      }
    }

    if (cond) {
      st.site = &dg_emlrtRSI;
      emlrtDynamicBoundsCheckR2012b(idx + 1, 1, actors_size[0], &w_emlrtBCI, &st);
      b_st.site = &ib_emlrtRSI;
      cond = true;
      if ((!!muDoubleScalarIsInf(b_actors_data[idx].Yaw)) ||
          (!!muDoubleScalarIsNaN(b_actors_data[idx].Yaw))) {
        cond = false;
      }

      if (!cond) {
        for (b_idx = 0; b_idx < 48; b_idx++) {
          c_u[b_idx] = d_u[b_idx];
        }

        c_y = NULL;
        m = emlrtCreateCharArray(2, &iv2[0]);
        emlrtInitCharArrayR2013a(&b_st, 48, m, &c_u[0]);
        emlrtAssign(&c_y, m);
        for (b_idx = 0; b_idx < 46; b_idx++) {
          e_u[b_idx] = f_u[b_idx];
        }

        d_y = NULL;
        m = emlrtCreateCharArray(2, &iv3[0]);
        emlrtInitCharArrayR2013a(&b_st, 46, m, &e_u[0]);
        emlrtAssign(&d_y, m);
        for (b_idx = 0; b_idx < 14; b_idx++) {
          g_u[b_idx] = h_u[b_idx];
        }

        f_y = NULL;
        m = emlrtCreateCharArray(2, &iv5[0]);
        emlrtInitCharArrayR2013a(&b_st, 14, m, &g_u[0]);
        emlrtAssign(&f_y, m);
        c_st.site = &sv_emlrtRSI;
        error(&c_st, c_y, getString(&c_st, message(&c_st, d_y, f_y, &d_emlrtMCI),
               &d_emlrtMCI), &d_emlrtMCI);
      }
    }

    st.site = &eg_emlrtRSI;
    cond = false;
    idx = -1;
    b_idx = 0;
    exitg1 = false;
    while ((!exitg1) && (b_idx <= actors_size[0] - 1)) {
      idx = b_idx;
      emlrtDynamicBoundsCheckR2012b(b_idx + 1, 1, actors_size[0], &y_emlrtBCI,
        &st);
      cond = (muDoubleScalarIsInf(b_actors_data[b_idx].Pitch) ||
              muDoubleScalarIsNaN(b_actors_data[b_idx].Pitch));
      if (cond) {
        exitg1 = true;
      } else {
        b_idx++;
      }
    }

    if (cond) {
      st.site = &fg_emlrtRSI;
      emlrtDynamicBoundsCheckR2012b(idx + 1, 1, actors_size[0], &x_emlrtBCI, &st);
      b_st.site = &ib_emlrtRSI;
      cond = true;
      if ((!!muDoubleScalarIsInf(b_actors_data[idx].Pitch)) ||
          (!!muDoubleScalarIsNaN(b_actors_data[idx].Pitch))) {
        cond = false;
      }

      if (!cond) {
        for (b_idx = 0; b_idx < 48; b_idx++) {
          c_u[b_idx] = d_u[b_idx];
        }

        e_y = NULL;
        m = emlrtCreateCharArray(2, &iv4[0]);
        emlrtInitCharArrayR2013a(&b_st, 48, m, &c_u[0]);
        emlrtAssign(&e_y, m);
        for (b_idx = 0; b_idx < 46; b_idx++) {
          e_u[b_idx] = f_u[b_idx];
        }

        g_y = NULL;
        m = emlrtCreateCharArray(2, &iv6[0]);
        emlrtInitCharArrayR2013a(&b_st, 46, m, &e_u[0]);
        emlrtAssign(&g_y, m);
        for (b_idx = 0; b_idx < 16; b_idx++) {
          i_u[b_idx] = j_u[b_idx];
        }

        h_y = NULL;
        m = emlrtCreateCharArray(2, &iv7[0]);
        emlrtInitCharArrayR2013a(&b_st, 16, m, &i_u[0]);
        emlrtAssign(&h_y, m);
        c_st.site = &sv_emlrtRSI;
        error(&c_st, e_y, getString(&c_st, message(&c_st, g_y, h_y, &d_emlrtMCI),
               &d_emlrtMCI), &d_emlrtMCI);
      }
    }

    st.site = &gg_emlrtRSI;
    cond = false;
    idx = -1;
    b_idx = 0;
    exitg1 = false;
    while ((!exitg1) && (b_idx <= actors_size[0] - 1)) {
      idx = b_idx;
      emlrtDynamicBoundsCheckR2012b(b_idx + 1, 1, actors_size[0], &y_emlrtBCI,
        &st);
      cond = (muDoubleScalarIsInf(b_actors_data[b_idx].Roll) ||
              muDoubleScalarIsNaN(b_actors_data[b_idx].Roll));
      if (cond) {
        exitg1 = true;
      } else {
        b_idx++;
      }
    }

    if (cond) {
      st.site = &hg_emlrtRSI;
      h_validateattributes(&st, b_actors_data[emlrtDynamicBoundsCheckR2012b(idx
        + 1, 1, actors_size[0], &gb_emlrtBCI, (emlrtConstCTX)sp) - 1].Roll);
    }

    st.site = &ig_emlrtRSI;
    c_findFirstInvalid(&st, b_actors_data, actors_size, &cond, &c_idx);
    if (cond) {
      st.site = &jg_emlrtRSI;
      i_validateattributes(&st, b_actors_data[emlrtDynamicBoundsCheckR2012b
                           ((int32_T)c_idx, 1, actors_size[0], &hb_emlrtBCI,
                            (emlrtConstCTX)sp) - 1].AngularVelocity);
    }

    st.site = &kg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      idx = emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1;
      for (i = 0; i < 3; i++) {
        actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size
          [0], &ib_emlrtBCI, &st) - 1].Velocity[i] = b_actors_data[idx]
          .Velocity[i];
      }
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0],
        &jb_emlrtBCI, &st) - 1].ActorID =
        b_actors_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1].ActorID;
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      idx = emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1;
      for (i = 0; i < 3; i++) {
        actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size
          [0], &ib_emlrtBCI, &st) - 1].Position[i] = b_actors_data[idx]
          .Position[i];
      }
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0],
        &jb_emlrtBCI, &st) - 1].Yaw =
        b_actors_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1].Yaw;
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0],
        &jb_emlrtBCI, &st) - 1].Pitch =
        b_actors_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1].Pitch;
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0],
        &jb_emlrtBCI, &st) - 1].Roll =
        b_actors_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1].Roll;
    }

    st.site = &lg_emlrtRSI;
    b_idx = actors_size[0];
    for (b_m = 0; b_m < b_idx; b_m++) {
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size[0], &ab_emlrtBCI,
        &st);
      emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0], &bb_emlrtBCI,
        &st);
      idx = emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actors_size[0],
        &cb_emlrtBCI, &st) - 1;
      for (i = 0; i < 3; i++) {
        actorsOut_data[emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, actorsOut_size
          [0], &ib_emlrtBCI, &st) - 1].AngularVelocity[i] = b_actors_data[idx].
          AngularVelocity[i];
      }
    }
  }
}

static void b_repmat(const emlrtStack *sp, real_T varargin_1,
                     syCnTpqdknhOEQKNq30nf4E b_data[], int32_T b_size[1])
{
  static syCnTpqdknhOEQKNq30nf4E r = { 0.0,/* ActorID */
    { 0.0, 0.0, 0.0 },                 /* Position */

    { 0.0, 0.0, 0.0 },                 /* Velocity */
    0.0,                               /* Yaw */
    0.0,                               /* Pitch */
    0.0,                               /* Roll */

    { 0.0, 0.0, 0.0 }                  /* AngularVelocity */
  };

  emlrtStack st;
  int32_T i;
  int32_T outsize_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &mf_emlrtRSI;
  b_assertValidSizeArg(&st, varargin_1);
  outsize_idx_0 = (int32_T)varargin_1;
  b_size[0] = (int32_T)varargin_1;
  for (i = 0; i < outsize_idx_0; i++) {
    b_data[i] = r;
  }
}

static void e_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 50 };

  static const int32_T iv1[2] = { 1, 48 };

  static const int32_T iv2[2] = { 1, 48 };

  static const int32_T iv3[2] = { 1, 49 };

  static const int32_T iv4[2] = { 1, 46 };

  static const int32_T iv5[2] = { 1, 18 };

  static const int32_T iv6[2] = { 1, 47 };

  static const int32_T iv7[2] = { 1, 18 };

  static const int32_T iv8[2] = { 1, 18 };

  static char_T b_u[50] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'P', 'o', 's', 'i', 't', 'i', 'v', 'e' };

  static char_T i_u[49] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T d_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T e_u[48] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'P', 'o', 's', 'i', 't', 'i', 'v', 'e' };

  static char_T m_u[47] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T j_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T k_u[18] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'A', 'c', 't', 'o', 'r', 'I', 'D' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[50];
  char_T f_u[49];
  char_T c_u[48];
  char_T l_u[47];
  char_T g_u[46];
  char_T h_u[18];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if (a <= 0.0) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 50; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 50, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 48; i++) {
      c_u[i] = e_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 18; i++) {
      h_u[i] = k_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&st, 18, m, &h_u[0]);
    emlrtAssign(&f_y, m);
    b_st.site = &yv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, c_y, f_y, &eb_emlrtMCI),
           &eb_emlrtMCI), &eb_emlrtMCI);
  }

  st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 48; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 46; i++) {
      g_u[i] = j_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &g_u[0]);
    emlrtAssign(&e_y, m);
    for (i = 0; i < 18; i++) {
      h_u[i] = k_u[i];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a(&st, 18, m, &h_u[0]);
    emlrtAssign(&h_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, message(&b_st, e_y, h_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &ib_emlrtRSI;
  p = true;
  if ((!muDoubleScalarIsInf(a)) && (!muDoubleScalarIsNaN(a)) &&
      (muDoubleScalarFloor(a) == a)) {
  } else {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 49; i++) {
      f_u[i] = i_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 49, m, &f_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 47; i++) {
      l_u[i] = m_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a(&st, 47, m, &l_u[0]);
    emlrtAssign(&g_y, m);
    for (i = 0; i < 18; i++) {
      h_u[i] = k_u[i];
    }

    i_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a(&st, 18, m, &h_u[0]);
    emlrtAssign(&i_y, m);
    b_st.site = &vv_emlrtRSI;
    error(&b_st, d_y, getString(&b_st, message(&b_st, g_y, i_y, &db_emlrtMCI),
           &db_emlrtMCI), &db_emlrtMCI);
  }
}

static void AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[2])
{
  emlrtStack st;
  real_T c_tmp_data[500];
  real_T b_vals_data[300];
  int32_T tmp_size[2];
  int32_T b_vals_size[1];
  int32_T i;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  if (s_size[0] == 0) {
    vals_size[0] = 1;
    vals_size[1] = 0;
  } else {
    b_vals_size[0] = s_size[0];
    loop_ub = s_size[0];
    for (i = 0; i < loop_ub; i++) {
      b_vals_data[i] = 0.0;
    }

    i = s_size[0];
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      b_vals_data[emlrtDynamicBoundsCheckR2012b(loop_ub + 1, 1, b_vals_size[0],
        &lb_emlrtBCI, (emlrtConstCTX)sp) - 1] =
        s_data[emlrtDynamicBoundsCheckR2012b(loop_ub + 1, 1, s_size[0],
        &kb_emlrtBCI, (emlrtConstCTX)sp) - 1].ActorID;
    }

    st.site = &ng_emlrtRSI;
    shiftdim(&st, b_vals_data, b_vals_size, c_tmp_data, tmp_size);
    vals_size[0] = 1;
    vals_size[1] = tmp_size[1];
    loop_ub = tmp_size[0] * tmp_size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&vals_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
    }
  }
}

static void shiftdim(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                     real_T b_data[], int32_T b_size[2])
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 39 };

  static char_T b_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[39];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &og_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &lc_emlrtRSI;
  c_st.site = &nc_emlrtRSI;
  if (x_size[0] > muIntScalarMax_sint32(x_size[0], x_size[0])) {
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &u[0]);
    emlrtAssign(&b_y, m);
    b_st.site = &qv_emlrtRSI;
    error(&b_st, y, getString(&b_st, b_message(&b_st, b_y, &g_emlrtMCI),
           &g_emlrtMCI), &g_emlrtMCI);
  }

  b_size[0] = 1;
  b_size[1] = x_size[0];
  if (x_size[0] - 1 >= 0) {
    memcpy(&b_data[0], &x_data[0], (uint32_T)x_size[0] * sizeof(real_T));
  }
}

static void unique_vector(const emlrtStack *sp, real_T a_data[], int32_T a_size
  [2], real_T b_data[], int32_T b_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'b', 'u', 'i', 'l',
    't', 'i', 'n', 's', ':', 'A', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', 'F',
    'a', 'i', 'l', 'e', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T x;
  int32_T idx_data[300];
  int32_T idx_size[2];
  int32_T k;
  int32_T nInf;
  int32_T nMInf;
  int32_T nNaN;
  int32_T nb;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  sortIdx(a_data, a_size, idx_data, idx_size);
  b_size[0] = 1;
  nInf = a_size[1];
  for (k = 0; k < nInf; k++) {
    b_data[k] = a_data[idx_data[k] - 1];
  }

  k = 0;
  while ((k + 1 <= a_size[1]) && muDoubleScalarIsInf(b_data[k]) && (b_data[k] <
          0.0)) {
    k++;
  }

  nMInf = k;
  k = a_size[1];
  while ((k >= 1) && muDoubleScalarIsNaN(b_data[k - 1])) {
    k--;
  }

  nNaN = a_size[1] - k;
  while ((k >= 1) && muDoubleScalarIsInf(b_data[k - 1]) && (b_data[k - 1] > 0.0))
  {
    k--;
  }

  nInf = (a_size[1] - k) - nNaN;
  nb = -1;
  if (nMInf > 0) {
    nb = 0;
  }

  while (nMInf + 1 <= k) {
    x = b_data[nMInf];
    do {
      nMInf++;
    } while (!((nMInf + 1 > k) || (b_data[nMInf] != x)));

    nb++;
    b_data[nb] = x;
  }

  if (nInf > 0) {
    nb++;
    b_data[nb] = b_data[k];
  }

  nMInf = k + nInf;
  for (nInf = 0; nInf < nNaN; nInf++) {
    nb++;
    b_data[nb] = b_data[nMInf + nInf];
  }

  if (nb + 1 > a_size[1]) {
    for (nInf = 0; nInf < 30; nInf++) {
      u[nInf] = b_u[nInf];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (nInf = 0; nInf < 30; nInf++) {
      u[nInf] = b_u[nInf];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &gx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &jb_emlrtMCI), &jb_emlrtMCI),
          &jb_emlrtMCI);
  }

  if (nb + 1 < 1) {
    nInf = 0;
  } else {
    nInf = nb + 1;
  }

  b_size[1] = nInf;
}

static void sortIdx(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
                    int32_T idx_size[2])
{
  int32_T iwork_data[300];
  int32_T i;
  int32_T i2;
  int32_T j;
  int32_T k;
  int32_T kEnd;
  int32_T n;
  int32_T p;
  int32_T pEnd;
  int32_T q;
  int32_T qEnd;
  n = x_size[1] + 1;
  idx_size[0] = 1;
  idx_size[1] = x_size[1];
  i = x_size[1];
  for (i2 = 0; i2 < i; i2++) {
    idx_data[i2] = 0;
  }

  if (x_size[1] != 0) {
    idx_size[0] = 1;
    idx_size[1] = x_size[1];
    i = x_size[1];
    for (i2 = 0; i2 < i; i2++) {
      idx_data[i2] = 0;
    }

    i2 = x_size[1];
    for (k = 1; k <= i2 - 1; k += 2) {
      if ((x_data[k - 1] <= x_data[k]) || muDoubleScalarIsNaN(x_data[k])) {
        idx_data[k - 1] = k;
        idx_data[k] = k + 1;
      } else {
        idx_data[k - 1] = k + 1;
        idx_data[k] = k;
      }
    }

    if (((uint32_T)x_size[1] & 1U) != 0U) {
      idx_data[x_size[1] - 1] = x_size[1];
    }

    i = 2;
    while (i < n - 1) {
      i2 = i << 1;
      j = 1;
      for (pEnd = i + 1; pEnd < n; pEnd = qEnd + i) {
        p = j - 1;
        q = pEnd - 1;
        qEnd = j + i2;
        if (qEnd > n) {
          qEnd = n;
        }

        k = 0;
        kEnd = qEnd - j;
        while (k + 1 <= kEnd) {
          if ((x_data[idx_data[p] - 1] <= x_data[idx_data[q] - 1]) ||
              muDoubleScalarIsNaN(x_data[idx_data[q] - 1])) {
            iwork_data[k] = idx_data[p];
            p++;
            if (p + 1 == pEnd) {
              while (q + 1 < qEnd) {
                k++;
                iwork_data[k] = idx_data[q];
                q++;
              }
            }
          } else {
            iwork_data[k] = idx_data[q];
            q++;
            if (q + 1 == qEnd) {
              while (p + 1 < pEnd) {
                k++;
                iwork_data[k] = idx_data[p];
                p++;
              }
            }
          }

          k++;
        }

        for (k = 0; k < kEnd; k++) {
          idx_data[(j + k) - 1] = iwork_data[k];
        }

        j = qEnd;
      }

      i = i2;
    }
  }
}

static void findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx)
{
  int32_T idx;
  int32_T k;
  boolean_T b[3];
  boolean_T b_b[3];
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T y;
  *cond = false;
  *invalidIdx = 0.0;
  idx = 0;
  exitg1 = false;
  while ((!exitg1) && (idx <= s_size[0] - 1)) {
    *invalidIdx = (real_T)idx + 1.0;
    emlrtDynamicBoundsCheckR2012b(idx + 1, 1, s_size[0], &y_emlrtBCI,
      (emlrtConstCTX)sp);
    for (k = 0; k < 3; k++) {
      b[k] = muDoubleScalarIsInf(s_data[idx].Position[k]);
      b_b[k] = muDoubleScalarIsNaN(s_data[idx].Position[k]);
    }

    y = true;
    k = 0;
    exitg2 = false;
    while ((!exitg2) && (k < 3)) {
      if (b[k] || b_b[k]) {
        y = false;
        exitg2 = true;
      } else {
        k++;
      }
    }

    *cond = !y;
    if (*cond) {
      exitg1 = true;
    } else {
      idx++;
    }
  }
}

static void f_validateattributes(const emlrtStack *sp, real_T a[3])
{
  static const int32_T iv[2] = { 1, 48 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 19 };

  static char_T b_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[19] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'P', 'o', 's', 'i', 't', 'i', 'o', 'n' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T k;
  char_T u[48];
  char_T c_u[46];
  char_T e_u[19];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 3)) {
    if ((!muDoubleScalarIsInf(a[k])) && (!muDoubleScalarIsNaN(a[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 48; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 19; k++) {
      e_u[k] = f_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 19, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void b_findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx)
{
  int32_T idx;
  int32_T k;
  boolean_T b[3];
  boolean_T b_b[3];
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T y;
  *cond = false;
  *invalidIdx = 0.0;
  idx = 0;
  exitg1 = false;
  while ((!exitg1) && (idx <= s_size[0] - 1)) {
    *invalidIdx = (real_T)idx + 1.0;
    emlrtDynamicBoundsCheckR2012b(idx + 1, 1, s_size[0], &y_emlrtBCI,
      (emlrtConstCTX)sp);
    for (k = 0; k < 3; k++) {
      b[k] = muDoubleScalarIsInf(s_data[idx].Velocity[k]);
      b_b[k] = muDoubleScalarIsNaN(s_data[idx].Velocity[k]);
    }

    y = true;
    k = 0;
    exitg2 = false;
    while ((!exitg2) && (k < 3)) {
      if (b[k] || b_b[k]) {
        y = false;
        exitg2 = true;
      } else {
        k++;
      }
    }

    *cond = !y;
    if (*cond) {
      exitg1 = true;
    } else {
      idx++;
    }
  }
}

static void g_validateattributes(const emlrtStack *sp, real_T a[3])
{
  static const int32_T iv[2] = { 1, 48 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 19 };

  static char_T b_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[19] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'V', 'e', 'l', 'o', 'c', 'i', 't', 'y' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T k;
  char_T u[48];
  char_T c_u[46];
  char_T e_u[19];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 3)) {
    if ((!muDoubleScalarIsInf(a[k])) && (!muDoubleScalarIsNaN(a[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 48; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 19; k++) {
      e_u[k] = f_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 19, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void h_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 48 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 15 };

  static char_T b_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[15] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'R', 'o', 'l', 'l' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[48];
  char_T c_u[46];
  char_T e_u[15];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 48; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 15; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 15, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void c_findFirstInvalid(const emlrtStack *sp, syCnTpqdknhOEQKNq30nf4E
  s_data[], int32_T s_size[1], boolean_T *cond, real_T *invalidIdx)
{
  int32_T idx;
  int32_T k;
  boolean_T b[3];
  boolean_T b_b[3];
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T y;
  *cond = false;
  *invalidIdx = 0.0;
  idx = 0;
  exitg1 = false;
  while ((!exitg1) && (idx <= s_size[0] - 1)) {
    *invalidIdx = (real_T)idx + 1.0;
    emlrtDynamicBoundsCheckR2012b(idx + 1, 1, s_size[0], &y_emlrtBCI,
      (emlrtConstCTX)sp);
    for (k = 0; k < 3; k++) {
      b[k] = muDoubleScalarIsInf(s_data[idx].AngularVelocity[k]);
      b_b[k] = muDoubleScalarIsNaN(s_data[idx].AngularVelocity[k]);
    }

    y = true;
    k = 0;
    exitg2 = false;
    while ((!exitg2) && (k < 3)) {
      if (b[k] || b_b[k]) {
        y = false;
        exitg2 = true;
      } else {
        k++;
      }
    }

    *cond = !y;
    if (*cond) {
      exitg1 = true;
    } else {
      idx++;
    }
  }
}

static void i_validateattributes(const emlrtStack *sp, real_T a[3])
{
  static const int32_T iv[2] = { 1, 48 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 26 };

  static char_T b_u[48] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'A', 'b', 's',
    't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', 'G',
    'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'e', 'x', 'p', 'e', 'c', 't',
    'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[26] = { 'a', 'c', 't', 'o', 'r', 'P', 'o', 's', 'e', 's',
    '.', 'A', 'n', 'g', 'u', 'l', 'a', 'r', 'V', 'e', 'l', 'o', 'c', 'i', 't',
    'y' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T k;
  char_T u[48];
  char_T c_u[46];
  char_T e_u[26];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 3)) {
    if ((!muDoubleScalarIsInf(a[k])) && (!muDoubleScalarIsNaN(a[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 48; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 48, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 26; k++) {
      e_u[k] = f_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 26, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void visionDetectionGenerator_parseLaneBoundaryInput(const emlrtStack *sp,
  real_T varargin_1_NumLaneBoundaries, real_T varargin_1_Time, BusLaneBoundary
  varargin_1_LaneBoundaries[500], coder_array_s_CP1nqD0d6aDeTm14G *lanebounds,
  real_T *dettime)
{
  coder_array_BusLaneBoundary_2D b_varargin_1_LaneBoundaries;
  emlrtStack st;
  int32_T i;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  if (varargin_1_NumLaneBoundaries < 1.0) {
    loop_ub = 0;
  } else {
    i = (int32_T)emlrtIntegerCheckR2012b(varargin_1_NumLaneBoundaries,
      &e_emlrtDCI, (emlrtConstCTX)sp);
    loop_ub = emlrtDynamicBoundsCheckR2012b(i, 1, 500, &mb_emlrtBCI,
      (emlrtConstCTX)sp);
  }

  st.site = &pg_emlrtRSI;
  d_validateattributes(&st, varargin_1_Time);
  array_BusLaneBoundary_2D_Constr(&b_varargin_1_LaneBoundaries);
  array_BusLaneBoundary_2D_SetSiz(&b_varargin_1_LaneBoundaries, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    b_varargin_1_LaneBoundaries.vector.data[i] = varargin_1_LaneBoundaries[i];
  }

  st.site = &qg_emlrtRSI;
  visionDetectionGenerator_assembleLanes(&st, &b_varargin_1_LaneBoundaries,
    lanebounds);
  array_BusLaneBoundary_2D_Destru(&b_varargin_1_LaneBoundaries);
  *dettime = varargin_1_Time;
}

static void visionDetectionGenerator_assembleLanes(const emlrtStack *sp,
  coder_array_BusLaneBoundary_2D *lanebounds, coder_array_s_CP1nqD0d6aDeTm14G
  *lanesOut)
{
  emlrtStack b_st;
  emlrtStack st;
  s_CP1nqD0d6aDeTm14G2mGp b_lanesOut;
  int32_T b_i;
  int32_T i;
  int32_T maxCoordLen;
  int16_T outsize_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  maxCoordLen = 0;
  i = lanebounds->size[1];
  for (b_i = 0; b_i < i; b_i++) {
    emlrtDynamicBoundsCheckR2012b(b_i + 1, 1, lanebounds->size[1], &rb_emlrtBCI,
      (emlrtConstCTX)sp);
    if (maxCoordLen < 100) {
      maxCoordLen = 100;
    }
  }

  b_lanesOut.Coordinates.size[0] = maxCoordLen;
  b_lanesOut.Coordinates.size[1] = 3;
  maxCoordLen *= 3;
  for (i = 0; i < maxCoordLen; i++) {
    b_lanesOut.Coordinates.data[i] = 0.0;
  }

  b_lanesOut.BoundaryType = 0U;
  b_lanesOut.Strength = 0.0;
  b_lanesOut.Length = 0.0;
  b_lanesOut.Width = 0.0;
  st.site = &rg_emlrtRSI;
  b_st.site = &mf_emlrtRSI;
  b_assertValidSizeArg(&b_st, (real_T)lanebounds->size[1]);
  outsize_idx_0 = (int16_T)lanebounds->size[1];
  array_s_CP1nqD0d6aDeTm14G2mGp_S(lanesOut, (int32_T)outsize_idx_0);
  maxCoordLen = outsize_idx_0;
  for (i = 0; i < maxCoordLen; i++) {
    lanesOut->vector.data[i] = b_lanesOut;
  }

  if (lanebounds->size[1] != 0) {
    st.site = &sg_emlrtRSI;
    visionDetectionGenerator_copyStructField2D(&st, lanebounds, lanesOut);
    st.site = &sg_emlrtRSI;
    i = lanebounds->size[1];
    for (maxCoordLen = 0; maxCoordLen < i; maxCoordLen++) {
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &qb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &pb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &ob_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &nb_emlrtBCI, &st);
      lanesOut->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanesOut->size[0], &tb_emlrtBCI, &st) - 1].BoundaryType =
        lanebounds->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanebounds->size[1], &sb_emlrtBCI, &st) - 1].BoundaryType;
    }

    st.site = &sg_emlrtRSI;
    i = lanebounds->size[1];
    for (maxCoordLen = 0; maxCoordLen < i; maxCoordLen++) {
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &qb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &pb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &ob_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &nb_emlrtBCI, &st);
      lanesOut->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanesOut->size[0], &tb_emlrtBCI, &st) - 1].Strength =
        lanebounds->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanebounds->size[1], &sb_emlrtBCI, &st) - 1].Strength;
    }

    st.site = &sg_emlrtRSI;
    i = lanebounds->size[1];
    for (maxCoordLen = 0; maxCoordLen < i; maxCoordLen++) {
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &qb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &pb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &ob_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &nb_emlrtBCI, &st);
      lanesOut->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanesOut->size[0], &tb_emlrtBCI, &st) - 1].Length =
        lanebounds->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanebounds->size[1], &sb_emlrtBCI, &st) - 1].Length;
    }

    st.site = &sg_emlrtRSI;
    i = lanebounds->size[1];
    for (maxCoordLen = 0; maxCoordLen < i; maxCoordLen++) {
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &qb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &pb_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanesOut->size[0],
        &ob_emlrtBCI, &st);
      emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1, lanebounds->size[1],
        &nb_emlrtBCI, &st);
      lanesOut->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanesOut->size[0], &tb_emlrtBCI, &st) - 1].Width =
        lanebounds->vector.data[emlrtDynamicBoundsCheckR2012b(maxCoordLen + 1, 1,
        lanebounds->size[1], &sb_emlrtBCI, &st) - 1].Width;
    }
  }
}

static void visionDetectionGenerator_detectObjects
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], real_T b_time, objectDetection b_detectionsGen[50],
   real_T *numDets, boolean_T *validUpdateTime)
{
  static char_T cv1[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T cv[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l', 'b',
    'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p', 't',
    'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T cv2[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  coder_array_real_T_2D Utgt;
  coder_array_real_T_2D actorIDs;
  coder_array_real_T_2D actorIdx;
  coder_array_real_T_2D b_actorIDs;
  coder_array_real_T_2D d_tmp_data;
  coder_array_real_T_2D e_tmp_data;
  coder_array_real_T_2D r;
  coder_array_real_T_3D Uothers;
  coder_array_real_T_3D b_UfacesVis_data;
  coder_array_real_T_3D b_covMatsOut;
  coder_array_real_T_3D covMats;
  coder_array_real_T_3D covMatsOut;
  coder_array_real_T_4D facesSen;
  emlrtStack b_st;
  emlrtStack st;
  monoCamera r1;
  real_T c_detsOut_data[1806];
  real_T detsOut_data[1806];
  real_T dets_data[1800];
  real_T xCam_data[1800];
  real_T xSen_data[1800];
  real_T b_detsOut_data[903];
  real_T c_tmp_data[903];
  real_T b_xSen_data[900];
  real_T rgOthers_data[598];
  real_T b_y_data[500];
  real_T classIDsOut_data[301];
  real_T range_data[301];
  real_T tgtIDsOut_data[301];
  real_T classIDsDets_data[300];
  real_T classIDs_data[300];
  real_T tgtIDsDets_data[300];
  real_T tgtIDs_data[300];
  real_T tgtRngs_data[300];
  real_T attribs_f2_data[50];
  real_T b_classIDsOut_data[50];
  real_T R[4];
  real_T R1[4];
  real_T Rv[4];
  real_T horzCoeffs[3];
  real_T B[2];
  real_T U[2];
  real_T Uvanish[2];
  real_T V[2];
  real_T imagSz[2];
  real_T b_B;
  real_T elapsedInterval;
  int32_T iidx_data[500];
  int32_T covMatsCoords_size[3];
  int32_T facesVis_size[3];
  int32_T attribs_f2_size[2];
  int32_T b_classIDsOut_size[2];
  int32_T b_detsOut_size[2];
  int32_T b_facesVis_size[2];
  int32_T b_xSen_size[2];
  int32_T c_detsOut_size[2];
  int32_T c_facesVis_size[2];
  int32_T classIDsDets_size[2];
  int32_T classIDsOut_size[2];
  int32_T classIDs_size[2];
  int32_T d_facesVis_size[2];
  int32_T detsOut_size[2];
  int32_T dets_size[2];
  int32_T range_size[2];
  int32_T rgOthers_size[2];
  int32_T tgtIDsDets_size[2];
  int32_T tgtIDsOut_size[2];
  int32_T tgtIDs_size[2];
  int32_T tgtRngs_size[2];
  int32_T xCam_size[2];
  int32_T xSen_size[2];
  int32_T x_size[2];
  int32_T detsAssigned_size[1];
  int32_T emptyDimValue;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T iTgt;
  int32_T n;
  int32_T nx;
  boolean_T x_data[4200];
  boolean_T isOccluded;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  st.site = &ph_emlrtRSI;
  AbstractDetectionGenerator_initializeDetections(&st, b_detectionsGen);
  *numDets = 0.0;
  elapsedInterval = b_time - obj->pTimeLastUpdate;
  if ((!obj->pHasFirstUpdate) || ((b_time > obj->pTimeLastUpdate) &&
       (muDoubleScalarAbs(elapsedInterval - muDoubleScalarRound(elapsedInterval /
          0.05) * 0.05) <= 0.0001))) {
    *validUpdateTime = true;
  } else {
    *validUpdateTime = false;
  }

  array_real_T_2D_Constructor(&actorIDs);
  array_real_T_3D_Constructor(&covMats);
  array_real_T_3D_Constructor(&covMatsOut);
  array_real_T_4D_Constructor(&facesSen);
  array_real_T_2D_Constructor(&actorIdx);
  array_real_T_2D_Constructor(&Utgt);
  array_real_T_3D_Constructor(&Uothers);
  array_real_T_3D_Constructor(&b_covMatsOut);
  array_real_T_2D_Constructor(&r);
  array_real_T_2D_Constructor(&b_actorIDs);
  if (*validUpdateTime) {
    st.site = &oh_emlrtRSI;
    AbstractDetectionGenerator_actorsFacesInSensorCoords(&st, obj, b_actors_data,
      actors_size, &facesSen, xCam_data, xCam_size, tgtIDsDets_data,
      tgtIDsDets_size, classIDsDets_data, classIDsDets_size);
    st.site = &nh_emlrtRSI;
    AbstractDetectionGenerator_isSensorInsideActor(&st, &facesSen, &isOccluded,
      &actorIdx);
    if (isOccluded) {
      st.site = &mh_emlrtRSI;
      AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data,
        actors_size, tgtIDsDets_data, tgtIDsDets_size);
      array_real_T_2D_SetSize(&actorIDs, 1, tgtIDsDets_size[1]);
      n = tgtIDsDets_size[0] * tgtIDsDets_size[1];
      for (i = 0; i < n; i++) {
        actorIDs.vector.data[i] = tgtIDsDets_data[i];
      }

      array_real_T_2D_SetSize(&b_actorIDs, 1, actorIdx.size[1]);
      n = actorIdx.size[0] * actorIdx.size[1];
      for (i = 0; i < n; i++) {
        i1 = (int32_T)actorIdx.vector.data[i];
        b_actorIDs.vector.data[i] =
          actorIDs.vector.data[emlrtDynamicBoundsCheckR2012b(i1, 1,
          actorIDs.size[1], &qc_emlrtBCI, (emlrtConstCTX)sp) - 1];
      }

      array_real_T_2D_SetSize(&actorIDs, 1, b_actorIDs.size[1]);
      n = b_actorIDs.size[0] * b_actorIDs.size[1];
      for (i = 0; i < n; i++) {
        actorIDs.vector.data[i] = b_actorIDs.vector.data[i];
      }

      i = actorIDs.size[1];
      for (n = 0; n < i; n++) {
        st.site = &lh_emlrtRSI;
        e_warning(&st, actorIDs.vector.data[emlrtDynamicBoundsCheckR2012b(n + 1,
                   1, actorIDs.size[1], &rc_emlrtBCI, (emlrtConstCTX)sp) - 1]);
      }
    } else {
      st.site = &kh_emlrtRSI;
      visionDetectionGenerator_findVisibleTargetFaces(moduleInstance, &st,
        &facesSen, xCam_data, xCam_size, tgtIDsDets_data, tgtIDsDets_size,
        classIDsDets_data, classIDsDets_size, moduleInstance->facesVis_data,
        facesVis_size, xSen_data, xSen_size, tgtIDs_data, tgtIDs_size,
        classIDs_data, classIDs_size);
      tgtIDsDets_size[0] = 1;
      tgtIDsDets_size[1] = tgtIDs_size[1];
      n = tgtIDs_size[1];
      classIDsDets_size[0] = 1;
      classIDsDets_size[1] = tgtIDs_size[1];
      for (i = 0; i < n; i++) {
        tgtIDsDets_data[i] = rtNaN;
        classIDsDets_data[i] = 0.0;
      }

      dets_size[1] = tgtIDs_size[1];
      n = 6 * tgtIDs_size[1];
      for (i = 0; i < n; i++) {
        dets_data[i] = rtNaN;
      }

      array_real_T_3D_SetSize(&covMats, 6, 6, tgtIDs_size[1]);
      n = 36 * tgtIDs_size[1];
      for (i = 0; i < n; i++) {
        covMats.vector.data[i] = 0.0;
      }

      n = tgtIDs_size[1];
      for (i = 0; i < n; i++) {
        covMats.vector.data[36 * i + 14] = 100.0;
      }

      n = covMats.size[2];
      for (i = 0; i < n; i++) {
        covMats.vector.data[36 * i + 35] = 100.0;
      }

      st.site = &jh_emlrtRSI;
      visionDetectionGenerator_sensorToCamera(moduleInstance, &st, obj,
        xSen_data, xSen_size, xCam_data, xCam_size);
      n = 7 * facesVis_size[2];
      b_facesVis_size[0] = 3;
      b_facesVis_size[1] = n;
      for (i = 0; i < n; i++) {
        for (i1 = 0; i1 < 3; i1++) {
          moduleInstance->b_facesVis_data[i1 + 3 * i] =
            moduleInstance->facesVis_data[i1 + 3 * i];
        }
      }

      st.site = &ih_emlrtRSI;
      b_visionDetectionGenerator_sensorToCamera(moduleInstance, &st, obj,
        moduleInstance->b_facesVis_data, b_facesVis_size,
        moduleInstance->facesVis_data, c_facesVis_size);
      emlrtSubAssignSizeCheck1dR2017a(21 * facesVis_size[2], 3 *
        c_facesVis_size[1], &e_emlrtECI, (emlrtConstCTX)sp);
      n = 7 * facesVis_size[2];
      d_facesVis_size[0] = 3;
      d_facesVis_size[1] = n;
      for (i = 0; i < n; i++) {
        for (i1 = 0; i1 < 3; i1++) {
          moduleInstance->b_facesVis_data[i1 + 3 * i] =
            moduleInstance->facesVis_data[i1 + 3 * i];
        }
      }

      st.site = &hh_emlrtRSI;
      b_visionDetectionGenerator_cameraToImageCoords(moduleInstance, &st, obj,
        moduleInstance->b_facesVis_data, d_facesVis_size, moduleInstance->dv,
        c_facesVis_size);
      memcpy(&moduleInstance->UfacesVis_data[0], &moduleInstance->dv[0], 4200U *
             sizeof(real_T));
      nx = c_facesVis_size[1] << 1;
      st.site = &lc_emlrtRSI;
      emptyDimValue = b_computeDimsData(&st, nx, (real_T)tgtIDs_size[1]);
      n = 2;
      if (c_facesVis_size[1] > 2) {
        n = c_facesVis_size[1];
      }

      n = muIntScalarMax_sint32(nx, n);
      if (emptyDimValue > n) {
        st.site = &qv_emlrtRSI;
        error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
                c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
              &g_emlrtMCI);
      }

      if (tgtIDs_size[1] > n) {
        st.site = &qv_emlrtRSI;
        error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
                c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
              &g_emlrtMCI);
      }

      if ((emptyDimValue << 1) * tgtIDs_size[1] != nx) {
        st.site = &ov_emlrtRSI;
        error(&st, emlrt_marshallOut(&st, cv1), getString(&st, b_message(&st,
                emlrt_marshallOut(&st, cv1), &i_emlrtMCI), &i_emlrtMCI),
              &i_emlrtMCI);
      }

      r1 = obj->pMonoCameraInSensorFrame;
      for (i = 0; i < 2; i++) {
        imagSz[i] = r1.Intrinsics->ImageSize[i];
      }

      for (i = 0; i < 3; i++) {
        horzCoeffs[i] = obj->pHorizonLine[i];
      }

      for (i = 0; i < 2; i++) {
        Uvanish[i] = horzCoeffs[i + 1];
      }

      b_xSen_size[0] = 3;
      b_xSen_size[1] = xSen_size[1];
      n = xSen_size[1];
      for (i = 0; i < n; i++) {
        for (i1 = 0; i1 < 3; i1++) {
          b_xSen_data[i1 + 3 * i] = xSen_data[i1 + xSen_size[0] * i];
        }
      }

      c_power(b_xSen_data, b_xSen_size, c_tmp_data, b_facesVis_size);
      d_tmp_data.vector.data = &c_tmp_data[0];
      d_tmp_data.vector.numel = b_facesVis_size[0] * b_facesVis_size[1];
      d_tmp_data.vector.allocated = d_tmp_data.vector.numel;
      d_tmp_data.vector.owner = false;
      d_tmp_data.size[0] = b_facesVis_size[0];
      d_tmp_data.size[1] = b_facesVis_size[1];
      d_sum(&d_tmp_data, &r);
      array_real_T_2D_Reserve(&r, 2100);
      st.site = &gh_emlrtRSI;
      b_sqrt(&st, (real_T *)r.vector.data, r.size, moduleInstance->b_tmp_data,
             b_facesVis_size);
      array_real_T_2D_SetSize(&r, r.size[0], r.size[1]);
      tgtRngs_size[0] = 1;
      tgtRngs_size[1] = b_facesVis_size[1];
      n = b_facesVis_size[0] * b_facesVis_size[1];
      if (n - 1 >= 0) {
        memcpy(&tgtRngs_data[0], &moduleInstance->b_tmp_data[0], (uint32_T)n *
               sizeof(real_T));
      }

      nx = 0;
      i = tgtIDs_size[1];
      for (iTgt = 0; iTgt < i; iTgt++) {
        b_UfacesVis_data.vector.data = &moduleInstance->UfacesVis_data[0];
        b_UfacesVis_data.vector.numel = (emptyDimValue << 1) * tgtIDs_size[1];
        b_UfacesVis_data.vector.allocated = b_UfacesVis_data.vector.numel;
        b_UfacesVis_data.vector.owner = false;
        b_UfacesVis_data.size[0] = 2;
        b_UfacesVis_data.size[1] = emptyDimValue;
        b_UfacesVis_data.size[2] = tgtIDs_size[1];
        st.site = &fh_emlrtRSI;
        visionDetectionGenerator_indexTarget(&st, (real_T)iTgt + 1.0,
          &b_UfacesVis_data, tgtRngs_data, tgtRngs_size, &Utgt, &elapsedInterval,
          &Uothers, rgOthers_data, rgOthers_size);
        if (Utgt.size[1] != 0) {
          st.site = &eh_emlrtRSI;
          isOccluded = visionDetectionGenerator_computeOccludedView
            (moduleInstance, &st, &Utgt, elapsedInterval, &Uothers,
             rgOthers_data, rgOthers_size, imagSz);
          if (!isOccluded) {
            st.site = &dh_emlrtRSI;
            if (obj->pUseRandSeed) {
              b_st.site = &rm_emlrtRSI;
              elapsedInterval = b_rand(moduleInstance, &b_st);
            } else {
              b_st.site = &sm_emlrtRSI;
              elapsedInterval = b_rand(moduleInstance, &b_st);
            }

            if (elapsedInterval < 0.9) {
              st.site = &ch_emlrtRSI;
              visionDetectionGenerator_estimateImageLocation(&st, obj, &Utgt, U,
                B);
              st.site = &bh_emlrtRSI;
              if ((!c_visionDetectionGenerator_isAbove(obj, U, Uvanish)) && (B[1]
                   >= 15.0) && (B[0] >= 15.0)) {
                n = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, xCam_size[1],
                  &pc_emlrtBCI, (emlrtConstCTX)sp);
                for (i1 = 0; i1 < 3; i1++) {
                  horzCoeffs[i1] = xCam_data[(emlrtDynamicBoundsCheckR2012b(i1 +
                    4, 1, xCam_size[0], &sc_emlrtBCI, (emlrtConstCTX)sp) +
                    xCam_size[0] * (n - 1)) - 1];
                }

                st.site = &ah_emlrtRSI;
                visionDetectionGenerator_imag2cam(&st, obj, U, horzCoeffs, B, R1,
                  V);
                st.site = &yg_emlrtRSI;
                visionDetectionGenerator_kalmanFilterModel(&st, R1, R, Rv);
                elapsedInterval = 0.0;
                for (i1 = 0; i1 < 2; i1++) {
                  b_B = B[i1];
                  elapsedInterval += b_B * b_B;
                }

                if ((elapsedInterval <= 22500.0) && (c_norm(V) <= 100.0)) {
                  nx++;
                  n = emlrtDynamicBoundsCheckR2012b(nx, 1, dets_size[1],
                    &oc_emlrtBCI, (emlrtConstCTX)sp);
                  for (i1 = 0; i1 < 2; i1++) {
                    dets_data[i1 + 6 * (n - 1)] = B[i1];
                  }

                  dets_data[2 + 6 * (emlrtDynamicBoundsCheckR2012b(nx, 1,
                    dets_size[1], &tc_emlrtBCI, (emlrtConstCTX)sp) - 1)] = 0.0;
                  n = emlrtDynamicBoundsCheckR2012b(nx, 1, dets_size[1],
                    &nc_emlrtBCI, (emlrtConstCTX)sp);
                  for (i1 = 0; i1 < 2; i1++) {
                    dets_data[(i1 + 6 * (n - 1)) + 3] = V[i1];
                  }

                  dets_data[5 + 6 * (emlrtDynamicBoundsCheckR2012b(nx, 1,
                    dets_size[1], &uc_emlrtBCI, (emlrtConstCTX)sp) - 1)] = 0.0;
                  n = emlrtDynamicBoundsCheckR2012b(nx, 1, covMats.size[2],
                    &kc_emlrtBCI, (emlrtConstCTX)sp);
                  for (i1 = 0; i1 < 2; i1++) {
                    for (i2 = 0; i2 < 2; i2++) {
                      covMats.vector.data[(i2 + 6 * i1) + 36 * (n - 1)] = R[i2 +
                        (i1 << 1)];
                    }
                  }

                  n = emlrtDynamicBoundsCheckR2012b(nx, 1, covMats.size[2],
                    &jc_emlrtBCI, (emlrtConstCTX)sp);
                  for (i1 = 0; i1 < 2; i1++) {
                    for (i2 = 0; i2 < 2; i2++) {
                      covMats.vector.data[((i2 + 6 * (i1 + 3)) + 36 * (n - 1)) +
                        3] = Rv[i2 + (i1 << 1)];
                    }
                  }

                  tgtIDsDets_data[emlrtDynamicBoundsCheckR2012b(nx, 1,
                    tgtIDsDets_size[1], &wc_emlrtBCI, (emlrtConstCTX)sp) - 1] =
                    tgtIDs_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
                    tgtIDs_size[1], &vc_emlrtBCI, (emlrtConstCTX)sp) - 1];
                  classIDsDets_data[emlrtDynamicBoundsCheckR2012b(nx, 1,
                    classIDsDets_size[1], &yc_emlrtBCI, (emlrtConstCTX)sp) - 1] =
                    classIDs_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
                    classIDs_size[1], &xc_emlrtBCI, (emlrtConstCTX)sp) - 1];
                }
              }
            }
          }
        }
      }

      if (nx < 1) {
        n = 0;
      } else {
        emlrtDynamicBoundsCheckR2012b(1, 1, tgtIDs_size[1], &mc_emlrtBCI,
          (emlrtConstCTX)sp);
        n = emlrtDynamicBoundsCheckR2012b(nx, 1, tgtIDs_size[1], &lc_emlrtBCI,
          (emlrtConstCTX)sp);
      }

      dets_size[0] = 6;
      dets_size[1] = n;
      if (nx < 1) {
        n = 0;
      } else {
        emlrtDynamicBoundsCheckR2012b(1, 1, covMats.size[2], &ic_emlrtBCI,
          (emlrtConstCTX)sp);
        n = emlrtDynamicBoundsCheckR2012b(nx, 1, covMats.size[2], &hc_emlrtBCI,
          (emlrtConstCTX)sp);
      }

      array_real_T_3D_SetSize(&covMats, 6, 6, n);
      if (nx < 1) {
        i = 0;
      } else {
        emlrtDynamicBoundsCheckR2012b(1, 1, tgtIDs_size[1], &gc_emlrtBCI,
          (emlrtConstCTX)sp);
        i = emlrtDynamicBoundsCheckR2012b(nx, 1, tgtIDs_size[1], &fc_emlrtBCI,
          (emlrtConstCTX)sp);
      }

      tgtIDsDets_size[1] = i;
      if (nx < 1) {
        i = 0;
      } else {
        emlrtDynamicBoundsCheckR2012b(1, 1, tgtIDs_size[1], &ec_emlrtBCI,
          (emlrtConstCTX)sp);
        i = emlrtDynamicBoundsCheckR2012b(nx, 1, tgtIDs_size[1], &dc_emlrtBCI,
          (emlrtConstCTX)sp);
      }

      classIDsDets_size[1] = i;
      st.site = &xg_emlrtRSI;
      visionDetectionGenerator_addFalsePositives(moduleInstance, &st, obj,
        dets_data, dets_size, &covMats, tgtIDsDets_data, tgtIDsDets_size,
        classIDsDets_data, classIDsDets_size, detsOut_data, detsOut_size,
        &b_covMatsOut, tgtIDsOut_data, tgtIDsOut_size, classIDsOut_data,
        classIDsOut_size);
      x_size[0] = 1;
      x_size[1] = tgtIDsOut_size[1];
      n = tgtIDsOut_size[1];
      for (i = 0; i < n; i++) {
        x_data[i] = (tgtIDsOut_data[i] < 0.0);
      }

      if ((tgtIDsOut_size[1] == 1) || (tgtIDsOut_size[1] != 1)) {
      } else {
        st.site = &rv_emlrtRSI;
        error(&st, d_emlrt_marshallOut(&st, cv2), getString(&st, b_message(&st,
                d_emlrt_marshallOut(&st, cv2), &kb_emlrtMCI), &kb_emlrtMCI),
              &kb_emlrtMCI);
      }

      *numDets = minimum2((real_T)nx + (real_T)b_combineVectorElements(x_data,
        x_size), 50.0);
      if (*numDets > 0.0) {
        b_detsOut_size[0] = 3;
        b_detsOut_size[1] = detsOut_size[1];
        n = detsOut_size[1];
        for (i = 0; i < n; i++) {
          for (i1 = 0; i1 < 3; i1++) {
            b_detsOut_data[i1 + 3 * i] = detsOut_data[i1 + 6 * i];
          }
        }

        c_power(b_detsOut_data, b_detsOut_size, c_tmp_data, b_facesVis_size);
        e_tmp_data.vector.data = &c_tmp_data[0];
        e_tmp_data.vector.numel = b_facesVis_size[0] * b_facesVis_size[1];
        e_tmp_data.vector.allocated = e_tmp_data.vector.numel;
        e_tmp_data.vector.owner = false;
        e_tmp_data.size[0] = b_facesVis_size[0];
        e_tmp_data.size[1] = b_facesVis_size[1];
        d_sum(&e_tmp_data, &r);
        array_real_T_2D_Reserve(&r, 2100);
        st.site = &wg_emlrtRSI;
        b_sqrt(&st, (real_T *)r.vector.data, r.size, moduleInstance->b_tmp_data,
               b_facesVis_size);
        array_real_T_2D_SetSize(&r, r.size[0], r.size[1]);
        range_size[0] = 1;
        range_size[1] = b_facesVis_size[1];
        n = b_facesVis_size[0] * b_facesVis_size[1];
        if (n - 1 >= 0) {
          memcpy(&range_data[0], &moduleInstance->b_tmp_data[0], (uint32_T)n *
                 sizeof(real_T));
        }

        sort(range_data, range_size, b_y_data, b_facesVis_size, iidx_data,
             c_facesVis_size);
        n = c_facesVis_size[1];
        for (i = 0; i < n; i++) {
          b_y_data[i] = (real_T)iidx_data[i];
        }

        n = c_facesVis_size[1];
        for (i = 0; i < n; i++) {
          for (i1 = 0; i1 < 6; i1++) {
            c_detsOut_data[i1 + 6 * i] = detsOut_data[i1 + 6 *
              (emlrtDynamicBoundsCheckR2012b((int32_T)b_y_data[i], 1,
                detsOut_size[1], &ad_emlrtBCI, (emlrtConstCTX)sp) - 1)];
          }
        }

        array_real_T_3D_SetSize(&covMatsOut, 6, 6, c_facesVis_size[1]);
        n = c_facesVis_size[1];
        for (i = 0; i < n; i++) {
          for (i1 = 0; i1 < 6; i1++) {
            for (i2 = 0; i2 < 6; i2++) {
              covMatsOut.vector.data[(i2 + 6 * i1) + 36 * i] =
                b_covMatsOut.vector.data[(i2 + 6 * i1) + 36 *
                (emlrtDynamicBoundsCheckR2012b((int32_T)b_y_data[i], 1,
                  b_covMatsOut.size[2], &bd_emlrtBCI, (emlrtConstCTX)sp) - 1)];
            }
          }
        }

        n = c_facesVis_size[1];
        for (i = 0; i < n; i++) {
          emlrtDynamicBoundsCheckR2012b((int32_T)b_y_data[i], 1, tgtIDsOut_size
            [1], &cd_emlrtBCI, (emlrtConstCTX)sp);
        }

        n = c_facesVis_size[1];
        for (i = 0; i < n; i++) {
          emlrtDynamicBoundsCheckR2012b((int32_T)b_y_data[i], 1,
            classIDsOut_size[1], &dd_emlrtBCI, (emlrtConstCTX)sp);
        }

        emlrtDynamicBoundsCheckR2012b(1, 1, c_facesVis_size[1], &cc_emlrtBCI,
          (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b((int32_T)*numDets, 1, c_facesVis_size[1],
          &bc_emlrtBCI, (emlrtConstCTX)sp);
        c_detsOut_size[0] = 6;
        c_detsOut_size[1] = (int32_T)*numDets;
        emlrtDynamicBoundsCheckR2012b(1, 1, c_facesVis_size[1], &ac_emlrtBCI,
          (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b((int32_T)*numDets, 1, c_facesVis_size[1],
          &yb_emlrtBCI, (emlrtConstCTX)sp);
        array_real_T_3D_SetSize(&covMatsOut, 6, 6, (int32_T)*numDets);
        emlrtDynamicBoundsCheckR2012b(1, 1, c_facesVis_size[1], &xb_emlrtBCI,
          (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b((int32_T)*numDets, 1, c_facesVis_size[1],
          &wb_emlrtBCI, (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b(1, 1, c_facesVis_size[1], &vb_emlrtBCI,
          (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b((int32_T)*numDets, 1, c_facesVis_size[1],
          &ub_emlrtBCI, (emlrtConstCTX)sp);
        array_real_T_3D_Reserve(&covMatsOut, 1800);
        st.site = &vg_emlrtRSI;
        visionDetectionGenerator_cameraToSensor(&st, obj, c_detsOut_data,
          c_detsOut_size, (real_T *)covMatsOut.vector.data, covMatsOut.size,
          tgtIDsDets_data, c_facesVis_size, xCam_data, facesVis_size);
        array_real_T_3D_SetSize(&covMatsOut, covMatsOut.size[0],
          covMatsOut.size[1], covMatsOut.size[2]);
        st.site = &ug_emlrtRSI;
        AbstractDetectionGenerator_sensorToEgo(&st, tgtIDsDets_data,
          c_facesVis_size, xCam_data, facesVis_size, classIDsDets_data,
          b_facesVis_size, xSen_data, covMatsCoords_size);
        attribs_f2_size[0] = 1;
        attribs_f2_size[1] = (int32_T)*numDets;
        n = (int32_T)*numDets;
        for (i = 0; i < n; i++) {
          attribs_f2_data[i] = tgtIDsOut_data[(int32_T)b_y_data[i] - 1];
        }

        b_classIDsOut_size[0] = 1;
        b_classIDsOut_size[1] = (int32_T)*numDets;
        n = (int32_T)*numDets;
        for (i = 0; i < n; i++) {
          b_classIDsOut_data[i] = classIDsOut_data[(int32_T)b_y_data[i] - 1];
        }

        st.site = &tg_emlrtRSI;
        visionDetectionGenerator_assembleDetections(&st, b_time,
          classIDsDets_data, b_facesVis_size, xSen_data, covMatsCoords_size,
          attribs_f2_data, attribs_f2_size, b_classIDsOut_data,
          b_classIDsOut_size, moduleInstance->detsAssigned_data,
          detsAssigned_size);
        memcpy(&b_detectionsGen[0], &moduleInstance->detsAssigned_data[0],
               (uint32_T)(int32_T)*numDets * sizeof(objectDetection));
      }

      obj->pHasFirstUpdate = true;
      obj->pTimeLastUpdate = b_time;
    }
  }

  array_real_T_2D_Destructor(&b_actorIDs);
  array_real_T_2D_Destructor(&r);
  array_real_T_3D_Destructor(&b_covMatsOut);
  array_real_T_3D_Destructor(&Uothers);
  array_real_T_2D_Destructor(&Utgt);
  array_real_T_2D_Destructor(&actorIdx);
  array_real_T_4D_Destructor(&facesSen);
  array_real_T_3D_Destructor(&covMatsOut);
  array_real_T_3D_Destructor(&covMats);
  array_real_T_2D_Destructor(&actorIDs);
}

static void AbstractDetectionGenerator_initializeDetections(const emlrtStack *sp,
  objectDetection detections[50])
{
  static BusVisionDetectionsObjectAttributes r = { 0.0/* TargetIndex */
  };

  static real_T b_varargin_4[36] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static real_T varargin_4[36] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static int8_T b_orient[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  BusVisionDetectionsMeasurementParameters measParams0;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack f_st;
  emlrtStack g_st;
  emlrtStack st;
  objectDetection d[1];
  objectDetection oneObjDet;
  real_T b_dv[6];
  int32_T i;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &qh_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  e_st.prev = &d_st;
  e_st.tls = d_st.tls;
  f_st.prev = &e_st;
  f_st.tls = e_st.tls;
  g_st.prev = &f_st;
  g_st.tls = f_st.tls;
  b_st.site = &rh_emlrtRSI;
  c_st.site = &sh_emlrtRSI;
  measParams0.Frame = drivingCoordinateFrameType_Rectangular;
  for (i = 0; i < 3; i++) {
    measParams0.OriginPosition[i] = 0.0;
  }

  for (i = 0; i < 9; i++) {
    measParams0.Orientation[i] = (real_T)b_orient[i];
  }

  measParams0.HasVelocity = true;
  d_st.site = &uh_emlrtRSI;
  e_st.site = &vh_emlrtRSI;
  for (i = 0; i < 6; i++) {
    oneObjDet.Measurement[i] = 0.0;
  }

  oneObjDet.Time = 0.0;
  f_st.site = &wh_emlrtRSI;
  g_st.site = &yh_emlrtRSI;
  j_validateattributes(&g_st, varargin_4);
  g_st.site = &ai_emlrtRSI;
  isSymmetricPositiveSemiDefinite(&g_st, varargin_4);
  memcpy(&oneObjDet.pMeasurementNoise[0], &b_varargin_4[0], 36U * sizeof(real_T));
  f_st.site = &xh_emlrtRSI;
  g_st.site = &oj_emlrtRSI;
  k_validateattributes();
  oneObjDet.SensorIndex = 4.0;
  oneObjDet.ObjectClassID = 0.0;
  oneObjDet.MeasurementParameters[0] = measParams0;
  oneObjDet.ObjectAttributes[0] = r;
  for (i = 0; i < 6; i++) {
    b_dv[i] = 0.0;
  }

  d_st.site = &th_emlrtRSI;
  objectDetection_set_Measurement(&d_st, &oneObjDet, b_dv);
  for (i = 0; i < 36; i++) {
    oneObjDet.pMeasurementNoise[i] = 0.0;
  }

  oneObjDet.ObjectAttributes[0] = r;
  d[0] = oneObjDet;
  d[0].ObjectClassID = 0.0;
  for (i = 0; i < 50; i++) {
    detections[i] = d[0];
  }
}

static void j_validateattributes(const emlrtStack *sp, real_T a[36])
{
  static const int32_T iv[2] = { 1, 37 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 16 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'o', 'b', 'j',
    'e', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', ':', 'e', 'x',
    'p', 'e', 'c', 't', 'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[16] = { 'M', 'e', 'a', 's', 'u', 'r', 'e', 'm', 'e', 'n',
    't', 'N', 'o', 'i', 's', 'e' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T k;
  char_T c_u[46];
  char_T u[37];
  char_T e_u[16];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 36)) {
    if ((!muDoubleScalarIsInf(a[k])) && (!muDoubleScalarIsNaN(a[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (k = 0; k < 37; k++) {
      u[k] = b_u[k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 37, m, &u[0]);
    emlrtAssign(&y, m);
    for (k = 0; k < 46; k++) {
      c_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 16; k++) {
      e_u[k] = f_u[k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 16, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void isSymmetricPositiveSemiDefinite(const emlrtStack *sp, real_T
  b_value[36])
{
  static const int32_T iv[2] = { 1, 52 };

  static const int32_T iv1[2] = { 1, 52 };

  static const int32_T iv2[2] = { 1, 16 };

  static char_T b_u[52] = { 's', 'h', 'a', 'r', 'e', 'd', '_', 't', 'r', 'a',
    'c', 'k', 'i', 'n', 'g', ':', 'K', 'a', 'l', 'm', 'a', 'n', 'F', 'i', 'l',
    't', 'e', 'r', ':', 'i', 'n', 'v', 'a', 'l', 'i', 'd', 'C', 'o', 'v', 'a',
    'r', 'i', 'a', 'n', 'c', 'e', 'V', 'a', 'l', 'u', 'e', 's' };

  static char_T d_u[16] = { 'M', 'e', 'a', 's', 'u', 'r', 'e', 'm', 'e', 'n',
    't', 'N', 'o', 'i', 's', 'e' };

  ptrdiff_t ihi_t;
  ptrdiff_t ilo_t;
  ptrdiff_t info_t;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  creal_T d[6];
  real_T A[36];
  real_T y[36];
  real_T scale[6];
  real_T wimag[6];
  real_T wreal[6];
  real_T abnrm;
  real_T absx;
  real_T rconde;
  real_T rcondv;
  real_T tol;
  real_T vright;
  int32_T exitg2;
  int32_T i;
  int32_T i1;
  int32_T idx;
  int32_T iy;
  char_T u[52];
  char_T c_u[16];
  boolean_T x[36];
  boolean_T b_y[6];
  boolean_T c_y;
  boolean_T exitg1;
  boolean_T notPositiveSemidefinite;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  for (i1 = 0; i1 < 6; i1++) {
    wreal[i1] = muDoubleScalarAbs(b_value[i1 + 6 * i1]);
  }

  if (!muDoubleScalarIsNaN(wreal[0])) {
    idx = 1;
  } else {
    idx = 0;
    i1 = 2;
    exitg1 = false;
    while ((!exitg1) && (i1 < 7)) {
      if (!muDoubleScalarIsNaN(wreal[i1 - 1])) {
        idx = i1;
        exitg1 = true;
      } else {
        i1++;
      }
    }
  }

  if (idx == 0) {
    absx = wreal[0];
  } else {
    absx = wreal[idx - 1];
    for (i1 = idx + 1; i1 < 7; i1++) {
      if (absx < wreal[i1 - 1]) {
        absx = wreal[i1 - 1];
      }
    }
  }

  absx = muDoubleScalarAbs(absx);
  if (muDoubleScalarIsInf(absx) || muDoubleScalarIsNaN(absx)) {
    absx = rtNaN;
  } else if (absx < 4.4501477170144028E-308) {
    absx = 4.94065645841247E-324;
  } else {
    frexp(absx, &iy);
    absx = ldexp(1.0, iy - 53);
  }

  tol = 100.0 * absx;
  for (idx = 0; idx < 6; idx++) {
    for (iy = 0; iy < 6; iy++) {
      A[iy + 6 * idx] = b_value[iy + 6 * idx] - b_value[idx + 6 * iy];
    }
  }

  for (i1 = 0; i1 < 36; i1++) {
    y[i1] = muDoubleScalarAbs(A[i1]);
  }

  absx = tol;
  st.site = &bi_emlrtRSI;
  d_sqrt(&st, &absx);
  for (idx = 0; idx < 36; idx++) {
    x[idx] = (y[idx] < absx);
  }

  for (idx = 0; idx < 6; idx++) {
    b_y[idx] = true;
  }

  idx = 0;
  iy = -1;
  for (i = 0; i < 6; i++) {
    i1 = idx + 1;
    idx += 6;
    iy++;
    exitg1 = false;
    while ((!exitg1) && (i1 <= idx)) {
      if (!x[i1 - 1]) {
        b_y[iy] = false;
        exitg1 = true;
      } else {
        i1++;
      }
    }
  }

  c_y = true;
  i1 = 0;
  exitg1 = false;
  while ((!exitg1) && (i1 < 6)) {
    if (!b_y[i1]) {
      c_y = false;
      exitg1 = true;
    } else {
      i1++;
    }
  }

  st.site = &ci_emlrtRSI;
  for (idx = 0; idx < 6; idx++) {
    for (iy = 0; iy < 6; iy++) {
      A[iy + 6 * idx] = (b_value[iy + 6 * idx] + b_value[idx + 6 * iy]) / 2.0;
    }
  }

  notPositiveSemidefinite = true;
  for (i1 = 0; i1 < 36; i1++) {
    absx = A[i1];
    if (notPositiveSemidefinite && ((!muDoubleScalarIsInf(absx)) &&
         (!muDoubleScalarIsNaN(absx)))) {
      notPositiveSemidefinite = true;
    } else {
      notPositiveSemidefinite = false;
    }
  }

  if (!notPositiveSemidefinite) {
    for (i = 0; i < 6; i++) {
      d[i].re = rtNaN;
      d[i].im = 0.0;
    }
  } else {
    notPositiveSemidefinite = true;
    idx = 0;
    exitg1 = false;
    while ((!exitg1) && (idx < 6)) {
      i = 0;
      do {
        exitg2 = 0;
        if (i <= idx) {
          if (!(A[i + 6 * idx] == A[idx + 6 * i])) {
            notPositiveSemidefinite = false;
            exitg2 = 1;
          } else {
            i++;
          }
        } else {
          idx++;
          exitg2 = 2;
        }
      } while (exitg2 == 0);

      if (exitg2 == 1) {
        exitg1 = true;
      }
    }

    if (notPositiveSemidefinite) {
      b_st.site = &di_emlrtRSI;
      c_st.site = &gi_emlrtRSI;
      d_st.site = &ii_emlrtRSI;
      ilo_t = (ptrdiff_t)6;
      info_t = LAPACKE_dsyev(102, 'N', 'L', ilo_t, &A[0], ilo_t, &scale[0]);
      if ((int32_T)info_t < 0) {
        for (i = 0; i < 6; i++) {
          scale[i] = rtNaN;
        }
      }

      for (i = 0; i < 6; i++) {
        d[i].re = scale[i];
        d[i].im = 0.0;
      }

      if ((int32_T)info_t != 0) {
        c_st.site = &hi_emlrtRSI;
        c_warning(&c_st);
      }
    } else {
      notPositiveSemidefinite = true;
      idx = 0;
      exitg1 = false;
      while ((!exitg1) && (idx < 6)) {
        i = 0;
        do {
          exitg2 = 0;
          if (i <= idx) {
            if (!(A[i + 6 * idx] == -A[idx + 6 * i])) {
              notPositiveSemidefinite = false;
              exitg2 = 1;
            } else {
              i++;
            }
          } else {
            idx++;
            exitg2 = 2;
          }
        } while (exitg2 == 0);

        if (exitg2 == 1) {
          exitg1 = true;
        }
      }

      if (notPositiveSemidefinite) {
        b_st.site = &ei_emlrtRSI;
        eigSkewHermitianStandard(&b_st, A, d);
      } else {
        b_st.site = &fi_emlrtRSI;
        c_st.site = &lj_emlrtRSI;
        info_t = LAPACKE_dgeevx(102, 'B', 'N', 'N', 'N', (ptrdiff_t)6, &A[0],
          (ptrdiff_t)6, &wreal[0], &wimag[0], &absx, (ptrdiff_t)1, &vright,
          (ptrdiff_t)1, &ilo_t, &ihi_t, &scale[0], &abnrm, &rconde, &rcondv);
        if ((int32_T)info_t < 0) {
          for (i = 0; i < 6; i++) {
            d[i].re = rtNaN;
            d[i].im = 0.0;
          }
        } else {
          for (i = 0; i < 6; i++) {
            d[i].re = wreal[i];
            d[i].im = wimag[i];
          }
        }

        if ((int32_T)info_t != 0) {
          c_st.site = &mj_emlrtRSI;
          c_warning(&c_st);
        }
      }
    }
  }

  for (idx = 0; idx < 6; idx++) {
    b_y[idx] = (d[idx].re < -tol);
  }

  notPositiveSemidefinite = false;
  i1 = 0;
  exitg1 = false;
  while ((!exitg1) && (i1 < 6)) {
    if (b_y[i1]) {
      notPositiveSemidefinite = true;
      exitg1 = true;
    } else {
      i1++;
    }
  }

  if (notPositiveSemidefinite || (!c_y)) {
    for (idx = 0; idx < 52; idx++) {
      u[idx] = b_u[idx];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 52, m, &u[0]);
    emlrtAssign(&d_y, m);
    for (idx = 0; idx < 52; idx++) {
      u[idx] = b_u[idx];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 52, m, &u[0]);
    emlrtAssign(&e_y, m);
    for (idx = 0; idx < 16; idx++) {
      c_u[idx] = d_u[idx];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 16, m, &c_u[0]);
    emlrtAssign(&f_y, m);
    st.site = &xv_emlrtRSI;
    error(&st, d_y, getString(&st, message(&st, e_y, f_y, &mb_emlrtMCI),
           &mb_emlrtMCI), &mb_emlrtMCI);
  }
}

static real_T xnrm2(int32_T n, real_T x[36], int32_T ix0)
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  int32_T kend;
  y = 0.0;
  if (n < 1) {
  } else if (n == 1) {
    y = muDoubleScalarAbs(x[ix0 - 1]);
  } else {
    scale = 3.3121686421112381E-170;
    kend = ix0 + n;
    for (k = ix0; k < kend; k++) {
      absxk = muDoubleScalarAbs(x[k - 1]);
      if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
      } else {
        t = absxk / scale;
        y += t * t;
      }
    }

    y = scale * muDoubleScalarSqrt(y);
  }

  return y;
}

static void c_warning(const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 24 };

  static char_T b_msgID[24] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'e', 'i', 'g',
    ':', 'N', 'o', 'C', 'o', 'n', 'v', 'e', 'r', 'g', 'e', 'n', 'c', 'e' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[24];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 24; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 24, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, feval(&st, b_y, c_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void eigSkewHermitianStandard(const emlrtStack *sp, real_T A[36], creal_T
  V[6])
{
  __m128d r;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  real_T T[36];
  real_T work[6];
  real_T tau[5];
  real_T alpha1;
  real_T d;
  real_T xnorm;
  int32_T b_i;
  int32_T i;
  int32_T ia0;
  int32_T im1n;
  int32_T in;
  int32_T k;
  int32_T knt;
  int32_T scalarLB;
  int32_T vectorUB;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &wi_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &xi_emlrtRSI;
  p = true;
  for (k = 0; k < 36; k++) {
    xnorm = A[k];
    if (p && ((!muDoubleScalarIsInf(xnorm)) && (!muDoubleScalarIsNaN(xnorm)))) {
      p = true;
    } else {
      p = false;
    }
  }

  if (!p) {
    for (i = 0; i < 36; i++) {
      T[i] = rtNaN;
    }

    im1n = 2;
    for (in = 0; in < 5; in++) {
      for (b_i = im1n; b_i < 7; b_i++) {
        T[(b_i + 6 * in) - 1] = 0.0;
      }

      im1n++;
    }
  } else {
    memcpy(&T[0], &A[0], 36U * sizeof(real_T));
    for (b_i = 0; b_i < 6; b_i++) {
      work[b_i] = 0.0;
    }

    for (b_i = 0; b_i < 5; b_i++) {
      im1n = b_i * 6 + 2;
      in = (b_i + 1) * 6 + 1;
      i = b_i + 3;
      ia0 = muIntScalarMin_sint32(i, 6) + b_i * 6;
      alpha1 = T[(b_i + 6 * b_i) + 1];
      d = 0.0;
      xnorm = xnrm2(4 - b_i, T, ia0);
      if (xnorm != 0.0) {
        xnorm = muDoubleScalarHypot(T[(b_i + 6 * b_i) + 1], xnorm);
        if (T[(b_i + 6 * b_i) + 1] >= 0.0) {
          xnorm = -xnorm;
        }

        if (muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) {
          knt = -1;
          do {
            knt++;
            i = ia0 - b_i;
            scalarLB = ((i - ia0) + 4) / 2 * 2 + ia0;
            vectorUB = scalarLB - 2;
            for (k = ia0; k <= vectorUB; k += 2) {
              r = _mm_loadu_pd(&T[k - 1]);
              _mm_storeu_pd(&T[k - 1], _mm_mul_pd(_mm_set1_pd
                (9.9792015476736E+291), r));
            }

            for (k = scalarLB; k <= i + 3; k++) {
              T[k - 1] *= 9.9792015476736E+291;
            }

            xnorm *= 9.9792015476736E+291;
            alpha1 *= 9.9792015476736E+291;
          } while ((muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) && (knt
                    + 1 < 20));

          xnorm = muDoubleScalarHypot(alpha1, xnrm2(4 - b_i, T, ia0));
          if (alpha1 >= 0.0) {
            xnorm = -xnorm;
          }

          d = (xnorm - alpha1) / xnorm;
          alpha1 = 1.0 / (alpha1 - xnorm);
          i = ia0 - b_i;
          scalarLB = ((i - ia0) + 4) / 2 * 2 + ia0;
          vectorUB = scalarLB - 2;
          for (k = ia0; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&T[k - 1]);
            _mm_storeu_pd(&T[k - 1], _mm_mul_pd(_mm_set1_pd(alpha1), r));
          }

          for (k = scalarLB; k <= i + 3; k++) {
            T[k - 1] *= alpha1;
          }

          for (k = 0; k <= knt; k++) {
            xnorm *= 1.0020841800044864E-292;
          }

          alpha1 = xnorm;
        } else {
          d = (xnorm - T[(b_i + 6 * b_i) + 1]) / xnorm;
          alpha1 = 1.0 / (T[(b_i + 6 * b_i) + 1] - xnorm);
          i = ia0 - b_i;
          scalarLB = ((i - ia0) + 4) / 2 * 2 + ia0;
          vectorUB = scalarLB - 2;
          for (k = ia0; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&T[k - 1]);
            _mm_storeu_pd(&T[k - 1], _mm_mul_pd(_mm_set1_pd(alpha1), r));
          }

          for (k = scalarLB; k <= i + 3; k++) {
            T[k - 1] *= alpha1;
          }

          alpha1 = xnorm;
        }
      }

      tau[b_i] = d;
      T[(b_i + 6 * b_i) + 1] = 1.0;
      xzlarf(5 - b_i, b_i + im1n, tau[b_i], T, in, work);
      b_xzlarf(5 - b_i, 5 - b_i, b_i + im1n, tau[b_i], T, (b_i + in) + 1, work);
      T[(b_i + 6 * b_i) + 1] = alpha1;
    }

    c_st.site = &yi_emlrtRSI;
    im1n = xhseqr(&c_st, T);
    if (im1n != 0) {
      c_st.site = &aj_emlrtRSI;
      d_warning(&c_st);
    }
  }

  b_i = 1;
  while (b_i <= 6) {
    if ((b_i != 6) && (T[b_i + 6 * (b_i - 1)] != 0.0)) {
      xnorm = muDoubleScalarAbs(T[b_i + 6 * (b_i - 1)]);
      V[b_i - 1].re = 0.0;
      V[b_i - 1].im = xnorm;
      V[b_i].re = 0.0;
      V[b_i].im = -xnorm;
      b_i += 2;
    } else {
      V[b_i - 1].re = 0.0;
      V[b_i - 1].im = 0.0;
      b_i++;
    }
  }
}

static real_T b_xnrm2(int32_T n, real_T x[3])
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  y = 0.0;
  if (n < 1) {
  } else if (n == 1) {
    y = muDoubleScalarAbs(x[1]);
  } else {
    scale = 3.3121686421112381E-170;
    for (k = 0; k < 2; k++) {
      absxk = muDoubleScalarAbs(x[k + 1]);
      if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
      } else {
        t = absxk / scale;
        y += t * t;
      }
    }

    y = scale * muDoubleScalarSqrt(y);
  }

  return y;
}

static void d_warning(const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 26 };

  static char_T b_msgID[26] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 's', 'c', 'h', 'u', 'r', '_', 'f', 'a', 'i', 'l', 'e',
    'd' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[26];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 26; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 26, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, feval(&st, b_y, c_y, &v_emlrtMCI), &w_emlrtMCI);
}

static real_T maximum2(real_T x, real_T y)
{
  return muDoubleScalarMax(x, y);
}

static void k_validateattributes(void)
{
  emlrtStack st;
  st.site = &ib_emlrtRSI;
  st.site = &ib_emlrtRSI;
}

static void AbstractDetectionGenerator_actorsFacesInSensorCoords(const
  emlrtStack *sp, visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E
  b_actors_data[], int32_T actors_size[1], coder_array_real_T_4D *facesSen,
  real_T xSen_data[], int32_T xSen_size[2], real_T tgtIDs_data[], int32_T
  tgtIDs_size[2], real_T classIDs_data[], int32_T classIDs_size[2])
{
  static const int32_T iv1[2] = { 1, 37 };

  static const int32_T iv2[2] = { 1, 37 };

  static char_T cv1[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T cv[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l', 'b',
    'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p', 't',
    'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T b_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'h', 'e',
    'c', 'k', 'D', 'i', 'm', 'C', 'o', 'm', 'm', 'o', 'n', ':', 'n', 'o', 'n',
    'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', 'S', 'i', 'z', 'e' };

  coder_array_real_T_2D b_facesEgo;
  coder_array_real_T_2D b_facesSen;
  coder_array_real_T_4D facesEgo;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  sH79YtbsHrUKNl3jXbBnQ5F profiles[4];
  real_T c_x_data[1800];
  real_T b_x_data[900];
  real_T x_data[900];
  real_T ind;
  int32_T x_size[3];
  int32_T b_x_size[2];
  int32_T i;
  int32_T n;
  int32_T nx;
  int32_T unnamed_idx_1;
  int16_T iv[2];
  char_T u[37];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &qj_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data, actors_size,
    tgtIDs_data, tgtIDs_size);
  for (i = 0; i < 4; i++) {
    profiles[i] = obj->pActorProfiles[i];
  }

  for (i = 0; i < 2; i++) {
    iv[i] = (int16_T)tgtIDs_size[i];
  }

  classIDs_size[0] = 1;
  classIDs_size[1] = iv[1];
  n = iv[1];
  for (i = 0; i < n; i++) {
    classIDs_data[i] = 0.0;
  }

  i = actors_size[0];
  for (n = 0; n < i; n++) {
    st.site = &rj_emlrtRSI;
    ind = AbstractDetectionGenerator_lookupProfileIndex(&st, obj,
      tgtIDs_data[emlrtDynamicBoundsCheckR2012b(n + 1, 1, tgtIDs_size[1],
      &ed_emlrtBCI, (emlrtConstCTX)sp) - 1]);
    classIDs_data[emlrtDynamicBoundsCheckR2012b(n + 1, 1, classIDs_size[1],
      &fd_emlrtBCI, (emlrtConstCTX)sp) - 1] = profiles[(int32_T)ind - 1].ClassID;
  }

  if (actors_size[0] > 0) {
    st.site = &sj_emlrtRSI;
    b_AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data,
      actors_size, x_data, x_size);
    nx = x_size[1] * x_size[2];
    st.site = &lc_emlrtRSI;
    b_st.site = &nc_emlrtRSI;
    assertValidSizeArg(&b_st, (real_T)actors_size[0]);
    n = 1;
    if (x_size[1] > 1) {
      n = x_size[1];
    }

    if (x_size[2] > n) {
      n = x_size[2];
    }

    n = muIntScalarMax_sint32(nx, n);
    if (n < 3) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (actors_size[0] > n) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (3 * actors_size[0] != nx) {
      st.site = &ov_emlrtRSI;
      error(&st, emlrt_marshallOut(&st, cv1), getString(&st, b_message(&st,
              emlrt_marshallOut(&st, cv1), &i_emlrtMCI), &i_emlrtMCI),
            &i_emlrtMCI);
    }

    st.site = &tj_emlrtRSI;
    c_AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data,
      actors_size, b_x_data, x_size);
    nx = x_size[1] * x_size[2];
    st.site = &lc_emlrtRSI;
    b_st.site = &nc_emlrtRSI;
    assertValidSizeArg(&b_st, (real_T)actors_size[0]);
    n = 1;
    if (x_size[1] > 1) {
      n = x_size[1];
    }

    if (x_size[2] > n) {
      n = x_size[2];
    }

    n = muIntScalarMax_sint32(nx, n);
    if (n < 3) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (actors_size[0] > n) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (3 * actors_size[0] != nx) {
      st.site = &ov_emlrtRSI;
      error(&st, emlrt_marshallOut(&st, cv1), getString(&st, b_message(&st,
              emlrt_marshallOut(&st, cv1), &i_emlrtMCI), &i_emlrtMCI),
            &i_emlrtMCI);
    }

    array_real_T_4D_Constructor(&facesEgo);
    st.site = &uj_emlrtRSI;
    AbstractDetectionGenerator_actorsFaces(&st, obj, b_actors_data, actors_size,
      &facesEgo);
    n = actors_size[0];
    unnamed_idx_1 = actors_size[0];
    b_x_size[0] = 6;
    b_x_size[1] = actors_size[0];
    for (i = 0; i < n; i++) {
      for (nx = 0; nx < 3; nx++) {
        c_x_data[nx + 6 * i] = x_data[nx + 3 * i];
      }
    }

    for (i = 0; i < unnamed_idx_1; i++) {
      for (nx = 0; nx < 3; nx++) {
        c_x_data[(nx + 6 * i) + 3] = b_x_data[nx + 3 * i];
      }
    }

    st.site = &vj_emlrtRSI;
    AbstractDetectionGenerator_egoToSensor(&st, c_x_data, b_x_size, xSen_data,
      xSen_size);
    nx = 72 * facesEgo.size[3];
    st.site = &lc_emlrtRSI;
    unnamed_idx_1 = computeDimsData(&st, nx);
    n = 6;
    if (facesEgo.size[3] > 6) {
      n = facesEgo.size[3];
    }

    if (unnamed_idx_1 > muIntScalarMax_sint32(nx, n)) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (unnamed_idx_1 < 0) {
      for (i = 0; i < 37; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 37; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &ow_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &h_emlrtMCI), &h_emlrtMCI),
            &h_emlrtMCI);
    }

    if (3 * unnamed_idx_1 != nx) {
      st.site = &ov_emlrtRSI;
      error(&st, emlrt_marshallOut(&st, cv1), getString(&st, b_message(&st,
              emlrt_marshallOut(&st, cv1), &i_emlrtMCI), &i_emlrtMCI),
            &i_emlrtMCI);
    }

    b_facesEgo.vector.data = facesEgo.vector.data;
    b_facesEgo.vector.numel = facesEgo.vector.numel;
    b_facesEgo.vector.allocated = facesEgo.vector.allocated;
    b_facesEgo.vector.owner = false;
    b_facesEgo.size[0] = 3;
    b_facesEgo.size[1] = unnamed_idx_1;
    array_real_T_2D_Constructor(&b_facesSen);
    st.site = &wj_emlrtRSI;
    b_AbstractDetectionGenerator_egoToSensor(&st, &b_facesEgo, &b_facesSen);
    array_real_T_4D_Destructor(&facesEgo);
    nx = 3 * b_facesSen.size[1];
    st.site = &lc_emlrtRSI;
    b_st.site = &nc_emlrtRSI;
    assertValidSizeArg(&b_st, (real_T)actors_size[0]);
    n = 3;
    if (b_facesSen.size[1] > 3) {
      n = b_facesSen.size[1];
    }

    n = muIntScalarMax_sint32(nx, n);
    if (n < 4) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (n < 6) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (actors_size[0] > n) {
      st.site = &qv_emlrtRSI;
      error(&st, c_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              c_emlrt_marshallOut(&st, cv), &g_emlrtMCI), &g_emlrtMCI),
            &g_emlrtMCI);
    }

    if (72 * actors_size[0] != nx) {
      st.site = &ov_emlrtRSI;
      error(&st, emlrt_marshallOut(&st, cv1), getString(&st, b_message(&st,
              emlrt_marshallOut(&st, cv1), &i_emlrtMCI), &i_emlrtMCI),
            &i_emlrtMCI);
    }

    array_real_T_4D_SetSize(facesSen, 3, 4, 6, actors_size[0]);
    n = 72 * actors_size[0];
    for (i = 0; i < n; i++) {
      facesSen->vector.data[i] = b_facesSen.vector.data[i];
    }

    array_real_T_2D_Destructor(&b_facesSen);
  } else {
    xSen_size[0] = 6;
    xSen_size[1] = 0;
    array_real_T_4D_SetSize(facesSen, 3, 4, 6, 0);
  }
}

static real_T AbstractDetectionGenerator_lookupProfileIndex(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T actorID)
{
  static const int32_T iv[2] = { 1, 63 };

  static const int32_T iv1[2] = { 1, 63 };

  static char_T b_u[63] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'a', 'b',
    's', 't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n',
    'G', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 'm', 'a', 't', 'c', 'h',
    'i', 'n', 'g', 'A', 'c', 't', 'o', 'r', 'P', 'r', 'o', 'f', 'i', 'l', 'e',
    'N', 'o', 't', 'F', 'o', 'u', 'n', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  sH79YtbsHrUKNl3jXbBnQ5F s[4];
  real_T ind;
  int32_T idx;
  int32_T ii;
  int32_T ii_size_idx_1;
  char_T u[63];
  int8_T ii_data_idx_0;
  int8_T ind_data_idx_0;
  boolean_T x[4];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if (obj->pActorIDMatchRequired) {
    for (idx = 0; idx < 4; idx++) {
      s[idx] = obj->pActorProfiles[idx];
    }

    for (idx = 0; idx < 4; idx++) {
      x[idx] = (s[idx].ActorID == actorID);
    }

    idx = 0;
    ii_size_idx_1 = 1;
    ii = 1;
    exitg1 = false;
    while ((!exitg1) && (ii - 1 < 4)) {
      if (x[ii - 1]) {
        idx = 1;
        ii_data_idx_0 = (int8_T)ii;
        exitg1 = true;
      } else {
        ii++;
      }
    }

    if (idx == 0) {
      ii_size_idx_1 = 0;
    }

    for (idx = 0; idx < ii_size_idx_1; idx++) {
      ind_data_idx_0 = ii_data_idx_0;
    }

    if (ii_size_idx_1 == 0) {
      for (idx = 0; idx < 63; idx++) {
        u[idx] = b_u[idx];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 63, m, &u[0]);
      emlrtAssign(&y, m);
      for (idx = 0; idx < 63; idx++) {
        u[idx] = b_u[idx];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 63, m, &u[0]);
      emlrtAssign(&b_y, m);
      c_y = NULL;
      m = emlrtCreateDoubleScalar(actorID);
      emlrtAssign(&c_y, m);
      st.site = &wv_emlrtRSI;
      error(&st, y, getString(&st, message(&st, b_y, c_y, &ob_emlrtMCI),
             &ob_emlrtMCI), &ob_emlrtMCI);
    }

    emlrtDynamicBoundsCheckR2012b(1, 1, ii_size_idx_1, &gd_emlrtBCI,
      (emlrtConstCTX)sp);
    ind = (real_T)ind_data_idx_0;
  } else {
    ind = 1.0;
  }

  return ind;
}

static void b_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[3])
{
  emlrtStack st;
  real_T b_vals_data[900];
  real_T c_tmp_data[900];
  int32_T b_vals_size[3];
  int32_T tmp_size[3];
  int32_T b_m;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T m;
  int16_T sz[3];
  st.prev = sp;
  st.tls = sp->tls;
  if (s_size[0] == 0) {
    vals_size[0] = 1;
    vals_size[1] = 0;
    vals_size[2] = 1;
  } else {
    sz[0] = (int16_T)s_size[0];
    for (i = 0; i < 2; i++) {
      sz[i + 1] = (int16_T)((i << 1) + 1);
    }

    b_vals_size[0] = sz[0];
    b_vals_size[1] = 1;
    b_vals_size[2] = 3;
    loop_ub = sz[0] * 3;
    for (i = 0; i < loop_ub; i++) {
      b_vals_data[i] = 0.0;
    }

    i = s_size[0];
    for (m = 0; m < i; m++) {
      loop_ub = emlrtDynamicBoundsCheckR2012b(m + 1, 1, s_size[0], &kb_emlrtBCI,
        (emlrtConstCTX)sp) - 1;
      b_m = emlrtDynamicBoundsCheckR2012b(m + 1, 1, b_vals_size[0], &lb_emlrtBCI,
        (emlrtConstCTX)sp);
      for (i1 = 0; i1 < 3; i1++) {
        b_vals_data[(b_m + b_vals_size[0] * i1) - 1] = s_data[loop_ub]
          .Position[i1];
      }
    }

    st.site = &ng_emlrtRSI;
    b_shiftdim(&st, b_vals_data, b_vals_size, c_tmp_data, tmp_size);
    vals_size[0] = 1;
    vals_size[1] = 3;
    vals_size[2] = tmp_size[2];
    loop_ub = tmp_size[0] * tmp_size[1] * tmp_size[2];
    if (loop_ub - 1 >= 0) {
      memcpy(&vals_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
    }
  }
}

static void b_shiftdim(const emlrtStack *sp, real_T x_data[], int32_T x_size[3],
  real_T b_data[], int32_T b_size[3])
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 40 };

  static const int32_T iv2[2] = { 1, 39 };

  static const int32_T iv3[2] = { 1, 40 };

  static char_T d_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T c_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  int32_T n;
  int32_T nx;
  char_T b_u[40];
  char_T u[39];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &og_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  nx = x_size[0] * 3;
  b_st.site = &lc_emlrtRSI;
  c_st.site = &nc_emlrtRSI;
  n = x_size[0];
  if (x_size[0] < 3) {
    n = 3;
  }

  if (x_size[0] > muIntScalarMax_sint32(nx, n)) {
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &qv_emlrtRSI;
    error(&b_st, y, getString(&b_st, b_message(&b_st, c_y, &g_emlrtMCI),
           &g_emlrtMCI), &g_emlrtMCI);
  }

  if (3 * x_size[0] != nx) {
    for (i = 0; i < 40; i++) {
      b_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 40, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 40; i++) {
      b_u[i] = d_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 40, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    b_st.site = &ov_emlrtRSI;
    error(&b_st, b_y, getString(&b_st, b_message(&b_st, d_y, &i_emlrtMCI),
           &i_emlrtMCI), &i_emlrtMCI);
  }

  b_size[2] = x_size[0];
  b_size[0] = 1;
  b_size[1] = 3;
  for (n = 0; n < 3; n++) {
    b_size[0] = 1;
    b_size[1] = 3;
    i = x_size[0];
    for (nx = 0; nx < i; nx++) {
      b_size[0] = 1;
      b_size[1] = 3;
      b_data[n + 3 * nx] = x_data[nx + x_size[0] * n];
    }
  }
}

static void c_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  syCnTpqdknhOEQKNq30nf4E s_data[], int32_T s_size[1], real_T vals_data[],
  int32_T vals_size[3])
{
  emlrtStack st;
  real_T b_vals_data[900];
  real_T c_tmp_data[900];
  int32_T b_vals_size[3];
  int32_T tmp_size[3];
  int32_T b_m;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T m;
  int16_T sz[3];
  st.prev = sp;
  st.tls = sp->tls;
  if (s_size[0] == 0) {
    vals_size[0] = 1;
    vals_size[1] = 0;
    vals_size[2] = 1;
  } else {
    sz[0] = (int16_T)s_size[0];
    for (i = 0; i < 2; i++) {
      sz[i + 1] = (int16_T)((i << 1) + 1);
    }

    b_vals_size[0] = sz[0];
    b_vals_size[1] = 1;
    b_vals_size[2] = 3;
    loop_ub = sz[0] * 3;
    for (i = 0; i < loop_ub; i++) {
      b_vals_data[i] = 0.0;
    }

    i = s_size[0];
    for (m = 0; m < i; m++) {
      loop_ub = emlrtDynamicBoundsCheckR2012b(m + 1, 1, s_size[0], &kb_emlrtBCI,
        (emlrtConstCTX)sp) - 1;
      b_m = emlrtDynamicBoundsCheckR2012b(m + 1, 1, b_vals_size[0], &lb_emlrtBCI,
        (emlrtConstCTX)sp);
      for (i1 = 0; i1 < 3; i1++) {
        b_vals_data[(b_m + b_vals_size[0] * i1) - 1] = s_data[loop_ub]
          .Velocity[i1];
      }
    }

    st.site = &ng_emlrtRSI;
    b_shiftdim(&st, b_vals_data, b_vals_size, c_tmp_data, tmp_size);
    vals_size[0] = 1;
    vals_size[1] = 3;
    vals_size[2] = tmp_size[2];
    loop_ub = tmp_size[0] * tmp_size[1] * tmp_size[2];
    if (loop_ub - 1 >= 0) {
      memcpy(&vals_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
    }
  }
}

static void AbstractDetectionGenerator_actorsFaces(const emlrtStack *sp,
  visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
  int32_T actors_size[1], coder_array_real_T_4D *faces)
{
  emlrtStack st;
  sH79YtbsHrUKNl3jXbBnQ5F actorProfiles[4];
  real_T actorIDs_data[300];
  real_T dv1[72];
  real_T dv2[72];
  real_T b_dv[9];
  real_T b_actorProfiles[3];
  real_T ind;
  int32_T actorIDs_size[2];
  int32_T b_m;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T m;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 4; i++) {
    actorProfiles[i] = obj->pActorProfiles[i];
  }

  st.site = &xj_emlrtRSI;
  AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data, actors_size,
    actorIDs_data, actorIDs_size);
  i = actors_size[0];
  array_real_T_4D_SetSize(faces, 3, 4, 6, actors_size[0]);
  for (m = 0; m < i; m++) {
    st.site = &yj_emlrtRSI;
    ind = AbstractDetectionGenerator_lookupProfileIndex(&st, obj,
      actorIDs_data[emlrtDynamicBoundsCheckR2012b(m + 1, 1, actorIDs_size[1],
      &md_emlrtBCI, (emlrtConstCTX)sp) - 1]);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, actors_size[0], &hd_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, actors_size[0], &id_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, actors_size[0], &jd_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, actors_size[0], &kd_emlrtBCI,
      (emlrtConstCTX)sp);
    rotChildToParent(b_actors_data[m].Roll, b_actors_data[m].Pitch,
                     b_actors_data[m].Yaw, b_dv);
    b_actorProfiles[0] = actorProfiles[(int32_T)ind - 1].Length;
    b_actorProfiles[1] = actorProfiles[(int32_T)ind - 1].Width;
    b_actorProfiles[2] = actorProfiles[(int32_T)ind - 1].Height;
    ComputationalGeometry_cuboid(b_actorProfiles, dv2);
    n_bsxfun(dv2, actorProfiles[(int32_T)ind - 1].OriginOffset, dv1);
    for (i1 = 0; i1 < 3; i1++) {
      for (i2 = 0; i2 < 24; i2++) {
        dv2[i1 + 3 * i2] = 0.0;
        for (i3 = 0; i3 < 3; i3++) {
          dv2[i1 + 3 * i2] += b_dv[i1 + 3 * i3] * dv1[i3 + 3 * i2];
        }
      }
    }

    o_bsxfun(dv2, b_actors_data[m].Position, dv1);
    b_m = emlrtDynamicBoundsCheckR2012b(m + 1, 1, faces->size[3], &ld_emlrtBCI,
      (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 4; i2++) {
        for (i3 = 0; i3 < 3; i3++) {
          faces->vector.data[((i3 + 3 * i2) + 12 * i1) + 72 * (b_m - 1)] = dv1
            [(i3 + 3 * i2) + 12 * i1];
        }
      }
    }
  }
}

static void ComputationalGeometry_cuboid(real_T dims[3], real_T cube[72])
{
  static int8_T iv[12] = { 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1 };

  static int8_T iv1[12] = { 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1 };

  static int8_T iv2[12] = { 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1 };

  static int8_T iv3[12] = { 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 };

  static int8_T iv4[12] = { -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1 };

  static int8_T iv5[12] = { -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1 };

  __m128d r;
  __m128d r1;
  real_T b_cube[72];
  real_T a[12];
  real_T b[3];
  real_T offset[3];
  int32_T i;
  int32_T k;
  int32_T m;
  for (i = 0; i < 3; i++) {
    offset[i] = 0.0;
  }

  offset[2] = -dims[2] / 2.0;
  for (i = 0; i < 72; i++) {
    cube[i] = 0.0;
  }

  for (m = 0; m < 6; m++) {
    switch (m + 1) {
     case 1:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv1[k + 3 * i];
        }
      }
      break;

     case 2:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv2[k + 3 * i];
        }
      }
      break;

     case 3:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv3[k + 3 * i];
        }
      }
      break;

     case 4:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv4[k + 3 * i];
        }
      }
      break;

     case 5:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv5[k + 3 * i];
        }
      }
      break;

     default:
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 3; k++) {
          cube[(k + 3 * i) + 12 * m] = (real_T)iv[k + 3 * i];
        }
      }
      break;
    }

    for (i = 0; i < 4; i++) {
      for (k = 0; k < 3; k++) {
        a[k + 3 * i] = cube[(k + 3 * i) + 12 * m];
      }
    }

    for (i = 0; i <= 0; i += 2) {
      r = _mm_loadu_pd(&dims[0]);
      _mm_storeu_pd(&b[0], _mm_div_pd(r, _mm_set1_pd(2.0)));
    }

    for (i = 2; i < 3; i++) {
      b[2] = dims[2] / 2.0;
    }

    for (i = 0; i < 4; i++) {
      for (k = 0; k <= 0; k += 2) {
        r = _mm_loadu_pd(&a[3 * i]);
        r1 = _mm_loadu_pd(&b[0]);
        _mm_storeu_pd(&cube[3 * i + 12 * m], _mm_mul_pd(r, r1));
        r = _mm_loadu_pd(&cube[3 * i + 12 * m]);
        _mm_storeu_pd(&b_cube[3 * i + 12 * m], r);
      }

      for (k = 2; k < 3; k++) {
        cube[(3 * i + 12 * m) + 2] = a[3 * i + 2] * b[2];
        b_cube[(3 * i + 12 * m) + 2] = cube[(3 * i + 12 * m) + 2];
      }
    }
  }

  m_bsxfun(b_cube, offset, cube);
}

static void m_bsxfun(real_T a[72], real_T b[3], real_T c[72])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T c_k;
  int32_T k;
  for (k = 0; k < 6; k++) {
    for (b_k = 0; b_k < 4; b_k++) {
      for (c_k = 0; c_k <= 0; c_k += 2) {
        r = _mm_loadu_pd(&a[3 * b_k + 12 * k]);
        r1 = _mm_loadu_pd(&b[0]);
        _mm_storeu_pd(&c[3 * b_k + 12 * k], _mm_sub_pd(r, r1));
      }

      for (c_k = 2; c_k < 3; c_k++) {
        c[(3 * b_k + 12 * k) + 2] = a[(3 * b_k + 12 * k) + 2] - b[2];
      }
    }
  }
}

static void n_bsxfun(real_T a[72], real_T b[3], real_T c[72])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T k;
  for (k = 0; k < 24; k++) {
    for (b_k = 0; b_k <= 0; b_k += 2) {
      r = _mm_loadu_pd(&a[3 * k]);
      r1 = _mm_loadu_pd(&b[0]);
      _mm_storeu_pd(&c[3 * k], _mm_sub_pd(r, r1));
    }

    for (b_k = 2; b_k < 3; b_k++) {
      c[3 * k + 2] = a[3 * k + 2] - b[2];
    }
  }
}

static void o_bsxfun(real_T a[72], real_T b[3], real_T c[72])
{
  __m128d r;
  __m128d r1;
  int32_T b_k;
  int32_T k;
  for (k = 0; k < 24; k++) {
    for (b_k = 0; b_k <= 0; b_k += 2) {
      r = _mm_loadu_pd(&a[3 * k]);
      r1 = _mm_loadu_pd(&b[0]);
      _mm_storeu_pd(&c[3 * k], _mm_add_pd(r, r1));
    }

    for (b_k = 2; b_k < 3; b_k++) {
      c[3 * k + 2] = a[3 * k + 2] + b[2];
    }
  }
}

static void AbstractDetectionGenerator_egoToSensor(const emlrtStack *sp, real_T
  detEgo_data[], int32_T detEgo_size[2], real_T detSen_data[], int32_T
  detSen_size[2])
{
  coder_array_real_T_2D c_detEgo_data;
  coder_array_real_T_2D e_detEgo_data;
  coder_array_real_T_2D r;
  coder_array_real_T_2D y;
  emlrtStack st;
  real_T b_detEgo_data[900];
  real_T d_detEgo_data[900];
  int32_T iv[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  boolean_T hasVel;
  hasVel = (detEgo_size[0] > 3);
  if (hasVel) {
    detSen_size[0] = 6;
    detSen_size[1] = detEgo_size[1];
    loop_ub = 6 * detEgo_size[1];
    for (i = 0; i < loop_ub; i++) {
      detSen_data[i] = 0.0;
    }
  } else {
    detSen_size[0] = 3;
    detSen_size[1] = detEgo_size[1];
    loop_ub = 3 * detEgo_size[1];
    for (i = 0; i < loop_ub; i++) {
      detSen_data[i] = 0.0;
    }
  }

  for (i = 0; i < 3; i++) {
    emlrtDynamicBoundsCheckR2012b(i + 1, 1, detEgo_size[0], &nd_emlrtBCI,
      (emlrtConstCTX)sp);
  }

  loop_ub = detEgo_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detEgo_data[i1 + 3 * i] = detEgo_data[i1 + detEgo_size[0] * i];
    }
  }

  c_detEgo_data.vector.data = &b_detEgo_data[0];
  c_detEgo_data.vector.numel = 3 * detEgo_size[1];
  c_detEgo_data.vector.allocated = c_detEgo_data.vector.numel;
  c_detEgo_data.vector.owner = false;
  c_detEgo_data.size[0] = 3;
  c_detEgo_data.size[1] = detEgo_size[1];
  array_real_T_2D_Constructor(&r);
  p_bsxfun(&c_detEgo_data, &r);
  array_real_T_2D_Constructor(&y);
  st.site = &md_emlrtRSI;
  f_mtimes(&r, &y);
  array_real_T_2D_Destructor(&r);
  iv[0] = 3;
  iv[1] = detSen_size[1];
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &y.size[0], 2, &f_emlrtECI, (void *)
    sp);
  loop_ub = detSen_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen_data[i1 + detSen_size[0] * i] = y.vector.data[i1 + 3 * i];
    }
  }

  if (hasVel) {
    for (i = 0; i < 3; i++) {
      emlrtDynamicBoundsCheckR2012b(i + 4, 1, detEgo_size[0], &od_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    loop_ub = detEgo_size[1];
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        d_detEgo_data[i1 + 3 * i] = detEgo_data[(i1 + detEgo_size[0] * i) + 3];
      }
    }

    e_detEgo_data.vector.data = &d_detEgo_data[0];
    e_detEgo_data.vector.numel = 3 * detEgo_size[1];
    e_detEgo_data.vector.allocated = e_detEgo_data.vector.numel;
    e_detEgo_data.vector.owner = false;
    e_detEgo_data.size[0] = 3;
    e_detEgo_data.size[1] = detEgo_size[1];
    st.site = &md_emlrtRSI;
    f_mtimes(&e_detEgo_data, &y);
    for (i = 0; i < 3; i++) {
      emlrtDynamicBoundsCheckR2012b(i + 4, 1, detSen_size[0], &pd_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    iv[0] = 3;
    iv[1] = detSen_size[1];
    emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &y.size[0], 2, &g_emlrtECI, (void *)
      sp);
    loop_ub = detSen_size[1];
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        detSen_data[(i1 + detSen_size[0] * i) + 3] = y.vector.data[i1 + 3 * i];
      }
    }
  }

  array_real_T_2D_Destructor(&y);
}

static void p_bsxfun(coder_array_real_T_2D *a, coder_array_real_T_2D *c)
{
  static real_T b_dv[3] = { 0.0, 0.0, 1.1 };

  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  array_real_T_2D_SetSize(c, 3, (int32_T)(int16_T)a->size[1]);
  if (c->size[1] != 0) {
    array_real_T_2D_SetSize(c, 3, c->size[1]);
    acoef = (a->size[1] != 1);
    i = c->size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      array_real_T_2D_SetSize(c, 3, c->size[1]);
      for (b_k = 0; b_k < 3; b_k++) {
        array_real_T_2D_SetSize(c, 3, c->size[1]);
        c->vector.data[b_k + 3 * k] = a->vector.data[b_k + 3 * ia] - b_dv[b_k];
      }
    }
  }
}

static void f_mtimes(coder_array_real_T_2D *B, coder_array_real_T_2D *C)
{
  static int8_T b_A[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T A[9];
  real_T alpha1;
  real_T beta1;
  int32_T i;
  char_T TRANSA1;
  char_T TRANSB1;
  if (B->size[1] == 0) {
    array_real_T_2D_SetSize(C, 3, 0);
  } else {
    for (i = 0; i < 9; i++) {
      A[i] = (real_T)b_A[i];
    }

    TRANSB1 = 'N';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)3;
    n_t = (ptrdiff_t)B->size[1];
    k_t = (ptrdiff_t)3;
    lda_t = (ptrdiff_t)3;
    ldb_t = (ptrdiff_t)3;
    ldc_t = (ptrdiff_t)3;
    array_real_T_2D_SetSize(C, 3, B->size[1]);
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t,
          &B->vector.data[0], &ldb_t, &beta1, &C->vector.data[0], &ldc_t);
  }
}

static int32_T computeDimsData(const emlrtStack *sp, int32_T nx)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'b', 'u', 'i', 'l',
    't', 'i', 'n', 's', ':', 'A', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', 'F',
    'a', 'i', 'l', 'e', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T calclen;
  int32_T i;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  calclen = (int32_T)((uint32_T)nx / 3U);
  if (calclen > nx) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &rw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &pb_emlrtMCI), &pb_emlrtMCI),
          &pb_emlrtMCI);
  }

  return calclen;
}

static void b_AbstractDetectionGenerator_egoToSensor(const emlrtStack *sp,
  coder_array_real_T_2D *detEgo, coder_array_real_T_2D *detSen)
{
  coder_array_real_T_2D b_detEgo;
  coder_array_real_T_2D posSen;
  coder_array_real_T_2D r;
  emlrtStack st;
  int32_T iv[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  array_real_T_2D_SetSize(detSen, 3, detEgo->size[1]);
  loop_ub = 3 * detEgo->size[1];
  for (i = 0; i < loop_ub; i++) {
    detSen->vector.data[i] = 0.0;
  }

  array_real_T_2D_Constructor(&b_detEgo);
  array_real_T_2D_SetSize(&b_detEgo, 3, detEgo->size[1]);
  loop_ub = detEgo->size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detEgo.vector.data[i1 + 3 * i] = detEgo->vector.data[i1 + 3 * i];
    }
  }

  array_real_T_2D_Constructor(&r);
  p_bsxfun(&b_detEgo, &r);
  array_real_T_2D_Destructor(&b_detEgo);
  array_real_T_2D_Constructor(&posSen);
  st.site = &md_emlrtRSI;
  f_mtimes(&r, &posSen);
  array_real_T_2D_Destructor(&r);
  iv[0] = 3;
  iv[1] = detEgo->size[1];
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &posSen.size[0], 2, &f_emlrtECI,
    (void *)sp);
  loop_ub = detEgo->size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen->vector.data[i1 + 3 * i] = posSen.vector.data[i1 + 3 * i];
    }
  }

  array_real_T_2D_Destructor(&posSen);
}

static void AbstractDetectionGenerator_isSensorInsideActor(const emlrtStack *sp,
  coder_array_real_T_4D *facesSen, boolean_T *isInsideAny, coder_array_real_T_2D
  *actorIdx)
{
  real_T thisCube[72];
  real_T b_thisCube[12];
  real_T c_y1[9];
  real_T vp[3];
  real_T t;
  real_T tmp1;
  real_T work;
  real_T y;
  int32_T i;
  int32_T iActor;
  int32_T iFace;
  int32_T ix;
  int32_T ixLead;
  int32_T iy;
  int32_T iyLead;
  int32_T m;
  int32_T s;
  boolean_T b_isInsideAny;
  boolean_T exitg1;
  boolean_T isInsideActor;
  array_real_T_2D_SetSize(actorIdx, 1, 0);
  b_isInsideAny = false;
  i = facesSen->size[3];
  for (iActor = 0; iActor < i; iActor++) {
    isInsideActor = true;
    ix = emlrtDynamicBoundsCheckR2012b(iActor + 1, 1, facesSen->size[3],
      &qd_emlrtBCI, (emlrtConstCTX)sp);
    for (ixLead = 0; ixLead < 6; ixLead++) {
      for (iyLead = 0; iyLead < 4; iyLead++) {
        for (iy = 0; iy < 3; iy++) {
          thisCube[(iy + 3 * iyLead) + 12 * ixLead] = facesSen->vector.data[((iy
            + 3 * iyLead) + 12 * ixLead) + 72 * (ix - 1)];
        }
      }
    }

    iFace = 0;
    exitg1 = false;
    while ((!exitg1) && (iFace < 6)) {
      ix = 0;
      iy = 1;
      for (s = 0; s < 3; s++) {
        ixLead = ix + 3;
        iyLead = iy - 1;
        work = thisCube[(ix % 3 + 3 * div_nzp_s32_floor(ix, 3)) + 12 * iFace];
        for (m = 0; m < 3; m++) {
          tmp1 = work;
          work = thisCube[(ixLead % 3 + 3 * div_nzp_s32_floor(ixLead, 3)) + 12 *
            iFace];
          tmp1 = thisCube[(ixLead % 3 + 3 * div_nzp_s32_floor(ixLead, 3)) + 12 *
            iFace] - tmp1;
          ixLead += 3;
          c_y1[iyLead] = tmp1;
          iyLead += 3;
        }

        ix++;
        iy++;
      }

      vp[0] = c_y1[1] * c_y1[5] - c_y1[2] * c_y1[4];
      vp[1] = c_y1[2] * c_y1[3] - c_y1[0] * c_y1[5];
      vp[2] = c_y1[0] * c_y1[4] - c_y1[1] * c_y1[3];
      y = 0.0;
      tmp1 = 3.3121686421112381E-170;
      for (ix = 0; ix < 3; ix++) {
        work = muDoubleScalarAbs(vp[ix]);
        if (work > tmp1) {
          t = tmp1 / work;
          y = y * t * t + 1.0;
          tmp1 = work;
        } else {
          t = work / tmp1;
          y += t * t;
        }
      }

      y = tmp1 * muDoubleScalarSqrt(y);
      for (ixLead = 0; ixLead < 4; ixLead++) {
        for (iyLead = 0; iyLead < 3; iyLead++) {
          b_thisCube[iyLead + 3 * ixLead] = thisCube[(iyLead + 3 * ixLead) + 12 *
            iFace];
        }
      }

      tmp1 = 0.0;
      for (ixLead = 0; ixLead < 3; ixLead++) {
        tmp1 += b_thisCube[ixLead] * (vp[ixLead] / y);
      }

      isInsideActor = (tmp1 > 0.0);
      if (!isInsideActor) {
        exitg1 = true;
      } else {
        iFace++;
      }
    }

    if (isInsideActor) {
      ixLead = actorIdx->size[1];
      array_real_T_2D_SetSize(actorIdx, 1, actorIdx->size[1] + 1);
      actorIdx->vector.data[ixLead] = (real_T)iActor + 1.0;
    }

    if (b_isInsideAny || isInsideActor) {
      b_isInsideAny = true;
    } else {
      b_isInsideAny = false;
    }
  }

  *isInsideAny = b_isInsideAny;
}

static void e_warning(const emlrtStack *sp, real_T varargin_2)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 52 };

  static char_T b_msgID[52] = { 'd', 'r', 'i', 'v', 'i', 'n', 'g', ':', 'a', 'b',
    's', 't', 'r', 'a', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n',
    'G', 'e', 'n', 'e', 'r', 'a', 't', 'o', 'r', ':', 's', 'e', 'n', 's', 'o',
    'r', 'I', 'n', 's', 'i', 'd', 'e', 'A', 'c', 't', 'o', 'r' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[52];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 52; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 52, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  d_y = NULL;
  m = emlrtCreateDoubleScalar(4.0);
  emlrtAssign(&d_y, m);
  e_y = NULL;
  m = emlrtCreateDoubleScalar(varargin_2);
  emlrtAssign(&e_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, d_feval(&st, b_y, c_y, d_y, e_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void visionDetectionGenerator_findVisibleTargetFaces
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_4D *facesSen, real_T xSen_data[], int32_T xSen_size[2],
   real_T tgtIDs_data[], int32_T tgtIDs_size[2], real_T classIDs_data[], int32_T
   classIDs_size[2], real_T g_facesVis_data[], int32_T facesVis_size[3], real_T
   b_xSen_data[], int32_T b_xSen_size[2], real_T b_tgtIDs_data[], int32_T
   b_tgtIDs_size[2], real_T b_classIDs_data[], int32_T b_classIDs_size[2])
{
  coder_array_real_T_2D b_facesFront;
  coder_array_real_T_2D c_facesFront;
  coder_array_real_T_2D d_facesFront;
  coder_array_real_T_2D r;
  coder_array_real_T_2D r1;
  coder_array_real_T_4D faces2D;
  coder_array_real_T_4D facesCulled;
  coder_array_real_T_4D facesFront;
  emlrtStack st;
  real_T c_xSen_data[1800];
  real_T e_facesFront[90];
  real_T theseFaces_data[90];
  real_T theseFaces[72];
  real_T iHull_data[62];
  real_T theseVerts[60];
  real_T theseVerts_data[60];
  real_T b_theseVerts[30];
  real_T b_theseVerts_data[30];
  real_T thisFront_data[15];
  int32_T b_theseVerts_size[2];
  int32_T iv[2];
  int32_T theseVerts_size[2];
  int32_T thisFront_size[2];
  int32_T iHull_size[1];
  int32_T b_i;
  int32_T b_iTgt;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T iTgt;
  int32_T loop_ub;
  int32_T noneVis_size_idx_0;
  int32_T trueCount;
  int16_T c_tmp_data[9000];
  int16_T d_tmp_data[300];
  int16_T g_tmp_data[300];
  int16_T i3;
  int8_T e_tmp_data[30];
  int8_T f_tmp_data[30];
  boolean_T noneVis_data[300];
  boolean_T b_isGd[30];
  boolean_T isGd;
  st.prev = sp;
  st.tls = sp->tls;
  if (classIDs_size[1] - 1 >= 0) {
    memcpy(&b_classIDs_data[0], &classIDs_data[0], (uint32_T)classIDs_size[1] *
           sizeof(real_T));
  }

  if (tgtIDs_size[1] - 1 >= 0) {
    memcpy(&b_tgtIDs_data[0], &tgtIDs_data[0], (uint32_T)tgtIDs_size[1] * sizeof
           (real_T));
  }

  loop_ub = xSen_size[0] * xSen_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&b_xSen_data[0], &xSen_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  array_real_T_4D_Constructor(&facesCulled);
  st.site = &ek_emlrtRSI;
  backfaceCull(moduleInstance, &st, facesSen, &facesCulled);
  array_real_T_4D_Constructor(&facesFront);
  array_real_T_4D_SetSize(&facesFront, 3, 5, 6, facesCulled.size[3]);
  loop_ub = 90 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    facesFront.vector.data[i] = rtNaN;
  }

  i = facesCulled.size[3];
  for (iTgt = 0; iTgt < i; iTgt++) {
    b_iTgt = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesCulled.size[3],
      &xd_emlrtBCI, (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 4; i2++) {
        for (b_i = 0; b_i < 3; b_i++) {
          theseFaces[(b_i + 3 * i2) + 12 * i1] = facesCulled.vector.data[((b_i +
            3 * i2) + 12 * i1) + 72 * (b_iTgt - 1)];
        }
      }
    }

    for (loop_ub = 0; loop_ub < 6; loop_ub++) {
      st.site = &dk_emlrtRSI;
      splitFace(&st, &theseFaces[12 * loop_ub], thisFront_data, thisFront_size);
      if (thisFront_size[1] < 1) {
        b_iTgt = 0;
      } else {
        b_iTgt = thisFront_size[1];
      }

      emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesFront.size[3],
        &wd_emlrtBCI, (emlrtConstCTX)sp);
      iv[0] = 3;
      iv[1] = b_iTgt;
      emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &thisFront_size[0], 2,
        &k_emlrtECI, (void *)sp);
      for (i1 = 0; i1 < b_iTgt; i1++) {
        for (i2 = 0; i2 < 3; i2++) {
          facesFront.vector.data[((i2 + 3 * i1) + 15 * loop_ub) + 90 * iTgt] =
            thisFront_data[i2 + 3 * i1];
        }
      }
    }
  }

  array_real_T_4D_Constructor(&faces2D);
  array_real_T_4D_SetSize(&faces2D, 2, 5, 6, facesCulled.size[3]);
  loop_ub = 60 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    faces2D.vector.data[i] = rtNaN;
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&b_facesFront);
  array_real_T_2D_SetSize(&b_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    b_facesFront.vector.data[i] = facesFront.vector.data[3 * i];
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&c_facesFront);
  array_real_T_2D_SetSize(&c_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    c_facesFront.vector.data[i] = facesFront.vector.data[3 * i + 1];
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&d_facesFront);
  array_real_T_2D_SetSize(&d_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    d_facesFront.vector.data[i] = facesFront.vector.data[3 * i + 2];
  }

  array_real_T_2D_Constructor(&r);
  array_real_T_2D_Constructor(&r1);
  st.site = &ck_emlrtRSI;
  cart2sph(&st, &b_facesFront, &c_facesFront, &d_facesFront, &r, &r1);
  array_real_T_2D_Destructor(&d_facesFront);
  array_real_T_2D_Destructor(&c_facesFront);
  array_real_T_2D_Destructor(&b_facesFront);
  i3 = (int16_T)(30 * facesCulled.size[3] - 1);
  b_iTgt = i3 + 1;
  loop_ub = i3;
  for (i = 0; i <= loop_ub; i++) {
    c_tmp_data[i] = (int16_T)i;
  }

  iv[0] = 1;
  iv[1] = i3 + 1;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &r.size[0], 2, &j_emlrtECI, (void *)
    sp);
  for (i = 0; i < b_iTgt; i++) {
    faces2D.vector.data[c_tmp_data[i] << 1] = r.vector.data[i];
  }

  array_real_T_2D_Destructor(&r);
  i3 = (int16_T)(30 * faces2D.size[3] - 1);
  b_iTgt = i3 + 1;
  loop_ub = i3;
  for (i = 0; i <= loop_ub; i++) {
    c_tmp_data[i] = (int16_T)i;
  }

  iv[0] = 1;
  iv[1] = i3 + 1;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &r1.size[0], 2, &i_emlrtECI, (void *)
    sp);
  for (i = 0; i < b_iTgt; i++) {
    faces2D.vector.data[(c_tmp_data[i] << 1) + 1] = r1.vector.data[i];
  }

  array_real_T_2D_Destructor(&r1);
  loop_ub = 21 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    g_facesVis_data[i] = rtNaN;
  }

  noneVis_size_idx_0 = facesCulled.size[3];
  loop_ub = facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    noneVis_data[i] = false;
  }

  i = facesCulled.size[3];
  array_real_T_4D_Destructor(&facesCulled);
  for (iTgt = 0; iTgt < i; iTgt++) {
    b_iTgt = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, faces2D.size[3],
      &vd_emlrtBCI, (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 5; i2++) {
        for (b_i = 0; b_i < 2; b_i++) {
          theseVerts[(b_i + (i2 << 1)) + 10 * i1] = faces2D.vector.data[((b_i +
            (i2 << 1)) + 10 * i1) + 60 * (b_iTgt - 1)];
        }
      }
    }

    emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesFront.size[3], &ud_emlrtBCI,
      (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 30; i1++) {
      b_theseVerts[i1] = theseVerts[i1 << 1];
    }

    b_isfinite(b_theseVerts, b_isGd);
    if (c_combineVectorElements(b_isGd) < 3) {
      noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, noneVis_size_idx_0,
        &yd_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
    } else {
      loop_ub = 0;
      b_iTgt = 0;
      for (b_i = 0; b_i < 30; b_i++) {
        isGd = b_isGd[b_i];
        if (isGd) {
          loop_ub++;
          e_tmp_data[b_iTgt] = (int8_T)b_i;
          b_iTgt++;
        }
      }

      for (i1 = 0; i1 < loop_ub; i1++) {
        for (i2 = 0; i2 < 2; i2++) {
          theseVerts_data[i2 + (i1 << 1)] = theseVerts[i2 + (e_tmp_data[i1] << 1)];
        }
      }

      trueCount = 0;
      b_iTgt = 0;
      for (b_i = 0; b_i < 30; b_i++) {
        isGd = b_isGd[b_i];
        if (isGd) {
          trueCount++;
          f_tmp_data[b_iTgt] = (int8_T)b_i;
          b_iTgt++;
        }
      }

      for (i1 = 0; i1 < 6; i1++) {
        for (i2 = 0; i2 < 5; i2++) {
          for (b_i = 0; b_i < 3; b_i++) {
            e_facesFront[(b_i + 3 * i2) + 15 * i1] = facesFront.vector.data
              [((b_i + 3 * i2) + 15 * i1) + 90 * iTgt];
          }
        }
      }

      for (i1 = 0; i1 < trueCount; i1++) {
        for (i2 = 0; i2 < 3; i2++) {
          theseFaces_data[i2 + 3 * i1] = e_facesFront[i2 + 3 * f_tmp_data[i1]];
        }
      }

      theseVerts_size[0] = 1;
      theseVerts_size[1] = loop_ub;
      b_theseVerts_size[0] = 1;
      b_theseVerts_size[1] = loop_ub;
      for (i1 = 0; i1 < loop_ub; i1++) {
        b_theseVerts[i1] = theseVerts_data[i1 << 1];
        b_theseVerts_data[i1] = theseVerts_data[(i1 << 1) + 1];
      }

      st.site = &bk_emlrtRSI;
      convhull(&st, b_theseVerts, theseVerts_size, b_theseVerts_data,
               b_theseVerts_size, iHull_data, iHull_size);
      if (iHull_size[0] == 0) {
        noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
          noneVis_size_idx_0, &ce_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
      } else {
        if (iHull_size[0] - 1 < 1) {
          loop_ub = 0;
        } else {
          loop_ub = emlrtDynamicBoundsCheckR2012b(iHull_size[0] - 1, 1,
            iHull_size[0], &td_emlrtBCI, (emlrtConstCTX)sp);
        }

        iv[0] = 1;
        iv[1] = loop_ub;
        st.site = &ak_emlrtRSI;
        indexShapeCheck(&st, iHull_size[0], iv);
        for (i1 = 0; i1 < loop_ub; i1++) {
          emlrtDynamicBoundsCheckR2012b((int32_T)iHull_data[i1], 1, trueCount,
            &de_emlrtBCI, (emlrtConstCTX)sp);
        }

        if (loop_ub < 3) {
          noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
            noneVis_size_idx_0, &fe_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
        } else {
          emlrtDynamicBoundsCheckR2012b(loop_ub, 1, 7, &sd_emlrtBCI,
            (emlrtConstCTX)sp);
          emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesCulled.size[3],
            &rd_emlrtBCI, (emlrtConstCTX)sp);
          iv[0] = 3;
          iv[1] = loop_ub;
          thisFront_size[0] = 3;
          thisFront_size[1] = loop_ub;
          emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &thisFront_size[0], 2,
            &h_emlrtECI, (void *)sp);
          for (i1 = 0; i1 < loop_ub; i1++) {
            for (i2 = 0; i2 < 3; i2++) {
              g_facesVis_data[(i2 + 3 * i1) + 21 * iTgt] = theseFaces_data[i2 +
                3 * ((int32_T)iHull_data[i1] - 1)];
            }
          }
        }
      }
    }
  }

  array_real_T_4D_Destructor(&faces2D);
  array_real_T_4D_Destructor(&facesFront);
  loop_ub = 0;
  b_iTgt = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    isGd = noneVis_data[b_i];
    if (!isGd) {
      loop_ub++;
      d_tmp_data[b_iTgt] = (int16_T)b_i;
      b_iTgt++;
    }
  }

  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 7; i1++) {
      for (i2 = 0; i2 < 3; i2++) {
        moduleInstance->c_facesVis_data[(i2 + 3 * i1) + 21 * i] =
          g_facesVis_data[(i2 + 3 * i1) + 21 * emlrtDynamicBoundsCheckR2012b
          ((int32_T)d_tmp_data[i], 0, facesCulled.size[3] - 1, &ae_emlrtBCI,
           (emlrtConstCTX)sp)];
      }
    }
  }

  facesVis_size[0] = 3;
  facesVis_size[1] = 7;
  facesVis_size[2] = loop_ub;
  loop_ub *= 21;
  if (loop_ub - 1 >= 0) {
    memcpy(&g_facesVis_data[0], &moduleInstance->c_facesVis_data[0], (uint32_T)
           loop_ub * sizeof(real_T));
  }

  loop_ub = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      loop_ub++;
    }
  }

  b_iTgt = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      b_tgtIDs_data[b_iTgt] = b_tgtIDs_data[emlrtDynamicBoundsCheckR2012b
        ((int32_T)(int16_T)b_i, 0, tgtIDs_size[1] - 1, &be_emlrtBCI,
         (emlrtConstCTX)sp)];
      b_iTgt++;
    }
  }

  b_tgtIDs_size[0] = 1;
  b_tgtIDs_size[1] = loop_ub;
  loop_ub = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      loop_ub++;
    }
  }

  b_iTgt = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      b_classIDs_data[b_iTgt] = b_classIDs_data[emlrtDynamicBoundsCheckR2012b
        ((int32_T)(int16_T)b_i, 0, classIDs_size[1] - 1, &ee_emlrtBCI,
         (emlrtConstCTX)sp)];
      b_iTgt++;
    }
  }

  b_classIDs_size[0] = 1;
  b_classIDs_size[1] = loop_ub;
  loop_ub = 0;
  b_iTgt = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    isGd = noneVis_data[b_i];
    if (!isGd) {
      loop_ub++;
      g_tmp_data[b_iTgt] = (int16_T)b_i;
      b_iTgt++;
    }
  }

  b_iTgt = xSen_size[0];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < b_iTgt; i1++) {
      c_xSen_data[i1 + b_iTgt * i] = b_xSen_data[i1 + xSen_size[0] *
        emlrtDynamicBoundsCheckR2012b((int32_T)g_tmp_data[i], 0, xSen_size[1] -
        1, &ge_emlrtBCI, (emlrtConstCTX)sp)];
    }
  }

  b_xSen_size[0] = xSen_size[0];
  b_xSen_size[1] = loop_ub;
  loop_ub *= xSen_size[0];
  if (loop_ub - 1 >= 0) {
    memcpy(&b_xSen_data[0], &c_xSen_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }
}

static void backfaceCull(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance,
  const emlrtStack *sp, coder_array_real_T_4D *polys, coder_array_real_T_4D
  *vispolys)
{
  emlrtStack st;
  int32_T isFacing_size[2];
  int32_T b_i;
  int32_T i;
  int32_T loop_ub;
  int32_T partialTrueCount;
  int32_T trueCount;
  int16_T c_tmp_data[1800];
  boolean_T isFacing_data[1800];
  boolean_T b_isFacing_data;
  st.prev = sp;
  st.tls = sp->tls;
  array_real_T_4D_SetSize(vispolys, 3, 4, 6, polys->size[3]);
  loop_ub = 72 * polys->size[3];
  for (i = 0; i < loop_ub; i++) {
    vispolys->vector.data[i] = polys->vector.data[i];
  }

  st.site = &fk_emlrtRSI;
  isFacing(moduleInstance, &st, polys, isFacing_data, isFacing_size);
  loop_ub = 6 * isFacing_size[1];
  trueCount = 0;
  partialTrueCount = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    b_isFacing_data = isFacing_data[b_i];
    if (!b_isFacing_data) {
      trueCount++;
      c_tmp_data[partialTrueCount] = (int16_T)b_i;
      partialTrueCount++;
    }
  }

  i = 6 * polys->size[3];
  for (loop_ub = 0; loop_ub < trueCount; loop_ub++) {
    for (partialTrueCount = 0; partialTrueCount < 4; partialTrueCount++) {
      for (b_i = 0; b_i < 3; b_i++) {
        vispolys->vector.data[(b_i + 3 * partialTrueCount) + 12 *
          emlrtDynamicBoundsCheckR2012b((int32_T)c_tmp_data[loop_ub], 0, i - 1,
          &he_emlrtBCI, (emlrtConstCTX)sp)] = rtNaN;
      }
    }
  }
}

static void isFacing(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp, coder_array_real_T_4D *polys, boolean_T
                     tf_data[], int32_T tf_size[2])
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 40 };

  static const int32_T iv3[2] = { 1, 39 };

  static const int32_T iv4[2] = { 1, 39 };

  static const int32_T iv5[2] = { 1, 40 };

  static char_T d_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T b_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  coder_array_boolean_T r1;
  coder_array_boolean_T_2D x;
  coder_array_real_T_2D c_n;
  coder_array_real_T_2D dp;
  coder_array_real_T_2D r;
  coder_array_real_T_3D b_n;
  coder_array_real_T_4D fmat;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  int32_T v_size[4];
  int32_T b_i;
  int32_T i;
  int32_T n;
  char_T c_u[40];
  char_T u[39];
  boolean_T guard1;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  array_real_T_4D_Constructor(&fmat);
  array_real_T_4D_SetSize(&fmat, 3, 4, 6, polys->size[3]);
  n = 72 * polys->size[3];
  for (i = 0; i < n; i++) {
    fmat.vector.data[i] = polys->vector.data[i];
  }

  array_real_T_3D_Constructor(&b_n);
  array_real_T_2D_Constructor(&dp);
  array_boolean_T_2D_Constructor(&x);
  array_real_T_2D_Constructor(&r);
  array_boolean_T_Constructor(&r1);
  array_real_T_2D_Constructor(&c_n);
  guard1 = false;
  if (polys->size[3] == 0) {
    guard1 = true;
  } else {
    n = 72 * polys->size[3];
    array_boolean_T_SetSize(&r1, n);
    for (i = 0; i < n; i++) {
      r1.vector.data[i] = muDoubleScalarIsNaN(polys->vector.data[i]);
    }

    array_boolean_T_Reserve(&r1, 21600);
    st.site = &gk_emlrtRSI;
    if (all(&st, (boolean_T *)r1.vector.data, r1.size)) {
      array_boolean_T_SetSize(&r1, r1.size[0]);
      guard1 = true;
    } else {
      array_boolean_T_SetSize(&r1, r1.size[0]);
      st.site = &hk_emlrtRSI;
      faceNorm(moduleInstance, &st, polys, &b_n);
      n = 72 * polys->size[3];
      for (b_i = 0; b_i < n; b_i++) {
        if (muDoubleScalarIsNaN(polys->vector.data[b_i])) {
          fmat.vector.data[emlrtDynamicBoundsCheckR2012b((int32_T)(int16_T)b_i,
            0, 72 * polys->size[3] - 1, &ie_emlrtBCI, (emlrtConstCTX)sp)] = 0.0;
        }
      }

      c_sum(&fmat, moduleInstance->v_data, v_size);
      if (b_n.size[1] * b_n.size[2] == 6 * v_size[3]) {
        n = b_n.size[1] * b_n.size[2];
        array_real_T_2D_SetSize(&c_n, 3, n);
        for (i = 0; i < n; i++) {
          for (b_i = 0; b_i < 3; b_i++) {
            c_n.vector.data[b_i + 3 * i] = b_n.vector.data[b_i + 3 * i] *
              moduleInstance->v_data[b_i + 3 * i];
          }
        }

        d_sum(&c_n, &r);
      } else {
        binary_expand_op_2(&r, &b_n, moduleInstance->v_data, v_size);
      }

      st.site = &ik_emlrtRSI;
      squeeze(&st, &r, &dp);
      array_boolean_T_2D_SetSize(&x, 1, dp.size[1]);
      n = dp.size[1];
      for (i = 0; i < n; i++) {
        x.vector.data[i] = ((dp.vector.data[i] < 0.0) && (!muDoubleScalarIsNaN
          (dp.vector.data[i])));
      }

      st.site = &lc_emlrtRSI;
      b_st.site = &nc_emlrtRSI;
      assertValidSizeArg(&b_st, 6.0);
      b_st.site = &nc_emlrtRSI;
      assertValidSizeArg(&b_st, (real_T)fmat.size[3]);
      n = 1;
      if (x.size[1] > 1) {
        n = x.size[1];
      }

      n = muIntScalarMax_sint32(x.size[1], n);
      if (n < 6) {
        for (i = 0; i < 39; i++) {
          u[i] = b_u[i];
        }

        y = NULL;
        m = emlrtCreateCharArray(2, &iv[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
        emlrtAssign(&y, m);
        for (i = 0; i < 39; i++) {
          u[i] = b_u[i];
        }

        d_y = NULL;
        m = emlrtCreateCharArray(2, &iv3[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
        emlrtAssign(&d_y, m);
        st.site = &qv_emlrtRSI;
        error(&st, y, getString(&st, b_message(&st, d_y, &g_emlrtMCI),
               &g_emlrtMCI), &g_emlrtMCI);
      }

      if (fmat.size[3] > n) {
        for (i = 0; i < 39; i++) {
          u[i] = b_u[i];
        }

        b_y = NULL;
        m = emlrtCreateCharArray(2, &iv1[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
        emlrtAssign(&b_y, m);
        for (i = 0; i < 39; i++) {
          u[i] = b_u[i];
        }

        e_y = NULL;
        m = emlrtCreateCharArray(2, &iv4[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
        emlrtAssign(&e_y, m);
        st.site = &qv_emlrtRSI;
        error(&st, b_y, getString(&st, b_message(&st, e_y, &g_emlrtMCI),
               &g_emlrtMCI), &g_emlrtMCI);
      }

      if (6 * fmat.size[3] != x.size[1]) {
        for (i = 0; i < 40; i++) {
          c_u[i] = d_u[i];
        }

        c_y = NULL;
        m = emlrtCreateCharArray(2, &iv2[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &c_u[0]);
        emlrtAssign(&c_y, m);
        for (i = 0; i < 40; i++) {
          c_u[i] = d_u[i];
        }

        f_y = NULL;
        m = emlrtCreateCharArray(2, &iv5[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &c_u[0]);
        emlrtAssign(&f_y, m);
        st.site = &ov_emlrtRSI;
        error(&st, c_y, getString(&st, b_message(&st, f_y, &i_emlrtMCI),
               &i_emlrtMCI), &i_emlrtMCI);
      }

      tf_size[0] = 6;
      tf_size[1] = fmat.size[3];
      n = 6 * fmat.size[3];
      if (n - 1 >= 0) {
        memcpy(&tf_data[0], &x.vector.data[0], (uint32_T)n * sizeof(boolean_T));
      }
    }
  }

  if (guard1) {
    tf_size[0] = 6;
    tf_size[1] = polys->size[3];
    n = 6 * polys->size[3];
    for (i = 0; i < n; i++) {
      tf_data[i] = false;
    }
  }

  array_real_T_2D_Destructor(&c_n);
  array_boolean_T_Destructor(&r1);
  array_real_T_2D_Destructor(&r);
  array_boolean_T_2D_Destructor(&x);
  array_real_T_2D_Destructor(&dp);
  array_real_T_3D_Destructor(&b_n);
  array_real_T_4D_Destructor(&fmat);
}

static boolean_T all(const emlrtStack *sp, boolean_T x_data[], int32_T x_size[1])
{
  static const int32_T iv[2] = { 1, 51 };

  static const int32_T iv1[2] = { 1, 51 };

  static char_T b_u[51] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'a', 'l', 'l', '_', 'o', 'r', '_',
    'a', 'n', 'y', '_', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T ix;
  char_T u[51];
  boolean_T exitg1;
  boolean_T y;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (x_size[0] != 1)) {
  } else {
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &sw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &u_emlrtMCI), &u_emlrtMCI),
          &u_emlrtMCI);
  }

  y = true;
  ix = 0;
  exitg1 = false;
  while ((!exitg1) && (ix + 1 <= x_size[0])) {
    if (!x_data[ix]) {
      y = false;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

static void faceNorm(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp, coder_array_real_T_4D *face,
                     coder_array_real_T_3D *n)
{
  static const int32_T iv2[2] = { 1, 21 };

  static const int32_T iv3[2] = { 1, 21 };

  static const int32_T iv4[2] = { 1, 39 };

  static const int32_T iv5[2] = { 1, 39 };

  static const int32_T iv6[2] = { 1, 40 };

  static const int32_T iv7[2] = { 1, 39 };

  static const int32_T iv8[2] = { 1, 39 };

  static const int32_T iv9[2] = { 1, 40 };

  static char_T f_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T b_u[21] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'p', 'm', 'a', 'x', 's', 'i', 'z', 'e' };

  coder_array_real_T_3D b_vp_data;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *m;
  const mxArray *y;
  real_T c_n;
  int32_T iv[3];
  int32_T iv1[3];
  int32_T vp_size[2];
  int32_T w1_size[2];
  int32_T w2_size[2];
  int32_T b_n;
  int32_T i;
  int32_T i1;
  int32_T nx;
  int16_T num[3];
  int16_T szOut[3];
  int16_T b_szOut;
  char_T e_u[40];
  char_T c_u[39];
  char_T u[21];
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  szOut[0] = 3;
  for (i = 0; i < 2; i++) {
    szOut[i + 1] = (int16_T)face->size[i + 2];
  }

  if (face->size[3] == 0) {
    array_real_T_3D_SetSize(n, 3, 0, (int32_T)szOut[2]);
  } else {
    iv[0] = 3;
    iv[1] = 1;
    iv[2] = 6 * face->size[3];
    iv1[0] = 3;
    iv1[1] = 1;
    iv1[2] = 6 * face->size[3];
    emlrtSizeEqCheckNDR2012b(&iv[0], &iv1[0], &l_emlrtECI, (void *)sp);
    b_n = 6 * face->size[3];
    for (i = 0; i < b_n; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        moduleInstance->w1_data[i1 + 3 * i] = face->vector.data[(i1 + 12 * i) +
          3] - face->vector.data[i1 + 12 * i];
      }
    }

    iv[0] = 3;
    iv[1] = 1;
    iv[2] = 6 * face->size[3];
    iv1[0] = 3;
    iv1[1] = 1;
    iv1[2] = 6 * face->size[3];
    emlrtSizeEqCheckNDR2012b(&iv[0], &iv1[0], &m_emlrtECI, (void *)sp);
    nx = 6 * face->size[3];
    for (i = 0; i < nx; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        moduleInstance->w2_data[i1 + 3 * i] = face->vector.data[(i1 + 12 * i) +
          6] - face->vector.data[i1 + 12 * i];
      }
    }

    w1_size[0] = 3;
    w1_size[1] = b_n;
    for (i = 0; i < b_n; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        moduleInstance->b_w1_data[i1 + 3 * i] = moduleInstance->w1_data[i1 + 3 *
          i];
      }
    }

    w2_size[0] = 3;
    w2_size[1] = nx;
    for (i = 0; i < nx; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        moduleInstance->w1_data[i1 + 3 * i] = moduleInstance->w2_data[i1 + 3 * i];
      }
    }

    st.site = &kk_emlrtRSI;
    cross(&st, moduleInstance->b_w1_data, w1_size, moduleInstance->w1_data,
          w2_size, moduleInstance->vp_data, vp_size);
    nx = 3 * vp_size[1];
    st.site = &lk_emlrtRSI;
    c_n = 1.0;
    for (b_n = 0; b_n < 3; b_n++) {
      b_szOut = szOut[b_n];
      if (b_szOut <= 0) {
        c_n = 0.0;
      } else {
        c_n *= (real_T)b_szOut;
      }
    }

    if (!(c_n <= 2.147483647E+9)) {
      for (i = 0; i < 21; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a(&st, 21, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 21; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a(&st, 21, m, &u[0]);
      emlrtAssign(&b_y, m);
      b_st.site = &tw_emlrtRSI;
      error(&b_st, y, getString(&b_st, b_message(&b_st, b_y, &gb_emlrtMCI),
             &gb_emlrtMCI), &gb_emlrtMCI);
    }

    for (i = 0; i < 3; i++) {
      num[i] = szOut[i];
    }

    b_n = 3;
    if (vp_size[1] > 3) {
      b_n = vp_size[1];
    }

    b_n = muIntScalarMax_sint32(nx, b_n);
    if (num[1] > b_n) {
      for (i = 0; i < 39; i++) {
        c_u[i] = d_u[i];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv4[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&c_y, m);
      for (i = 0; i < 39; i++) {
        c_u[i] = d_u[i];
      }

      f_y = NULL;
      m = emlrtCreateCharArray(2, &iv7[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&f_y, m);
      st.site = &qv_emlrtRSI;
      error(&st, c_y, getString(&st, b_message(&st, f_y, &g_emlrtMCI),
             &g_emlrtMCI), &g_emlrtMCI);
    }

    if (num[2] > b_n) {
      for (i = 0; i < 39; i++) {
        c_u[i] = d_u[i];
      }

      d_y = NULL;
      m = emlrtCreateCharArray(2, &iv5[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&d_y, m);
      for (i = 0; i < 39; i++) {
        c_u[i] = d_u[i];
      }

      g_y = NULL;
      m = emlrtCreateCharArray(2, &iv8[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&g_y, m);
      st.site = &qv_emlrtRSI;
      error(&st, d_y, getString(&st, b_message(&st, g_y, &g_emlrtMCI),
             &g_emlrtMCI), &g_emlrtMCI);
    }

    if (3 * num[1] * num[2] != nx) {
      for (i = 0; i < 40; i++) {
        e_u[i] = f_u[i];
      }

      e_y = NULL;
      m = emlrtCreateCharArray(2, &iv6[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &e_u[0]);
      emlrtAssign(&e_y, m);
      for (i = 0; i < 40; i++) {
        e_u[i] = f_u[i];
      }

      h_y = NULL;
      m = emlrtCreateCharArray(2, &iv9[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &e_u[0]);
      emlrtAssign(&h_y, m);
      st.site = &ov_emlrtRSI;
      error(&st, e_y, getString(&st, b_message(&st, h_y, &i_emlrtMCI),
             &i_emlrtMCI), &i_emlrtMCI);
    }

    b_vp_data.vector.data = &moduleInstance->vp_data[0];
    b_vp_data.vector.numel = 3 * szOut[1] * szOut[2];
    b_vp_data.vector.allocated = b_vp_data.vector.numel;
    b_vp_data.vector.owner = false;
    b_vp_data.size[0] = 3;
    b_vp_data.size[1] = szOut[1];
    b_vp_data.size[2] = szOut[2];
    st.site = &jk_emlrtRSI;
    unitVector(&st, &b_vp_data, n);
  }
}

static void cross(const emlrtStack *sp, real_T a_data[], int32_T a_size[2],
                  real_T b_data[], int32_T b_size[2], real_T c_data[], int32_T
                  c_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static const int32_T iv2[2] = { 1, 40 };

  static const int32_T iv3[2] = { 1, 40 };

  static char_T d_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'S', 'i', 'z',
    'e', 'M', 'a', 't', 'r', 'i', 'x', 'T', 'o', 'V', 'e', 'c', 't', 'o', 'r' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'r', 'o',
    's', 's', ':', 'I', 'n', 'p', 'u', 't', 'S', 'i', 'z', 'e', 'M', 'i', 's',
    'm', 'a', 't', 'c', 'h' };

  __m128d r;
  __m128d r1;
  __m128d r2;
  __m128d r3;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T a[2];
  real_T b[2];
  int32_T i1;
  int32_T iStart;
  int32_T nHigh;
  int32_T vectorUB;
  char_T c_u[40];
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  for (nHigh = 0; nHigh < 2; nHigh++) {
    a[nHigh] = (real_T)a_size[nHigh];
    b[nHigh] = (real_T)b_size[nHigh];
  }

  if (!isequal(a, b)) {
    for (nHigh = 0; nHigh < 30; nHigh++) {
      u[nHigh] = b_u[nHigh];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (nHigh = 0; nHigh < 30; nHigh++) {
      u[nHigh] = b_u[nHigh];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &fx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &qb_emlrtMCI), &qb_emlrtMCI),
          &qb_emlrtMCI);
  }

  c_size[0] = 3;
  c_size[1] = (int16_T)a_size[1];
  if (a_size[1] != 0) {
    if ((a_size[1] == 1) && (b_size[1] == 1)) {
      for (nHigh = 0; nHigh < 2; nHigh++) {
        a[nHigh] = (real_T)a_size[nHigh];
        b[nHigh] = (real_T)b_size[nHigh];
      }

      if (isequal(a, b)) {
      } else {
        for (nHigh = 0; nHigh < 40; nHigh++) {
          c_u[nHigh] = d_u[nHigh];
        }

        c_y = NULL;
        m = emlrtCreateCharArray(2, &iv2[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &c_u[0]);
        emlrtAssign(&c_y, m);
        for (nHigh = 0; nHigh < 40; nHigh++) {
          c_u[nHigh] = d_u[nHigh];
        }

        d_y = NULL;
        m = emlrtCreateCharArray(2, &iv3[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &c_u[0]);
        emlrtAssign(&d_y, m);
        st.site = &ex_emlrtRSI;
        error(&st, c_y, getString(&st, b_message(&st, d_y, &rb_emlrtMCI),
               &rb_emlrtMCI), &rb_emlrtMCI);
      }
    }

    nHigh = 3 * (a_size[1] - 1);
    for (iStart = 1; iStart <= nHigh + 1; iStart += 3) {
      vectorUB = iStart - 2;
      for (i1 = iStart; i1 <= vectorUB; i1 += 2) {
        r = _mm_loadu_pd(&a_data[i1]);
        r1 = _mm_loadu_pd(&b_data[i1 + 1]);
        r2 = _mm_loadu_pd(&a_data[i1 + 1]);
        r3 = _mm_loadu_pd(&b_data[i1]);
        _mm_storeu_pd(&c_data[i1 - 1], _mm_sub_pd(_mm_mul_pd(r, r1), _mm_mul_pd
          (r2, r3)));
        r = _mm_loadu_pd(&a_data[i1 + 1]);
        r1 = _mm_loadu_pd(&b_data[i1 - 1]);
        r2 = _mm_loadu_pd(&a_data[i1 - 1]);
        r3 = _mm_loadu_pd(&b_data[i1 + 1]);
        _mm_storeu_pd(&c_data[i1], _mm_sub_pd(_mm_mul_pd(r, r1), _mm_mul_pd(r2,
          r3)));
        r = _mm_loadu_pd(&a_data[i1 - 1]);
        r1 = _mm_loadu_pd(&b_data[i1]);
        r2 = _mm_loadu_pd(&a_data[i1]);
        r3 = _mm_loadu_pd(&b_data[i1 - 1]);
        _mm_storeu_pd(&c_data[i1 + 1], _mm_sub_pd(_mm_mul_pd(r, r1), _mm_mul_pd
          (r2, r3)));
      }

      for (i1 = iStart; i1 <= iStart; i1++) {
        c_data[i1 - 1] = a_data[i1] * b_data[i1 + 1] - a_data[i1 + 1] *
          b_data[i1];
        c_data[i1] = a_data[i1 + 1] * b_data[i1 - 1] - a_data[i1 - 1] *
          b_data[i1 + 1];
        c_data[i1 + 1] = a_data[i1 - 1] * b_data[i1] - a_data[i1] * b_data[i1 -
          1];
      }
    }
  }
}

static void unitVector(const emlrtStack *sp, coder_array_real_T_3D *v,
  coder_array_real_T_3D *u)
{
  coder_array_real_T_3D nm;
  emlrtStack st;
  real_T d;
  int32_T i;
  st.prev = sp;
  st.tls = sp->tls;
  if ((v->size[1] == 1) && (v->size[2] == 1)) {
    array_real_T_3D_SetSize(u, 3, 1, 1);
    st.site = &mk_emlrtRSI;
    d = e_norm(&st, v);
    for (i = 0; i < 3; i++) {
      u->vector.data[i] = v->vector.data[i] / d;
    }
  } else {
    array_real_T_3D_Constructor(&nm);
    st.site = &nk_emlrtRSI;
    colvecnorm(v, &nm);
    st.site = &ok_emlrtRSI;
    q_bsxfun(&st, v, &nm, u);
    array_real_T_3D_Destructor(&nm);
  }
}

static real_T e_norm(const emlrtStack *sp, coder_array_real_T_3D *x)
{
  static const int32_T iv[2] = { 1, 25 };

  static const int32_T iv1[2] = { 1, 25 };

  static char_T b_u[25] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'n', 'o', 'r',
    'm', ':', 'i', 'n', 'p', 'u', 't', 'M', 'u', 's', 't', 'B', 'e', '2', 'D' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  real_T y;
  int32_T i;
  char_T u[25];
  boolean_T MATRIX_INPUT_AND_P_IS_TWO;
  boolean_T VECTOR_INPUT_AND_P_IS_NUMERIC;
  st.prev = sp;
  st.tls = sp->tls;
  VECTOR_INPUT_AND_P_IS_NUMERIC = false;
  MATRIX_INPUT_AND_P_IS_TWO = false;
  if ((x->size[1] == 1) && (x->size[2] == 1)) {
    VECTOR_INPUT_AND_P_IS_NUMERIC = true;
  } else {
    MATRIX_INPUT_AND_P_IS_TWO = true;
  }

  if (x->size[2] != 1) {
    for (i = 0; i < 25; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 25, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 25; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 25, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &dx_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &sb_emlrtMCI),
           &sb_emlrtMCI), &sb_emlrtMCI);
  }

  if ((x->size[1] == 0) || (x->size[2] == 0)) {
    y = 0.0;
  } else if (MATRIX_INPUT_AND_P_IS_TWO) {
    st.site = &pk_emlrtRSI;
    y = mat2norm(&st, x);
  } else if (VECTOR_INPUT_AND_P_IS_NUMERIC) {
    y = vecpnorm(x);
  } else {
    y = rtNaN;
  }

  return y;
}

static real_T mat2norm(const emlrtStack *sp, coder_array_real_T_3D *x)
{
  emlrtStack st;
  real_T s_data[3];
  real_T absx;
  real_T y;
  int32_T s_size[1];
  int32_T b_i;
  int32_T i;
  int32_T j;
  st.prev = sp;
  st.tls = sp->tls;
  y = 0.0;
  i = x->size[1];
  for (j = 0; j < i; j++) {
    for (b_i = 0; b_i < 3; b_i++) {
      absx = muDoubleScalarAbs(x->vector.data[b_i + 3 * j]);
      if (muDoubleScalarIsNaN(absx) || (absx > y)) {
        y = absx;
      }
    }
  }

  if ((!muDoubleScalarIsInf(y)) && (!muDoubleScalarIsNaN(y))) {
    st.site = &qk_emlrtRSI;
    svd(&st, x, s_data, s_size);
    y = s_data[0];
  }

  return y;
}

static void svd(const emlrtStack *sp, coder_array_real_T_3D *A, real_T b_U_data[],
                int32_T U_size[1])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 's', 'v', 'd', '_', 'N', 'o', 'C', 'o', 'n', 'v', 'e', 'r',
    'g', 'e', 'n', 'c', 'e' };

  coder_array_real_T_3D b_A;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T b_loop_ub;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T loop_ub;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  if ((A->size[1] == 0) || (A->size[2] == 0)) {
    U_size[0] = 0;
  } else {
    array_real_T_3D_Constructor(&b_A);
    array_real_T_3D_SetSize(&b_A, 3, A->size[1], A->size[2]);
    loop_ub = A->size[2];
    for (i = 0; i < loop_ub; i++) {
      b_loop_ub = A->size[1];
      for (i1 = 0; i1 < b_loop_ub; i1++) {
        for (i2 = 0; i2 < 3; i2++) {
          b_A.vector.data[(i2 + 3 * i1) + 3 * b_A.size[1] * i] = A->vector.data
            [(i2 + 3 * i1) + 3 * A->size[1] * i];
        }
      }
    }

    st.site = &rk_emlrtRSI;
    ceval_xgesvd(&b_A, b_U_data, U_size, &loop_ub);
    array_real_T_3D_Destructor(&b_A);
    if (loop_ub > 0) {
      for (i = 0; i < 30; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 30; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &cx_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &tb_emlrtMCI),
             &tb_emlrtMCI), &tb_emlrtMCI);
    }
  }
}

static void ceval_xgesvd(coder_array_real_T_3D *A, real_T S_data[], int32_T
  S_size[1], int32_T *info)
{
  ptrdiff_t info_t;
  real_T superb_data[2];
  int32_T i;
  int32_T minnm;
  minnm = muIntScalarMin_sint32(A->size[1], 3);
  S_size[0] = minnm;
  if ((A->size[1] != 0) && (A->size[2] != 0)) {
    if (minnm > 1) {
    }

    info_t = LAPACKE_dgesvd(102, 'N', 'N', (ptrdiff_t)3, (ptrdiff_t)A->size[1],
      &A->vector.data[0], (ptrdiff_t)3, &S_data[0], NULL, (ptrdiff_t)1, NULL,
      (ptrdiff_t)1, &superb_data[0]);
    *info = (int32_T)info_t;
  } else {
    *info = 0;
  }

  if (*info < 0) {
    S_size[0] = minnm;
    for (i = 0; i < minnm; i++) {
      S_data[i] = rtNaN;
    }
  }
}

static real_T vecpnorm(coder_array_real_T_3D *x)
{
  ptrdiff_t incx_t;
  ptrdiff_t n_t;
  real_T y;
  int32_T nx;
  nx = 3 * x->size[1] * x->size[2];
  if (nx < 1) {
    y = 0.0;
  } else {
    n_t = (ptrdiff_t)nx;
    incx_t = (ptrdiff_t)1;
    y = dnrm2(&n_t, &x->vector.data[0], &incx_t);
  }

  return y;
}

static void colvecnorm(coder_array_real_T_3D *vec, coder_array_real_T_3D *nm)
{
  coder_array_real_T_3D r;
  coder_array_real_T_3D r1;
  coder_array_real_T_3D y;
  emlrtStack st;
  int32_T k;
  int32_T nx;
  int16_T iv[3];
  nx = 3 * vec->size[1] * vec->size[2];
  for (k = 0; k < 3; k++) {
    iv[k] = (int16_T)vec->size[k];
  }

  array_real_T_3D_Constructor(&y);
  array_real_T_3D_SetSize(&y, 3, (int32_T)iv[1], (int32_T)iv[2]);
  for (k = 0; k < nx; k++) {
    y.vector.data[k] = muDoubleScalarAbs(vec->vector.data[k]);
  }

  array_real_T_3D_Constructor(&r);
  b_power(&y, &r);
  array_real_T_3D_Destructor(&y);
  array_real_T_3D_Constructor(&r1);
  b_sum(&r, &r1);
  array_real_T_3D_Destructor(&r);
  st.site = &vk_emlrtRSI;
  c_sqrt(&r1, nm);
  array_real_T_3D_Destructor(&r1);
}

static void b_power(coder_array_real_T_3D *a, coder_array_real_T_3D *y)
{
  int32_T i;
  int32_T loop_ub;
  array_real_T_3D_SetSize(y, 3, a->size[1], a->size[2]);
  loop_ub = 3 * a->size[1] * a->size[2];
  for (i = 0; i < loop_ub; i++) {
    y->vector.data[i] = b_function_handle_parenReference(a->vector.data[i]);
  }
}

static real_T b_function_handle_parenReference(real_T varargin_1)
{
  return varargin_1 * varargin_1;
}

static void b_sum(coder_array_real_T_3D *x, coder_array_real_T_3D *y)
{
  int32_T i;
  int32_T loop_ub;
  int16_T sz[3];
  if ((x->size[1] == 0) || (x->size[2] == 0)) {
    for (i = 0; i < 3; i++) {
      sz[i] = (int16_T)x->size[i];
    }

    array_real_T_3D_SetSize(y, 1, (int32_T)sz[1], (int32_T)sz[2]);
    loop_ub = sz[1] * sz[2];
    for (i = 0; i < loop_ub; i++) {
      y->vector.data[i] = 0.0;
    }
  } else {
    b_sumMatrixColumns(x, y);
  }
}

static void b_sumMatrixColumns(coder_array_real_T_3D *x, coder_array_real_T_3D
  *y)
{
  int32_T col;
  int32_T ncols;
  int16_T sz[3];
  for (ncols = 0; ncols < 3; ncols++) {
    sz[ncols] = (int16_T)x->size[ncols];
  }

  array_real_T_3D_SetSize(y, 1, (int32_T)sz[1], (int32_T)sz[2]);
  ncols = x->size[1] * x->size[2];
  for (col = 0; col < ncols; col++) {
    y->vector.data[col] = d_sumColumnB(x, col + 1);
  }
}

static real_T d_sumColumnB(coder_array_real_T_3D *x, int32_T col)
{
  real_T y;
  int32_T i0;
  int32_T k;
  i0 = (col - 1) * 3;
  y = x->vector.data[i0];
  for (k = 0; k < 2; k++) {
    y += x->vector.data[(i0 + k) + 1];
  }

  return y;
}

static void c_sqrt(coder_array_real_T_3D *x, coder_array_real_T_3D *b_x)
{
  int32_T k;
  int32_T nx;
  array_real_T_3D_SetSize(b_x, 1, x->size[1], x->size[2]);
  nx = x->size[1] * x->size[2];
  for (k = 0; k < nx; k++) {
    b_x->vector.data[k] = x->vector.data[k];
  }

  array_real_T_3D_SetSize(b_x, 1, b_x->size[1], b_x->size[2]);
  nx = b_x->size[1] * b_x->size[2];
  for (k = 0; k < nx; k++) {
    b_x->vector.data[k] = muDoubleScalarSqrt(b_x->vector.data[k]);
  }
}

static void q_bsxfun(const emlrtStack *sp, coder_array_real_T_3D *a,
                     coder_array_real_T_3D *b, coder_array_real_T_3D *c)
{
  static const int32_T iv[2] = { 1, 38 };

  static const int32_T iv1[2] = { 1, 38 };

  static char_T b_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'b', 's', 'x',
    'f', 'u', 'n', ':', 'a', 'r', 'r', 'a', 'y', 'D', 'i', 'm', 'e', 'n', 's',
    'i', 'o', 'n', 's', 'M', 'u', 's', 't', 'M', 'a', 't', 'c', 'h' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T acoef;
  int32_T b_bcoef;
  int32_T b_ia;
  int32_T b_ib;
  int32_T b_k;
  int32_T bcoef;
  int32_T c_k;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ib;
  int32_T k;
  int32_T sck;
  int16_T csz_idx_1;
  char_T u[38];
  boolean_T iscompatible;
  st.prev = sp;
  st.tls = sp->tls;
  iscompatible = true;
  if (b->size[1] == 1) {
    sck = a->size[1];
  } else if (a->size[1] == 1) {
    sck = b->size[1];
  } else if (a->size[1] == b->size[1]) {
    sck = a->size[1];
  } else {
    iscompatible = false;
    if (b->size[1] < a->size[1]) {
      sck = b->size[1];
    } else {
      sck = a->size[1];
    }
  }

  csz_idx_1 = (int16_T)sck;
  if (b->size[2] == 1) {
    sck = a->size[2];
  } else if (a->size[2] == 1) {
    sck = b->size[2];
  } else if (a->size[2] == b->size[2]) {
    sck = a->size[2];
  } else {
    iscompatible = false;
    if (b->size[2] < a->size[2]) {
      sck = b->size[2];
    } else {
      sck = a->size[2];
    }
  }

  if (!iscompatible) {
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 38, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &bx_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &l_emlrtMCI), &l_emlrtMCI),
          &l_emlrtMCI);
  }

  array_real_T_3D_SetSize(c, 3, (int32_T)csz_idx_1, (int32_T)(int16_T)sck);
  if ((c->size[1] != 0) && (c->size[2] != 0)) {
    array_real_T_3D_SetSize(c, 3, c->size[1], c->size[2]);
    sck = (a->size[2] != 1);
    bcoef = (b->size[2] != 1);
    i = c->size[2];
    for (k = 0; k < i; k++) {
      ia = sck * k;
      ib = bcoef * k;
      array_real_T_3D_SetSize(c, 3, c->size[1], c->size[2]);
      acoef = (a->size[1] != 1);
      b_bcoef = (b->size[1] != 1);
      i1 = c->size[1];
      for (b_k = 0; b_k < i1; b_k++) {
        b_ia = acoef * b_k;
        b_ib = b_bcoef * b_k;
        array_real_T_3D_SetSize(c, 3, c->size[1], c->size[2]);
        for (c_k = 0; c_k < 3; c_k++) {
          array_real_T_3D_SetSize(c, 3, c->size[1], c->size[2]);
          c->vector.data[(c_k + 3 * b_k) + 3 * c->size[1] * k] = a->vector.data
            [(c_k + 3 * b_ia) + 3 * a->size[1] * ia] / b->vector.data[b_ib +
            b->size[1] * ib];
        }
      }
    }
  }
}

static void c_sum(coder_array_real_T_4D *x, real_T b_y_data[], int32_T y_size[4])
{
  if (x->size[3] == 0) {
    y_size[0] = 3;
    y_size[1] = 1;
    y_size[2] = 6;
    y_size[3] = 0;
  } else {
    colMajorFlatIter(x, b_y_data, y_size);
  }
}

static void colMajorFlatIter(coder_array_real_T_4D *x, real_T b_y_data[],
  int32_T y_size[4])
{
  int32_T i;
  int32_T iy;
  int32_T k;
  int32_T xi;
  int32_T xj;
  int32_T xoffset;
  int32_T xpageoffset;
  int32_T ypageoffset;
  y_size[0] = 3;
  y_size[1] = 1;
  y_size[2] = 6;
  y_size[3] = (int16_T)x->size[3];
  i = 6 * x->size[3];
  for (xi = 0; xi < i; xi++) {
    xpageoffset = xi * 12;
    ypageoffset = xi * 3;
    for (xj = 0; xj < 3; xj++) {
      b_y_data[ypageoffset + xj] = x->vector.data[xpageoffset + xj];
    }

    for (k = 0; k < 3; k++) {
      xoffset = (xpageoffset + (k + 1) * 3) - 1;
      for (xj = 0; xj < 3; xj++) {
        iy = ypageoffset + xj;
        b_y_data[iy] += x->vector.data[(xoffset + xj) + 1];
      }
    }
  }
}

static void d_sum(coder_array_real_T_2D *x, coder_array_real_T_2D *y)
{
  if (x->size[1] == 0) {
    array_real_T_2D_SetSize(y, 1, 0);
  } else {
    c_sumMatrixColumns(x, y);
  }
}

static void c_sumMatrixColumns(coder_array_real_T_2D *x, coder_array_real_T_2D
  *y)
{
  int32_T col;
  int32_T ncols;
  array_real_T_2D_SetSize(y, 1, x->size[1]);
  ncols = x->size[1];
  for (col = 0; col < ncols; col++) {
    y->vector.data[col] = e_sumColumnB(x, col + 1);
  }
}

static real_T e_sumColumnB(coder_array_real_T_2D *x, int32_T col)
{
  real_T y;
  int32_T i0;
  int32_T k;
  i0 = (col - 1) * 3;
  y = x->vector.data[i0];
  for (k = 0; k < 2; k++) {
    y += x->vector.data[(i0 + k) + 1];
  }

  return y;
}

static void squeeze(const emlrtStack *sp, coder_array_real_T_2D *a,
                    coder_array_real_T_2D *b)
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 39 };

  static char_T b_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  int32_T n;
  char_T u[39];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &lc_emlrtRSI;
  b_st.site = &nc_emlrtRSI;
  n = 1;
  if (a->size[1] > 1) {
    n = a->size[1];
  }

  if (a->size[1] > muIntScalarMax_sint32(a->size[1], n)) {
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &qv_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &g_emlrtMCI), &g_emlrtMCI),
          &g_emlrtMCI);
  }

  array_real_T_2D_SetSize(b, 1, a->size[1]);
  n = a->size[1];
  for (i = 0; i < n; i++) {
    b->vector.data[i] = a->vector.data[i];
  }
}

static void splitFace(const emlrtStack *sp, real_T face[12], real_T
                      infront_data[], int32_T infront_size[2])
{
  emlrtStack st;
  real_T b_fmatInfront_data[15];
  real_T fmatInfront_data[15];
  real_T c_tmp_data[12];
  real_T fmat_data[12];
  real_T vEdges_data[12];
  real_T d_tmp_data[4];
  real_T sgndist_data[4];
  real_T ex;
  int32_T b_fmatInfront_size[2];
  int32_T fmatInfront_size[2];
  int32_T fmat_size[2];
  int32_T hasIntersection_size[2];
  int32_T tmp_size[2];
  int32_T vEdges_size[2];
  int32_T b_tmp_size[1];
  int32_T sgndist_size[1];
  int32_T i;
  int32_T nz;
  boolean_T hasIntersection_data[4];
  st.prev = sp;
  st.tls = sp->tls;
  fmat_size[0] = 3;
  fmat_size[1] = 4;
  for (nz = 0; nz < 4; nz++) {
    for (i = 0; i < 3; i++) {
      fmat_data[i + 3 * nz] = face[i + 3 * nz];
    }
  }

  r_bsxfun(fmat_data, fmat_size, c_tmp_data, tmp_size);
  st.site = &md_emlrtRSI;
  g_mtimes(c_tmp_data, sgndist_data, sgndist_size);
  st.site = &xk_emlrtRSI;
  intersectionDetection(&st, fmat_data, sgndist_data, c_tmp_data, tmp_size,
                        vEdges_data, vEdges_size);
  hasIntersection_size[0] = 1;
  hasIntersection_size[1] = 4;
  for (nz = 0; nz < 4; nz++) {
    hasIntersection_data[nz] = !muDoubleScalarIsNaN(c_tmp_data[3 * nz]);
  }

  nz = b_combineVectorElements(hasIntersection_data, hasIntersection_size);
  if (nz < 2) {
    c_abs(sgndist_data, d_tmp_data, b_tmp_size);
    st.site = &yk_emlrtRSI;
    maximum(&st, d_tmp_data, b_tmp_size, &ex, &nz);
    if (sgndist_data[nz - 1] > 0.0) {
      b_fmatInfront_size[1] = 4;
      memcpy(&fmatInfront_data[0], &fmat_data[0], 12U * sizeof(real_T));
    } else {
      b_fmatInfront_size[1] = 0;
    }
  } else if (nz == 2) {
    st.site = &wk_emlrtRSI;
    assembleHalves(&st, fmat_data, sgndist_data, hasIntersection_data,
                   c_tmp_data, vEdges_data, b_fmatInfront_data, fmatInfront_size,
                   fmatInfront_data, b_fmatInfront_size);
    b_fmatInfront_size[1] = fmatInfront_size[1];
    nz = 3 * fmatInfront_size[1];
    if (nz - 1 >= 0) {
      memcpy(&fmatInfront_data[0], &b_fmatInfront_data[0], (uint32_T)nz * sizeof
             (real_T));
    }
  } else {
    b_fmatInfront_size[1] = 0;
  }

  infront_size[0] = 3;
  infront_size[1] = b_fmatInfront_size[1];
  nz = 3 * b_fmatInfront_size[1];
  if (nz - 1 >= 0) {
    memcpy(&infront_data[0], &fmatInfront_data[0], (uint32_T)nz * sizeof(real_T));
  }
}

static void r_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static real_T b_dv[3] = { 1.0E-6, 0.0, 0.0 };

  __m128d r;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 3;
  c_size[1] = (int8_T)a_size[1];
  if ((int8_T)a_size[1] != 0) {
    c_size[0] = 3;
    acoef = (a_size[1] != 1);
    i = (int8_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 3;
        r = _mm_loadu_pd(&a_data[3 * ia]);
        _mm_storeu_pd(&c_data[3 * k], _mm_sub_pd(r, _mm_loadu_pd(&b_dv[0])));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_size[0] = 3;
        c_data[3 * k + 2] = a_data[3 * ia + 2];
      }
    }
  }
}

static void g_mtimes(real_T A_data[], real_T C_data[], int32_T C_size[1])
{
  static real_T B[3] = { 1.0, 0.0, 0.0 };

  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  TRANSB1 = 'N';
  TRANSA1 = 'T';
  alpha1 = 1.0;
  beta1 = 0.0;
  m_t = (ptrdiff_t)4;
  n_t = (ptrdiff_t)1;
  k_t = (ptrdiff_t)3;
  lda_t = (ptrdiff_t)3;
  ldb_t = (ptrdiff_t)3;
  ldc_t = (ptrdiff_t)4;
  C_size[0] = 4;
  dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A_data[0], &lda_t, &B[0],
        &ldb_t, &beta1, &C_data[0], &ldc_t);
}

static void intersectionDetection(const emlrtStack *sp, real_T fmat_data[],
  real_T sgndist_data[], real_T rEdges_data[], int32_T rEdges_size[2], real_T
  vEdges_data[], int32_T vEdges_size[2])
{
  real_T i0;
  real_T i2;
  int32_T i;
  int32_T m;
  rEdges_size[0] = 3;
  rEdges_size[1] = 4;
  vEdges_size[0] = 3;
  vEdges_size[1] = 4;
  for (i = 0; i < 12; i++) {
    rEdges_data[i] = rtNaN;
    vEdges_data[i] = rtNaN;
  }

  for (m = 0; m < 4; m++) {
    i2 = b_mod((real_T)m + 1.0) + 1.0;
    i = (int32_T)emlrtIntegerCheckR2012b(i2, &f_emlrtDCI, (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(i, 1, 4, &je_emlrtBCI, (emlrtConstCTX)sp);
    if (((sgndist_data[m] < 0.0) && (sgndist_data[(int32_T)i2 - 1] > 0.0)) ||
        ((sgndist_data[m] > 0.0) && (sgndist_data[(int32_T)i2 - 1] < 0.0))) {
      for (i = 0; i < 3; i++) {
        rEdges_data[i + 3 * m] = fmat_data[i + 3 * m];
        vEdges_data[i + 3 * m] = fmat_data[i + 3 * ((int32_T)i2 - 1)] -
          fmat_data[i + 3 * m];
      }
    } else if ((sgndist_data[m] == 0.0) && (sgndist_data[(int32_T)i2 - 1] != 0.0))
    {
      i0 = b_mod(((real_T)m + 1.0) - 2.0) + 1.0;
      i = (int32_T)emlrtIntegerCheckR2012b(b_mod(((real_T)m + 1.0) - 2.0) + 1.0,
        &g_emlrtDCI, (emlrtConstCTX)sp);
      emlrtDynamicBoundsCheckR2012b(i, 1, 4, &ke_emlrtBCI, (emlrtConstCTX)sp);
      if (((sgndist_data[(int32_T)i0 - 1] < 0.0) && (sgndist_data[(int32_T)i2 -
            1] > 0.0)) || ((sgndist_data[(int32_T)i0 - 1] > 0.0) &&
                           (sgndist_data[(int32_T)i2 - 1] < 0.0))) {
        for (i = 0; i < 3; i++) {
          rEdges_data[i + 3 * m] = fmat_data[i + 3 * m];
        }
      }
    }
  }
}

static real_T b_mod(real_T x)
{
  real_T r;
  if (muDoubleScalarIsNaN(x) || muDoubleScalarIsInf(x)) {
    r = rtNaN;
  } else if (x == 0.0) {
    r = 0.0;
  } else {
    r = muDoubleScalarRem(x, 4.0);
    if (r == 0.0) {
      r = 0.0;
    } else if (r < 0.0) {
      r += 4.0;
    }
  }

  return r;
}

static int32_T b_combineVectorElements(boolean_T x_data[], int32_T x_size[2])
{
  int32_T k;
  int32_T vlen;
  int32_T y;
  vlen = x_size[1];
  if (x_size[1] == 0) {
    y = 0;
  } else {
    y = (int32_T)x_data[0];
    for (k = 2; k <= vlen; k++) {
      y += (int32_T)x_data[k - 1];
    }
  }

  return y;
}

static void c_abs(real_T x_data[], real_T b_y_data[], int32_T y_size[1])
{
  int32_T k;
  y_size[0] = 4;
  for (k = 0; k < 4; k++) {
    b_y_data[k] = muDoubleScalarAbs(x_data[k]);
  }
}

static void maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                    real_T *ex, int32_T *idx)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T b_idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (x_size[0] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x_size[0] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x_size[0];
  if (x_size[0] <= 2) {
    if (x_size[0] == 1) {
      *ex = x_data[0];
      *idx = 1;
    } else if ((x_data[0] < x_data[x_size[0] - 1]) || (muDoubleScalarIsNaN
                (x_data[0]) && (!muDoubleScalarIsNaN(x_data[x_size[0] - 1])))) {
      *ex = x_data[x_size[0] - 1];
      *idx = x_size[0];
    } else {
      *ex = x_data[0];
      *idx = 1;
    }
  } else {
    if (!muDoubleScalarIsNaN(x_data[0])) {
      *idx = 1;
    } else {
      *idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x_data[k - 1])) {
          *idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (*idx == 0) {
      *ex = x_data[0];
      *idx = 1;
    } else {
      *ex = x_data[*idx - 1];
      b_idx = *idx;
      for (k = *idx + 1; k <= last; k++) {
        if (*ex < x_data[k - 1]) {
          *ex = x_data[k - 1];
          b_idx = k;
        }
      }

      *idx = b_idx;
    }
  }
}

static void assembleHalves(const emlrtStack *sp, real_T fmat_data[], real_T
  sgndist_data[], boolean_T hasIntersection_data[], real_T rEdges_data[], real_T
  vEdges_data[], real_T fmatInfront_data[], int32_T fmatInfront_size[2], real_T
  fmatBehind_data[], int32_T fmatBehind_size[2])
{
  emlrtStack st;
  real_T b_rEdges_data[12];
  real_T b_vEdges_data[12];
  real_T f_tmp_data[12];
  real_T intPts_data[12];
  real_T iInt;
  int32_T iv[2];
  int32_T rEdges_size[2];
  int32_T tmp_size[2];
  int32_T vEdges_size[2];
  int32_T b_iInt;
  int32_T i;
  int32_T iBehind;
  int32_T iFront;
  int32_T iVert;
  int32_T partialTrueCount;
  int32_T trueCount;
  int8_T c_tmp_data[4];
  int8_T d_tmp_data[4];
  int8_T e_tmp_data[4];
  int8_T h_tmp_data[4];
  int8_T g_tmp_data;
  boolean_T isCrossing_data[4];
  boolean_T isOnPlane_data[4];
  boolean_T b_isOnPlane_data;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 4; i++) {
    b_isOnPlane_data = (muDoubleScalarIsNaN(vEdges_data[3 * i]) &&
                        hasIntersection_data[i]);
    isCrossing_data[i] = (hasIntersection_data[i] && (!b_isOnPlane_data));
    isOnPlane_data[i] = b_isOnPlane_data;
  }

  for (i = 0; i < 12; i++) {
    intPts_data[i] = rtNaN;
  }

  trueCount = 0;
  partialTrueCount = 0;
  for (iBehind = 0; iBehind < 4; iBehind++) {
    b_isOnPlane_data = isOnPlane_data[iBehind];
    if (b_isOnPlane_data) {
      trueCount++;
      c_tmp_data[partialTrueCount] = (int8_T)iBehind;
      partialTrueCount++;
    }
  }

  iFront = 0;
  partialTrueCount = 0;
  for (iBehind = 0; iBehind < 4; iBehind++) {
    b_isOnPlane_data = isOnPlane_data[iBehind];
    if (b_isOnPlane_data) {
      iFront++;
      d_tmp_data[partialTrueCount] = (int8_T)iBehind;
      partialTrueCount++;
    }
  }

  iv[0] = 3;
  iv[1] = trueCount;
  tmp_size[0] = 3;
  tmp_size[1] = iFront;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &tmp_size[0], 2, &n_emlrtECI, (void *)
    sp);
  for (i = 0; i < trueCount; i++) {
    for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
      intPts_data[partialTrueCount + 3 * c_tmp_data[i]] =
        rEdges_data[partialTrueCount + 3 * d_tmp_data[i]];
    }
  }

  trueCount = 0;
  partialTrueCount = 0;
  for (iBehind = 0; iBehind < 4; iBehind++) {
    b_isOnPlane_data = isCrossing_data[iBehind];
    if (b_isOnPlane_data) {
      trueCount++;
      c_tmp_data[partialTrueCount] = (int8_T)iBehind;
      partialTrueCount++;
    }
  }

  iFront = 0;
  partialTrueCount = 0;
  for (iBehind = 0; iBehind < 4; iBehind++) {
    b_isOnPlane_data = isCrossing_data[iBehind];
    if (b_isOnPlane_data) {
      iFront++;
      e_tmp_data[partialTrueCount] = (int8_T)iBehind;
      partialTrueCount++;
    }
  }

  rEdges_size[0] = 3;
  rEdges_size[1] = iFront;
  vEdges_size[0] = 3;
  vEdges_size[1] = iFront;
  for (i = 0; i < iFront; i++) {
    for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
      g_tmp_data = e_tmp_data[i];
      b_rEdges_data[partialTrueCount + 3 * i] = rEdges_data[partialTrueCount + 3
        * g_tmp_data];
      b_vEdges_data[partialTrueCount + 3 * i] = vEdges_data[partialTrueCount + 3
        * g_tmp_data];
    }
  }

  st.site = &al_emlrtRSI;
  intersectLinesPlane(&st, b_rEdges_data, rEdges_size, b_vEdges_data,
                      vEdges_size, f_tmp_data, tmp_size);
  iv[0] = 3;
  iv[1] = trueCount;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &tmp_size[0], 2, &o_emlrtECI, (void *)
    sp);
  for (i = 0; i < trueCount; i++) {
    for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
      intPts_data[partialTrueCount + 3 * c_tmp_data[i]] =
        f_tmp_data[partialTrueCount + 3 * i];
    }
  }

  trueCount = 0;
  partialTrueCount = 0;
  for (iBehind = 0; iBehind < 4; iBehind++) {
    if (hasIntersection_data[iBehind]) {
      trueCount++;
    }

    if (hasIntersection_data[iBehind]) {
      h_tmp_data[partialTrueCount] = (int8_T)iBehind;
      partialTrueCount++;
    }
  }

  for (i = 0; i < trueCount; i++) {
    for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
      b_rEdges_data[partialTrueCount + 3 * i] = intPts_data[partialTrueCount + 3
        * h_tmp_data[i]];
    }
  }

  partialTrueCount = 3 * trueCount;
  if (partialTrueCount - 1 >= 0) {
    memcpy(&intPts_data[0], &b_rEdges_data[0], (uint32_T)partialTrueCount *
           sizeof(real_T));
  }

  for (i = 0; i < 15; i++) {
    fmatInfront_data[i] = rtNaN;
    fmatBehind_data[i] = rtNaN;
  }

  iFront = 0;
  iBehind = 0;
  iInt = 0.0;
  for (iVert = 0; iVert < 4; iVert++) {
    if (hasIntersection_data[iVert]) {
      iInt++;
      iFront++;
      iBehind++;
      if (sgndist_data[iVert] > 0.0) {
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iFront, 1, 5,
          &pe_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatInfront_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
            iVert];
        }

        iFront++;
        b_iInt = emlrtDynamicBoundsCheckR2012b((int32_T)iInt, 1, trueCount,
          &le_emlrtBCI, (emlrtConstCTX)sp);
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iFront, 1, 5,
          &qe_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatInfront_data[i + 3 * (partialTrueCount - 1)] = intPts_data[i + 3 *
            (b_iInt - 1)];
        }

        b_iInt = emlrtDynamicBoundsCheckR2012b((int32_T)iInt, 1, trueCount,
          &me_emlrtBCI, (emlrtConstCTX)sp);
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iBehind, 1, 5,
          &ue_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatBehind_data[i + 3 * (partialTrueCount - 1)] = intPts_data[i + 3 *
            (b_iInt - 1)];
        }
      } else if (sgndist_data[iVert] < 0.0) {
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iBehind, 1, 5,
          &ve_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatBehind_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
            iVert];
        }

        iBehind++;
        b_iInt = emlrtDynamicBoundsCheckR2012b((int32_T)iInt, 1, trueCount,
          &ne_emlrtBCI, (emlrtConstCTX)sp);
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iFront, 1, 5,
          &re_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatInfront_data[i + 3 * (partialTrueCount - 1)] = intPts_data[i + 3 *
            (b_iInt - 1)];
        }

        b_iInt = emlrtDynamicBoundsCheckR2012b((int32_T)iInt, 1, trueCount,
          &oe_emlrtBCI, (emlrtConstCTX)sp);
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iBehind, 1, 5,
          &we_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatBehind_data[i + 3 * (partialTrueCount - 1)] = intPts_data[i + 3 *
            (b_iInt - 1)];
        }
      } else {
        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iFront, 1, 5,
          &se_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatInfront_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
            iVert];
        }

        partialTrueCount = emlrtDynamicBoundsCheckR2012b(iBehind, 1, 5,
          &xe_emlrtBCI, (emlrtConstCTX)sp);
        for (i = 0; i < 3; i++) {
          fmatBehind_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
            iVert];
        }
      }
    } else if (sgndist_data[iVert] > 0.0) {
      iFront++;
      partialTrueCount = emlrtDynamicBoundsCheckR2012b(iFront, 1, 5,
        &te_emlrtBCI, (emlrtConstCTX)sp);
      for (i = 0; i < 3; i++) {
        fmatInfront_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
          iVert];
      }
    } else if (sgndist_data[iVert] < 0.0) {
      iBehind++;
      partialTrueCount = emlrtDynamicBoundsCheckR2012b(iBehind, 1, 5,
        &ye_emlrtBCI, (emlrtConstCTX)sp);
      for (i = 0; i < 3; i++) {
        fmatBehind_data[i + 3 * (partialTrueCount - 1)] = fmat_data[i + 3 *
          iVert];
      }
    }
  }

  if (iFront < 1) {
    iFront = 0;
  }

  fmatInfront_size[0] = 3;
  fmatInfront_size[1] = iFront;
  if (iBehind < 1) {
    iBehind = 0;
  }

  fmatBehind_size[0] = 3;
  fmatBehind_size[1] = iBehind;
}

static void intersectLinesPlane(const emlrtStack *sp, real_T r_data[], int32_T
  r_size[2], real_T b_v_data[], int32_T v_size[2], real_T pts_data[], int32_T
  pts_size[2])
{
  static const int32_T iv[2] = { 1, 38 };

  static const int32_T iv1[2] = { 1, 38 };

  static const int32_T iv2[2] = { 1, 38 };

  static const int32_T iv3[2] = { 1, 38 };

  static const int32_T iv4[2] = { 1, 38 };

  static const int32_T iv5[2] = { 1, 38 };

  static char_T b_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'b', 's', 'x',
    'f', 'u', 'n', ':', 'a', 'r', 'r', 'a', 'y', 'D', 'i', 'm', 'e', 'n', 's',
    'i', 'o', 'n', 's', 'M', 'u', 's', 't', 'M', 'a', 't', 'c', 'h' };

  __m128d r;
  __m128d r1;
  coder_array_real_T_2D f_y;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *g_y;
  const mxArray *m;
  const mxArray *y;
  real_T c_data[12];
  real_T den_data[4];
  real_T num_data[4];
  real_T s_data[4];
  int32_T c_size[2];
  int32_T den_size[2];
  int32_T num_size[2];
  int32_T acoef;
  int32_T b_k;
  int32_T b_sck;
  int32_T bcoef;
  int32_T i;
  int32_T ia;
  int32_T ib;
  int32_T k;
  int32_T sck;
  char_T u[38];
  int8_T c_tmp_data[4];
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  dotprod(b_v_data, v_size, den_data, den_size);
  r_bsxfun(r_data, r_size, c_data, c_size);
  dotprod(c_data, c_size, num_data, num_size);
  sck = num_size[0] * num_size[1] - 1;
  ia = (sck + 1) / 2 * 2;
  ib = ia - 2;
  for (i = 0; i <= ib; i += 2) {
    r = _mm_loadu_pd(&num_data[i]);
    _mm_storeu_pd(&num_data[i], _mm_mul_pd(r, _mm_set1_pd(-1.0)));
  }

  for (i = ia; i <= sck; i++) {
    num_data[i] = -num_data[i];
  }

  st.site = &bl_emlrtRSI;
  if (den_size[1] == 1) {
    b_sck = num_size[1];
  } else if (num_size[1] == 1) {
    b_sck = den_size[1];
  } else if (num_size[1] == den_size[1]) {
    b_sck = num_size[1];
  } else {
    if (den_size[1] < num_size[1]) {
      b_sck = den_size[1];
    } else {
      b_sck = num_size[1];
    }

    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&b_y, m);
    b_st.site = &bx_emlrtRSI;
    error(&b_st, y, getString(&b_st, b_message(&b_st, b_y, &l_emlrtMCI),
           &l_emlrtMCI), &l_emlrtMCI);
  }

  sck = (int8_T)b_sck;
  if ((int8_T)b_sck != 0) {
    acoef = (num_size[1] != 1);
    bcoef = (den_size[1] != 1);
    for (k = 0; k < sck; k++) {
      s_data[k] = num_data[acoef * k] / den_data[bcoef * k];
    }
  }

  st.site = &cl_emlrtRSI;
  if (v_size[1] == 1) {
    sck = (int8_T)b_sck;
  } else if ((int8_T)b_sck == 1) {
    sck = v_size[1];
  } else if ((int8_T)b_sck == v_size[1]) {
    sck = (int8_T)b_sck;
  } else {
    if (v_size[1] < (int8_T)b_sck) {
      sck = v_size[1];
    } else {
      sck = (int8_T)b_sck;
    }

    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&d_y, m);
    b_st.site = &bx_emlrtRSI;
    error(&b_st, c_y, getString(&b_st, b_message(&b_st, d_y, &l_emlrtMCI),
           &l_emlrtMCI), &l_emlrtMCI);
  }

  if ((int8_T)sck != 0) {
    acoef = ((int8_T)b_sck != 1);
    bcoef = (v_size[1] != 1);
    i = (int8_T)sck;
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      ib = bcoef * k;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        r = _mm_loadu_pd(&b_v_data[3 * ib]);
        _mm_storeu_pd(&c_data[3 * k], _mm_mul_pd(_mm_set1_pd(s_data[ia]), r));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_data[3 * k + 2] = s_data[ia] * b_v_data[3 * ib + 2];
      }
    }
  }

  st.site = &cl_emlrtRSI;
  if ((int8_T)sck == 1) {
    b_sck = r_size[1];
  } else if (r_size[1] == 1) {
    b_sck = (int8_T)sck;
  } else if (r_size[1] == (int8_T)sck) {
    b_sck = r_size[1];
  } else {
    if ((int8_T)sck < r_size[1]) {
      b_sck = (int8_T)sck;
    } else {
      b_sck = r_size[1];
    }

    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&e_y, m);
    for (i = 0; i < 38; i++) {
      u[i] = b_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&st, 38, m, &u[0]);
    emlrtAssign(&g_y, m);
    b_st.site = &bx_emlrtRSI;
    error(&b_st, e_y, getString(&b_st, b_message(&b_st, g_y, &l_emlrtMCI),
           &l_emlrtMCI), &l_emlrtMCI);
  }

  pts_size[0] = 3;
  pts_size[1] = (int8_T)b_sck;
  if ((int8_T)b_sck != 0) {
    pts_size[0] = 3;
    acoef = (r_size[1] != 1);
    bcoef = ((int8_T)sck != 1);
    i = (int8_T)b_sck;
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      ib = bcoef * k;
      pts_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        pts_size[0] = 3;
        r = _mm_loadu_pd(&r_data[3 * ia]);
        r1 = _mm_loadu_pd(&c_data[3 * ib]);
        _mm_storeu_pd(&pts_data[3 * k], _mm_add_pd(r, r1));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        pts_size[0] = 3;
        pts_data[3 * k + 2] = r_data[3 * ia + 2] + c_data[3 * ib + 2];
      }
    }
  }

  sck = den_size[1];
  array_real_T_2D_Constructor(&f_y);
  array_real_T_2D_SetSize(&f_y, 1, (int32_T)(int8_T)den_size[1]);
  for (k = 0; k < sck; k++) {
    f_y.vector.data[k] = muDoubleScalarAbs(den_data[k]);
  }

  sck = f_y.size[1];
  ib = 0;
  ia = 0;
  for (acoef = 0; acoef < sck; acoef++) {
    if (!(f_y.vector.data[acoef] > 0.0)) {
      ib++;
    }

    if (!(f_y.vector.data[acoef] > 0.0)) {
      c_tmp_data[ia] = (int8_T)acoef;
      ia++;
    }
  }

  array_real_T_2D_Destructor(&f_y);
  for (i = 0; i < ib; i++) {
    for (sck = 0; sck < 3; sck++) {
      pts_data[sck + 3 * emlrtDynamicBoundsCheckR2012b((int32_T)c_tmp_data[i], 0,
        (int8_T)b_sck - 1, &af_emlrtBCI, (emlrtConstCTX)sp)] = rtNaN;
    }
  }
}

static void dotprod(real_T b_data[], int32_T b_size[2], real_T dp_data[],
                    int32_T dp_size[2])
{
  static int8_T iv[3] = { 1, 0, 0 };

  coder_array_real_T_2D b_c_data;
  coder_array_real_T_2D r;
  real_T c_data[12];
  int32_T b_k;
  int32_T bcoef;
  int32_T c_size_idx_1;
  int32_T ib;
  int32_T k;
  c_size_idx_1 = (int8_T)b_size[1];
  if ((int8_T)b_size[1] != 0) {
    bcoef = (b_size[1] != 1);
    for (k = 0; k < c_size_idx_1; k++) {
      ib = bcoef * k;
      for (b_k = 0; b_k < 3; b_k++) {
        c_data[b_k + 3 * k] = (real_T)iv[b_k] * b_data[b_k + 3 * ib];
      }
    }
  }

  b_c_data.vector.data = &c_data[0];
  b_c_data.vector.numel = 3 * (int8_T)b_size[1];
  b_c_data.vector.allocated = b_c_data.vector.numel;
  b_c_data.vector.owner = false;
  b_c_data.size[0] = 3;
  b_c_data.size[1] = (int8_T)b_size[1];
  array_real_T_2D_Constructor(&r);
  d_sum(&b_c_data, &r);
  dp_size[0] = 1;
  dp_size[1] = r.size[1];
  c_size_idx_1 = r.size[0] * r.size[1];
  if (c_size_idx_1 - 1 >= 0) {
    memcpy(&dp_data[0], &r.vector.data[0], (uint32_T)c_size_idx_1 * sizeof
           (real_T));
  }

  array_real_T_2D_Destructor(&r);
}

static void cart2sph(const emlrtStack *sp, coder_array_real_T_2D *x,
                     coder_array_real_T_2D *y, coder_array_real_T_2D *z,
                     coder_array_real_T_2D *az, coder_array_real_T_2D *elev)
{
  coder_array_real_T_2D hypotxy;
  coder_array_real_T_2D vx_emlrtRSI;
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;
  array_real_T_2D_Constructor(&hypotxy);
  st.site = &dl_emlrtRSI;
  b_hypot(&st, x, y, &hypotxy);
  array_real_T_2D_Constructor(&vx_emlrtRSI);
  st.site = &el_emlrtRSI;
  b_hypot(&st, &hypotxy, z, &vx_emlrtRSI);
  array_real_T_2D_Destructor(&vx_emlrtRSI);
  st.site = &fl_emlrtRSI;
  c_atan2(&st, z, &hypotxy, elev);
  array_real_T_2D_Destructor(&hypotxy);
  st.site = &gl_emlrtRSI;
  c_atan2(&st, y, x, az);
}

static void b_hypot(const emlrtStack *sp, coder_array_real_T_2D *x,
                    coder_array_real_T_2D *y, coder_array_real_T_2D *r)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T c;
  int32_T k;
  char_T u[15];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  if (x->size[1] <= y->size[1]) {
    c = x->size[1];
  } else {
    c = y->size[1];
  }

  p = true;
  if ((int16_T)c == x->size[1]) {
    if ((int16_T)c == y->size[1]) {
    } else {
      p = false;
    }
  } else {
    p = false;
  }

  if (!p) {
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &ax_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &r_emlrtMCI), &r_emlrtMCI),
          &r_emlrtMCI);
  }

  if (x->size[1] <= y->size[1]) {
    c = x->size[1];
  } else {
    c = y->size[1];
  }

  array_real_T_2D_SetSize(r, 1, (int32_T)(int16_T)c);
  c = (int16_T)c;
  for (k = 0; k < c; k++) {
    r->vector.data[k] = muDoubleScalarHypot(x->vector.data[k], y->vector.data[k]);
  }
}

static void c_atan2(const emlrtStack *sp, coder_array_real_T_2D *y,
                    coder_array_real_T_2D *x, coder_array_real_T_2D *r)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T c;
  int32_T k;
  char_T u[15];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  if (y->size[1] <= x->size[1]) {
    c = y->size[1];
  } else {
    c = x->size[1];
  }

  p = true;
  if ((int16_T)c == y->size[1]) {
    if ((int16_T)c == x->size[1]) {
    } else {
      p = false;
    }
  } else {
    p = false;
  }

  if (!p) {
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (c = 0; c < 15; c++) {
      u[c] = b_u[c];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &ax_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &r_emlrtMCI), &r_emlrtMCI),
          &r_emlrtMCI);
  }

  if (y->size[1] <= x->size[1]) {
    c = y->size[1];
  } else {
    c = x->size[1];
  }

  array_real_T_2D_SetSize(r, 1, (int32_T)(int16_T)c);
  c = (int16_T)c;
  for (k = 0; k < c; k++) {
    r->vector.data[k] = muDoubleScalarAtan2(y->vector.data[k], x->vector.data[k]);
  }
}

static void b_isfinite(real_T x[30], boolean_T b[30])
{
  real_T b_x;
  int32_T i;
  for (i = 0; i < 30; i++) {
    b_x = x[i];
    b[i] = ((!muDoubleScalarIsInf(b_x)) && (!muDoubleScalarIsNaN(b_x)));
  }
}

static int32_T c_combineVectorElements(boolean_T x[30])
{
  int32_T k;
  int32_T y;
  y = (int32_T)x[0];
  for (k = 0; k < 29; k++) {
    y += (int32_T)x[k + 1];
  }

  return y;
}

static boolean_T b_all(coder_array_real_T_2D *a)
{
  int32_T k;
  boolean_T exitg1;
  boolean_T p;
  p = true;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k <= a->size[1] - 1)) {
    if ((!muDoubleScalarIsInf(a->vector.data[k])) && (!muDoubleScalarIsNaN
         (a->vector.data[k]))) {
      k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  return p;
}

static void convhull(const emlrtStack *sp, real_T varargin_1_data[], int32_T
                     varargin_1_size[2], real_T varargin_2_data[], int32_T
                     varargin_2_size[2], real_T varargout_1_data[], int32_T
                     varargout_1_size[1])
{
  static const int32_T iv[2] = { 1, 44 };

  static const int32_T iv1[2] = { 1, 44 };

  static int32_T offsets[4] = { 0, 1, 2, 3 };

  static char_T b_u[44] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'm', 'a', 't',
    'h', 'c', 'g', 'e', 'o', '_', 'c', 'a', 't', 'a', 'l', 'o', 'g', ':', 'E',
    'm', 'p', 't', 'y', 'C', 'o', 'n', 'v', 'h', 'u', 'l', 'l', '2', 'D', 'E',
    'r', 'r', 'I', 'd' };

  coder_array_boolean_T c_pointsOffHull_data;
  coder_array_int32_T c_i;
  coder_array_int32_T ii;
  coder_array_real_T_2D c_y;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T orientedPts_data[212];
  real_T b_orientedPts_data[106];
  real_T orientPerm_data[106];
  real_T b_varargout_1_data[62];
  real_T opts_pts_data[60];
  real_T ptsLikelyOnHull_data[60];
  real_T ex;
  int32_T b_y_data[299];
  int32_T b_orientPerm_data[135];
  int32_T traversalOrder_data[135];
  int32_T hull_data[31];
  int32_T ptsPosOnHull_data[30];
  int32_T opts_pts_size[2];
  int32_T ptsLikelyOnHull_size[2];
  int32_T traversalOrder_size[2];
  int32_T orientPerm_size[1];
  int32_T orientedPts_size[1];
  int32_T pointsOffHull_size[1];
  int32_T b_i;
  int32_T end;
  int32_T i;
  int32_T i1;
  int32_T partialTrueCount;
  int32_T trueCount;
  char_T u[44];
  int8_T c_tmp_data[30];
  boolean_T b_pointsOffHull_data[30];
  boolean_T pointsOffHull_data[30];
  boolean_T expl_temp;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ml_emlrtRSI;
  parseOptions(&st, varargin_1_data, varargin_1_size, varargin_2_data,
               varargin_2_size, opts_pts_data, opts_pts_size, &expl_temp);
  st.site = &ll_emlrtRSI;
  qhullReject2D(&st, opts_pts_data, opts_pts_size, pointsOffHull_data,
                pointsOffHull_size, &expl_temp);
  if (expl_temp) {
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 44; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 44, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &yw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &xb_emlrtMCI), &xb_emlrtMCI),
          &xb_emlrtMCI);
  }

  end = pointsOffHull_size[0];
  trueCount = 0;
  partialTrueCount = 0;
  for (b_i = 0; b_i < end; b_i++) {
    expl_temp = pointsOffHull_data[b_i];
    if (!expl_temp) {
      trueCount++;
      c_tmp_data[partialTrueCount] = (int8_T)b_i;
      partialTrueCount++;
    }
  }

  ptsLikelyOnHull_size[0] = trueCount;
  ptsLikelyOnHull_size[1] = 2;
  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < trueCount; i1++) {
      ptsLikelyOnHull_data[i1 + trueCount * i] = opts_pts_data[c_tmp_data[i1] +
        opts_pts_size[0] * i];
    }
  }

  st.site = &kl_emlrtRSI;
  orient(&st, ptsLikelyOnHull_data, ptsLikelyOnHull_size, orientedPts_data,
         opts_pts_size, orientPerm_data, orientPerm_size);
  orientedPts_size[0] = opts_pts_size[0];
  partialTrueCount = opts_pts_size[0];
  for (i = 0; i < partialTrueCount; i++) {
    b_orientedPts_data[i] = orientedPts_data[i + opts_pts_size[0]];
  }

  st.site = &ol_emlrtRSI;
  minimum(&st, b_orientedPts_data, orientedPts_size, &ex, &b_i);
  array_real_T_2D_Constructor(&c_y);
  if (trueCount < b_i) {
    array_real_T_2D_SetSize(&c_y, 1, 0);
  } else {
    array_real_T_2D_SetSize(&c_y, 1, (trueCount - b_i) + 1);
    partialTrueCount = trueCount - b_i;
    for (i = 0; i <= partialTrueCount; i++) {
      c_y.vector.data[i] = (real_T)(b_i + i);
    }
  }

  if ((real_T)b_i - 1.0 < 1.0) {
    trueCount = 0;
  } else {
    trueCount = b_i - 1;
    end = (b_i - 1) / 4 * 4;
    partialTrueCount = end - 4;
    for (i = 0; i <= partialTrueCount; i += 4) {
      _mm_storeu_si128((__m128i *)&b_y_data[i], _mm_add_epi32(_mm_set1_epi32(1),
        _mm_add_epi32(_mm_set1_epi32(i), _mm_loadu_si128((const __m128i *)
        &offsets[0]))));
    }

    for (i = end; i <= b_i - 2; i++) {
      b_y_data[i] = i + 1;
    }
  }

  traversalOrder_size[0] = 1;
  traversalOrder_size[1] = c_y.size[1] + trueCount;
  partialTrueCount = c_y.size[1];
  for (i = 0; i < partialTrueCount; i++) {
    traversalOrder_data[i] = (int32_T)c_y.vector.data[i];
  }

  for (i = 0; i < trueCount; i++) {
    traversalOrder_data[i + c_y.size[1]] = b_y_data[i];
  }

  array_real_T_2D_Destructor(&c_y);
  st.site = &jl_emlrtRSI;
  indexShapeCheck(&st, orientPerm_size[0], traversalOrder_size);
  partialTrueCount = traversalOrder_size[1];
  for (i = 0; i < partialTrueCount; i++) {
    b_orientPerm_data[i] = (int32_T)orientPerm_data[traversalOrder_data[i] - 1];
  }

  grahamComputeHull(ptsLikelyOnHull_data, ptsLikelyOnHull_size,
                    b_orientPerm_data, hull_data, traversalOrder_size);
  array_int32_T_Constructor(&c_i);
  partialTrueCount = pointsOffHull_size[0];
  for (i = 0; i < partialTrueCount; i++) {
    b_pointsOffHull_data[i] = !pointsOffHull_data[i];
  }

  c_pointsOffHull_data.vector.data = &b_pointsOffHull_data[0];
  c_pointsOffHull_data.vector.numel = pointsOffHull_size[0];
  c_pointsOffHull_data.vector.allocated = pointsOffHull_size[0];
  c_pointsOffHull_data.vector.owner = false;
  c_pointsOffHull_data.size[0] = pointsOffHull_size[0];
  array_int32_T_Constructor(&ii);
  st.site = &nl_emlrtRSI;
  eml_find(&st, &c_pointsOffHull_data, &ii);
  array_int32_T_SetSize(&c_i, ii.size[0]);
  partialTrueCount = ii.size[0];
  for (i = 0; i < partialTrueCount; i++) {
    c_i.vector.data[i] = ii.vector.data[i];
  }

  if (ii.size[0] - 1 >= 0) {
    memcpy(&ptsPosOnHull_data[0], &ii.vector.data[0], (uint32_T)ii.size[0] *
           sizeof(int32_T));
  }

  array_int32_T_Destructor(&ii);
  st.site = &il_emlrtRSI;
  indexShapeCheck(&st, c_i.size[0], traversalOrder_size);
  varargout_1_size[0] = traversalOrder_size[1];
  partialTrueCount = traversalOrder_size[1];
  for (i = 0; i < partialTrueCount; i++) {
    varargout_1_data[i] = (real_T)c_i.vector.data[hull_data[i] - 1];
  }

  array_int32_T_Destructor(&c_i);
  st.site = &ol_emlrtRSI;
  minimum(&st, varargout_1_data, varargout_1_size, &ex, &b_i);
  if (b_i != 1) {
    if (b_i > traversalOrder_size[1] - 1) {
      i = 0;
      i1 = 0;
    } else {
      i = b_i - 1;
      i1 = traversalOrder_size[1] - 1;
    }

    opts_pts_size[0] = 1;
    opts_pts_size[1] = i1 - i;
    st.site = &hl_emlrtRSI;
    indexShapeCheck(&st, traversalOrder_size[1], opts_pts_size);
    opts_pts_size[0] = 1;
    opts_pts_size[1] = b_i - 1;
    st.site = &hl_emlrtRSI;
    indexShapeCheck(&st, traversalOrder_size[1], opts_pts_size);
    end = (i1 - i) + b_i;
    partialTrueCount = i1 - i;
    for (trueCount = 0; trueCount < partialTrueCount; trueCount++) {
      b_varargout_1_data[trueCount] = varargout_1_data[i + trueCount];
    }

    for (trueCount = 0; trueCount <= b_i - 2; trueCount++) {
      b_varargout_1_data[(trueCount + i1) - i] = varargout_1_data[trueCount];
    }

    b_varargout_1_data[((i1 - i) + b_i) - 1] = (real_T)
      ptsPosOnHull_data[hull_data[b_i - 1] - 1];
    varargout_1_size[0] = end;
    if (end - 1 >= 0) {
      memcpy(&varargout_1_data[0], &b_varargout_1_data[0], (uint32_T)end *
             sizeof(real_T));
    }
  }
}

static void parseOptions(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T varargin_2_data[], int32_T varargin_2_size[2],
  real_T opts_pts_data[], int32_T opts_pts_size[2], boolean_T *opts_simplify)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv10[2] = { 1, 49 };

  static const int32_T iv11[2] = { 1, 49 };

  static const int32_T iv2[2] = { 1, 30 };

  static const int32_T iv3[2] = { 1, 47 };

  static const int32_T iv4[2] = { 1, 18 };

  static const int32_T iv5[2] = { 1, 39 };

  static const int32_T iv6[2] = { 1, 46 };

  static const int32_T iv7[2] = { 1, 47 };

  static const int32_T iv8[2] = { 1, 39 };

  static const int32_T iv9[2] = { 1, 18 };

  static char_T m_u[49] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'm', 'a', 't',
    'h', 'c', 'g', 'e', 'o', '_', 'c', 'a', 't', 'a', 'l', 'o', 'g', ':', 'N',
    'o', 't', 'E', 'n', 'o', 'u', 'g', 'h', 'P', 't', 's', 'C', 'o', 'n', 'v',
    'h', 'u', 'l', 'l', 'E', 'r', 'r', 'I', 'd' };

  static char_T g_u[47] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'm', 'a', 't',
    'h', 'c', 'g', 'e', 'o', '_', 'c', 'a', 't', 'a', 'l', 'o', 'g', ':', 'M',
    'i', 'x', 'D', 'i', 'm', 'D', 'a', 't', 'a', 'P', 't', 'C', 'o', 'o', 'r',
    'd', 's', 'E', 'r', 'r', 'I', 'd' };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T j_u[39] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'a', 't',
    'e', 'n', 'a', 't', 'e', ':', 'm', 'a', 't', 'r', 'i', 'x', 'D', 'i', 'm',
    'e', 'n', 's', 'i', 'o', 'n', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'o', 'n',
    'v', 'h', 'u', 'l', 'l', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T h_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '1', ',', ' ', 'x', ',' };

  static char_T k_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '2', ',', ' ', 'y', ',' };

  coder_array_real_T_2D b_varargin_1_data;
  coder_array_real_T_2D b_varargin_2_data;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  int32_T varargin_1_idx_0;
  int32_T varargin_2_idx_0;
  char_T l_u[49];
  char_T e_u[47];
  char_T c_u[46];
  char_T i_u[39];
  char_T u[30];
  char_T f_u[18];
  boolean_T b;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ql_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &ib_emlrtRSI;
  b_varargin_1_data.vector.data = &varargin_1_data[0];
  b_varargin_1_data.vector.numel = varargin_1_size[0] * varargin_1_size[1];
  b_varargin_1_data.vector.allocated = b_varargin_1_data.vector.numel;
  b_varargin_1_data.vector.owner = false;
  b_varargin_1_data.size[0] = varargin_1_size[0];
  b_varargin_1_data.size[1] = varargin_1_size[1];
  b = b_all(&b_varargin_1_data);
  if (!b) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 18; i++) {
      f_u[i] = h_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&b_st, 18, m, &f_u[0]);
    emlrtAssign(&e_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, b_y, e_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &rl_emlrtRSI;
  b_st.site = &ib_emlrtRSI;
  b_varargin_2_data.vector.data = &varargin_2_data[0];
  b_varargin_2_data.vector.numel = varargin_2_size[0] * varargin_2_size[1];
  b_varargin_2_data.vector.allocated = b_varargin_2_data.vector.numel;
  b_varargin_2_data.vector.owner = false;
  b_varargin_2_data.size[0] = varargin_2_size[0];
  b_varargin_2_data.size[1] = varargin_2_size[1];
  b = b_all(&b_varargin_2_data);
  if (!b) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 30, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&g_y, m);
    for (i = 0; i < 18; i++) {
      f_u[i] = k_u[i];
    }

    j_y = NULL;
    m = emlrtCreateCharArray(2, &iv9[0]);
    emlrtInitCharArrayR2013a(&b_st, 18, m, &f_u[0]);
    emlrtAssign(&j_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, c_y, getString(&c_st, message(&c_st, g_y, j_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  if (varargin_1_size[1] != varargin_2_size[1]) {
    for (i = 0; i < 47; i++) {
      e_u[i] = g_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 47, m, &e_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 47; i++) {
      e_u[i] = g_u[i];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 47, m, &e_u[0]);
    emlrtAssign(&h_y, m);
    st.site = &xw_emlrtRSI;
    error(&st, d_y, getString(&st, b_message(&st, h_y, &yb_emlrtMCI),
           &yb_emlrtMCI), &yb_emlrtMCI);
  }

  b = true;
  if (varargin_2_size[1] != varargin_1_size[1]) {
    b = false;
  }

  if (!b) {
    for (i = 0; i < 39; i++) {
      i_u[i] = j_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &i_u[0]);
    emlrtAssign(&f_y, m);
    for (i = 0; i < 39; i++) {
      i_u[i] = j_u[i];
    }

    i_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &i_u[0]);
    emlrtAssign(&i_y, m);
    st.site = &lw_emlrtRSI;
    error(&st, f_y, getString(&st, b_message(&st, i_y, &t_emlrtMCI), &t_emlrtMCI),
          &t_emlrtMCI);
  }

  varargin_1_idx_0 = varargin_1_size[1];
  varargin_2_idx_0 = varargin_2_size[1];
  opts_pts_size[0] = varargin_1_size[1];
  opts_pts_size[1] = 2;
  for (i = 0; i < varargin_1_idx_0; i++) {
    opts_pts_data[i] = varargin_1_data[i];
  }

  for (i = 0; i < varargin_2_idx_0; i++) {
    opts_pts_data[i + varargin_1_idx_0] = varargin_2_data[i];
  }

  *opts_simplify = true;
  if (varargin_1_size[1] < 3) {
    for (i = 0; i < 49; i++) {
      l_u[i] = m_u[i];
    }

    k_y = NULL;
    m = emlrtCreateCharArray(2, &iv10[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 49, m, &l_u[0]);
    emlrtAssign(&k_y, m);
    for (i = 0; i < 49; i++) {
      l_u[i] = m_u[i];
    }

    l_y = NULL;
    m = emlrtCreateCharArray(2, &iv11[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 49, m, &l_u[0]);
    emlrtAssign(&l_y, m);
    st.site = &ww_emlrtRSI;
    error(&st, k_y, getString(&st, b_message(&st, l_y, &ac_emlrtMCI),
           &ac_emlrtMCI), &ac_emlrtMCI);
  }
}

static void qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1],
  boolean_T *ptsAreCollinear)
{
  coder_array_boolean_T b_northPts_data;
  coder_array_boolean_T b_southPts_data;
  coder_array_int32_T ii;
  emlrtStack st;
  real_T f_pts_data[60];
  real_T b_pts_data[30];
  real_T c_pts_data[2];
  real_T d_pts_data[2];
  real_T e_pts_data[2];
  real_T farthestNorth_data[1];
  real_T farthestSouth_data[1];
  real_T ex;
  int32_T d_tmp_data[30];
  int32_T d_pts_size[2];
  int32_T e_pts_size[2];
  int32_T farthestNorth_size[2];
  int32_T farthestSouth_size[2];
  int32_T b_pts_size[1];
  int32_T c_pts_size[1];
  int32_T ptsInNorthTria_size[1];
  int32_T ptsInSouthTria_size[1];
  int32_T southPts_size[1];
  int32_T b_idx;
  int32_T i;
  int32_T idx;
  int32_T loop_ub;
  int8_T c_tmp_data[30];
  int8_T e_tmp_data[30];
  boolean_T northPts_data[30];
  boolean_T ptsInNorthTria_data[30];
  boolean_T ptsInSouthTria_data[30];
  boolean_T southPts_data[30];
  boolean_T b_ptsInNorthTria_data;
  st.prev = sp;
  st.tls = sp->tls;
  array_int32_T_Constructor(&ii);
  if (pts_size[0] == 0) {
    *ptsAreCollinear = false;
    ptsOffHull_size[0] = 0;
  } else {
    b_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &ol_emlrtRSI;
    minimum(&st, b_pts_data, b_pts_size, &ex, &idx);
    c_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &yk_emlrtRSI;
    maximum(&st, b_pts_data, c_pts_size, &ex, &b_idx);
    st.site = &sl_emlrtRSI;
    getFarthestPoints(&st, pts_data, pts_size, (real_T)idx, (real_T)b_idx,
                      farthestNorth_data, farthestNorth_size, farthestSouth_data,
                      farthestSouth_size, northPts_data, c_pts_size,
                      southPts_data, southPts_size, ptsAreCollinear);
    if (*ptsAreCollinear) {
      ptsOffHull_size[0] = pts_size[0];
      loop_ub = pts_size[0];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[i] = false;
      }
    } else {
      ptsInNorthTria_size[0] = 0;
      if ((farthestNorth_size[0] != 0) && (farthestNorth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestNorth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInNorthTria_data, ptsInNorthTria_size);
      }

      ptsInSouthTria_size[0] = 0;
      if ((farthestSouth_size[0] != 0) && (farthestSouth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestSouth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInSouthTria_data, ptsInSouthTria_size);
      }

      ptsOffHull_size[0] = southPts_size[0];
      if (southPts_size[0] - 1 >= 0) {
        memcpy(&ptsOffHull_data[0], &southPts_data[0], (uint32_T)southPts_size[0]
               * sizeof(boolean_T));
      }

      if (ptsInNorthTria_size[0] != 0) {
        ptsOffHull_size[0] = southPts_size[0];
        loop_ub = southPts_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (southPts_data[i] || ptsInNorthTria_data[i]);
        }
      }

      if (ptsInSouthTria_size[0] != 0) {
        loop_ub = ptsOffHull_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (ptsOffHull_data[i] || ptsInSouthTria_data[i]);
        }
      }

      ptsOffHull_data[idx - 1] = false;
      ptsOffHull_data[b_idx - 1] = false;
      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestNorth_data[i];
      }

      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestSouth_data[i];
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }

      b_northPts_data.vector.data = &northPts_data[0];
      b_northPts_data.vector.numel = c_pts_size[0];
      b_northPts_data.vector.allocated = c_pts_size[0];
      b_northPts_data.vector.owner = false;
      b_northPts_data.size[0] = c_pts_size[0];
      st.site = &nl_emlrtRSI;
      eml_find(&st, &b_northPts_data, &ii);
      idx = c_pts_size[0];
      loop_ub = 0;
      for (i = 0; i < idx; i++) {
        if (northPts_data[i]) {
          loop_ub++;
        }
      }

      b_idx = 0;
      for (i = 0; i < idx; i++) {
        if (northPts_data[i]) {
          c_tmp_data[b_idx] = (int8_T)i;
          b_idx++;
        }
      }

      d_pts_size[0] = loop_ub;
      d_pts_size[1] = 2;
      for (i = 0; i < 2; i++) {
        for (idx = 0; idx < loop_ub; idx++) {
          f_pts_data[idx + loop_ub * i] = pts_data[c_tmp_data[idx] + pts_size[0]
            * i];
        }
      }

      st.site = &tl_emlrtRSI;
      b_qhullReject2D(&st, f_pts_data, d_pts_size, ptsInNorthTria_data,
                      ptsInNorthTria_size);
      idx = ptsInNorthTria_size[0];
      loop_ub = 0;
      b_idx = 0;
      for (i = 0; i < idx; i++) {
        b_ptsInNorthTria_data = ptsInNorthTria_data[i];
        if (b_ptsInNorthTria_data) {
          loop_ub++;
          d_tmp_data[b_idx] = ii.vector.data[(int8_T)i];
          b_idx++;
        }
      }

      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[d_tmp_data[i] - 1] = true;
      }

      loop_ub = southPts_size[0];
      for (i = 0; i < loop_ub; i++) {
        southPts_data[i] = ((!southPts_data[i]) && (!northPts_data[i]));
      }

      b_southPts_data.vector.data = &southPts_data[0];
      b_southPts_data.vector.numel = southPts_size[0];
      b_southPts_data.vector.allocated = southPts_size[0];
      b_southPts_data.vector.owner = false;
      b_southPts_data.size[0] = southPts_size[0];
      st.site = &nl_emlrtRSI;
      eml_find(&st, &b_southPts_data, &ii);
      idx = southPts_size[0];
      loop_ub = 0;
      for (i = 0; i < idx; i++) {
        if (southPts_data[i]) {
          loop_ub++;
        }
      }

      b_idx = 0;
      for (i = 0; i < idx; i++) {
        if (southPts_data[i]) {
          e_tmp_data[b_idx] = (int8_T)i;
          b_idx++;
        }
      }

      e_pts_size[0] = loop_ub;
      e_pts_size[1] = 2;
      for (i = 0; i < 2; i++) {
        for (idx = 0; idx < loop_ub; idx++) {
          f_pts_data[idx + loop_ub * i] = pts_data[e_tmp_data[idx] + pts_size[0]
            * i];
        }
      }

      st.site = &ul_emlrtRSI;
      b_qhullReject2D(&st, f_pts_data, e_pts_size, ptsInNorthTria_data,
                      ptsInNorthTria_size);
      idx = ptsInNorthTria_size[0];
      loop_ub = 0;
      b_idx = 0;
      for (i = 0; i < idx; i++) {
        b_ptsInNorthTria_data = ptsInNorthTria_data[i];
        if (b_ptsInNorthTria_data) {
          loop_ub++;
          d_tmp_data[b_idx] = ii.vector.data[(int8_T)i];
          b_idx++;
        }
      }

      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[d_tmp_data[i] - 1] = true;
      }
    }
  }

  array_int32_T_Destructor(&ii);
}

static void minimum(const emlrtStack *sp, real_T x_data[], int32_T x_size[1],
                    real_T *ex, int32_T *idx)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T b_idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (x_size[0] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x_size[0] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x_size[0];
  if (x_size[0] <= 2) {
    if (x_size[0] == 1) {
      *ex = x_data[0];
      *idx = 1;
    } else if ((x_data[0] > x_data[x_size[0] - 1]) || (muDoubleScalarIsNaN
                (x_data[0]) && (!muDoubleScalarIsNaN(x_data[x_size[0] - 1])))) {
      *ex = x_data[x_size[0] - 1];
      *idx = x_size[0];
    } else {
      *ex = x_data[0];
      *idx = 1;
    }
  } else {
    if (!muDoubleScalarIsNaN(x_data[0])) {
      *idx = 1;
    } else {
      *idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x_data[k - 1])) {
          *idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (*idx == 0) {
      *ex = x_data[0];
      *idx = 1;
    } else {
      *ex = x_data[*idx - 1];
      b_idx = *idx;
      for (k = *idx + 1; k <= last; k++) {
        if (*ex > x_data[k - 1]) {
          *ex = x_data[k - 1];
          b_idx = k;
        }
      }

      *idx = b_idx;
    }
  }
}

static void getFarthestPoints(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], real_T pt1, real_T pt2, real_T farthestNorth_data[], int32_T
  farthestNorth_size[2], real_T farthestSouth_data[], int32_T
  farthestSouth_size[2], boolean_T northPts_data[], int32_T northPts_size[1],
  boolean_T linePts_data[], int32_T linePts_size[1], boolean_T *collinearPts)
{
  emlrtStack st;
  real_T distVector_data[30];
  real_T a;
  real_T b;
  real_T b_distVector_data;
  real_T c;
  int32_T distVector_size[1];
  int32_T i;
  int32_T idx;
  st.prev = sp;
  st.tls = sp->tls;
  a = pts_data[((int32_T)pt1 + pts_size[0]) - 1] - pts_data[((int32_T)pt2 +
    pts_size[0]) - 1];
  b = pts_data[(int32_T)pt2 - 1] - pts_data[(int32_T)pt1 - 1];
  c = pts_data[((int32_T)pt2 + pts_size[0]) - 1] * -b - pts_data[(int32_T)pt2 -
    1] * a;
  idx = pts_size[0];
  distVector_size[0] = pts_size[0];
  northPts_size[0] = pts_size[0];
  linePts_size[0] = pts_size[0];
  for (i = 0; i < idx; i++) {
    b_distVector_data = (a * pts_data[i] + b * pts_data[i + pts_size[0]]) + c;
    northPts_data[i] = (b_distVector_data > 0.0);
    linePts_data[i] = (b_distVector_data == 0.0);
    distVector_data[i] = b_distVector_data;
  }

  st.site = &ol_emlrtRSI;
  minimum(&st, distVector_data, distVector_size, &a, &idx);
  st.site = &yk_emlrtRSI;
  maximum(&st, distVector_data, distVector_size, &b, &i);
  farthestNorth_size[0] = 0;
  farthestNorth_size[1] = 0;
  if (((real_T)i != pt1) && ((real_T)i != pt2)) {
    farthestNorth_size[0] = 1;
    farthestNorth_size[1] = 1;
    farthestNorth_data[0] = (real_T)i;
  }

  farthestSouth_size[0] = 0;
  farthestSouth_size[1] = 0;
  if (((real_T)idx != pt1) && ((real_T)idx != pt2)) {
    farthestSouth_size[0] = 1;
    farthestSouth_size[1] = 1;
    farthestSouth_data[0] = (real_T)idx;
  }

  *collinearPts = (b == a);
}

static void markPtsInTria(real_T pts_data[], int32_T pts_size[2], real_T a_data[],
  real_T b_data[], real_T c_data[], boolean_T ptsInTria_data[], int32_T
  ptsInTria_size[1])
{
  __m128d r;
  __m128d r1;
  __m128d r2;
  real_T centeroid_data[2];
  real_T slope_ab;
  real_T slope_bc;
  real_T slope_ca;
  int32_T b_i;
  int32_T i;
  boolean_T centeroid_parity_ab_b;
  boolean_T centeroid_parity_bc_b;
  boolean_T centeroid_parity_ca_b;
  slope_ab = (b_data[1] - a_data[1]) / (b_data[0] - a_data[0]);
  slope_bc = (c_data[1] - b_data[1]) / (c_data[0] - b_data[0]);
  slope_ca = (a_data[1] - c_data[1]) / (a_data[0] - c_data[0]);
  if (muDoubleScalarIsInf(slope_ab) || muDoubleScalarIsInf(slope_bc) ||
      muDoubleScalarIsInf(slope_ca)) {
    ptsInTria_size[0] = pts_size[0];
    b_i = pts_size[0];
    for (i = 0; i < b_i; i++) {
      ptsInTria_data[i] = false;
    }
  } else {
    for (i = 0; i <= 0; i += 2) {
      r = _mm_loadu_pd(&a_data[0]);
      r1 = _mm_loadu_pd(&b_data[0]);
      r2 = _mm_loadu_pd(&c_data[0]);
      _mm_storeu_pd(&centeroid_data[0], _mm_div_pd(_mm_add_pd(_mm_add_pd(r, r1),
        r2), _mm_set1_pd(3.0)));
    }

    centeroid_parity_ab_b = (slope_ab * (centeroid_data[0] - a_data[0]) -
      (centeroid_data[1] - a_data[1]) < 0.0);
    centeroid_parity_bc_b = (slope_bc * (centeroid_data[0] - b_data[0]) -
      (centeroid_data[1] - b_data[1]) < 0.0);
    centeroid_parity_ca_b = (slope_ca * (centeroid_data[0] - c_data[0]) -
      (centeroid_data[1] - c_data[1]) < 0.0);
    i = pts_size[0];
    ptsInTria_size[0] = pts_size[0];
    for (b_i = 0; b_i < i; b_i++) {
      ptsInTria_data[b_i] = (((slope_ab * (pts_data[b_i] - a_data[0]) -
        (pts_data[b_i + pts_size[0]] - a_data[1]) < 0.0) == (int32_T)
        centeroid_parity_ab_b) && ((slope_bc * (pts_data[b_i] - b_data[0]) -
        (pts_data[b_i + pts_size[0]] - b_data[1]) < 0.0) == (int32_T)
        centeroid_parity_bc_b) && ((slope_ca * (pts_data[b_i] - c_data[0]) -
        (pts_data[b_i + pts_size[0]] - c_data[1]) < 0.0) == (int32_T)
        centeroid_parity_ca_b));
    }
  }
}

static void eml_find(const emlrtStack *sp, coder_array_boolean_T *x,
                     coder_array_int32_T *i)
{
  static const int32_T iv1[2] = { 1, 30 };

  static const int32_T iv2[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'b', 'u', 'i', 'l',
    't', 'i', 'n', 's', ':', 'A', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', 'F',
    'a', 'i', 'l', 'e', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T iv[2];
  int32_T idx;
  int32_T ii;
  int32_T nx;
  char_T u[30];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  nx = x->size[0];
  idx = 0;
  array_int32_T_SetSize(i, x->size[0]);
  ii = 1;
  exitg1 = false;
  while ((!exitg1) && (ii - 1 <= nx - 1)) {
    if (x->vector.data[ii - 1]) {
      idx++;
      i->vector.data[idx - 1] = ii;
      if (idx >= nx) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (idx > x->size[0]) {
    for (nx = 0; nx < 30; nx++) {
      u[nx] = b_u[nx];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (nx = 0; nx < 30; nx++) {
      u[nx] = b_u[nx];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &pw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &bc_emlrtMCI), &bc_emlrtMCI),
          &bc_emlrtMCI);
  }

  if (x->size[0] == 1) {
    if (idx == 0) {
      array_int32_T_SetSize(i, 0);
    }
  } else {
    if (idx < 1) {
      idx = 0;
    }

    iv[0] = 1;
    iv[1] = idx;
    st.site = &vl_emlrtRSI;
    indexShapeCheck(&st, i->size[0], iv);
    array_int32_T_SetSize(i, idx);
  }
}

static void b_qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1])
{
  coder_array_boolean_T b_northPts_data;
  coder_array_boolean_T b_southPts_data;
  coder_array_int32_T ii;
  emlrtStack st;
  real_T f_pts_data[60];
  real_T b_pts_data[30];
  real_T c_pts_data[2];
  real_T d_pts_data[2];
  real_T e_pts_data[2];
  real_T farthestNorth_data[1];
  real_T farthestSouth_data[1];
  real_T ex;
  int32_T d_tmp_data[30];
  int32_T d_pts_size[2];
  int32_T e_pts_size[2];
  int32_T farthestNorth_size[2];
  int32_T farthestSouth_size[2];
  int32_T b_pts_size[1];
  int32_T c_pts_size[1];
  int32_T ptsInNorthTria_size[1];
  int32_T ptsInSouthTria_size[1];
  int32_T southPts_size[1];
  int32_T b_idx;
  int32_T i;
  int32_T idx;
  int32_T loop_ub;
  int8_T c_tmp_data[30];
  int8_T e_tmp_data[30];
  boolean_T northPts_data[30];
  boolean_T ptsInNorthTria_data[30];
  boolean_T ptsInSouthTria_data[30];
  boolean_T southPts_data[30];
  boolean_T ptsAreCollinear;
  st.prev = sp;
  st.tls = sp->tls;
  array_int32_T_Constructor(&ii);
  if (pts_size[0] == 0) {
    ptsOffHull_size[0] = 0;
  } else {
    b_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &ol_emlrtRSI;
    minimum(&st, b_pts_data, b_pts_size, &ex, &idx);
    c_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &yk_emlrtRSI;
    maximum(&st, b_pts_data, c_pts_size, &ex, &b_idx);
    st.site = &sl_emlrtRSI;
    getFarthestPoints(&st, pts_data, pts_size, (real_T)idx, (real_T)b_idx,
                      farthestNorth_data, farthestNorth_size, farthestSouth_data,
                      farthestSouth_size, northPts_data, c_pts_size,
                      southPts_data, southPts_size, &ptsAreCollinear);
    if (ptsAreCollinear) {
      ptsOffHull_size[0] = pts_size[0];
      loop_ub = pts_size[0];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[i] = false;
      }
    } else {
      ptsInNorthTria_size[0] = 0;
      if ((farthestNorth_size[0] != 0) && (farthestNorth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestNorth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInNorthTria_data, ptsInNorthTria_size);
      }

      ptsInSouthTria_size[0] = 0;
      if ((farthestSouth_size[0] != 0) && (farthestSouth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestSouth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInSouthTria_data, ptsInSouthTria_size);
      }

      ptsOffHull_size[0] = southPts_size[0];
      if (southPts_size[0] - 1 >= 0) {
        memcpy(&ptsOffHull_data[0], &southPts_data[0], (uint32_T)southPts_size[0]
               * sizeof(boolean_T));
      }

      if (ptsInNorthTria_size[0] != 0) {
        ptsOffHull_size[0] = southPts_size[0];
        loop_ub = southPts_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (southPts_data[i] || ptsInNorthTria_data[i]);
        }
      }

      if (ptsInSouthTria_size[0] != 0) {
        loop_ub = ptsOffHull_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (ptsOffHull_data[i] || ptsInSouthTria_data[i]);
        }
      }

      ptsOffHull_data[idx - 1] = false;
      ptsOffHull_data[b_idx - 1] = false;
      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestNorth_data[i];
      }

      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestSouth_data[i];
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }

      b_northPts_data.vector.data = &northPts_data[0];
      b_northPts_data.vector.numel = c_pts_size[0];
      b_northPts_data.vector.allocated = c_pts_size[0];
      b_northPts_data.vector.owner = false;
      b_northPts_data.size[0] = c_pts_size[0];
      st.site = &nl_emlrtRSI;
      eml_find(&st, &b_northPts_data, &ii);
      idx = c_pts_size[0];
      loop_ub = 0;
      for (i = 0; i < idx; i++) {
        if (northPts_data[i]) {
          loop_ub++;
        }
      }

      b_idx = 0;
      for (i = 0; i < idx; i++) {
        if (northPts_data[i]) {
          c_tmp_data[b_idx] = (int8_T)i;
          b_idx++;
        }
      }

      d_pts_size[0] = loop_ub;
      d_pts_size[1] = 2;
      for (i = 0; i < 2; i++) {
        for (idx = 0; idx < loop_ub; idx++) {
          f_pts_data[idx + loop_ub * i] = pts_data[c_tmp_data[idx] + pts_size[0]
            * i];
        }
      }

      st.site = &tl_emlrtRSI;
      c_qhullReject2D(&st, f_pts_data, d_pts_size, ptsInNorthTria_data,
                      ptsInNorthTria_size);
      idx = ptsInNorthTria_size[0];
      loop_ub = 0;
      b_idx = 0;
      for (i = 0; i < idx; i++) {
        ptsAreCollinear = ptsInNorthTria_data[i];
        if (ptsAreCollinear) {
          loop_ub++;
          d_tmp_data[b_idx] = ii.vector.data[(int8_T)i];
          b_idx++;
        }
      }

      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[d_tmp_data[i] - 1] = true;
      }

      loop_ub = southPts_size[0];
      for (i = 0; i < loop_ub; i++) {
        southPts_data[i] = ((!southPts_data[i]) && (!northPts_data[i]));
      }

      b_southPts_data.vector.data = &southPts_data[0];
      b_southPts_data.vector.numel = southPts_size[0];
      b_southPts_data.vector.allocated = southPts_size[0];
      b_southPts_data.vector.owner = false;
      b_southPts_data.size[0] = southPts_size[0];
      st.site = &nl_emlrtRSI;
      eml_find(&st, &b_southPts_data, &ii);
      idx = southPts_size[0];
      loop_ub = 0;
      for (i = 0; i < idx; i++) {
        if (southPts_data[i]) {
          loop_ub++;
        }
      }

      b_idx = 0;
      for (i = 0; i < idx; i++) {
        if (southPts_data[i]) {
          e_tmp_data[b_idx] = (int8_T)i;
          b_idx++;
        }
      }

      e_pts_size[0] = loop_ub;
      e_pts_size[1] = 2;
      for (i = 0; i < 2; i++) {
        for (idx = 0; idx < loop_ub; idx++) {
          f_pts_data[idx + loop_ub * i] = pts_data[e_tmp_data[idx] + pts_size[0]
            * i];
        }
      }

      st.site = &ul_emlrtRSI;
      c_qhullReject2D(&st, f_pts_data, e_pts_size, ptsInNorthTria_data,
                      ptsInNorthTria_size);
      idx = ptsInNorthTria_size[0];
      loop_ub = 0;
      b_idx = 0;
      for (i = 0; i < idx; i++) {
        ptsAreCollinear = ptsInNorthTria_data[i];
        if (ptsAreCollinear) {
          loop_ub++;
          d_tmp_data[b_idx] = ii.vector.data[(int8_T)i];
          b_idx++;
        }
      }

      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[d_tmp_data[i] - 1] = true;
      }
    }
  }

  array_int32_T_Destructor(&ii);
}

static void c_qhullReject2D(const emlrtStack *sp, real_T pts_data[], int32_T
  pts_size[2], boolean_T ptsOffHull_data[], int32_T ptsOffHull_size[1])
{
  emlrtStack st;
  real_T b_pts_data[30];
  real_T c_pts_data[2];
  real_T d_pts_data[2];
  real_T e_pts_data[2];
  real_T farthestNorth_data[1];
  real_T farthestSouth_data[1];
  real_T ex;
  int32_T farthestNorth_size[2];
  int32_T farthestSouth_size[2];
  int32_T b_pts_size[1];
  int32_T c_pts_size[1];
  int32_T ptsInSouthTria_size[1];
  int32_T b_idx;
  int32_T i;
  int32_T idx;
  int32_T loop_ub;
  boolean_T ptsInNorthTria_data[30];
  boolean_T ptsInSouthTria_data[30];
  boolean_T ptsAreCollinear;
  st.prev = sp;
  st.tls = sp->tls;
  if (pts_size[0] == 0) {
    ptsOffHull_size[0] = 0;
  } else {
    b_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &ol_emlrtRSI;
    minimum(&st, b_pts_data, b_pts_size, &ex, &idx);
    c_pts_size[0] = pts_size[0];
    if (pts_size[0] - 1 >= 0) {
      memcpy(&b_pts_data[0], &pts_data[0], (uint32_T)pts_size[0] * sizeof(real_T));
    }

    st.site = &yk_emlrtRSI;
    maximum(&st, b_pts_data, c_pts_size, &ex, &b_idx);
    st.site = &sl_emlrtRSI;
    getFarthestPoints(&st, pts_data, pts_size, (real_T)idx, (real_T)b_idx,
                      farthestNorth_data, farthestNorth_size, farthestSouth_data,
                      farthestSouth_size, ptsInNorthTria_data, b_pts_size,
                      ptsOffHull_data, ptsOffHull_size, &ptsAreCollinear);
    if (ptsAreCollinear) {
      ptsOffHull_size[0] = pts_size[0];
      loop_ub = pts_size[0];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[i] = false;
      }
    } else {
      b_pts_size[0] = 0;
      if ((farthestNorth_size[0] != 0) && (farthestNorth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestNorth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInNorthTria_data, b_pts_size);
      }

      ptsInSouthTria_size[0] = 0;
      if ((farthestSouth_size[0] != 0) && (farthestSouth_size[1] != 0)) {
        for (i = 0; i < 2; i++) {
          c_pts_data[i] = pts_data[(idx + pts_size[0] * i) - 1];
          d_pts_data[i] = pts_data[((int32_T)farthestSouth_data[0] + pts_size[0]
            * i) - 1];
          e_pts_data[i] = pts_data[(b_idx + pts_size[0] * i) - 1];
        }

        markPtsInTria(pts_data, pts_size, c_pts_data, d_pts_data, e_pts_data,
                      ptsInSouthTria_data, ptsInSouthTria_size);
      }

      if (b_pts_size[0] != 0) {
        loop_ub = ptsOffHull_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (ptsOffHull_data[i] || ptsInNorthTria_data[i]);
        }
      }

      if (ptsInSouthTria_size[0] != 0) {
        loop_ub = ptsOffHull_size[0];
        for (i = 0; i < loop_ub; i++) {
          ptsOffHull_data[i] = (ptsOffHull_data[i] || ptsInSouthTria_data[i]);
        }
      }

      ptsOffHull_data[idx - 1] = false;
      ptsOffHull_data[b_idx - 1] = false;
      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestNorth_data[i];
      }

      loop_ub = farthestNorth_size[0] * farthestNorth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_pts_size[i] = (int32_T)farthestSouth_data[i];
      }

      loop_ub = farthestSouth_size[0] * farthestSouth_size[1];
      for (i = 0; i < loop_ub; i++) {
        ptsOffHull_data[b_pts_size[i] - 1] = false;
      }
    }
  }
}

static void orient(const emlrtStack *sp, real_T pts_data[], int32_T pts_size[2],
                   real_T orientedPts_data[], int32_T orientedPts_size[2],
                   real_T orientPerm_data[], int32_T orientPerm_size[1])
{
  emlrtStack st;
  real_T b_y_data[300];
  real_T b_orientPerm_data[106];
  real_T lineStretches_data[106];
  real_T this_workspace_pts_data[60];
  real_T workspace_pts_data[60];
  real_T b_pts_data[30];
  real_T relativePt_data[2];
  real_T numStretch;
  int32_T iidx_data[300];
  int32_T this_workspace_pts_size[2];
  int32_T b_pts_size[1];
  int32_T y_size[1];
  int32_T b_i;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T loop_ub;
  int32_T npts;
  int32_T stretchEnd;
  int32_T y;
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  b_pts_size[0] = pts_size[0];
  loop_ub = pts_size[0];
  for (i = 0; i < loop_ub; i++) {
    b_pts_data[i] = pts_data[i + pts_size[0]];
  }

  st.site = &ol_emlrtRSI;
  minimum(&st, b_pts_data, b_pts_size, &numStretch, &stretchEnd);
  i = pts_size[0];
  y_size[0] = pts_size[0];
  for (b_i = 0; b_i < i; b_i++) {
    for (i1 = 0; i1 < 2; i1++) {
      relativePt_data[i1] = pts_data[b_i + pts_size[0] * i1] - pts_data
        [(stretchEnd + pts_size[0] * i1) - 1];
    }

    numStretch = relativePt_data[1] / relativePt_data[0];
    if (muDoubleScalarIsNaN(numStretch)) {
      numStretch = 0.0;
    }

    b_y_data[b_i] = numStretch;
  }

  c_sort(b_y_data, y_size, iidx_data, b_pts_size);
  orientPerm_size[0] = b_pts_size[0];
  loop_ub = b_pts_size[0];
  for (i = 0; i < loop_ub; i++) {
    orientPerm_data[i] = (real_T)iidx_data[i];
  }

  npts = y_size[0];
  y = (int32_T)muDoubleScalarCeil((real_T)y_size[0] / 2.0);
  loop_ub = y << 1;
  for (i = 0; i < loop_ub; i++) {
    lineStretches_data[i] = 0.0;
  }

  numStretch = 0.0;
  stretchEnd = 0;
  b_i = 0;
  exitg1 = false;
  while ((!exitg1) && (b_i <= y_size[0] - 2)) {
    if (((stretchEnd != 0) && ((real_T)b_i + 1.0 <= (real_T)stretchEnd)) ||
        (!(b_y_data[b_i] == b_y_data[b_i + 1]))) {
      b_i++;
    } else {
      stretchEnd = b_i + 2;
      numStretch++;
      lineStretches_data[(int32_T)numStretch - 1] = (real_T)b_i + 1.0;
      while ((stretchEnd <= npts - 1) && (b_y_data[stretchEnd - 1] ==
              b_y_data[stretchEnd])) {
        stretchEnd++;
      }

      if (stretchEnd == npts) {
        lineStretches_data[((int32_T)numStretch + y) - 1] = (real_T)npts;
        exitg1 = true;
      } else {
        lineStretches_data[((int32_T)numStretch + y) - 1] = (real_T)stretchEnd;
        b_i++;
      }
    }
  }

  if (numStretch < 1.0) {
    loop_ub = 0;
  } else {
    loop_ub = (int32_T)numStretch;
  }

  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < loop_ub; i1++) {
      lineStretches_data[i1 + loop_ub * i] = lineStretches_data[i1 + y * i];
    }
  }

  for (b_i = 0; b_i < loop_ub; b_i++) {
    stretchEnd = pts_size[0] << 1;
    if (stretchEnd - 1 >= 0) {
      memcpy(&workspace_pts_data[0], &pts_data[0], (uint32_T)stretchEnd * sizeof
             (real_T));
    }

    this_workspace_pts_size[0] = pts_size[0];
    this_workspace_pts_size[1] = 2;
    stretchEnd = pts_size[0] << 1;
    if (stretchEnd - 1 >= 0) {
      memcpy(&this_workspace_pts_data[0], &workspace_pts_data[0], (uint32_T)
             stretchEnd * sizeof(real_T));
    }

    st.site = &wl_emlrtRSI;
    introsort(&st, orientPerm_data, (int32_T)lineStretches_data[b_i], (int32_T)
              lineStretches_data[b_i + loop_ub], this_workspace_pts_data,
              this_workspace_pts_size);
  }

  for (b_i = 0; b_i < loop_ub; b_i++) {
    if ((lineStretches_data[b_i] > 1.0) && ((pts_data[(int32_T)orientPerm_data
          [(int32_T)lineStretches_data[b_i] - 1] - 1] - pts_data[(int32_T)
          orientPerm_data[(int32_T)(lineStretches_data[b_i] - 1.0) - 1] - 1]) *
         (pts_data[((int32_T)orientPerm_data[(int32_T)lineStretches_data[b_i +
                    loop_ub] - 1] + pts_size[0]) - 1] - pts_data[((int32_T)
           orientPerm_data[(int32_T)(lineStretches_data[b_i] - 1.0) - 1] +
           pts_size[0]) - 1]) - (pts_data[((int32_T)orientPerm_data[(int32_T)
           lineStretches_data[b_i] - 1] + pts_size[0]) - 1] - pts_data[((int32_T)
           orientPerm_data[(int32_T)(lineStretches_data[b_i] - 1.0) - 1] +
           pts_size[0]) - 1]) * (pts_data[(int32_T)orientPerm_data[(int32_T)
          lineStretches_data[b_i + loop_ub] - 1] - 1] - pts_data[(int32_T)
          orientPerm_data[(int32_T)(lineStretches_data[b_i] - 1.0) - 1] - 1]) <
         0.0)) {
      numStretch = lineStretches_data[b_i + loop_ub];
      if (lineStretches_data[b_i] > numStretch) {
        i = 1;
        i1 = 1;
        i2 = 0;
      } else {
        i = (int32_T)numStretch;
        i1 = -1;
        i2 = (int32_T)lineStretches_data[b_i];
      }

      if (lineStretches_data[b_i] > lineStretches_data[b_i + loop_ub]) {
        npts = 0;
      } else {
        npts = (int32_T)lineStretches_data[b_i] - 1;
      }

      st.site = &ux_emlrtRSI;
      y = div_s32(&st, i2 - i, i1) + 1;
      st.site = &ux_emlrtRSI;
      stretchEnd = div_s32(&st, i2 - i, i1);
      for (i2 = 0; i2 <= stretchEnd; i2++) {
        b_orientPerm_data[i2] = orientPerm_data[(i + i1 * i2) - 1];
      }

      for (i = 0; i < y; i++) {
        orientPerm_data[npts + i] = b_orientPerm_data[i];
      }
    }
  }

  orientedPts_size[0] = orientPerm_size[0];
  orientedPts_size[1] = 2;
  for (i = 0; i < 2; i++) {
    loop_ub = orientPerm_size[0];
    for (i1 = 0; i1 < loop_ub; i1++) {
      orientedPts_data[i1 + orientedPts_size[0] * i] = pts_data[((int32_T)
        orientPerm_data[i1] + pts_size[0] * i) - 1];
    }
  }
}

static void stack_stack(const emlrtStack *sp, int32_T n, sBaHy6MF1FZJsDHxMqvBaiH
  this_d_data[], int32_T this_d_size[1], int32_T *this_n)
{
  int32_T unnamed_idx_0;
  (void)this_d_data;
  *this_n = 0;
  unnamed_idx_0 = (int32_T)emlrtNonNegativeCheckR2012b((real_T)n, &h_emlrtDCI,
    (emlrtConstCTX)sp);
  emlrtNonNegativeCheckR2012b(1.0, &h_emlrtDCI, (emlrtConstCTX)sp);
  this_d_size[0] = unnamed_idx_0;
}

static void eml_float_colon(const emlrtStack *sp, real_T a, real_T b,
  coder_array_real_T_2D *y)
{
  emlrtStack st;
  real_T apnd;
  real_T cdiff;
  real_T ndbl;
  int32_T i;
  int32_T k;
  int32_T n;
  int32_T nm1d2;
  st.prev = sp;
  st.tls = sp->tls;
  ndbl = muDoubleScalarFloor((b - a) + 0.5);
  apnd = a + ndbl;
  cdiff = apnd - b;
  if (muDoubleScalarAbs(cdiff) < 4.4408920985006262E-16 * muDoubleScalarMax
      (muDoubleScalarAbs(a), muDoubleScalarAbs(b))) {
    ndbl++;
    apnd = b;
  } else if (cdiff > 0.0) {
    apnd = a + (ndbl - 1.0);
  } else {
    ndbl++;
  }

  if (ndbl >= 0.0) {
    n = (int32_T)ndbl - 1;
  } else {
    n = -1;
  }

  st.site = &yl_emlrtRSI;
  assert_pmaxsize(&st, true);
  array_real_T_2D_SetSize(y, 1, n + 1);
  if (n + 1 > 0) {
    y->vector.data[0] = a;
    if (n + 1 > 1) {
      y->vector.data[n] = apnd;
      nm1d2 = div_nzp_s32(n, 2);
      i = nm1d2 - 2;
      for (k = 0; k <= i; k++) {
        y->vector.data[k + 1] = a + (real_T)(k + 1);
        y->vector.data[(n - k) - 1] = apnd - (real_T)(k + 1);
      }

      if (nm1d2 << 1 == n) {
        y->vector.data[nm1d2] = (a + apnd) / 2.0;
      } else {
        y->vector.data[nm1d2] = a + (real_T)nm1d2;
        y->vector.data[nm1d2 + 1] = apnd - (real_T)nm1d2;
      }
    }
  }
}

static void assert_pmaxsize(const emlrtStack *sp, boolean_T p)
{
  static const int32_T iv[2] = { 1, 21 };

  static const int32_T iv1[2] = { 1, 21 };

  static char_T b_u[21] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'p', 'm', 'a', 'x', 's', 'i', 'z', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[21];
  st.prev = sp;
  st.tls = sp->tls;
  if (!p) {
    for (i = 0; i < 21; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 21, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 21; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 21, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &vw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &ec_emlrtMCI), &ec_emlrtMCI),
          &ec_emlrtMCI);
  }
}

static void grahamComputeHull(real_T pts_data[], int32_T pts_size[2], int32_T
  traversalOrder_data[], int32_T hull_data[], int32_T hull_size[2])
{
  real_T diffPt_data[2];
  int32_T b_i;
  int32_T i;
  int32_T i1;
  int32_T j;
  int32_T k;
  int32_T traversalOrder;
  boolean_T guard1;
  hull_size[0] = 1;
  k = pts_size[0];
  for (i = 0; i <= k; i++) {
    hull_data[i] = 0;
  }

  k = -2;
  i = pts_size[0];
  for (j = 0; j <= i; j++) {
    if (j == pts_size[0]) {
      b_i = 0;
    } else {
      b_i = j;
    }

    guard1 = false;
    if (k + 3 > 1) {
      traversalOrder = traversalOrder_data[b_i];
      for (i1 = 0; i1 < 2; i1++) {
        diffPt_data[i1] = pts_data[(traversalOrder + pts_size[0] * i1) - 1] -
          pts_data[(hull_data[k + 1] + pts_size[0] * i1) - 1];
      }

      if ((diffPt_data[0] == 0.0) && (diffPt_data[1] == 0.0)) {
      } else {
        guard1 = true;
      }
    } else {
      guard1 = true;
    }

    if (guard1) {
      while ((k + 3 >= 3) && ((pts_data[hull_data[k + 1] - 1] -
               pts_data[hull_data[k] - 1]) * (pts_data[(traversalOrder_data[b_i]
                + pts_size[0]) - 1] - pts_data[(hull_data[k] + pts_size[0]) - 1])
              - (pts_data[(hull_data[k + 1] + pts_size[0]) - 1] - pts_data
                 [(hull_data[k] + pts_size[0]) - 1]) *
                              (pts_data[traversalOrder_data[b_i] - 1] -
               pts_data[hull_data[k] - 1]) <= 0.0)) {
        k--;
      }

      hull_data[k + 2] = traversalOrder_data[b_i];
      k++;
    }
  }

  if (k + 2 < 1) {
    k = -2;
  }

  hull_size[1] = k + 2;
}

static void visionDetectionGenerator_sensorToCamera
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T detSen_data[], int32_T detSen_size[2],
   real_T detCam_data[], int32_T detCam_size[2])
{
  emlrtStack st;
  monoCamera r;
  real_T b_posCam_data[900];
  real_T Rsen2cam[9];
  real_T b_monoCamSen_SensorLocation[3];
  real_T monoCamSen_SensorLocation[2];
  real_T t129_SensorLocation[2];
  int32_T b_detSen_size[2];
  int32_T c_detSen_size[2];
  int32_T posCam_size[2];
  int32_T y_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  boolean_T hasVel;
  hasVel = (detSen_size[0] > 3);
  if (hasVel) {
    detCam_size[0] = 6;
    detCam_size[1] = detSen_size[1];
    loop_ub = 6 * detSen_size[1];
    for (i = 0; i < loop_ub; i++) {
      detCam_data[i] = 0.0;
    }
  } else {
    detCam_size[0] = 3;
    detCam_size[1] = detSen_size[1];
    loop_ub = 3 * detSen_size[1];
    for (i = 0; i < loop_ub; i++) {
      detCam_data[i] = 0.0;
    }
  }

  r = obj->pMonoCameraInSensorFrame;
  for (i = 0; i < 2; i++) {
    t129_SensorLocation[i] = r.SensorLocation[i];
  }

  for (i = 0; i < 2; i++) {
    monoCamSen_SensorLocation[i] = t129_SensorLocation[i];
  }

  rotChildToParent(r.Roll, r.Pitch, r.Yaw, Rsen2cam);
  b_detSen_size[0] = 3;
  b_detSen_size[1] = detSen_size[1];
  loop_ub = detSen_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_posCam_data[i1 + 3 * i] = detSen_data[i1 + detSen_size[0] * i];
    }
  }

  st.site = &md_emlrtRSI;
  h_mtimes(Rsen2cam, b_posCam_data, b_detSen_size, moduleInstance->y_data,
           y_size);
  for (i = 0; i < 2; i++) {
    b_monoCamSen_SensorLocation[i] = monoCamSen_SensorLocation[i];
  }

  b_monoCamSen_SensorLocation[2] = r.Height;
  s_bsxfun(moduleInstance->y_data, y_size, b_monoCamSen_SensorLocation,
           moduleInstance->tmp_data, b_detSen_size);
  posCam_size[0] = 3;
  posCam_size[1] = b_detSen_size[1];
  loop_ub = b_detSen_size[0] * b_detSen_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&b_posCam_data[0], &moduleInstance->tmp_data[0], (uint32_T)loop_ub *
           sizeof(real_T));
  }

  b_detSen_size[0] = 3;
  b_detSen_size[1] = detCam_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detSen_size[0], 2, &posCam_size[0], 2,
    &p_emlrtECI, (void *)sp);
  loop_ub = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detCam_data[i1 + detCam_size[0] * i] = b_posCam_data[i1 + 3 * i];
    }
  }

  if (hasVel) {
    for (i = 0; i < 3; i++) {
      emlrtDynamicBoundsCheckR2012b(i + 4, 1, detSen_size[0], &bf_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    c_detSen_size[0] = 3;
    c_detSen_size[1] = detSen_size[1];
    loop_ub = detSen_size[1];
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        b_posCam_data[i1 + 3 * i] = detSen_data[(i1 + detSen_size[0] * i) + 3];
      }
    }

    st.site = &md_emlrtRSI;
    h_mtimes(Rsen2cam, b_posCam_data, c_detSen_size, moduleInstance->y_data,
             y_size);
    for (i = 0; i < 3; i++) {
      emlrtDynamicBoundsCheckR2012b(i + 4, 1, detCam_size[0], &cf_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    b_detSen_size[0] = 3;
    b_detSen_size[1] = detCam_size[1];
    emlrtSubAssignSizeCheckR2012b(&b_detSen_size[0], 2, &y_size[0], 2,
      &q_emlrtECI, (void *)sp);
    loop_ub = detCam_size[1];
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 3; i1++) {
        detCam_data[(i1 + detCam_size[0] * i) + 3] = moduleInstance->y_data[i1 +
          3 * i];
      }
    }
  }
}

static void h_mtimes(real_T A[9], real_T B_data[], int32_T B_size[2], real_T
                     C_data[], int32_T C_size[2])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  coder_array_real_T_2D C;
  real_T alpha1;
  real_T beta1;
  int32_T loop_ub;
  char_T TRANSA1;
  char_T TRANSB1;
  if (B_size[1] == 0) {
    C_size[0] = 3;
    C_size[1] = 0;
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)3;
    n_t = (ptrdiff_t)B_size[1];
    k_t = (ptrdiff_t)3;
    lda_t = (ptrdiff_t)3;
    ldb_t = (ptrdiff_t)3;
    ldc_t = (ptrdiff_t)3;
    array_real_T_2D_Constructor(&C);
    array_real_T_2D_SetSize(&C, 3, B_size[1]);
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t, &B_data
          [0], &ldb_t, &beta1, &C.vector.data[0], &ldc_t);
    C_size[0] = 3;
    C_size[1] = C.size[1];
    loop_ub = 3 * C.size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&C_data[0], &C.vector.data[0], (uint32_T)loop_ub * sizeof(real_T));
    }

    array_real_T_2D_Destructor(&C);
  }
}

static void s_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[3], real_T
                     c_data[], int32_T c_size[2])
{
  __m128d r;
  __m128d r1;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 3;
  c_size[1] = (int16_T)a_size[1];
  if ((int16_T)a_size[1] != 0) {
    c_size[0] = 3;
    acoef = (a_size[1] != 1);
    i = (int16_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 3;
        r = _mm_loadu_pd(&a_data[3 * ia]);
        r1 = _mm_loadu_pd(&b[0]);
        _mm_storeu_pd(&c_data[3 * k], _mm_add_pd(r, r1));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_size[0] = 3;
        c_data[3 * k + 2] = a_data[3 * ia + 2] + b[2];
      }
    }
  }
}

static void b_visionDetectionGenerator_sensorToCamera
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T detSen_data[], int32_T detSen_size[2],
   real_T detCam_data[], int32_T detCam_size[2])
{
  emlrtStack st;
  monoCamera r;
  real_T b_y_data[6300];
  real_T b_dv[9];
  real_T b_monoCamSen_SensorLocation[3];
  real_T monoCamSen_SensorLocation[2];
  real_T t127_SensorLocation[2];
  int32_T b_detSen_size[2];
  int32_T posCam_size[2];
  int32_T y_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  detCam_size[0] = 3;
  detCam_size[1] = detSen_size[1];
  loop_ub = 3 * detSen_size[1];
  for (i = 0; i < loop_ub; i++) {
    detCam_data[i] = 0.0;
  }

  r = obj->pMonoCameraInSensorFrame;
  for (i = 0; i < 2; i++) {
    t127_SensorLocation[i] = r.SensorLocation[i];
  }

  for (i = 0; i < 2; i++) {
    monoCamSen_SensorLocation[i] = t127_SensorLocation[i];
  }

  b_detSen_size[0] = 3;
  b_detSen_size[1] = detSen_size[1];
  loop_ub = detSen_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      moduleInstance->posCam_data[i1 + 3 * i] = detSen_data[i1 + 3 * i];
    }
  }

  rotChildToParent(r.Roll, r.Pitch, r.Yaw, b_dv);
  st.site = &md_emlrtRSI;
  h_mtimes(b_dv, moduleInstance->posCam_data, b_detSen_size, b_y_data, y_size);
  for (i = 0; i < 2; i++) {
    b_monoCamSen_SensorLocation[i] = monoCamSen_SensorLocation[i];
  }

  b_monoCamSen_SensorLocation[2] = r.Height;
  s_bsxfun(b_y_data, y_size, b_monoCamSen_SensorLocation,
           moduleInstance->posCam_data, posCam_size);
  b_detSen_size[0] = 3;
  b_detSen_size[1] = detSen_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detSen_size[0], 2, &posCam_size[0], 2,
    &p_emlrtECI, (void *)sp);
  loop_ub = detSen_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detCam_data[i1 + 3 * i] = moduleInstance->posCam_data[i1 + 3 * i];
    }
  }
}

static void b_visionDetectionGenerator_cameraToImageCoords
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T b_pos_data[], int32_T pos_size[2],
   real_T b_U_data[], int32_T U_size[2])
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 36 };

  static const int32_T iv2[2] = { 1, 39 };

  static const int32_T iv3[2] = { 1, 37 };

  static const int32_T iv4[2] = { 1, 40 };

  static const int32_T iv5[2] = { 1, 39 };

  static const int32_T iv6[2] = { 1, 37 };

  static const int32_T iv7[2] = { 1, 40 };

  static char_T h_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T e_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T g_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'h', 'e',
    'c', 'k', 'D', 'i', 'm', 'C', 'o', 'm', 'm', 'o', 'n', ':', 'n', 'o', 'n',
    'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', 'S', 'i', 'z', 'e' };

  static char_T b_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  __m128d r1;
  coder_array_real_T_2D X;
  emlrtStack b_st;
  emlrtStack st;
  monoCamera r;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *m;
  const mxArray *y;
  real_T wp_data[2100];
  real_T z_data[2100];
  real_T camMtx[12];
  real_T horzCoeffs[3];
  real_T vanishPt[2];
  real_T bigNum;
  int32_T Uprime_size[2];
  int32_T b_U_size[2];
  int32_T b_Uprime_size[2];
  int32_T b_pos_size[2];
  int32_T bigNum_size[2];
  int32_T isBehind_size[2];
  int32_T vec_size[2];
  int32_T wp_size[2];
  int32_T y_size[2];
  int32_T Uprime_size_idx_1;
  int32_T i;
  int32_T n;
  int32_T numBehind;
  int32_T nz;
  int32_T partialTrueCount;
  int32_T trueCount;
  int16_T c_tmp_data[2100];
  int16_T d_tmp_data[2100];
  char_T f_u[40];
  char_T c_u[39];
  char_T d_u[37];
  char_T u[36];
  boolean_T isBehind_data[2100];
  boolean_T b_isBehind_data;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  r = obj->pMonoCameraInSensorFrame;
  st.site = &hc_emlrtRSI;
  visionDetectionGenerator_getCameraMatrix(r.Intrinsics, r.Height, r.Pitch,
    r.Yaw, r.Roll, camMtx);
  b_pos_size[0] = pos_size[1];
  b_pos_size[1] = 3;
  for (i = 0; i < 3; i++) {
    n = pos_size[1];
    for (partialTrueCount = 0; partialTrueCount < n; partialTrueCount++) {
      moduleInstance->pos_data[partialTrueCount + b_pos_size[0] * i] =
        b_pos_data[i + 3 * partialTrueCount];
    }
  }

  array_real_T_2D_Constructor(&X);
  st.site = &am_emlrtRSI;
  b_padarray(&st, moduleInstance->pos_data, b_pos_size, &X);
  st.site = &md_emlrtRSI;
  i_mtimes(&X, camMtx, moduleInstance->pos_data, y_size);
  array_real_T_2D_Destructor(&X);
  Uprime_size_idx_1 = y_size[0];
  n = y_size[0];
  for (i = 0; i < n; i++) {
    for (partialTrueCount = 0; partialTrueCount < 3; partialTrueCount++) {
      moduleInstance->Uprime_data[partialTrueCount + 3 * i] =
        moduleInstance->pos_data[i + y_size[0] * partialTrueCount];
    }
  }

  wp_size[0] = 1;
  wp_size[1] = y_size[0];
  Uprime_size[0] = 1;
  Uprime_size[1] = y_size[0];
  st.site = &rd_emlrtRSI;
  assertCompatibleDims(&st, Uprime_size, wp_size);
  b_Uprime_size[0] = 1;
  b_Uprime_size[1] = y_size[0];
  for (i = 0; i < Uprime_size_idx_1; i++) {
    z_data[i] = moduleInstance->Uprime_data[3 * i] / moduleInstance->
      Uprime_data[3 * i + 2];
  }

  st.site = &rd_emlrtRSI;
  assertCompatibleDims(&st, b_Uprime_size, wp_size);
  for (i = 0; i < Uprime_size_idx_1; i++) {
    wp_data[i] = moduleInstance->Uprime_data[3 * i + 1] /
      moduleInstance->Uprime_data[3 * i + 2];
  }

  U_size[0] = 2;
  U_size[1] = y_size[0];
  n = y_size[0];
  isBehind_size[0] = 1;
  isBehind_size[1] = y_size[0];
  for (i = 0; i < n; i++) {
    b_U_data[i << 1] = z_data[i];
    b_U_data[(i << 1) + 1] = wp_data[i];
    isBehind_data[i] = (moduleInstance->Uprime_data[3 * i + 2] < 0.0);
  }

  st.site = &bm_emlrtRSI;
  if (b_any(&st, isBehind_data, isBehind_size)) {
    if ((y_size[0] == 1) || (y_size[0] != 1)) {
    } else {
      for (i = 0; i < 36; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 36; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &rv_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &kb_emlrtMCI),
             &kb_emlrtMCI), &kb_emlrtMCI);
    }

    nz = b_combineVectorElements(isBehind_data, isBehind_size);
    numBehind = b_combineVectorElements(isBehind_data, isBehind_size);
    bigNum = 10.0 * b_norm(r.Intrinsics->ImageSize);
    for (i = 0; i < 3; i++) {
      horzCoeffs[i] = obj->pHorizonLine[i];
    }

    for (i = 0; i < 2; i++) {
      vanishPt[i] = horzCoeffs[i + 1];
    }

    n = y_size[0];
    trueCount = 0;
    partialTrueCount = 0;
    for (i = 0; i < n; i++) {
      b_isBehind_data = isBehind_data[i];
      if (b_isBehind_data) {
        trueCount++;
        c_tmp_data[partialTrueCount] = (int16_T)i;
        partialTrueCount++;
      }
    }

    b_U_size[0] = 2;
    b_U_size[1] = trueCount;
    for (i = 0; i < trueCount; i++) {
      for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
        moduleInstance->U_data[partialTrueCount + (i << 1)] =
          b_U_data[partialTrueCount + (emlrtDynamicBoundsCheckR2012b((int32_T)
          c_tmp_data[i], 0, y_size[0] - 1, &ef_emlrtBCI, (emlrtConstCTX)sp) << 1)];
      }
    }

    b_bsxfun(vanishPt, moduleInstance->U_data, b_U_size,
             moduleInstance->vec_data, Uprime_size);
    power(moduleInstance->vec_data, Uprime_size, moduleInstance->U_data,
          b_pos_size);
    sum(moduleInstance->U_data, b_pos_size, wp_data, wp_size);
    st.site = &ic_emlrtRSI;
    b_sqrt(&st, wp_data, wp_size, z_data, b_pos_size);
    st.site = &lc_emlrtRSI;
    b_st.site = &nc_emlrtRSI;
    assertValidSizeArg(&b_st, (real_T)nz);
    n = 1;
    if (b_pos_size[1] > 1) {
      n = b_pos_size[1];
    }

    if (numBehind > muIntScalarMax_sint32(b_pos_size[1], n)) {
      for (i = 0; i < 39; i++) {
        c_u[i] = e_u[i];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&c_y, m);
      for (i = 0; i < 39; i++) {
        c_u[i] = e_u[i];
      }

      f_y = NULL;
      m = emlrtCreateCharArray(2, &iv5[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &c_u[0]);
      emlrtAssign(&f_y, m);
      st.site = &qv_emlrtRSI;
      error(&st, c_y, getString(&st, b_message(&st, f_y, &g_emlrtMCI),
             &g_emlrtMCI), &g_emlrtMCI);
    }

    if (nz < 0) {
      for (i = 0; i < 37; i++) {
        d_u[i] = g_u[i];
      }

      d_y = NULL;
      m = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &d_u[0]);
      emlrtAssign(&d_y, m);
      for (i = 0; i < 37; i++) {
        d_u[i] = g_u[i];
      }

      g_y = NULL;
      m = emlrtCreateCharArray(2, &iv6[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &d_u[0]);
      emlrtAssign(&g_y, m);
      st.site = &ow_emlrtRSI;
      error(&st, d_y, getString(&st, b_message(&st, g_y, &h_emlrtMCI),
             &h_emlrtMCI), &h_emlrtMCI);
    }

    if (nz != b_pos_size[1]) {
      for (i = 0; i < 40; i++) {
        f_u[i] = h_u[i];
      }

      e_y = NULL;
      m = emlrtCreateCharArray(2, &iv4[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &f_u[0]);
      emlrtAssign(&e_y, m);
      for (i = 0; i < 40; i++) {
        f_u[i] = h_u[i];
      }

      h_y = NULL;
      m = emlrtCreateCharArray(2, &iv7[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &f_u[0]);
      emlrtAssign(&h_y, m);
      st.site = &ov_emlrtRSI;
      error(&st, e_y, getString(&st, b_message(&st, h_y, &i_emlrtMCI),
             &i_emlrtMCI), &i_emlrtMCI);
    }

    b_pos_size[0] = 1;
    b_pos_size[1] = numBehind;
    vec_size[0] = 2;
    vec_size[1] = Uprime_size[1];
    n = Uprime_size[1];
    for (i = 0; i < n; i++) {
      for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
        moduleInstance->U_data[partialTrueCount + (i << 1)] =
          moduleInstance->vec_data[partialTrueCount + (i << 1)];
      }
    }

    st.site = &jc_emlrtRSI;
    c_bsxfun(&st, moduleInstance->U_data, vec_size, z_data, b_pos_size,
             moduleInstance->vec_data, Uprime_size);
    n = y_size[0];
    trueCount = 0;
    for (i = 0; i < n; i++) {
      if (isBehind_data[i]) {
        trueCount++;
      }
    }

    partialTrueCount = 0;
    for (i = 0; i < n; i++) {
      if (isBehind_data[i]) {
        d_tmp_data[partialTrueCount] = (int16_T)emlrtDynamicBoundsCheckR2012b
          ((int32_T)(int16_T)i, 0, Uprime_size_idx_1 - 1, &df_emlrtBCI,
           (emlrtConstCTX)sp);
        partialTrueCount++;
      }
    }

    bigNum_size[0] = 1;
    bigNum_size[1] = numBehind;
    n = numBehind / 2 * 2;
    partialTrueCount = n - 2;
    for (i = 0; i <= partialTrueCount; i += 2) {
      r1 = _mm_loadu_pd(&z_data[i]);
      _mm_storeu_pd(&wp_data[i], _mm_add_pd(_mm_set1_pd(bigNum), r1));
    }

    for (i = n; i < numBehind; i++) {
      wp_data[i] = bigNum + z_data[i];
    }

    st.site = &kc_emlrtRSI;
    d_bsxfun(&st, moduleInstance->vec_data, Uprime_size, wp_data, bigNum_size,
             moduleInstance->U_data, b_pos_size);
    e_bsxfun(moduleInstance->U_data, b_pos_size, vanishPt,
             moduleInstance->vec_data, Uprime_size);
    b_pos_size[0] = 2;
    b_pos_size[1] = trueCount;
    emlrtSubAssignSizeCheckR2012b(&b_pos_size[0], 2, &Uprime_size[0], 2,
      &emlrtECI, (void *)sp);
    for (i = 0; i < trueCount; i++) {
      for (partialTrueCount = 0; partialTrueCount < 2; partialTrueCount++) {
        b_U_data[partialTrueCount + (d_tmp_data[i] << 1)] =
          moduleInstance->vec_data[partialTrueCount + (i << 1)];
      }
    }
  }
}

static void b_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], coder_array_real_T_2D *b)
{
  coder_array_real_T_2D r;
  emlrtStack st;
  real_T varargin_1[2];
  int32_T b_i;
  int32_T i;
  int32_T j;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  if (varargin_1_size[0] == 0) {
    varargin_1[0] = 0.0;
    varargin_1[1] = 4.0;
    array_real_T_2D_Constructor(&r);
    st.site = &cm_emlrtRSI;
    c_repmat(&st, varargin_1, &r);
    array_real_T_2D_SetSize(b, r.size[0], r.size[1]);
    loop_ub = r.size[0] * r.size[1];
    for (i = 0; i < loop_ub; i++) {
      b->vector.data[i] = r.vector.data[i];
    }

    array_real_T_2D_Destructor(&r);
  } else {
    array_real_T_2D_SetSize(b, (int32_T)(int16_T)varargin_1_size[0], 4);
    for (j = 0; j < 1; j++) {
      i = b->size[0];
      for (b_i = 0; b_i < i; b_i++) {
        b->vector.data[(emlrtDynamicBoundsCheckR2012b(b_i + 1, 1, b->size[0],
          &ff_emlrtBCI, (emlrtConstCTX)sp) + b->size[0] * 3) - 1] = 1.0;
      }
    }

    for (j = 0; j < 3; j++) {
      i = varargin_1_size[0];
      loop_ub = b->size[0];
      for (b_i = i + 1; b_i <= loop_ub; b_i++) {
        b->vector.data[(emlrtDynamicBoundsCheckR2012b(b_i, 1, b->size[0],
          &gf_emlrtBCI, (emlrtConstCTX)sp) + b->size[0] * j) - 1] = 1.0;
      }
    }

    for (j = 0; j < 3; j++) {
      i = varargin_1_size[0];
      for (b_i = 0; b_i < i; b_i++) {
        b->vector.data[(emlrtDynamicBoundsCheckR2012b(b_i + 1, 1, b->size[0],
          &if_emlrtBCI, (emlrtConstCTX)sp) + b->size[0] * j) - 1] =
          varargin_1_data[(emlrtDynamicBoundsCheckR2012b(b_i + 1, 1,
          varargin_1_size[0], &hf_emlrtBCI, (emlrtConstCTX)sp) +
                           varargin_1_size[0] * j) - 1];
      }
    }
  }
}

static void c_repmat(const emlrtStack *sp, real_T varargin_1[2],
                     coder_array_real_T_2D *b)
{
  emlrtStack st;
  int32_T i;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &mf_emlrtRSI;
  c_assertValidSizeArg(&st, varargin_1);
  array_real_T_2D_SetSize(b, (int32_T)varargin_1[0], (int32_T)varargin_1[1]);
  loop_ub = (int32_T)varargin_1[0] * (int32_T)varargin_1[1];
  for (i = 0; i < loop_ub; i++) {
    b->vector.data[i] = 1.0;
  }
}

static void c_assertValidSizeArg(const emlrtStack *sp, real_T varargin_1[2])
{
  static const int32_T iv[2] = { 1, 57 };

  static const int32_T iv1[2] = { 1, 21 };

  static const int32_T iv2[2] = { 1, 57 };

  static const int32_T iv3[2] = { 1, 21 };

  static char_T c_u[57] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'a', 's', 's', 'e', 'r', 't', '_',
    'v', 'a', 'l', 'i', 'd', '_', 's', 'i', 'z', 'e', '_', 'a', 'r', 'g', '_',
    'i', 'n', 'v', 'a', 'l', 'i', 'd', 'S', 'i', 'z', 'e', 'V', 'e', 'c', 't',
    'o', 'r' };

  static char_T d_u[21] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'p', 'm', 'a', 'x', 's', 'i', 'z', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  real_T b_varargin_1;
  real_T n;
  int32_T k;
  char_T u[57];
  char_T b_u[21];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 2)) {
    if ((varargin_1[k] != varargin_1[k]) || muDoubleScalarIsInf(varargin_1[k]))
    {
      for (k = 0; k < 57; k++) {
        u[k] = c_u[k];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 57, m, &u[0]);
      emlrtAssign(&y, m);
      for (k = 0; k < 57; k++) {
        u[k] = c_u[k];
      }

      c_y = NULL;
      m = emlrtCreateCharArray(2, &iv2[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 57, m, &u[0]);
      emlrtAssign(&c_y, m);
      e_y = NULL;
      m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
      *(int32_T *)emlrtMxGetData(m) = MIN_int32_T;
      emlrtAssign(&e_y, m);
      f_y = NULL;
      m = emlrtCreateNumericMatrix(1, 1, mxINT32_CLASS, mxREAL);
      *(int32_T *)emlrtMxGetData(m) = MAX_int32_T;
      emlrtAssign(&f_y, m);
      st.site = &uw_emlrtRSI;
      error(&st, y, getString(&st, c_message(&st, c_y, e_y, f_y, &fb_emlrtMCI),
             &fb_emlrtMCI), &fb_emlrtMCI);
      exitg1 = true;
    } else {
      k++;
    }
  }

  n = 1.0;
  for (k = 0; k < 2; k++) {
    b_varargin_1 = varargin_1[k];
    if (b_varargin_1 <= 0.0) {
      n = 0.0;
    } else {
      n *= b_varargin_1;
    }
  }

  if (!(n <= 2.147483647E+9)) {
    for (k = 0; k < 21; k++) {
      b_u[k] = d_u[k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 21, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (k = 0; k < 21; k++) {
      b_u[k] = d_u[k];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 21, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &tw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &gb_emlrtMCI),
           &gb_emlrtMCI), &gb_emlrtMCI);
  }
}

static void i_mtimes(coder_array_real_T_2D *A, real_T B[12], real_T C_data[],
                     int32_T C_size[2])
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  if (A->size[0] == 0) {
    C_size[0] = 0;
    C_size[1] = 3;
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)A->size[0];
    n_t = (ptrdiff_t)3;
    k_t = (ptrdiff_t)4;
    lda_t = (ptrdiff_t)A->size[0];
    ldb_t = (ptrdiff_t)4;
    ldc_t = (ptrdiff_t)A->size[0];
    C_size[0] = A->size[0];
    C_size[1] = 3;
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A->vector.data[0],
          &lda_t, &B[0], &ldb_t, &beta1, &C_data[0], &ldc_t);
  }
}

static boolean_T b_any(const emlrtStack *sp, boolean_T x_data[], int32_T x_size
  [2])
{
  static const int32_T iv[2] = { 1, 51 };

  static const int32_T iv1[2] = { 1, 51 };

  static char_T b_u[51] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'a', 'l', 'l', '_', 'o', 'r', '_',
    'a', 'n', 'y', '_', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T ix;
  char_T u[51];
  boolean_T exitg1;
  boolean_T y;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[1] == 1) || (x_size[1] != 1)) {
  } else {
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (ix = 0; ix < 51; ix++) {
      u[ix] = b_u[ix];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 51, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &sw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &u_emlrtMCI), &u_emlrtMCI),
          &u_emlrtMCI);
  }

  y = false;
  ix = 0;
  exitg1 = false;
  while ((!exitg1) && (ix + 1 <= x_size[1])) {
    if (x_data[ix]) {
      y = true;
      exitg1 = true;
    } else {
      ix++;
    }
  }

  return y;
}

static int32_T b_computeDimsData(const emlrtStack *sp, int32_T nx, real_T
  varargin_3)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'b', 'u', 'i', 'l',
    't', 'i', 'n', 's', ':', 'A', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', 'F',
    'a', 'i', 'l', 'e', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T calclen;
  int32_T prodsz;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &nc_emlrtRSI;
  assertValidSizeArg(&st, varargin_3);
  prodsz = (int32_T)varargin_3 << 1;
  if (prodsz > 0) {
    if ((uint16_T)prodsz == 0) {
      calclen = MAX_int32_T;
      emlrtDivisionByZeroWarningOrError2018b(&b_emlrtRTEI, (emlrtConstCTX)sp);
    } else {
      calclen = (int32_T)((uint32_T)nx / (uint32_T)(uint16_T)prodsz);
    }

    if (calclen > nx) {
      for (prodsz = 0; prodsz < 30; prodsz++) {
        u[prodsz] = b_u[prodsz];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
      emlrtAssign(&y, m);
      for (prodsz = 0; prodsz < 30; prodsz++) {
        u[prodsz] = b_u[prodsz];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &rw_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &pb_emlrtMCI),
             &pb_emlrtMCI), &pb_emlrtMCI);
    }
  } else {
    calclen = 0;
  }

  return calclen;
}

static void c_power(real_T a_data[], int32_T a_size[2], real_T b_y_data[],
                    int32_T y_size[2])
{
  int32_T i;
  int32_T loop_ub;
  y_size[0] = 3;
  y_size[1] = a_size[1];
  loop_ub = 3 * a_size[1];
  for (i = 0; i < loop_ub; i++) {
    b_y_data[i] = c_function_handle_parenReference(a_data[i]);
  }
}

static real_T c_function_handle_parenReference(real_T varargin_1)
{
  return varargin_1 * varargin_1;
}

static void visionDetectionGenerator_indexTarget(const emlrtStack *sp, real_T
  iTgt, coder_array_real_T_3D *Uall, real_T tgtRngs_data[], int32_T
  tgtRngs_size[2], coder_array_real_T_2D *Utgt, real_T *rgTgt,
  coder_array_real_T_3D *Uothers, real_T rgOthers_data[], int32_T rgOthers_size
  [2])
{
  coder_array_real_T_2D b_Utgt;
  coder_array_real_T_2D y;
  emlrtStack st;
  real_T b_y_data[299];
  real_T b_rgTgt;
  real_T d;
  int32_T c_y_data[598];
  int32_T b_i;
  int32_T b_iTgt;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T trueCount;
  int16_T d_tmp_data[4200];
  boolean_T c_tmp_data;
  st.prev = sp;
  st.tls = sp->tls;
  b_iTgt = emlrtDynamicBoundsCheckR2012b((int32_T)iTgt, 1, Uall->size[2],
    &jf_emlrtBCI, (emlrtConstCTX)sp);
  array_real_T_2D_SetSize(Utgt, 2, Uall->size[1]);
  loop_ub = Uall->size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 2; i1++) {
      Utgt->vector.data[i1 + (i << 1)] = Uall->vector.data[(i1 + (i << 1)) +
        (Uall->size[1] << 1) * (b_iTgt - 1)];
    }
  }

  b_rgTgt = tgtRngs_data[emlrtDynamicBoundsCheckR2012b((int32_T)iTgt, 1,
    tgtRngs_size[1], &kf_emlrtBCI, (emlrtConstCTX)sp) - 1];
  loop_ub = Utgt->size[1];
  trueCount = 0;
  b_iTgt = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    c_tmp_data = !muDoubleScalarIsNaN(Utgt->vector.data[b_i << 1]);
    if (c_tmp_data) {
      trueCount++;
      d_tmp_data[b_iTgt] = (int16_T)b_i;
      b_iTgt++;
    }
  }

  b_iTgt = Uall->size[1];
  array_real_T_2D_Constructor(&b_Utgt);
  array_real_T_2D_SetSize(&b_Utgt, 2, trueCount);
  for (i = 0; i < trueCount; i++) {
    for (i1 = 0; i1 < 2; i1++) {
      b_Utgt.vector.data[i1 + (i << 1)] = Utgt->vector.data[i1 +
        (emlrtDynamicBoundsCheckR2012b((int32_T)d_tmp_data[i], 0, b_iTgt - 1,
          &lf_emlrtBCI, (emlrtConstCTX)sp) << 1)];
    }
  }

  array_real_T_2D_SetSize(Utgt, 2, b_Utgt.size[1]);
  loop_ub = b_Utgt.size[0] * b_Utgt.size[1];
  for (i = 0; i < loop_ub; i++) {
    Utgt->vector.data[i] = b_Utgt.vector.data[i];
  }

  array_real_T_2D_Destructor(&b_Utgt);
  if (muDoubleScalarIsNaN(iTgt - 1.0)) {
    b_i = 1;
    b_y_data[0] = rtNaN;
  } else if (iTgt - 1.0 < 1.0) {
    b_i = 0;
  } else {
    b_i = (int32_T)((iTgt - 1.0) - 1.0) + 1;
    loop_ub = (int32_T)((iTgt - 1.0) - 1.0);
    for (i = 0; i <= loop_ub; i++) {
      b_y_data[i] = (real_T)i + 1.0;
    }
  }

  array_real_T_2D_Constructor(&y);
  if (muDoubleScalarIsNaN(iTgt + 1.0)) {
    array_real_T_2D_SetSize(&y, 1, 1);
    y.vector.data[0] = rtNaN;
  } else if ((real_T)Uall->size[2] < iTgt + 1.0) {
    array_real_T_2D_SetSize(&y, 1, 0);
  } else if (muDoubleScalarFloor(iTgt + 1.0) == iTgt + 1.0) {
    i = Uall->size[2];
    array_real_T_2D_SetSize(&y, 1, (int32_T)((real_T)i - (iTgt + 1.0)) + 1);
    loop_ub = (int32_T)((real_T)i - (iTgt + 1.0));
    for (i = 0; i <= loop_ub; i++) {
      y.vector.data[i] = (iTgt + 1.0) + (real_T)i;
    }
  } else {
    st.site = &pl_emlrtRSI;
    eml_float_colon(&st, iTgt + 1.0, (real_T)Uall->size[2], &y);
  }

  b_iTgt = Uall->size[2];
  trueCount = b_i + y.size[1];
  for (i = 0; i < b_i; i++) {
    i1 = (int32_T)emlrtIntegerCheckR2012b(b_y_data[i], &i_emlrtDCI,
      (emlrtConstCTX)sp);
    c_y_data[i] = emlrtDynamicBoundsCheckR2012b(i1, 1, b_iTgt, &mf_emlrtBCI,
      (emlrtConstCTX)sp) - 1;
  }

  loop_ub = y.size[1];
  for (i = 0; i < loop_ub; i++) {
    d = y.vector.data[i];
    i1 = (int32_T)emlrtIntegerCheckR2012b(d, &i_emlrtDCI, (emlrtConstCTX)sp);
    c_y_data[i + b_i] = emlrtDynamicBoundsCheckR2012b(i1, 1, b_iTgt,
      &mf_emlrtBCI, (emlrtConstCTX)sp) - 1;
  }

  array_real_T_3D_SetSize(Uothers, 2, Uall->size[1], trueCount);
  for (i = 0; i < trueCount; i++) {
    loop_ub = Uall->size[1];
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (b_iTgt = 0; b_iTgt < 2; b_iTgt++) {
        Uothers->vector.data[(b_iTgt + (i1 << 1)) + (Uothers->size[1] << 1) * i]
          = Uall->vector.data[(b_iTgt + (i1 << 1)) + (Uall->size[1] << 1) *
          c_y_data[i]];
      }
    }
  }

  if (muDoubleScalarIsNaN(iTgt - 1.0)) {
    b_i = 1;
    b_y_data[0] = rtNaN;
  } else if (iTgt - 1.0 < 1.0) {
    b_i = 0;
  } else {
    b_i = (int32_T)((iTgt - 1.0) - 1.0) + 1;
    loop_ub = (int32_T)((iTgt - 1.0) - 1.0);
    for (i = 0; i <= loop_ub; i++) {
      b_y_data[i] = (real_T)i + 1.0;
    }
  }

  if (muDoubleScalarIsNaN(iTgt + 1.0)) {
    array_real_T_2D_SetSize(&y, 1, 1);
    y.vector.data[0] = rtNaN;
  } else if ((real_T)tgtRngs_size[1] < iTgt + 1.0) {
    array_real_T_2D_SetSize(&y, 1, 0);
  } else if (muDoubleScalarFloor(iTgt + 1.0) == iTgt + 1.0) {
    array_real_T_2D_SetSize(&y, 1, (int32_T)((real_T)tgtRngs_size[1] - (iTgt +
      1.0)) + 1);
    loop_ub = (int32_T)((real_T)tgtRngs_size[1] - (iTgt + 1.0));
    for (i = 0; i <= loop_ub; i++) {
      y.vector.data[i] = (iTgt + 1.0) + (real_T)i;
    }
  } else {
    st.site = &pl_emlrtRSI;
    eml_float_colon(&st, iTgt + 1.0, (real_T)tgtRngs_size[1], &y);
  }

  b_iTgt = tgtRngs_size[1];
  trueCount = b_i + y.size[1];
  for (i = 0; i < b_i; i++) {
    i1 = (int32_T)emlrtIntegerCheckR2012b(b_y_data[i], &j_emlrtDCI,
      (emlrtConstCTX)sp);
    c_y_data[i] = emlrtDynamicBoundsCheckR2012b(i1, 1, b_iTgt, &nf_emlrtBCI,
      (emlrtConstCTX)sp) - 1;
  }

  loop_ub = y.size[1];
  for (i = 0; i < loop_ub; i++) {
    d = y.vector.data[i];
    i1 = (int32_T)emlrtIntegerCheckR2012b(d, &j_emlrtDCI, (emlrtConstCTX)sp);
    c_y_data[i + b_i] = emlrtDynamicBoundsCheckR2012b(i1, 1, b_iTgt,
      &nf_emlrtBCI, (emlrtConstCTX)sp) - 1;
  }

  array_real_T_2D_Destructor(&y);
  rgOthers_size[0] = 1;
  rgOthers_size[1] = trueCount;
  for (i = 0; i < trueCount; i++) {
    rgOthers_data[i] = tgtRngs_data[c_y_data[i]];
  }

  *rgTgt = b_rgTgt;
}

static boolean_T visionDetectionGenerator_computeOccludedView
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_2D *Utgt, real_T rgTgt, coder_array_real_T_3D *Uothers,
   real_T rgOthers_data[], int32_T rgOthers_size[2], real_T imagSz[2])
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 36 };

  static char_T b_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  coder_array_boolean_T r;
  coder_array_boolean_T_2D c_rgOthers_data;
  coder_array_int32_T b_ii;
  coder_array_int32_T_2D b_i;
  coder_array_int32_T_2D ii;
  coder_array_real_T iBrk;
  coder_array_real_T_2D Ublock;
  coder_array_real_T_2D b_Ublock;
  coder_array_real_T_2D b_uOcc;
  coder_array_real_T_2D b_vOcc;
  coder_array_real_T_2D e_Utgt_data;
  coder_array_real_T_2D f_Utgt_data;
  coder_array_real_T_2D idx;
  coder_array_real_T_2D uOcc;
  coder_array_real_T_2D vCrop;
  coder_array_real_T_2D vOcc;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T b_dv[4];
  real_T dv1[4];
  real_T d;
  real_T iStart;
  real_T numPixels;
  real_T totNumPixels;
  int32_T Ublock_size[2];
  int32_T Utgt_size[2];
  int32_T b_Ublock_size[2];
  int32_T b_Utgt_size[2];
  int32_T iGd_size[2];
  int32_T Utgt_size_idx_1;
  int32_T b_Utgt_size_idx_1;
  int32_T c_i;
  int32_T i;
  int32_T i1;
  int32_T iTgt;
  int32_T loop_ub;
  int16_T c_tmp_data[4200];
  char_T u[36];
  boolean_T iGd_data[4200];
  boolean_T b_rgOthers_data[598];
  boolean_T b_iGd_data;
  boolean_T exitg1;
  boolean_T isOccluded;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  isOccluded = true;
  Utgt_size_idx_1 = Utgt->size[1];
  loop_ub = Utgt->size[1];
  for (i = 0; i < loop_ub; i++) {
    moduleInstance->Utgt_data[i] = Utgt->vector.data[i << 1];
  }

  b_Utgt_size_idx_1 = Utgt->size[1];
  loop_ub = Utgt->size[1];
  for (i = 0; i < loop_ub; i++) {
    moduleInstance->b_Utgt_data[i] = Utgt->vector.data[(i << 1) + 1];
  }

  e_Utgt_data.vector.data = &moduleInstance->Utgt_data[0];
  e_Utgt_data.vector.numel = Utgt_size_idx_1;
  e_Utgt_data.vector.allocated = Utgt_size_idx_1;
  e_Utgt_data.vector.owner = false;
  e_Utgt_data.size[0] = 1;
  e_Utgt_data.size[1] = Utgt_size_idx_1;
  f_Utgt_data.vector.data = &moduleInstance->b_Utgt_data[0];
  f_Utgt_data.vector.numel = b_Utgt_size_idx_1;
  f_Utgt_data.vector.allocated = b_Utgt_size_idx_1;
  f_Utgt_data.vector.owner = false;
  f_Utgt_data.size[0] = 1;
  f_Utgt_data.size[1] = b_Utgt_size_idx_1;
  st.site = &dm_emlrtRSI;
  totNumPixels = polyarea(&st, &e_Utgt_data, &f_Utgt_data);
  Utgt_size[0] = 1;
  Utgt_size[1] = Utgt->size[1];
  loop_ub = Utgt->size[1];
  b_Utgt_size[0] = 1;
  b_Utgt_size[1] = Utgt->size[1];
  for (i = 0; i < loop_ub; i++) {
    moduleInstance->c_Utgt_data[i] = Utgt->vector.data[i << 1];
    moduleInstance->d_Utgt_data[i] = Utgt->vector.data[(i << 1) + 1];
  }

  b_dv[0] = 1.0;
  b_dv[1] = 1.0;
  b_dv[2] = imagSz[1];
  b_dv[3] = imagSz[1];
  dv1[0] = 1.0;
  dv1[1] = imagSz[0];
  dv1[2] = imagSz[0];
  dv1[3] = 1.0;
  array_real_T_2D_Constructor(&vCrop);
  array_real_T_2D_Constructor(&idx);
  st.site = &em_emlrtRSI;
  PolygonBooleanAPI_polybool(moduleInstance, &st, moduleInstance->c_Utgt_data,
    Utgt_size, moduleInstance->d_Utgt_data, b_Utgt_size, b_dv, dv1, &idx, &vCrop);
  if (idx.size[1] != 0) {
    array_int32_T_2D_Constructor(&b_i);
    loop_ub = rgOthers_size[0] * rgOthers_size[1];
    for (i = 0; i < loop_ub; i++) {
      b_rgOthers_data[i] = (rgOthers_data[i] <= rgTgt);
    }

    c_rgOthers_data.vector.data = &b_rgOthers_data[0];
    c_rgOthers_data.vector.numel = rgOthers_size[1];
    c_rgOthers_data.vector.allocated = rgOthers_size[1];
    c_rgOthers_data.vector.owner = false;
    c_rgOthers_data.size[0] = 1;
    c_rgOthers_data.size[1] = rgOthers_size[1];
    array_int32_T_2D_Constructor(&ii);
    st.site = &nl_emlrtRSI;
    b_eml_find(&st, &c_rgOthers_data, &ii);
    array_int32_T_2D_SetSize(&b_i, 1, ii.size[1]);
    loop_ub = ii.size[1];
    for (i = 0; i < loop_ub; i++) {
      b_i.vector.data[i] = ii.vector.data[i];
    }

    array_int32_T_2D_Destructor(&ii);
    array_real_T_2D_Constructor(&uOcc);
    array_real_T_2D_SetSize(&uOcc, 1, idx.size[1]);
    loop_ub = idx.size[1];
    for (i = 0; i < loop_ub; i++) {
      uOcc.vector.data[i] = idx.vector.data[i];
    }

    array_real_T_2D_Constructor(&vOcc);
    array_real_T_2D_SetSize(&vOcc, 1, vCrop.size[1]);
    loop_ub = vCrop.size[1];
    for (i = 0; i < loop_ub; i++) {
      vOcc.vector.data[i] = vCrop.vector.data[i];
    }

    iTgt = 1;
    array_real_T_2D_Constructor(&Ublock);
    array_real_T_2D_Constructor(&b_Ublock);
    exitg1 = false;
    while ((!exitg1) && (iTgt - 1 <= b_i.size[1] - 1)) {
      i = b_i.vector.data[emlrtDynamicBoundsCheckR2012b(iTgt, 1, b_i.size[1],
        &qf_emlrtBCI, (emlrtConstCTX)sp) - 1];
      c_i = emlrtDynamicBoundsCheckR2012b(i, 1, Uothers->size[2], &pf_emlrtBCI,
        (emlrtConstCTX)sp);
      array_real_T_2D_SetSize(&Ublock, 2, Uothers->size[1]);
      loop_ub = Uothers->size[1];
      for (i = 0; i < loop_ub; i++) {
        for (i1 = 0; i1 < 2; i1++) {
          Ublock.vector.data[i1 + (i << 1)] = Uothers->vector.data[(i1 + (i << 1))
            + (Uothers->size[1] << 1) * (c_i - 1)];
        }
      }

      iGd_size[0] = 1;
      iGd_size[1] = Uothers->size[1];
      loop_ub = Uothers->size[1];
      for (i = 0; i < loop_ub; i++) {
        iGd_data[i] = !muDoubleScalarIsNaN(Ublock.vector.data[i << 1]);
      }

      if ((iGd_size[1] == 1) || (iGd_size[1] != 1)) {
      } else {
        for (i = 0; i < 36; i++) {
          u[i] = b_u[i];
        }

        y = NULL;
        m = emlrtCreateCharArray(2, &iv[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
        emlrtAssign(&y, m);
        for (i = 0; i < 36; i++) {
          u[i] = b_u[i];
        }

        b_y = NULL;
        m = emlrtCreateCharArray(2, &iv1[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
        emlrtAssign(&b_y, m);
        st.site = &rv_emlrtRSI;
        error(&st, y, getString(&st, b_message(&st, b_y, &kb_emlrtMCI),
               &kb_emlrtMCI), &kb_emlrtMCI);
      }

      if (b_combineVectorElements(iGd_data, iGd_size) >= 3) {
        Utgt_size_idx_1 = iGd_size[1];
        loop_ub = 0;
        b_Utgt_size_idx_1 = 0;
        for (c_i = 0; c_i < Utgt_size_idx_1; c_i++) {
          b_iGd_data = iGd_data[c_i];
          if (b_iGd_data) {
            loop_ub++;
            c_tmp_data[b_Utgt_size_idx_1] = (int16_T)c_i;
            b_Utgt_size_idx_1++;
          }
        }

        Utgt_size_idx_1 = Uothers->size[1];
        array_real_T_2D_SetSize(&b_Ublock, 2, loop_ub);
        for (i = 0; i < loop_ub; i++) {
          for (i1 = 0; i1 < 2; i1++) {
            b_Ublock.vector.data[i1 + (i << 1)] = Ublock.vector.data[i1 +
              (emlrtDynamicBoundsCheckR2012b((int32_T)c_tmp_data[i], 0,
                Utgt_size_idx_1 - 1, &rf_emlrtBCI, (emlrtConstCTX)sp) << 1)];
          }
        }

        array_real_T_2D_SetSize(&Ublock, 2, b_Ublock.size[1]);
        loop_ub = b_Ublock.size[0] * b_Ublock.size[1];
        for (i = 0; i < loop_ub; i++) {
          Ublock.vector.data[i] = b_Ublock.vector.data[i];
        }

        Ublock_size[0] = 1;
        Ublock_size[1] = Ublock.size[1];
        loop_ub = Ublock.size[1];
        b_Ublock_size[0] = 1;
        b_Ublock_size[1] = Ublock.size[1];
        for (i = 0; i < loop_ub; i++) {
          moduleInstance->c_Utgt_data[i] = Ublock.vector.data[i << 1];
          moduleInstance->d_Utgt_data[i] = Ublock.vector.data[(i << 1) + 1];
        }

        st.site = &fm_emlrtRSI;
        b_PolygonBooleanAPI_polybool(moduleInstance, &st, &uOcc, &vOcc,
          moduleInstance->c_Utgt_data, Ublock_size, moduleInstance->d_Utgt_data,
          b_Ublock_size, &idx, &vCrop);
        array_real_T_2D_SetSize(&uOcc, 1, idx.size[1]);
        loop_ub = idx.size[1];
        for (i = 0; i < loop_ub; i++) {
          uOcc.vector.data[i] = idx.vector.data[i];
        }

        array_real_T_2D_SetSize(&vOcc, 1, vCrop.size[1]);
        loop_ub = vCrop.size[1];
        for (i = 0; i < loop_ub; i++) {
          vOcc.vector.data[i] = vCrop.vector.data[i];
        }
      }

      if (uOcc.size[1] == 0) {
        exitg1 = true;
      } else {
        iTgt++;
      }
    }

    array_real_T_2D_Destructor(&b_Ublock);
    array_int32_T_2D_Destructor(&b_i);
    array_real_T_2D_Destructor(&Ublock);
    st.site = &gm_emlrtRSI;
    Utgt_size_idx_1 = uOcc.size[1];
    array_boolean_T_Constructor(&r);
    array_boolean_T_SetSize(&r, uOcc.size[1]);
    for (i = 0; i < Utgt_size_idx_1; i++) {
      r.vector.data[i] = muDoubleScalarIsNaN(uOcc.vector.data[i]);
    }

    array_int32_T_Constructor(&b_ii);
    b_st.site = &nl_emlrtRSI;
    eml_find(&b_st, &r, &b_ii);
    array_boolean_T_Destructor(&r);
    array_real_T_Constructor(&iBrk);
    array_real_T_SetSize(&iBrk, b_ii.size[0] + 1);
    loop_ub = b_ii.size[0];
    for (i = 0; i < loop_ub; i++) {
      iBrk.vector.data[i] = (real_T)b_ii.vector.data[i];
    }

    iBrk.vector.data[b_ii.size[0]] = (real_T)uOcc.size[1] + 1.0;
    array_int32_T_Destructor(&b_ii);
    iStart = 1.0;
    numPixels = 0.0;
    i = iBrk.size[0];
    array_real_T_2D_Constructor(&b_uOcc);
    array_real_T_2D_Constructor(&b_vOcc);
    for (b_Utgt_size_idx_1 = 0; b_Utgt_size_idx_1 < i; b_Utgt_size_idx_1++) {
      emlrtDynamicBoundsCheckR2012b(b_Utgt_size_idx_1 + 1, 1, iBrk.size[0],
        &of_emlrtBCI, &st);
      if (iBrk.vector.data[b_Utgt_size_idx_1] - 1.0 < iStart) {
        array_real_T_2D_SetSize(&idx, 1, 0);
      } else {
        d = iBrk.vector.data[b_Utgt_size_idx_1] - 1.0;
        array_real_T_2D_SetSize(&idx, 1, (int32_T)(d - iStart) + 1);
        loop_ub = (int32_T)(d - iStart);
        for (i1 = 0; i1 <= loop_ub; i1++) {
          idx.vector.data[i1] = iStart + (real_T)i1;
        }
      }

      array_real_T_2D_SetSize(&b_uOcc, 1, idx.size[1]);
      loop_ub = idx.size[0] * idx.size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        d = idx.vector.data[i1];
        Utgt_size_idx_1 = (int32_T)emlrtIntegerCheckR2012b(d, &k_emlrtDCI, &st);
        b_uOcc.vector.data[i1] = uOcc.vector.data[emlrtDynamicBoundsCheckR2012b
          (Utgt_size_idx_1, 1, uOcc.size[1], &sf_emlrtBCI, &st) - 1];
      }

      array_real_T_2D_SetSize(&b_vOcc, 1, idx.size[1]);
      loop_ub = idx.size[0] * idx.size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        Utgt_size_idx_1 = (int32_T)idx.vector.data[i1];
        b_vOcc.vector.data[i1] = vOcc.vector.data[emlrtDynamicBoundsCheckR2012b
          (Utgt_size_idx_1, 1, vOcc.size[1], &tf_emlrtBCI, &st) - 1];
      }

      b_st.site = &qm_emlrtRSI;
      numPixels += polyarea(&b_st, &b_uOcc, &b_vOcc);
      iStart = iBrk.vector.data[emlrtDynamicBoundsCheckR2012b(b_Utgt_size_idx_1
        + 1, 1, iBrk.size[0], &uf_emlrtBCI, &st) - 1] + 1.0;
    }

    array_real_T_2D_Destructor(&b_vOcc);
    array_real_T_2D_Destructor(&b_uOcc);
    array_real_T_Destructor(&iBrk);
    array_real_T_2D_Destructor(&vOcc);
    array_real_T_2D_Destructor(&uOcc);
    isOccluded = (1.0 - numPixels / totNumPixels > 0.5);
  }

  array_real_T_2D_Destructor(&idx);
  array_real_T_2D_Destructor(&vCrop);
  return isOccluded;
}

static real_T polyarea(const emlrtStack *sp, coder_array_real_T_2D *x,
  coder_array_real_T_2D *y)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'p', 'o', 'l',
    'y', 'a', 'r', 'e', 'a', ':', 'X', 'Y', 'S', 'i', 'z', 'e', 'M', 'i', 's',
    'm', 'a', 't', 'c', 'h' };

  emlrtStack st;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  real_T b_x[2];
  real_T b_y[2];
  real_T area;
  real_T s;
  int32_T i;
  int32_T k;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 2; i++) {
    b_x[i] = (real_T)x->size[i];
    b_y[i] = (real_T)y->size[i];
  }

  if (!isequal(b_x, b_y)) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&d_y, m);
    st.site = &qw_emlrtRSI;
    error(&st, c_y, getString(&st, b_message(&st, d_y, &fc_emlrtMCI),
           &fc_emlrtMCI), &fc_emlrtMCI);
  }

  if (x->size[1] == 0) {
    area = 0.0;
  } else {
    s = (x->vector.data[0] - x->vector.data[x->size[1] - 1]) * (y->vector.data[0]
      + y->vector.data[x->size[1] - 1]) / 2.0;
    i = x->size[1] - 2;
    for (k = 0; k <= i; k++) {
      s += (x->vector.data[k + 1] - x->vector.data[k]) * (y->vector.data[k + 1]
        + y->vector.data[k]) / 2.0;
    }

    area = muDoubleScalarAbs(s);
  }

  return area;
}

static void PolygonBooleanAPI_polybool(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, real_T b_x1_data[], int32_T x1_size[2],
  real_T y1_data[], int32_T y1_size[2], real_T x2[4], real_T y2[4],
  coder_array_real_T_2D *rxOut, coder_array_real_T_2D *ryOut)
{
  static const int32_T iv[2] = { 1, 46 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv10[2] = { 1, 40 };

  static const int32_T iv11[2] = { 1, 39 };

  static const int32_T iv12[2] = { 1, 37 };

  static const int32_T iv13[2] = { 1, 40 };

  static const int32_T iv14[2] = { 1, 39 };

  static const int32_T iv15[2] = { 1, 37 };

  static const int32_T iv16[2] = { 1, 40 };

  static const int32_T iv17[2] = { 1, 39 };

  static const int32_T iv18[2] = { 1, 37 };

  static const int32_T iv19[2] = { 1, 40 };

  static const int32_T iv2[2] = { 1, 2 };

  static const int32_T iv3[2] = { 1, 2 };

  static const int32_T iv4[2] = { 1, 39 };

  static const int32_T iv5[2] = { 1, 39 };

  static const int32_T iv6[2] = { 1, 39 };

  static const int32_T iv7[2] = { 1, 39 };

  static const int32_T iv8[2] = { 1, 39 };

  static const int32_T iv9[2] = { 1, 37 };

  static char_T b_u[46] = { 's', 'h', 'a', 'r', 'e', 'd', '_', 't', 'r', 'a',
    'c', 'k', 'i', 'n', 'g', ':', 'P', 'o', 'l', 'y', 'g', 'o', 'n', 'B', 'o',
    'o', 'l', 'e', 'a', 'n', 'A', 'P', 'I', ':', 'n', 'u', 'm', 'e', 'l', 'N',
    'o', 'M', 'a', 't', 'c', 'h' };

  static char_T l_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T g_u[39] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'a', 't',
    'e', 'n', 'a', 't', 'e', ':', 'm', 'a', 't', 'r', 'i', 'x', 'D', 'i', 'm',
    'e', 'n', 's', 'i', 'o', 'n', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h' };

  static char_T i_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T k_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'h', 'e',
    'c', 'k', 'D', 'i', 'm', 'C', 'o', 'm', 'm', 'o', 'n', ':', 'n', 'o', 'n',
    'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', 'S', 'i', 'z', 'e' };

  static char_T d_u[2] = { 'x', '1' };

  static char_T e_u[2] = { 'y', '1' };

  coder_array_int32_T_2D T;
  coder_array_real_T b_mp_c;
  coder_array_real_T b_mp_p;
  coder_array_real_T b_mp_v;
  coder_array_real_T b_rx;
  coder_array_real_T b_ry;
  coder_array_real_T mp_c;
  coder_array_real_T mp_p;
  coder_array_real_T mp_v;
  coder_array_real_T rx;
  coder_array_real_T ry;
  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *m_y;
  const mxArray *n_y;
  const mxArray *o_y;
  const mxArray *p_y;
  const mxArray *q_y;
  const mxArray *r_y;
  const mxArray *s_y;
  const mxArray *t_y;
  const mxArray *y;
  real_T b_y1_data[4200];
  real_T b_x2[4];
  real_T b_y2[4];
  real_T scale;
  int32_T i;
  int32_T nvtx;
  int32_T op_type;
  int32_T size1;
  int32_T size2;
  char_T u[46];
  char_T j_u[40];
  char_T f_u[39];
  char_T h_u[37];
  char_T c_u[2];
  boolean_T b;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &hm_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (x1_size[1] - 1 >= 0) {
    memcpy(&moduleInstance->x1_data[0], &b_x1_data[0], (uint32_T)x1_size[1] *
           sizeof(real_T));
  }

  if (y1_size[1] - 1 >= 0) {
    memcpy(&b_y1_data[0], &y1_data[0], (uint32_T)y1_size[1] * sizeof(real_T));
  }

  for (i = 0; i < 4; i++) {
    b_x2[i] = x2[i];
    b_y2[i] = y2[i];
  }

  if (x1_size[1] != y1_size[1]) {
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = d_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 2, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = e_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&st, 2, m, &c_u[0]);
    emlrtAssign(&d_y, m);
    b_st.site = &nw_emlrtRSI;
    error(&b_st, y, getString(&b_st, c_message(&b_st, b_y, c_y, d_y,
            &gc_emlrtMCI), &gc_emlrtMCI), &gc_emlrtMCI);
  }

  size1 = x1_size[1];
  size2 = 4;
  scale = -1.0;
  op_type = 1;
  nvtx = (int32_T)muDoubleScalarRound((real_T)x1_size[1] * 1.5) + 206;
  array_real_T_Constructor(&rx);
  array_real_T_SetSize(&rx, nvtx);
  for (i = 0; i < nvtx; i++) {
    rx.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&ry);
  array_real_T_SetSize(&ry, nvtx);
  for (i = 0; i < nvtx; i++) {
    ry.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_p);
  array_real_T_SetSize(&mp_p, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_p.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_c);
  array_real_T_SetSize(&mp_c, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_c.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_v);
  array_real_T_SetSize(&mp_v, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_v.vector.data[i] = 0.0;
  }

  polyBoolean_c(&moduleInstance->x1_data[0], &b_y1_data[0], &size1, &b_x2[0],
                &b_y2[0], &size2, &scale, &op_type, &rx.vector.data[0],
                &ry.vector.data[0], &nvtx, &mp_p.vector.data[0],
                &mp_c.vector.data[0], &mp_v.vector.data[0]);
  array_int32_T_2D_Constructor(&T);
  b_st.site = &nm_emlrtRSI;
  eml_integer_colon_dispatcher(&b_st, nvtx, &T);
  b_st.site = &mm_emlrtRSI;
  indexShapeCheck(&b_st, rx.size[0], T.size);
  array_real_T_Constructor(&b_rx);
  array_real_T_SetSize(&b_rx, T.size[1]);
  size1 = T.size[1];
  for (i = 0; i < size1; i++) {
    size2 = T.vector.data[i];
    b_rx.vector.data[i] = rx.vector.data[emlrtDynamicBoundsCheckR2012b(size2, 1,
      rx.size[0], &vf_emlrtBCI, &st) - 1];
  }

  array_real_T_SetSize(&rx, b_rx.size[0]);
  size1 = b_rx.size[0];
  for (i = 0; i < size1; i++) {
    rx.vector.data[i] = b_rx.vector.data[i];
  }

  array_real_T_Destructor(&b_rx);
  b_st.site = &lm_emlrtRSI;
  indexShapeCheck(&b_st, ry.size[0], T.size);
  array_real_T_Constructor(&b_ry);
  array_real_T_SetSize(&b_ry, T.size[1]);
  size1 = T.size[1];
  for (i = 0; i < size1; i++) {
    size2 = T.vector.data[i];
    b_ry.vector.data[i] = ry.vector.data[emlrtDynamicBoundsCheckR2012b(size2, 1,
      ry.size[0], &wf_emlrtBCI, &st) - 1];
  }

  array_real_T_SetSize(&ry, b_ry.size[0]);
  size1 = b_ry.size[0];
  for (i = 0; i < size1; i++) {
    ry.vector.data[i] = b_ry.vector.data[i];
  }

  array_real_T_Destructor(&b_ry);
  b_st.site = &km_emlrtRSI;
  indexShapeCheck(&b_st, mp_p.size[0], T.size);
  array_real_T_Constructor(&b_mp_p);
  array_real_T_SetSize(&b_mp_p, T.size[1]);
  size1 = T.size[1];
  for (i = 0; i < size1; i++) {
    size2 = T.vector.data[i];
    b_mp_p.vector.data[i] = mp_p.vector.data[emlrtDynamicBoundsCheckR2012b(size2,
      1, mp_p.size[0], &xf_emlrtBCI, &st) - 1];
  }

  array_real_T_SetSize(&mp_p, b_mp_p.size[0]);
  size1 = b_mp_p.size[0];
  for (i = 0; i < size1; i++) {
    mp_p.vector.data[i] = b_mp_p.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_p);
  b_st.site = &jm_emlrtRSI;
  indexShapeCheck(&b_st, mp_c.size[0], T.size);
  array_real_T_Constructor(&b_mp_c);
  array_real_T_SetSize(&b_mp_c, T.size[1]);
  size1 = T.size[1];
  for (i = 0; i < size1; i++) {
    size2 = T.vector.data[i];
    b_mp_c.vector.data[i] = mp_c.vector.data[emlrtDynamicBoundsCheckR2012b(size2,
      1, mp_c.size[0], &yf_emlrtBCI, &st) - 1];
  }

  array_real_T_SetSize(&mp_c, b_mp_c.size[0]);
  size1 = b_mp_c.size[0];
  for (i = 0; i < size1; i++) {
    mp_c.vector.data[i] = b_mp_c.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_c);
  b_st.site = &im_emlrtRSI;
  indexShapeCheck(&b_st, mp_v.size[0], T.size);
  array_real_T_Constructor(&b_mp_v);
  array_real_T_SetSize(&b_mp_v, T.size[1]);
  size1 = T.size[1];
  for (i = 0; i < size1; i++) {
    size2 = T.vector.data[i];
    b_mp_v.vector.data[i] = mp_v.vector.data[emlrtDynamicBoundsCheckR2012b(size2,
      1, mp_v.size[0], &ag_emlrtBCI, &st) - 1];
  }

  array_int32_T_2D_Destructor(&T);
  array_real_T_SetSize(&mp_v, b_mp_v.size[0]);
  size1 = b_mp_v.size[0];
  for (i = 0; i < size1; i++) {
    mp_v.vector.data[i] = b_mp_v.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_v);
  b = true;
  if (mp_c.size[0] != mp_p.size[0]) {
    b = false;
  }

  array_real_T_Destructor(&mp_c);
  if (!b) {
    for (i = 0; i < 39; i++) {
      f_u[i] = g_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &f_u[0]);
    emlrtAssign(&e_y, m);
    for (i = 0; i < 39; i++) {
      f_u[i] = g_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &f_u[0]);
    emlrtAssign(&g_y, m);
    b_st.site = &lw_emlrtRSI;
    error(&b_st, e_y, getString(&b_st, b_message(&b_st, g_y, &t_emlrtMCI),
           &t_emlrtMCI), &t_emlrtMCI);
  }

  array_real_T_Destructor(&mp_v);
  array_real_T_Destructor(&mp_p);
  if (mp_v.size[0] != mp_p.size[0]) {
    for (i = 0; i < 39; i++) {
      f_u[i] = g_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &f_u[0]);
    emlrtAssign(&f_y, m);
    for (i = 0; i < 39; i++) {
      f_u[i] = g_u[i];
    }

    i_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a(&st, 39, m, &f_u[0]);
    emlrtAssign(&i_y, m);
    b_st.site = &lw_emlrtRSI;
    error(&b_st, f_y, getString(&b_st, b_message(&b_st, i_y, &t_emlrtMCI),
           &t_emlrtMCI), &t_emlrtMCI);
  }

  st.site = &lc_emlrtRSI;
  size2 = c_computeDimsData(rx.size[0]);
  size1 = rx.size[0];
  if (rx.size[0] < 1) {
    size1 = 1;
  }

  if (size2 > muIntScalarMax_sint32(rx.size[0], size1)) {
    for (i = 0; i < 39; i++) {
      f_u[i] = i_u[i];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &f_u[0]);
    emlrtAssign(&h_y, m);
    for (i = 0; i < 39; i++) {
      f_u[i] = i_u[i];
    }

    l_y = NULL;
    m = emlrtCreateCharArray(2, &iv11[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &f_u[0]);
    emlrtAssign(&l_y, m);
    st.site = &qv_emlrtRSI;
    error(&st, h_y, getString(&st, b_message(&st, l_y, &g_emlrtMCI), &g_emlrtMCI),
          &g_emlrtMCI);
  }

  if (size2 < 0) {
    for (i = 0; i < 37; i++) {
      h_u[i] = k_u[i];
    }

    j_y = NULL;
    m = emlrtCreateCharArray(2, &iv9[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &h_u[0]);
    emlrtAssign(&j_y, m);
    for (i = 0; i < 37; i++) {
      h_u[i] = k_u[i];
    }

    m_y = NULL;
    m = emlrtCreateCharArray(2, &iv12[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &h_u[0]);
    emlrtAssign(&m_y, m);
    st.site = &ow_emlrtRSI;
    error(&st, j_y, getString(&st, b_message(&st, m_y, &h_emlrtMCI), &h_emlrtMCI),
          &h_emlrtMCI);
  }

  if (size2 != rx.size[0]) {
    for (i = 0; i < 40; i++) {
      j_u[i] = l_u[i];
    }

    k_y = NULL;
    m = emlrtCreateCharArray(2, &iv10[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &j_u[0]);
    emlrtAssign(&k_y, m);
    for (i = 0; i < 40; i++) {
      j_u[i] = l_u[i];
    }

    n_y = NULL;
    m = emlrtCreateCharArray(2, &iv13[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &j_u[0]);
    emlrtAssign(&n_y, m);
    st.site = &ov_emlrtRSI;
    error(&st, k_y, getString(&st, b_message(&st, n_y, &i_emlrtMCI), &i_emlrtMCI),
          &i_emlrtMCI);
  }

  array_real_T_2D_SetSize(rxOut, 1, size2);
  for (i = 0; i < size2; i++) {
    rxOut->vector.data[i] = rx.vector.data[i];
  }

  array_real_T_Destructor(&rx);
  st.site = &lc_emlrtRSI;
  size2 = c_computeDimsData(ry.size[0]);
  size1 = ry.size[0];
  if (ry.size[0] < 1) {
    size1 = 1;
  }

  if (size2 > muIntScalarMax_sint32(ry.size[0], size1)) {
    for (i = 0; i < 39; i++) {
      f_u[i] = i_u[i];
    }

    o_y = NULL;
    m = emlrtCreateCharArray(2, &iv14[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &f_u[0]);
    emlrtAssign(&o_y, m);
    for (i = 0; i < 39; i++) {
      f_u[i] = i_u[i];
    }

    r_y = NULL;
    m = emlrtCreateCharArray(2, &iv17[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &f_u[0]);
    emlrtAssign(&r_y, m);
    st.site = &qv_emlrtRSI;
    error(&st, o_y, getString(&st, b_message(&st, r_y, &g_emlrtMCI), &g_emlrtMCI),
          &g_emlrtMCI);
  }

  if (size2 < 0) {
    for (i = 0; i < 37; i++) {
      h_u[i] = k_u[i];
    }

    p_y = NULL;
    m = emlrtCreateCharArray(2, &iv15[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &h_u[0]);
    emlrtAssign(&p_y, m);
    for (i = 0; i < 37; i++) {
      h_u[i] = k_u[i];
    }

    s_y = NULL;
    m = emlrtCreateCharArray(2, &iv18[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &h_u[0]);
    emlrtAssign(&s_y, m);
    st.site = &ow_emlrtRSI;
    error(&st, p_y, getString(&st, b_message(&st, s_y, &h_emlrtMCI), &h_emlrtMCI),
          &h_emlrtMCI);
  }

  if (size2 != ry.size[0]) {
    for (i = 0; i < 40; i++) {
      j_u[i] = l_u[i];
    }

    q_y = NULL;
    m = emlrtCreateCharArray(2, &iv16[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &j_u[0]);
    emlrtAssign(&q_y, m);
    for (i = 0; i < 40; i++) {
      j_u[i] = l_u[i];
    }

    t_y = NULL;
    m = emlrtCreateCharArray(2, &iv19[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &j_u[0]);
    emlrtAssign(&t_y, m);
    st.site = &ov_emlrtRSI;
    error(&st, q_y, getString(&st, b_message(&st, t_y, &i_emlrtMCI), &i_emlrtMCI),
          &i_emlrtMCI);
  }

  array_real_T_2D_SetSize(ryOut, 1, size2);
  for (i = 0; i < size2; i++) {
    ryOut->vector.data[i] = ry.vector.data[i];
  }

  array_real_T_Destructor(&ry);
}

static void eml_integer_colon_dispatcher(const emlrtStack *sp, int32_T b,
  coder_array_int32_T_2D *y)
{
  emlrtStack b_st;
  emlrtStack st;
  int32_T k;
  int32_T n;
  int32_T yk;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &om_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (b < 1) {
    n = 0;
  } else {
    b_st.site = &pm_emlrtRSI;
    assert_pmaxsize(&b_st, true);
    n = b;
  }

  array_int32_T_2D_SetSize(y, 1, n);
  if (n > 0) {
    y->vector.data[0] = 1;
    yk = 1;
    for (k = 2; k <= n; k++) {
      yk++;
      y->vector.data[k - 1] = yk;
    }
  }
}

static int32_T c_computeDimsData(int32_T nx)
{
  return nx;
}

static void b_eml_find(const emlrtStack *sp, coder_array_boolean_T_2D *x,
  coder_array_int32_T_2D *i)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'b', 'u', 'i', 'l',
    't', 'i', 'n', 's', ':', 'A', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', 'F',
    'a', 'i', 'l', 'e', 'd' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T idx;
  int32_T ii;
  int32_T nx;
  char_T u[30];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  nx = x->size[1];
  idx = 0;
  array_int32_T_2D_SetSize(i, 1, x->size[1]);
  ii = 1;
  exitg1 = false;
  while ((!exitg1) && (ii - 1 <= nx - 1)) {
    if (x->vector.data[ii - 1]) {
      idx++;
      i->vector.data[idx - 1] = ii;
      if (idx >= nx) {
        exitg1 = true;
      } else {
        ii++;
      }
    } else {
      ii++;
    }
  }

  if (idx > x->size[1]) {
    for (nx = 0; nx < 30; nx++) {
      u[nx] = b_u[nx];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (nx = 0; nx < 30; nx++) {
      u[nx] = b_u[nx];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &pw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &bc_emlrtMCI), &bc_emlrtMCI),
          &bc_emlrtMCI);
  }

  if (x->size[1] == 1) {
    if (idx == 0) {
      array_int32_T_2D_SetSize(i, 1, 0);
    }
  } else {
    if (idx < 1) {
      idx = 0;
    }

    array_int32_T_2D_SetSize(i, i->size[0], idx);
  }
}

static void b_PolygonBooleanAPI_polybool(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, coder_array_real_T_2D *x1,
  coder_array_real_T_2D *c_y1, real_T b_x2_data[], int32_T x2_size[2], real_T
  y2_data[], int32_T y2_size[2], coder_array_real_T_2D *rxOut,
  coder_array_real_T_2D *ryOut)
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 37 };

  static const int32_T iv10[2] = { 1, 37 };

  static const int32_T iv11[2] = { 1, 40 };

  static const int32_T iv2[2] = { 1, 40 };

  static const int32_T iv3[2] = { 1, 39 };

  static const int32_T iv4[2] = { 1, 37 };

  static const int32_T iv5[2] = { 1, 40 };

  static const int32_T iv6[2] = { 1, 39 };

  static const int32_T iv7[2] = { 1, 37 };

  static const int32_T iv8[2] = { 1, 40 };

  static const int32_T iv9[2] = { 1, 39 };

  static char_T f_u[40] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'g', 'e', 't', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'D', 'i',
    'm', 's', '_', 'n', 'o', 't', 'S', 'a', 'm', 'e', 'N', 'u', 'm', 'e', 'l' };

  static char_T c_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'r', 'e', 's', 'h', 'a', 'p', 'e', '_', 'e', 'm', 'p',
    't', 'y', 'R', 'e', 's', 'h', 'a', 'p', 'e', 'L', 'i', 'm', 'i', 't' };

  static char_T e_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'h', 'e',
    'c', 'k', 'D', 'i', 'm', 'C', 'o', 'm', 'm', 'o', 'n', ':', 'n', 'o', 'n',
    'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', 'S', 'i', 'z', 'e' };

  coder_array_real_T rx;
  coder_array_real_T ry;
  coder_array_real_T_2D b_x1;
  coder_array_real_T_2D d_y1;
  coder_array_real_T_2D mp;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *y;
  real_T b_y2_data[4200];
  int32_T b_x2_size[2];
  int32_T b_y2_size[2];
  int32_T emptyDimValue;
  int32_T i;
  int32_T n;
  char_T d_u[40];
  char_T u[39];
  char_T b_u[37];
  st.prev = sp;
  st.tls = sp->tls;
  array_real_T_2D_Constructor(&b_x1);
  array_real_T_2D_SetSize(&b_x1, 1, x1->size[1]);
  n = x1->size[1];
  for (i = 0; i < n; i++) {
    b_x1.vector.data[i] = x1->vector.data[i];
  }

  array_real_T_2D_Constructor(&d_y1);
  array_real_T_2D_SetSize(&d_y1, 1, c_y1->size[1]);
  n = c_y1->size[1];
  for (i = 0; i < n; i++) {
    d_y1.vector.data[i] = c_y1->vector.data[i];
  }

  b_x2_size[0] = 1;
  b_x2_size[1] = x2_size[1];
  if (x2_size[1] - 1 >= 0) {
    memcpy(&moduleInstance->x2_data[0], &b_x2_data[0], (uint32_T)x2_size[1] *
           sizeof(real_T));
  }

  b_y2_size[0] = 1;
  b_y2_size[1] = y2_size[1];
  if (y2_size[1] - 1 >= 0) {
    memcpy(&b_y2_data[0], &y2_data[0], (uint32_T)y2_size[1] * sizeof(real_T));
  }

  array_real_T_Constructor(&rx);
  array_real_T_Constructor(&ry);
  array_real_T_2D_Constructor(&mp);
  st.site = &hm_emlrtRSI;
  polyBgen(&st, &b_x1, &d_y1, moduleInstance->x2_data, b_x2_size, b_y2_data,
           b_y2_size, &rx, &ry, &mp);
  array_real_T_2D_Destructor(&d_y1);
  array_real_T_2D_Destructor(&b_x1);
  array_real_T_2D_Destructor(&mp);
  st.site = &lc_emlrtRSI;
  emptyDimValue = c_computeDimsData(rx.size[0]);
  n = rx.size[0];
  if (rx.size[0] < 1) {
    n = 1;
  }

  if (emptyDimValue > muIntScalarMax_sint32(rx.size[0], n)) {
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&d_y, m);
    st.site = &qv_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, d_y, &g_emlrtMCI), &g_emlrtMCI),
          &g_emlrtMCI);
  }

  if (emptyDimValue < 0) {
    for (i = 0; i < 37; i++) {
      b_u[i] = e_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 37; i++) {
      b_u[i] = e_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &b_u[0]);
    emlrtAssign(&e_y, m);
    st.site = &ow_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, e_y, &h_emlrtMCI), &h_emlrtMCI),
          &h_emlrtMCI);
  }

  if (emptyDimValue != rx.size[0]) {
    for (i = 0; i < 40; i++) {
      d_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &d_u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 40; i++) {
      d_u[i] = f_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &d_u[0]);
    emlrtAssign(&f_y, m);
    st.site = &ov_emlrtRSI;
    error(&st, c_y, getString(&st, b_message(&st, f_y, &i_emlrtMCI), &i_emlrtMCI),
          &i_emlrtMCI);
  }

  array_real_T_2D_SetSize(rxOut, 1, emptyDimValue);
  for (i = 0; i < emptyDimValue; i++) {
    rxOut->vector.data[i] = rx.vector.data[i];
  }

  array_real_T_Destructor(&rx);
  st.site = &lc_emlrtRSI;
  emptyDimValue = c_computeDimsData(ry.size[0]);
  n = ry.size[0];
  if (ry.size[0] < 1) {
    n = 1;
  }

  if (emptyDimValue > muIntScalarMax_sint32(ry.size[0], n)) {
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&g_y, m);
    for (i = 0; i < 39; i++) {
      u[i] = c_u[i];
    }

    j_y = NULL;
    m = emlrtCreateCharArray(2, &iv9[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&j_y, m);
    st.site = &qv_emlrtRSI;
    error(&st, g_y, getString(&st, b_message(&st, j_y, &g_emlrtMCI), &g_emlrtMCI),
          &g_emlrtMCI);
  }

  if (emptyDimValue < 0) {
    for (i = 0; i < 37; i++) {
      b_u[i] = e_u[i];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &b_u[0]);
    emlrtAssign(&h_y, m);
    for (i = 0; i < 37; i++) {
      b_u[i] = e_u[i];
    }

    k_y = NULL;
    m = emlrtCreateCharArray(2, &iv10[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 37, m, &b_u[0]);
    emlrtAssign(&k_y, m);
    st.site = &ow_emlrtRSI;
    error(&st, h_y, getString(&st, b_message(&st, k_y, &h_emlrtMCI), &h_emlrtMCI),
          &h_emlrtMCI);
  }

  if (emptyDimValue != ry.size[0]) {
    for (i = 0; i < 40; i++) {
      d_u[i] = f_u[i];
    }

    i_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &d_u[0]);
    emlrtAssign(&i_y, m);
    for (i = 0; i < 40; i++) {
      d_u[i] = f_u[i];
    }

    l_y = NULL;
    m = emlrtCreateCharArray(2, &iv11[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &d_u[0]);
    emlrtAssign(&l_y, m);
    st.site = &ov_emlrtRSI;
    error(&st, i_y, getString(&st, b_message(&st, l_y, &i_emlrtMCI), &i_emlrtMCI),
          &i_emlrtMCI);
  }

  array_real_T_2D_SetSize(ryOut, 1, emptyDimValue);
  for (i = 0; i < emptyDimValue; i++) {
    ryOut->vector.data[i] = ry.vector.data[i];
  }

  array_real_T_Destructor(&ry);
}

static void polyBgen(const emlrtStack *sp, coder_array_real_T_2D *x1,
                     coder_array_real_T_2D *c_y1, real_T b_x2_data[], int32_T
                     x2_size[2], real_T y2_data[], int32_T y2_size[2],
                     coder_array_real_T *rx, coder_array_real_T *ry,
                     coder_array_real_T_2D *mp)
{
  static const int32_T iv[2] = { 1, 46 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv10[2] = { 1, 39 };

  static const int32_T iv11[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 46 };

  static const int32_T iv3[2] = { 1, 46 };

  static const int32_T iv4[2] = { 1, 2 };

  static const int32_T iv5[2] = { 1, 2 };

  static const int32_T iv6[2] = { 1, 2 };

  static const int32_T iv7[2] = { 1, 2 };

  static const int32_T iv8[2] = { 1, 39 };

  static const int32_T iv9[2] = { 1, 39 };

  static char_T b_u[46] = { 's', 'h', 'a', 'r', 'e', 'd', '_', 't', 'r', 'a',
    'c', 'k', 'i', 'n', 'g', ':', 'P', 'o', 'l', 'y', 'g', 'o', 'n', 'B', 'o',
    'o', 'l', 'e', 'a', 'n', 'A', 'P', 'I', ':', 'n', 'u', 'm', 'e', 'l', 'N',
    'o', 'M', 'a', 't', 'c', 'h' };

  static char_T i_u[39] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'c', 'a', 't',
    'e', 'n', 'a', 't', 'e', ':', 'm', 'a', 't', 'r', 'i', 'x', 'D', 'i', 'm',
    'e', 'n', 's', 'i', 'o', 'n', 'M', 'i', 's', 'm', 'a', 't', 'c', 'h' };

  static char_T d_u[2] = { 'x', '1' };

  static char_T e_u[2] = { 'x', '2' };

  static char_T f_u[2] = { 'y', '1' };

  static char_T g_u[2] = { 'y', '2' };

  coder_array_int32_T_2D T;
  coder_array_real_T b_mp_c;
  coder_array_real_T b_mp_p;
  coder_array_real_T b_mp_v;
  coder_array_real_T b_rx;
  coder_array_real_T b_ry;
  coder_array_real_T mp_c;
  coder_array_real_T mp_p;
  coder_array_real_T mp_v;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *y;
  real_T d;
  real_T scale;
  int32_T i;
  int32_T nvtx;
  int32_T op_type;
  int32_T q1;
  int32_T size1;
  int32_T size2;
  char_T u[46];
  char_T h_u[39];
  char_T c_u[2];
  boolean_T b;
  st.prev = sp;
  st.tls = sp->tls;
  if (x1->size[1] != c_y1->size[1]) {
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 46, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 46, m, &u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = d_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 2, m, &c_u[0]);
    emlrtAssign(&e_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = f_u[i];
    }

    g_y = NULL;
    m = emlrtCreateCharArray(2, &iv6[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 2, m, &c_u[0]);
    emlrtAssign(&g_y, m);
    st.site = &nw_emlrtRSI;
    error(&st, y, getString(&st, c_message(&st, c_y, e_y, g_y, &gc_emlrtMCI),
           &gc_emlrtMCI), &gc_emlrtMCI);
  }

  if (x2_size[1] != y2_size[1]) {
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 46, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 46; i++) {
      u[i] = b_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 46, m, &u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = e_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 2, m, &c_u[0]);
    emlrtAssign(&f_y, m);
    for (i = 0; i < 2; i++) {
      c_u[i] = g_u[i];
    }

    h_y = NULL;
    m = emlrtCreateCharArray(2, &iv7[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 2, m, &c_u[0]);
    emlrtAssign(&h_y, m);
    st.site = &mw_emlrtRSI;
    error(&st, b_y, getString(&st, c_message(&st, d_y, f_y, h_y, &hc_emlrtMCI),
           &hc_emlrtMCI), &hc_emlrtMCI);
  }

  size1 = x1->size[1];
  size2 = x2_size[1];
  scale = -1.0;
  op_type = 3;
  d = muDoubleScalarRound((real_T)x1->size[1] * 1.5);
  if (d < 2.147483648E+9) {
    if (d >= -2.147483648E+9) {
      nvtx = (int32_T)d;
    } else {
      nvtx = MIN_int32_T;
    }
  } else {
    nvtx = MAX_int32_T;
  }

  q1 = (int32_T)muDoubleScalarRound((real_T)x2_size[1] * 1.5);
  if ((nvtx < 0) && (q1 < MIN_int32_T - nvtx)) {
    nvtx = MIN_int32_T;
  } else if ((nvtx > 0) && (q1 > MAX_int32_T - nvtx)) {
    nvtx = MAX_int32_T;
  } else {
    nvtx += q1;
  }

  if (nvtx > 2147483447) {
    nvtx = MAX_int32_T;
  } else {
    nvtx += 200;
  }

  array_real_T_SetSize(rx, nvtx);
  for (i = 0; i < nvtx; i++) {
    rx->vector.data[i] = 0.0;
  }

  array_real_T_SetSize(ry, nvtx);
  for (i = 0; i < nvtx; i++) {
    ry->vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_p);
  array_real_T_SetSize(&mp_p, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_p.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_c);
  array_real_T_SetSize(&mp_c, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_c.vector.data[i] = 0.0;
  }

  array_real_T_Constructor(&mp_v);
  array_real_T_SetSize(&mp_v, nvtx);
  for (i = 0; i < nvtx; i++) {
    mp_v.vector.data[i] = 0.0;
  }

  polyBoolean_c(&x1->vector.data[0], &c_y1->vector.data[0], &size1, &b_x2_data[0],
                &y2_data[0], &size2, &scale, &op_type, &rx->vector.data[0],
                &ry->vector.data[0], &nvtx, &mp_p.vector.data[0],
                &mp_c.vector.data[0], &mp_v.vector.data[0]);
  array_int32_T_2D_Constructor(&T);
  st.site = &nm_emlrtRSI;
  eml_integer_colon_dispatcher(&st, nvtx, &T);
  st.site = &mm_emlrtRSI;
  indexShapeCheck(&st, rx->size[0], T.size);
  nvtx = rx->size[0];
  array_real_T_Constructor(&b_rx);
  array_real_T_SetSize(&b_rx, T.size[1]);
  q1 = T.size[1];
  for (i = 0; i < q1; i++) {
    size1 = T.vector.data[i];
    b_rx.vector.data[i] = rx->vector.data[emlrtDynamicBoundsCheckR2012b(size1, 1,
      nvtx, &vf_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }

  array_real_T_SetSize(rx, b_rx.size[0]);
  q1 = b_rx.size[0];
  for (i = 0; i < q1; i++) {
    rx->vector.data[i] = b_rx.vector.data[i];
  }

  array_real_T_Destructor(&b_rx);
  st.site = &lm_emlrtRSI;
  indexShapeCheck(&st, ry->size[0], T.size);
  nvtx = ry->size[0];
  array_real_T_Constructor(&b_ry);
  array_real_T_SetSize(&b_ry, T.size[1]);
  q1 = T.size[1];
  for (i = 0; i < q1; i++) {
    size1 = T.vector.data[i];
    b_ry.vector.data[i] = ry->vector.data[emlrtDynamicBoundsCheckR2012b(size1, 1,
      nvtx, &wf_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }

  array_real_T_SetSize(ry, b_ry.size[0]);
  q1 = b_ry.size[0];
  for (i = 0; i < q1; i++) {
    ry->vector.data[i] = b_ry.vector.data[i];
  }

  array_real_T_Destructor(&b_ry);
  st.site = &km_emlrtRSI;
  indexShapeCheck(&st, mp_p.size[0], T.size);
  array_real_T_Constructor(&b_mp_p);
  array_real_T_SetSize(&b_mp_p, T.size[1]);
  q1 = T.size[1];
  for (i = 0; i < q1; i++) {
    size1 = T.vector.data[i];
    b_mp_p.vector.data[i] = mp_p.vector.data[emlrtDynamicBoundsCheckR2012b(size1,
      1, mp_p.size[0], &xf_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }

  array_real_T_SetSize(&mp_p, b_mp_p.size[0]);
  q1 = b_mp_p.size[0];
  for (i = 0; i < q1; i++) {
    mp_p.vector.data[i] = b_mp_p.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_p);
  st.site = &jm_emlrtRSI;
  indexShapeCheck(&st, mp_c.size[0], T.size);
  array_real_T_Constructor(&b_mp_c);
  array_real_T_SetSize(&b_mp_c, T.size[1]);
  q1 = T.size[1];
  for (i = 0; i < q1; i++) {
    size1 = T.vector.data[i];
    b_mp_c.vector.data[i] = mp_c.vector.data[emlrtDynamicBoundsCheckR2012b(size1,
      1, mp_c.size[0], &yf_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }

  array_real_T_SetSize(&mp_c, b_mp_c.size[0]);
  q1 = b_mp_c.size[0];
  for (i = 0; i < q1; i++) {
    mp_c.vector.data[i] = b_mp_c.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_c);
  st.site = &im_emlrtRSI;
  indexShapeCheck(&st, mp_v.size[0], T.size);
  array_real_T_Constructor(&b_mp_v);
  array_real_T_SetSize(&b_mp_v, T.size[1]);
  q1 = T.size[1];
  for (i = 0; i < q1; i++) {
    size1 = T.vector.data[i];
    b_mp_v.vector.data[i] = mp_v.vector.data[emlrtDynamicBoundsCheckR2012b(size1,
      1, mp_v.size[0], &ag_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }

  array_int32_T_2D_Destructor(&T);
  array_real_T_SetSize(&mp_v, b_mp_v.size[0]);
  q1 = b_mp_v.size[0];
  for (i = 0; i < q1; i++) {
    mp_v.vector.data[i] = b_mp_v.vector.data[i];
  }

  array_real_T_Destructor(&b_mp_v);
  b = true;
  if (mp_c.size[0] != mp_p.size[0]) {
    b = false;
  }

  if (!b) {
    for (i = 0; i < 39; i++) {
      h_u[i] = i_u[i];
    }

    i_y = NULL;
    m = emlrtCreateCharArray(2, &iv8[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &h_u[0]);
    emlrtAssign(&i_y, m);
    for (i = 0; i < 39; i++) {
      h_u[i] = i_u[i];
    }

    k_y = NULL;
    m = emlrtCreateCharArray(2, &iv10[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &h_u[0]);
    emlrtAssign(&k_y, m);
    st.site = &lw_emlrtRSI;
    error(&st, i_y, getString(&st, b_message(&st, k_y, &t_emlrtMCI), &t_emlrtMCI),
          &t_emlrtMCI);
  }

  if (mp_v.size[0] != mp_p.size[0]) {
    for (i = 0; i < 39; i++) {
      h_u[i] = i_u[i];
    }

    j_y = NULL;
    m = emlrtCreateCharArray(2, &iv9[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &h_u[0]);
    emlrtAssign(&j_y, m);
    for (i = 0; i < 39; i++) {
      h_u[i] = i_u[i];
    }

    l_y = NULL;
    m = emlrtCreateCharArray(2, &iv11[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &h_u[0]);
    emlrtAssign(&l_y, m);
    st.site = &lw_emlrtRSI;
    error(&st, j_y, getString(&st, b_message(&st, l_y, &t_emlrtMCI), &t_emlrtMCI),
          &t_emlrtMCI);
  }

  array_real_T_2D_SetSize(mp, mp_p.size[0], 3);
  q1 = mp_p.size[0];
  for (i = 0; i < q1; i++) {
    mp->vector.data[i] = mp_p.vector.data[i];
  }

  array_real_T_Destructor(&mp_p);
  q1 = mp_c.size[0];
  for (i = 0; i < q1; i++) {
    mp->vector.data[i + mp->size[0]] = mp_c.vector.data[i];
  }

  array_real_T_Destructor(&mp_c);
  q1 = mp_v.size[0];
  for (i = 0; i < q1; i++) {
    mp->vector.data[i + (mp->size[0] << 1)] = mp_v.vector.data[i];
  }

  array_real_T_Destructor(&mp_v);
}

static real_T b_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp)
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tm_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &um_emlrtRSI;
  c_st.site = &vm_emlrtRSI;
  return eml_rand_mt19937ar(&c_st, moduleInstance->state);
}

static void visionDetectionGenerator_estimateImageLocation(const emlrtStack *sp,
  visionDetectionGenerator *obj, coder_array_real_T_2D *Utgt, real_T U[2],
  real_T B[2])
{
  coder_array_real_T_2D r;
  coder_array_real_T_2D uvRot;
  emlrtStack st;
  real_T uvRot_data[4200];
  real_T rot[4];
  real_T b_dv[2];
  real_T cntr[2];
  real_T uvUp[2];
  real_T b_maxval;
  real_T b_minval;
  real_T maxval;
  real_T minval;
  int32_T b_uvRot_size[2];
  int32_T c_uvRot_size[2];
  int32_T d_uvRot_size[2];
  int32_T uvRot_size[2];
  int32_T b_i;
  int32_T i;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 2; i++) {
    uvUp[i] = obj->puvUp[i];
  }

  rot[0] = -uvUp[1];
  rot[2] = uvUp[0];
  for (b_i = 0; b_i < 2; b_i++) {
    rot[(b_i << 1) + 1] = uvUp[b_i];
  }

  b_mean(Utgt, cntr);
  array_real_T_2D_Constructor(&r);
  i_bsxfun(Utgt, cntr, &r);
  array_real_T_2D_Constructor(&uvRot);
  st.site = &md_emlrtRSI;
  j_mtimes(rot, &r, &uvRot);
  array_real_T_2D_Destructor(&r);
  uvRot_size[0] = 1;
  uvRot_size[1] = uvRot.size[1];
  i = uvRot.size[1];
  for (b_i = 0; b_i < i; b_i++) {
    uvRot_data[b_i] = uvRot.vector.data[b_i << 1];
  }

  st.site = &xm_emlrtRSI;
  minval = b_minimum(&st, uvRot_data, uvRot_size);
  b_uvRot_size[0] = 1;
  b_uvRot_size[1] = uvRot.size[1];
  i = uvRot.size[1];
  for (b_i = 0; b_i < i; b_i++) {
    uvRot_data[b_i] = uvRot.vector.data[b_i << 1];
  }

  st.site = &ym_emlrtRSI;
  maxval = b_maximum(&st, uvRot_data, b_uvRot_size);
  uvUp[0] = minval;
  uvUp[1] = maxval;
  c_uvRot_size[0] = 1;
  c_uvRot_size[1] = uvRot.size[1];
  i = uvRot.size[1];
  for (b_i = 0; b_i < i; b_i++) {
    uvRot_data[b_i] = uvRot.vector.data[(b_i << 1) + 1];
  }

  st.site = &xm_emlrtRSI;
  b_minval = b_minimum(&st, uvRot_data, c_uvRot_size);
  d_uvRot_size[0] = 1;
  d_uvRot_size[1] = uvRot.size[1];
  i = uvRot.size[1];
  for (b_i = 0; b_i < i; b_i++) {
    uvRot_data[b_i] = uvRot.vector.data[(b_i << 1) + 1];
  }

  array_real_T_2D_Destructor(&uvRot);
  st.site = &ym_emlrtRSI;
  b_maxval = b_maximum(&st, uvRot_data, d_uvRot_size);
  B[0] = maxval - minval;
  B[1] = b_maxval - b_minval;
  uvUp[0] = c_mean(uvUp);
  uvUp[1] = b_minval;
  k_mtimes(rot, uvUp, b_dv);
  t_bsxfun(b_dv, cntr, U);
}

static void b_mean(coder_array_real_T_2D *x, real_T y[2])
{
  __m128d r;
  __m128d r1;
  real_T bsum[2];
  real_T b_y;
  int32_T firstBlockLength;
  int32_T ib;
  int32_T k;
  int32_T lastBlockLength;
  int32_T nblocks;
  int32_T xblockoffset;
  int32_T xj;
  int32_T xoffset;
  if (x->size[1] == 0) {
    for (firstBlockLength = 0; firstBlockLength < 2; firstBlockLength++) {
      y[firstBlockLength] = 0.0;
    }
  } else {
    if (x->size[1] <= 1024) {
      firstBlockLength = x->size[1];
      lastBlockLength = 0;
      nblocks = 1;
    } else {
      firstBlockLength = 1024;
      nblocks = (int32_T)((uint32_T)x->size[1] >> 10);
      lastBlockLength = x->size[1] - (nblocks << 10);
      if (lastBlockLength > 0) {
        nblocks++;
      } else {
        lastBlockLength = 1024;
      }
    }

    for (xj = 0; xj < 2; xj++) {
      y[xj] = x->vector.data[xj];
    }

    for (k = 2; k <= firstBlockLength; k++) {
      xoffset = ((k - 1) << 1) - 1;
      for (xj = 0; xj < 2; xj++) {
        b_y = y[xj] + x->vector.data[(xoffset + xj) + 1];
        y[xj] = b_y;
      }
    }

    for (ib = 2; ib <= nblocks; ib++) {
      xblockoffset = (ib - 1) << 11;
      for (xj = 0; xj < 2; xj++) {
        bsum[xj] = x->vector.data[xblockoffset + xj];
      }

      if (ib == nblocks) {
        firstBlockLength = lastBlockLength;
      } else {
        firstBlockLength = 1024;
      }

      for (k = 2; k <= firstBlockLength; k++) {
        xoffset = (xblockoffset + ((k - 1) << 1)) - 1;
        for (xj = 0; xj < 2; xj++) {
          b_y = bsum[xj] + x->vector.data[(xoffset + xj) + 1];
          bsum[xj] = b_y;
        }
      }

      for (xj = 0; xj <= 0; xj += 2) {
        r = _mm_loadu_pd(&y[0]);
        r1 = _mm_loadu_pd(&bsum[0]);
        _mm_storeu_pd(&y[0], _mm_add_pd(r, r1));
      }
    }
  }

  firstBlockLength = x->size[1];
  for (xblockoffset = 0; xblockoffset <= 0; xblockoffset += 2) {
    r = _mm_loadu_pd(&y[0]);
    _mm_storeu_pd(&y[0], _mm_div_pd(r, _mm_set1_pd((real_T)firstBlockLength)));
  }
}

static void j_mtimes(real_T A[4], coder_array_real_T_2D *B,
                     coder_array_real_T_2D *C)
{
  ptrdiff_t k_t;
  ptrdiff_t lda_t;
  ptrdiff_t ldb_t;
  ptrdiff_t ldc_t;
  ptrdiff_t m_t;
  ptrdiff_t n_t;
  real_T alpha1;
  real_T beta1;
  char_T TRANSA1;
  char_T TRANSB1;
  if (B->size[1] == 0) {
    array_real_T_2D_SetSize(C, 2, 0);
  } else {
    TRANSB1 = 'N';
    TRANSA1 = 'N';
    alpha1 = 1.0;
    beta1 = 0.0;
    m_t = (ptrdiff_t)2;
    n_t = (ptrdiff_t)B->size[1];
    k_t = (ptrdiff_t)2;
    lda_t = (ptrdiff_t)2;
    ldb_t = (ptrdiff_t)2;
    ldc_t = (ptrdiff_t)2;
    array_real_T_2D_SetSize(C, 2, B->size[1]);
    dgemm(&TRANSA1, &TRANSB1, &m_t, &n_t, &k_t, &alpha1, &A[0], &lda_t,
          &B->vector.data[0], &ldb_t, &beta1, &C->vector.data[0], &ldc_t);
  }
}

static real_T b_minimum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2])
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T ex;
  int32_T idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[1] == 1) || (x_size[1] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x_size[1] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x_size[1];
  if (x_size[1] <= 2) {
    if (x_size[1] == 1) {
      ex = x_data[0];
    } else if ((x_data[0] > x_data[x_size[1] - 1]) || (muDoubleScalarIsNaN
                (x_data[0]) && (!muDoubleScalarIsNaN(x_data[x_size[1] - 1])))) {
      ex = x_data[x_size[1] - 1];
    } else {
      ex = x_data[0];
    }
  } else {
    if (!muDoubleScalarIsNaN(x_data[0])) {
      idx = 1;
    } else {
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x_data[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (idx == 0) {
      ex = x_data[0];
    } else {
      ex = x_data[idx - 1];
      for (k = idx + 1; k <= last; k++) {
        if (ex > x_data[k - 1]) {
          ex = x_data[k - 1];
        }
      }
    }
  }

  return ex;
}

static real_T b_maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2])
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T ex;
  int32_T idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[1] == 1) || (x_size[1] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x_size[1] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x_size[1];
  if (x_size[1] <= 2) {
    if (x_size[1] == 1) {
      ex = x_data[0];
    } else if ((x_data[0] < x_data[x_size[1] - 1]) || (muDoubleScalarIsNaN
                (x_data[0]) && (!muDoubleScalarIsNaN(x_data[x_size[1] - 1])))) {
      ex = x_data[x_size[1] - 1];
    } else {
      ex = x_data[0];
    }
  } else {
    if (!muDoubleScalarIsNaN(x_data[0])) {
      idx = 1;
    } else {
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x_data[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (idx == 0) {
      ex = x_data[0];
    } else {
      ex = x_data[idx - 1];
      for (k = idx + 1; k <= last; k++) {
        if (ex < x_data[k - 1]) {
          ex = x_data[k - 1];
        }
      }
    }
  }

  return ex;
}

static real_T diff(real_T x[2])
{
  return x[1] - x[0];
}

static real_T c_mean(real_T x[2])
{
  return b_sumColumnB(x) / 2.0;
}

static void k_mtimes(real_T A[4], real_T B[2], real_T C[2])
{
  real_T s;
  int32_T aoffset;
  int32_T i;
  int32_T k;
  for (i = 0; i < 2; i++) {
    aoffset = (i << 1) - 1;
    s = 0.0;
    for (k = 0; k < 2; k++) {
      s += A[(aoffset + k) + 1] * B[k];
    }

    C[i] = s;
  }
}

static void t_bsxfun(real_T a[2], real_T b[2], real_T c[2])
{
  __m128d r;
  __m128d r1;
  int32_T k;
  for (k = 0; k <= 0; k += 2) {
    r = _mm_loadu_pd(&a[0]);
    r1 = _mm_loadu_pd(&b[0]);
    _mm_storeu_pd(&c[0], _mm_add_pd(r, r1));
  }
}

static boolean_T c_visionDetectionGenerator_isAbove(visionDetectionGenerator
  *obj, real_T pts[2], real_T r0[2])
{
  real_T vUp[2];
  real_T b_vUp;
  int32_T i;
  for (i = 0; i < 2; i++) {
    vUp[i] = obj->puvUp[i];
  }

  b_vUp = 0.0;
  for (i = 0; i < 2; i++) {
    b_vUp += vUp[i] * (pts[i] - r0[i]);
  }

  return muDoubleScalarRound(b_vUp * 1.0E+6) > 0.0;
}

static void visionDetectionGenerator_imag2cam(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T U[2], real_T vel[3], real_T X[2], real_T
  R[4], real_T V[2])
{
  emlrtStack st;
  real_T M[9];
  real_T b_dxdu[4];
  real_T Xprime[3];
  real_T a[3];
  real_T Uvel[2];
  real_T b_obj[2];
  real_T b_a;
  real_T c_a;
  real_T cxy;
  real_T d_a;
  real_T dxdu;
  real_T dxdv;
  real_T dydu;
  real_T dydv;
  real_T e_a;
  int32_T i;
  int32_T i1;
  int32_T j;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 2; i++) {
    b_obj[i] = obj->pMonoCameraInSensorFrame.SensorLocation[i];
  }

  st.site = &an_emlrtRSI;
  monoCamera_get_ImageToVehicleTransform(&st,
    obj->pMonoCameraInSensorFrame.Intrinsics,
    obj->pMonoCameraInSensorFrame.Height, obj->pMonoCameraInSensorFrame.Pitch,
    obj->pMonoCameraInSensorFrame.Yaw, obj->pMonoCameraInSensorFrame.Roll, b_obj,
    M);
  a[2] = 1.0;
  for (j = 0; j < 2; j++) {
    a[j] = U[j];
  }

  for (j = 0; j < 3; j++) {
    Xprime[j] = 0.0;
    for (i1 = 0; i1 < 3; i1++) {
      Xprime[j] += a[i1] * M[i1 + 3 * j];
    }
  }

  X[0] = Xprime[0] / Xprime[2];
  X[1] = Xprime[1] / Xprime[2];
  dxdu = M[0] / Xprime[2] - Xprime[0] * M[6] / (Xprime[2] * Xprime[2]);
  dxdv = M[1] / Xprime[2] - Xprime[0] * M[7] / (Xprime[2] * Xprime[2]);
  b_a = 1.4433756729740645 * dxdu;
  c_a = 1.4433756729740645 * dxdv;
  dydu = M[3] / Xprime[2] - Xprime[1] * M[6] / (Xprime[2] * Xprime[2]);
  dydv = M[4] / Xprime[2] - Xprime[1] * M[7] / (Xprime[2] * Xprime[2]);
  d_a = 1.4433756729740645 * dydu;
  e_a = 1.4433756729740645 * dydv;
  cxy = dxdu * dydu * 2.0833333333333339 + dxdv * dydv * 2.0833333333333339;
  R[0] = b_a * b_a + c_a * c_a;
  R[2] = cxy;
  R[1] = cxy;
  R[3] = d_a * d_a + e_a * e_a;
  st.site = &bn_emlrtRSI;
  visionDetectionGenerator_computeImageVelocity(&st, obj, U, vel, Uvel);
  b_dxdu[0] = dxdu;
  b_dxdu[2] = dydu;
  b_dxdu[1] = dxdv;
  b_dxdu[3] = dydv;
  for (j = 0; j < 2; j++) {
    b_obj[j] = 0.0;
    for (i1 = 0; i1 < 2; i1++) {
      b_obj[j] += Uvel[i1] * b_dxdu[i1 + (j << 1)];
    }

    V[j] = b_obj[j];
  }
}

static void visionDetectionGenerator_computeImageVelocity(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T Uimg[2], real_T Xvel[3], real_T Uvel[2])
{
  emlrtStack b_st;
  emlrtStack st;
  monoCamera r;
  real_T camMtx[12];
  real_T M[9];
  real_T c_Xpos[4];
  real_T Xprime[3];
  real_T b_Xpos[3];
  real_T Xpos[2];
  int32_T i;
  int32_T i1;
  int32_T j;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  r = obj->pMonoCameraInSensorFrame;
  st.site = &cn_emlrtRSI;
  visionDetectionGenerator_getCameraMatrix(r.Intrinsics, r.Height, r.Pitch,
    r.Yaw, r.Roll, camMtx);
  st.site = &dn_emlrtRSI;
  for (i = 0; i < 2; i++) {
    Xpos[i] = obj->pMonoCameraInSensorFrame.SensorLocation[i];
  }

  b_st.site = &en_emlrtRSI;
  monoCamera_get_ImageToVehicleTransform(&b_st,
    obj->pMonoCameraInSensorFrame.Intrinsics,
    obj->pMonoCameraInSensorFrame.Height, obj->pMonoCameraInSensorFrame.Pitch,
    obj->pMonoCameraInSensorFrame.Yaw, obj->pMonoCameraInSensorFrame.Roll, Xpos,
    M);
  b_Xpos[2] = 1.0;
  for (j = 0; j < 2; j++) {
    b_Xpos[j] = Uimg[j];
  }

  for (j = 0; j < 3; j++) {
    Xprime[j] = 0.0;
    for (i1 = 0; i1 < 3; i1++) {
      Xprime[j] += b_Xpos[i1] * M[i1 + 3 * j];
    }
  }

  Xpos[0] = Xprime[0] / Xprime[2];
  Xpos[1] = Xprime[1] / Xprime[2];
  b_Xpos[2] = 0.0;
  for (j = 0; j < 2; j++) {
    b_Xpos[j] = Xpos[j];
  }

  c_Xpos[3] = 1.0;
  for (j = 0; j < 3; j++) {
    c_Xpos[j] = b_Xpos[j];
  }

  for (j = 0; j < 3; j++) {
    b_Xpos[j] = 0.0;
    for (i1 = 0; i1 < 4; i1++) {
      b_Xpos[j] += c_Xpos[i1] * camMtx[i1 + (j << 2)];
    }
  }

  Uvel[0] = ((camMtx[0] - Uimg[0] * camMtx[8]) / b_Xpos[2] * Xvel[0] + (camMtx[1]
              - Uimg[0] * camMtx[9]) / b_Xpos[2] * Xvel[1]) + (camMtx[2] - Uimg
    [0] * camMtx[10]) / b_Xpos[2] * Xvel[2];
  Uvel[1] = ((camMtx[4] - Uimg[1] * camMtx[8]) / b_Xpos[2] * Xvel[0] + (camMtx[5]
              - Uimg[1] * camMtx[9]) / b_Xpos[2] * Xvel[1]) + (camMtx[6] - Uimg
    [1] * camMtx[10]) / b_Xpos[2] * Xvel[2];
}

static void visionDetectionGenerator_kalmanFilterModel(const emlrtStack *sp,
  real_T R1[4], real_T R[4], real_T Rv[4])
{
  static real_T b_dv[16] = { 1.0, 0.0, 0.0, 0.0, 0.05, 1.0, 0.0, 0.0, 0.0, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.05, 1.0 };

  static real_T dv1[16] = { 3.9062500000000008E-5, 0.0015625000000000003, 0.0,
    0.0, 0.0015625000000000003, 0.062500000000000014, 0.0, 0.0, 0.0, 0.0,
    3.9062500000000008E-5, 0.0015625000000000003, 0.0, 0.0,
    0.0015625000000000003, 0.062500000000000014 };

  static real_T dv2[8] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 };

  emlrtStack st;
  real_T Ps[16];
  real_T a__16[16];
  int32_T i;
  int32_T i1;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &fn_emlrtRSI;
  AbstractDetectionGenerator_steadyStateKalmanCovariance(&st, b_dv, dv1, dv2, R1,
    a__16, Ps);
  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < 2; i1++) {
      R[i1 + (i << 1)] = Ps[(i1 << 1) + (i << 3)];
      Rv[i1 + (i << 1)] = Ps[((i1 << 1) + (((i << 1) + 1) << 2)) + 1];
    }
  }
}

static void AbstractDetectionGenerator_steadyStateKalmanCovariance(const
  emlrtStack *sp, real_T A[16], real_T Q[16], real_T H[8], real_T R[4], real_T
  PpOut[16], real_T Ps[16])
{
  __m128d r;
  emlrtStack st;
  creal_T W[64];
  creal_T b_W[64];
  creal_T Y[16];
  creal_T c_W[16];
  creal_T d_W[16];
  real_T b_I[64];
  real_T c_Atinv[64];
  real_T Atinv[16];
  real_T PsInv[16];
  real_T Rf[16];
  real_T b_Atinv[16];
  real_T b_Q[16];
  real_T c_Q[16];
  real_T b[8];
  real_T c_S[4];
  real_T d_S[4];
  real_T b_S;
  int32_T iidx[8];
  int32_T i;
  int32_T i1;
  int32_T k;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &gn_emlrtRSI;
  mldivide(&st, R, H, b);
  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      Rf[i + (i1 << 2)] = 0.0;
      for (k = 0; k < 2; k++) {
        Rf[i + (i1 << 2)] += H[k + (i << 1)] * b[k + (i1 << 1)];
      }

      PsInv[i1 + (i << 2)] = A[i + (i1 << 2)];
    }
  }

  st.site = &hn_emlrtRSI;
  inv(&st, PsInv, Atinv);
  for (i = 0; i < 64; i++) {
    b_I[i] = 0.0;
  }

  for (k = 0; k < 8; k++) {
    b_I[k + (k << 3)] = 1.0;
  }

  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      b_Atinv[i + (i1 << 2)] = 0.0;
      b_Q[i + (i1 << 2)] = 0.0;
      c_Q[i + (i1 << 2)] = 0.0;
      for (k = 0; k < 4; k++) {
        b_Atinv[i + (i1 << 2)] += Atinv[i + (k << 2)] * Rf[k + (i1 << 2)];
        b_Q[i + (i1 << 2)] += Q[i + (k << 2)] * Atinv[k + (i1 << 2)];
        c_Q[i + (i1 << 2)] += Q[i + (k << 2)] * Atinv[k + (i1 << 2)];
      }
    }

    for (i1 = 0; i1 < 4; i1++) {
      b_S = 0.0;
      for (k = 0; k < 4; k++) {
        b_S += b_Q[i + (k << 2)] * Rf[k + (i1 << 2)];
      }

      PsInv[i + (i1 << 2)] = A[i + (i1 << 2)] + b_S;
      c_Atinv[i1 + (i << 3)] = Atinv[i1 + (i << 2)];
    }
  }

  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      c_Atinv[i1 + ((i + 4) << 3)] = b_Atinv[i1 + (i << 2)];
      c_Atinv[(i1 + (i << 3)) + 4] = c_Q[i1 + (i << 2)];
      c_Atinv[(i1 + ((i + 4) << 3)) + 4] = PsInv[i1 + (i << 2)];
    }
  }

  st.site = &in_emlrtRSI;
  eig(&st, c_Atinv, b_I, W, b_W);
  for (k = 0; k < 8; k++) {
    b[k] = muDoubleScalarHypot(b_W[k + (k << 3)].re, b_W[k + (k << 3)].im);
  }

  d_sort(b, iidx);
  for (i = 0; i < 8; i++) {
    for (i1 = 0; i1 < 8; i1++) {
      k = iidx[i];
      b_W[i1 + (i << 3)].re = W[i1 + ((emlrtDynamicBoundsCheckR2012b(k, 1, 8,
        &bg_emlrtBCI, (emlrtConstCTX)sp) - 1) << 3)].re;
      b_W[i1 + (i << 3)].im = W[i1 + ((emlrtDynamicBoundsCheckR2012b(k, 1, 8,
        &bg_emlrtBCI, (emlrtConstCTX)sp) - 1) << 3)].im;
    }
  }

  for (i = 0; i < 4; i++) {
    memcpy(&c_W[i << 2], &b_W[(i << 3) + 4], sizeof(creal_T) << 2);
    memcpy(&d_W[i << 2], &b_W[i << 3], sizeof(creal_T) << 2);
  }

  st.site = &nn_emlrtRSI;
  mrdiv(&st, c_W, d_W, Y);
  for (i = 0; i < 16; i++) {
    Rf[i] = Y[i].re;
  }

  st.site = &jn_emlrtRSI;
  ensureSymmetricPositiveSemidefinite(&st, Rf, PpOut);
  st.site = &kn_emlrtRSI;
  mldivide(&st, R, H, b);
  st.site = &kn_emlrtRSI;
  inv(&st, Rf, Atinv);
  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      b_S = 0.0;
      for (k = 0; k < 2; k++) {
        b_S += H[k + (i << 1)] * b[k + (i1 << 1)];
      }

      PsInv[i + (i1 << 2)] = Atinv[i + (i1 << 2)] + b_S;
    }
  }

  st.site = &ln_emlrtRSI;
  b_svd(&st, PsInv, Atinv, Rf, b_Q);
  for (k = 0; k < 4; k++) {
    b_S = Rf[k + (k << 2)];
    d_S[k] = b_S;
    c_S[k] = b_S;
  }

  b_maximum2(d_S, c_maximum(c_S) * 1.0E-16, c_S);
  for (i = 0; i <= 2; i += 2) {
    r = _mm_loadu_pd(&c_S[i]);
    _mm_storeu_pd(&c_S[i], _mm_div_pd(_mm_set1_pd(1.0), r));
  }

  for (i = 0; i < 16; i++) {
    Rf[i] = 0.0;
  }

  for (k = 0; k < 4; k++) {
    Rf[k + (k << 2)] = c_S[k];
  }

  for (i = 0; i < 4; i++) {
    for (i1 = 0; i1 < 4; i1++) {
      b_Atinv[i + (i1 << 2)] = 0.0;
      for (k = 0; k < 4; k++) {
        b_Atinv[i + (i1 << 2)] += Atinv[i + (k << 2)] * Rf[k + (i1 << 2)];
      }
    }

    for (i1 = 0; i1 < 4; i1++) {
      PsInv[i + (i1 << 2)] = 0.0;
      for (k = 0; k < 4; k++) {
        PsInv[i + (i1 << 2)] += b_Atinv[i + (k << 2)] * b_Q[i1 + (k << 2)];
      }
    }
  }

  st.site = &mn_emlrtRSI;
  ensureSymmetricPositiveSemidefinite(&st, PsInv, Ps);
}

static void mldivide(const emlrtStack *sp, real_T A[4], real_T B[8], real_T Y[8])
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  real_T a21;
  real_T a22;
  int32_T k;
  int32_T r1;
  int32_T r2;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &on_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  b_st.site = &pn_emlrtRSI;
  if (muDoubleScalarAbs(A[1]) > muDoubleScalarAbs(A[0])) {
    r1 = 1;
    r2 = 0;
  } else {
    r1 = 0;
    r2 = 1;
  }

  a21 = A[r2] / A[r1];
  a22 = A[r2 + 2] - a21 * A[r1 + 2];
  if ((a22 == 0.0) || (A[r1] == 0.0)) {
    c_st.site = &qn_emlrtRSI;
    d_st.site = &rn_emlrtRSI;
    warning(&d_st);
  }

  for (k = 0; k < 4; k++) {
    Y[(k << 1) + 1] = (B[r2 + (k << 1)] - B[r1 + (k << 1)] * a21) / a22;
    Y[k << 1] = (B[r1 + (k << 1)] - Y[(k << 1) + 1] * A[r1 + 2]) / A[r1];
  }
}

static void inv(const emlrtStack *sp, real_T x[16], real_T y[16])
{
  static const int32_T iv[2] = { 1, 6 };

  static char_T b_rfmt[6] = { '%', '1', '4', '.', '6', 'e' };

  __m128d r;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  real_T A[16];
  real_T n1xinv;
  real_T rc;
  real_T smax;
  int32_T b_i;
  int32_T c;
  int32_T i;
  int32_T ijA;
  int32_T ix;
  int32_T iy;
  int32_T j;
  int32_T jy;
  int32_T k;
  char_T str[14];
  char_T rfmt[6];
  int8_T ipiv[4];
  int8_T p[4];
  int8_T b_ipiv;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  for (i = 0; i < 16; i++) {
    y[i] = 0.0;
    A[i] = x[i];
  }

  for (i = 0; i < 4; i++) {
    ipiv[i] = (int8_T)(i + 1);
  }

  for (j = 0; j < 3; j++) {
    c = j * 5;
    iy = 5 - j;
    jy = 1;
    ix = c;
    smax = muDoubleScalarAbs(A[c]);
    for (k = 2; k < iy; k++) {
      ix++;
      n1xinv = muDoubleScalarAbs(A[ix]);
      if (n1xinv > smax) {
        jy = k;
        smax = n1xinv;
      }
    }

    if (A[(c + jy) - 1] != 0.0) {
      if (jy - 1 != 0) {
        ipiv[j] = (int8_T)(j + jy);
        ix = j;
        iy = (j + jy) - 1;
        for (k = 0; k < 4; k++) {
          smax = A[ix];
          A[ix] = A[iy];
          A[iy] = smax;
          ix += 4;
          iy += 4;
        }
      }

      i = c - j;
      iy = (((i - c) + 3) / 2 * 2 + c) + 2;
      jy = iy - 2;
      for (b_i = c + 2; b_i <= jy; b_i += 2) {
        r = _mm_loadu_pd(&A[b_i - 1]);
        _mm_storeu_pd(&A[b_i - 1], _mm_div_pd(r, _mm_set1_pd(A[c])));
      }

      for (b_i = iy; b_i <= i + 4; b_i++) {
        A[b_i - 1] /= A[c];
      }
    }

    iy = c;
    jy = c + 4;
    i = 2 - j;
    for (k = 0; k <= i; k++) {
      smax = A[jy];
      if (A[jy] != 0.0) {
        ix = c;
        b_i = iy - j;
        for (ijA = iy + 6; ijA <= b_i + 8; ijA++) {
          A[ijA - 1] += A[ix + 1] * -smax;
          ix++;
        }
      }

      jy += 4;
      iy += 4;
    }
  }

  for (i = 0; i < 4; i++) {
    p[i] = (int8_T)(i + 1);
  }

  for (k = 0; k < 3; k++) {
    b_ipiv = ipiv[k];
    if (b_ipiv > k + 1) {
      iy = p[b_ipiv - 1];
      p[b_ipiv - 1] = p[k];
      p[k] = (int8_T)iy;
    }
  }

  for (k = 0; k < 4; k++) {
    b_ipiv = p[k];
    y[k + ((b_ipiv - 1) << 2)] = 1.0;
    for (j = k + 1; j < 5; j++) {
      if (y[(j + ((b_ipiv - 1) << 2)) - 1] != 0.0) {
        for (b_i = j + 1; b_i < 5; b_i++) {
          y[(b_i + ((b_ipiv - 1) << 2)) - 1] -= y[(j + ((b_ipiv - 1) << 2)) - 1]
            * A[(b_i + ((j - 1) << 2)) - 1];
        }
      }
    }
  }

  for (j = 0; j < 4; j++) {
    iy = j << 2;
    for (k = 3; k >= 0; k--) {
      jy = k << 2;
      if (y[k + iy] != 0.0) {
        y[k + iy] /= A[k + jy];
        for (b_i = 0; b_i < k; b_i++) {
          y[b_i + iy] -= y[k + iy] * A[b_i + jy];
        }
      }
    }
  }

  st.site = &sn_emlrtRSI;
  smax = f_norm(x);
  n1xinv = f_norm(y);
  rc = 1.0 / (smax * n1xinv);
  if ((smax == 0.0) || (n1xinv == 0.0) || (rc == 0.0)) {
    b_st.site = &ee_emlrtRSI;
    warning(&b_st);
  } else if (muDoubleScalarIsNaN(rc) || (rc < 2.2204460492503131E-16)) {
    b_st.site = &fe_emlrtRSI;
    for (i = 0; i < 6; i++) {
      rfmt[i] = b_rfmt[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 6, m, &rfmt[0]);
    emlrtAssign(&b_y, m);
    c_y = NULL;
    m = emlrtCreateDoubleScalar(rc);
    emlrtAssign(&c_y, m);
    c_st.site = &tx_emlrtRSI;
    emlrt_marshallIn(&c_st, b_sprintf(&c_st, b_y, c_y, &x_emlrtMCI),
                     "<output of sprintf>", str);
    b_st.site = &fe_emlrtRSI;
    b_warning(&b_st, str);
  }
}

static real_T f_norm(real_T x[16])
{
  real_T s;
  real_T y;
  int32_T i;
  int32_T j;
  boolean_T exitg1;
  y = 0.0;
  j = 0;
  exitg1 = false;
  while ((!exitg1) && (j < 4)) {
    s = 0.0;
    for (i = 0; i < 4; i++) {
      s += muDoubleScalarAbs(x[i + (j << 2)]);
    }

    if (muDoubleScalarIsNaN(s)) {
      y = rtNaN;
      exitg1 = true;
    } else {
      if (s > y) {
        y = s;
      }

      j++;
    }
  }

  return y;
}

static void eig(const emlrtStack *sp, real_T A[64], real_T B[64], creal_T V[64],
                creal_T D[64])
{
  emlrtStack st;
  real_T b_A;
  int32_T k;
  boolean_T guard1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  p = true;
  for (k = 0; k < 64; k++) {
    b_A = A[k];
    if (p && ((!muDoubleScalarIsInf(b_A)) && (!muDoubleScalarIsNaN(b_A)))) {
      p = true;
    } else {
      p = false;
    }
  }

  guard1 = false;
  if (!p) {
    guard1 = true;
  } else {
    p = true;
    for (k = 0; k < 64; k++) {
      b_A = B[k];
      if (p && ((!muDoubleScalarIsInf(b_A)) && (!muDoubleScalarIsNaN(b_A)))) {
        p = true;
      } else {
        p = false;
      }
    }

    if (!p) {
      guard1 = true;
    } else if (ishermitian(A) && ishermitian(B)) {
      st.site = &tn_emlrtRSI;
      eigHermitianGeneralized(&st, A, B, V, D);
    } else {
      st.site = &un_emlrtRSI;
      eigGeneralized(&st, A, B, V, D);
    }
  }

  if (guard1) {
    for (k = 0; k < 64; k++) {
      V[k].re = rtNaN;
      V[k].im = 0.0;
      D[k].re = 0.0;
      D[k].im = 0.0;
    }

    for (k = 0; k < 8; k++) {
      D[k + (k << 3)].re = rtNaN;
      D[k + (k << 3)].im = 0.0;
    }
  }
}

static boolean_T ishermitian(real_T A[64])
{
  int32_T exitg1;
  int32_T i;
  int32_T j;
  boolean_T exitg2;
  boolean_T p;
  p = true;
  j = 0;
  exitg2 = false;
  while ((!exitg2) && (j < 8)) {
    i = 0;
    do {
      exitg1 = 0;
      if (i <= j) {
        if (!(A[i + (j << 3)] == A[j + (i << 3)])) {
          p = false;
          exitg1 = 1;
        } else {
          i++;
        }
      } else {
        j++;
        exitg1 = 2;
      }
    } while (exitg1 == 0);

    if (exitg1 == 1) {
      exitg2 = true;
    }
  }

  return p;
}

static void eigHermitianGeneralized(const emlrtStack *sp, real_T A[64], real_T
  B[64], creal_T V[64], creal_T D[64])
{
  emlrtStack st;
  creal_T dt[8];
  int32_T info;
  int32_T k;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &vn_emlrtRSI;
  xsyhegvd(A, B, &info, dt, V);
  for (k = 0; k < 64; k++) {
    D[k].re = 0.0;
    D[k].im = 0.0;
  }

  if (info <= 0) {
    for (k = 0; k < 8; k++) {
      D[k + (k << 3)].re = dt[k].re;
      D[k + (k << 3)].im = dt[k].im;
    }
  }

  if (info > 0) {
    st.site = &wn_emlrtRSI;
    eigGeneralized(&st, A, B, V, D);
  }
}

static void xsyhegvd(real_T A[64], real_T B[64], int32_T *info, creal_T W[8],
                     creal_T V[64])
{
  ptrdiff_t info_t;
  real_T b_A[64];
  real_T b_B[64];
  real_T w[8];
  int32_T i;
  memcpy(&b_A[0], &A[0], sizeof(real_T) << 6);
  memcpy(&b_B[0], &B[0], sizeof(real_T) << 6);
  info_t = LAPACKE_dsygvd(102, (ptrdiff_t)1, 'V', 'U', (ptrdiff_t)8, &b_A[0],
    (ptrdiff_t)8, &b_B[0], (ptrdiff_t)8, &w[0]);
  if ((int32_T)info_t < 0) {
    for (i = 0; i < 8; i++) {
      W[i].re = rtNaN;
      W[i].im = 0.0;
    }

    for (i = 0; i < 64; i++) {
      V[i].re = rtNaN;
      V[i].im = 0.0;
    }
  } else if ((int32_T)info_t == 0) {
    for (i = 0; i < 8; i++) {
      W[i].re = w[i];
      W[i].im = 0.0;
    }

    for (i = 0; i < 64; i++) {
      V[i].re = b_A[i];
      V[i].im = 0.0;
    }
  }

  *info = (int32_T)info_t;
}

static real_T c_xnrm2(int32_T n, real_T x[64], int32_T ix0)
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  int32_T kend;
  y = 0.0;
  if (n < 1) {
  } else if (n == 1) {
    y = muDoubleScalarAbs(x[ix0 - 1]);
  } else {
    scale = 3.3121686421112381E-170;
    kend = ix0 + n;
    for (k = ix0; k < kend; k++) {
      absxk = muDoubleScalarAbs(x[k - 1]);
      if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
      } else {
        t = absxk / scale;
        y += t * t;
      }
    }

    y = scale * muDoubleScalarSqrt(y);
  }

  return y;
}

static void xzlartg(const emlrtStack *sp, real_T f, real_T g, real_T *cs, real_T
                    *sn, real_T *r)
{
  emlrtStack st;
  real_T b_f1;
  real_T d;
  real_T gs;
  real_T u;
  st.prev = sp;
  st.tls = sp->tls;
  b_f1 = 2.2250738585072014E-308;
  st.site = &ko_emlrtRSI;
  d_sqrt(&st, &b_f1);
  b_f1 = 2.2471164185778949E+307;
  st.site = &lo_emlrtRSI;
  d_sqrt(&st, &b_f1);
  b_f1 = muDoubleScalarAbs(f);
  *r = muDoubleScalarAbs(g);
  if (g == 0.0) {
    *cs = 1.0;
    *sn = 0.0;
    *r = f;
  } else if (f == 0.0) {
    *cs = 0.0;
    if (g >= 0.0) {
      *sn = 1.0;
    } else {
      *sn = -1.0;
    }
  } else if ((b_f1 > 1.4916681462400413E-154) && (b_f1 < 4.7403759540545887E+153)
             && (*r > 1.4916681462400413E-154) && (*r < 4.7403759540545887E+153))
  {
    d = f * f + g * g;
    st.site = &mo_emlrtRSI;
    d_sqrt(&st, &d);
    *cs = b_f1 / d;
    if (f >= 0.0) {
      *r = muDoubleScalarAbs(d);
    } else {
      *r = -muDoubleScalarAbs(d);
    }

    *sn = g / *r;
  } else {
    u = muDoubleScalarMin(4.49423283715579E+307, muDoubleScalarMax
                          (2.2250738585072014E-308, muDoubleScalarMax(b_f1, *r)));
    b_f1 = f / u;
    gs = g / u;
    d = b_f1 * b_f1 + gs * gs;
    st.site = &no_emlrtRSI;
    d_sqrt(&st, &d);
    *cs = muDoubleScalarAbs(b_f1) / d;
    if (f >= 0.0) {
      *r = muDoubleScalarAbs(d);
    } else {
      *r = -muDoubleScalarAbs(d);
    }

    *sn = gs / *r;
    *r *= u;
  }
}

static void eigGeneralized(const emlrtStack *sp, real_T A[64], real_T B[64],
  creal_T V[64], creal_T D[64])
{
  emlrtStack st;
  creal_T dt[8];
  int32_T i;
  int32_T info;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &oo_emlrtRSI;
  xggev(&st, A, B, &info, dt, V);
  for (i = 0; i < 64; i++) {
    D[i].re = 0.0;
    D[i].im = 0.0;
  }

  for (i = 0; i < 8; i++) {
    D[i + (i << 3)].re = dt[i].re;
    D[i + (i << 3)].im = dt[i].im;
  }

  if (info != 0) {
    st.site = &po_emlrtRSI;
    c_warning(&st);
  }
}

static void xggev(const emlrtStack *sp, real_T A[64], real_T B[64], int32_T
                  *info, creal_T W[8], creal_T VR[64])
{
  __m128d r;
  emlrtStack b_st;
  emlrtStack st;
  real_T b_A[64];
  real_T b_B[64];
  real_T vr[64];
  real_T alphai[8];
  real_T alphar[8];
  real_T tau[8];
  real_T absxk;
  real_T anrm;
  real_T anrmto;
  real_T bnrm;
  int32_T rscale[8];
  int32_T i;
  int32_T ihi;
  int32_T ilo;
  int32_T ip1;
  int32_T j;
  int32_T jr;
  int32_T k;
  boolean_T exitg1;
  boolean_T guard1;
  boolean_T ilascl;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &qo_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  memcpy(&b_A[0], &A[0], sizeof(real_T) << 6);
  anrm = 0.0;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 64)) {
    absxk = muDoubleScalarAbs(A[k]);
    if (muDoubleScalarIsNaN(absxk)) {
      anrm = rtNaN;
      exitg1 = true;
    } else {
      if (absxk > anrm) {
        anrm = absxk;
      }

      k++;
    }
  }

  bnrm = 0.0;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 64)) {
    absxk = muDoubleScalarAbs(B[k]);
    if (muDoubleScalarIsNaN(absxk)) {
      bnrm = rtNaN;
      exitg1 = true;
    } else {
      if (absxk > bnrm) {
        bnrm = absxk;
      }

      k++;
    }
  }

  if (muDoubleScalarIsInf(anrm) || muDoubleScalarIsNaN(anrm) ||
      (muDoubleScalarIsInf(bnrm) || muDoubleScalarIsNaN(bnrm))) {
    for (i = 0; i < 8; i++) {
      W[i].re = rtNaN;
      W[i].im = 0.0;
    }
  }

  anrmto = anrm;
  ilascl = false;
  guard1 = false;
  if ((anrm > 0.0) && (anrm < 6.7178761075670888E-139)) {
    anrmto = 6.7178761075670888E-139;
    ilascl = true;
    guard1 = true;
  } else if (anrm > 1.4885657073574029E+138) {
    anrmto = 1.4885657073574029E+138;
    ilascl = true;
    guard1 = true;
  }

  if (guard1) {
    memcpy(&b_A[0], &A[0], sizeof(real_T) << 6);
    xzlascl(anrm, anrmto, b_A);
  }

  memcpy(&b_B[0], &B[0], sizeof(real_T) << 6);
  xzggbal(b_A, b_B, &ilo, &ihi, rscale);
  xzgeqr2(b_B, ilo, ihi, tau);
  for (i = ilo - 1; i < ihi; i++) {
    ip1 = i + 2;
    jr = i - ilo;
    for (j = ilo; j < 9; j++) {
      absxk = b_A[i + ((j - 1) << 3)];
      for (k = ip1; k <= ihi; k++) {
        absxk += b_A[(k + ((j - 1) << 3)) - 1] * b_B[(k + (i << 3)) - 1];
      }

      absxk *= tau[jr + 1];
      b_A[i + ((j - 1) << 3)] -= absxk;
      for (k = ip1; k <= ihi; k++) {
        b_A[(k + ((j - 1) << 3)) - 1] -= b_B[(k + (i << 3)) - 1] * absxk;
      }
    }
  }

  b_st.site = &to_emlrtRSI;
  xzgghrd(&b_st, ilo, ihi, b_A, b_B, vr);
  b_st.site = &so_emlrtRSI;
  xdhgeqz(&b_st, b_A, b_B, ilo, ihi, vr, info, alphar, alphai, tau);
  if (*info == 0) {
    b_st.site = &ro_emlrtRSI;
    *info = xdtgevc(&b_st, b_A, b_B, vr);
    if (*info == 0) {
      if (ilo > 1) {
        for (i = ilo - 2; i + 1 >= 1; i--) {
          k = rscale[i] - 1;
          if (rscale[i] != i + 1) {
            for (j = 0; j < 8; j++) {
              absxk = vr[i + (j << 3)];
              vr[i + (j << 3)] = vr[k + (j << 3)];
              vr[k + (j << 3)] = absxk;
            }
          }
        }
      }

      if (ihi < 8) {
        for (i = ihi + 1; i < 9; i++) {
          k = rscale[i - 1] - 1;
          if (rscale[i - 1] != i) {
            for (j = 0; j < 8; j++) {
              absxk = vr[(i + (j << 3)) - 1];
              vr[(i + (j << 3)) - 1] = vr[k + (j << 3)];
              vr[k + (j << 3)] = absxk;
            }
          }
        }
      }

      for (ip1 = 0; ip1 < 8; ip1++) {
        absxk = alphai[ip1];
        bnrm = 0.0;
        if (!(absxk < 0.0)) {
          if ((ip1 + 1 != 8) && (absxk > 0.0)) {
            for (jr = 0; jr < 8; jr++) {
              bnrm = muDoubleScalarMax(bnrm, muDoubleScalarAbs(vr[jr + (ip1 << 3)])
                + muDoubleScalarAbs(vr[jr + ((ip1 + 1) << 3)]));
            }
          } else {
            for (jr = 0; jr < 8; jr++) {
              bnrm = muDoubleScalarMax(bnrm, muDoubleScalarAbs(vr[jr + (ip1 << 3)]));
            }
          }

          if (!(bnrm < 6.7178761075670888E-139)) {
            bnrm = 1.0 / bnrm;
            if (absxk > 0.0) {
              for (jr = 0; jr <= 6; jr += 2) {
                r = _mm_loadu_pd(&vr[jr + (ip1 << 3)]);
                _mm_storeu_pd(&vr[jr + (ip1 << 3)], _mm_mul_pd(r, _mm_set1_pd
                  (bnrm)));
                r = _mm_loadu_pd(&vr[jr + ((ip1 + 1) << 3)]);
                _mm_storeu_pd(&vr[jr + ((ip1 + 1) << 3)], _mm_mul_pd(r,
                  _mm_set1_pd(bnrm)));
              }
            } else {
              for (jr = 0; jr <= 6; jr += 2) {
                r = _mm_loadu_pd(&vr[jr + (ip1 << 3)]);
                _mm_storeu_pd(&vr[jr + (ip1 << 3)], _mm_mul_pd(r, _mm_set1_pd
                  (bnrm)));
              }
            }
          }
        }
      }

      for (ip1 = 0; ip1 < 64; ip1++) {
        VR[ip1].re = vr[ip1];
        VR[ip1].im = 0.0;
      }

      for (j = 0; j < 7; j++) {
        if ((alphai[j] > 0.0) && (alphai[j + 1] < 0.0)) {
          for (i = 0; i < 8; i++) {
            VR[i + (j << 3)].im = VR[i + ((j + 1) << 3)].re;
            VR[i + ((j + 1) << 3)].re = VR[i + (j << 3)].re;
            VR[i + ((j + 1) << 3)].im = -VR[i + (j << 3)].im;
          }
        }
      }
    } else {
      *info = 10;
      for (ip1 = 0; ip1 < 64; ip1++) {
        VR[ip1].re = rtNaN;
        VR[ip1].im = 0.0;
      }
    }
  } else {
    for (ip1 = 0; ip1 < 64; ip1++) {
      VR[ip1].re = rtNaN;
      VR[ip1].im = 0.0;
    }
  }

  if (ilascl) {
    b_xzlascl(anrmto, anrm, alphar);
    b_xzlascl(anrmto, anrm, alphai);
  }

  for (i = 0; i < 8; i++) {
    if (!(alphai[i] < 0.0)) {
      if ((i + 1 != 8) && (alphai[i] > 0.0)) {
        W[i].re = 0.5 * (alphar[i] / tau[i] + alphar[i + 1] / tau[i + 1]);
        W[i].im = 0.5 * (alphai[i] / tau[i] - alphai[i + 1] / tau[i + 1]);
        W[i + 1].re = W[i].re;
        W[i + 1].im = -W[i].im;
      } else {
        W[i].re = alphar[i] / tau[i];
        W[i].im = 0.0;
      }
    }
  }
}

static real_T xzlanhs(const emlrtStack *sp, real_T A[64], int32_T ilo, int32_T
                      ihi)
{
  emlrtStack st;
  real_T absxk;
  real_T colscale;
  real_T colssq;
  real_T f;
  real_T scale;
  real_T ssq;
  real_T t;
  int32_T col;
  int32_T i;
  int32_T j;
  int32_T nm1;
  int32_T row;
  st.prev = sp;
  st.tls = sp->tls;
  f = 0.0;
  if (ilo <= ihi) {
    scale = 3.3121686421112381E-170;
    ssq = 0.0;
    nm1 = ihi - ilo;
    for (j = 0; j <= nm1; j++) {
      colscale = 3.3121686421112381E-170;
      colssq = 0.0;
      col = (ilo + j) - 1;
      i = j + 1;
      i = ilo + muIntScalarMin_sint32(i, nm1);
      for (row = ilo; row <= i; row++) {
        absxk = muDoubleScalarAbs(A[(row + (col << 3)) - 1]);
        if (absxk > colscale) {
          t = colscale / absxk;
          colssq = colssq * t * t + 1.0;
          colscale = absxk;
        } else {
          t = absxk / colscale;
          colssq += t * t;
        }
      }

      if (scale >= colscale) {
        absxk = colscale / scale;
        ssq += absxk * absxk * colssq;
      } else {
        absxk = scale / colscale;
        ssq = colssq + absxk * absxk * ssq;
        scale = colscale;
      }
    }

    st.site = &op_emlrtRSI;
    d_sqrt(&st, &ssq);
    f = scale * ssq;
  }

  return f;
}

static void xdlag2(const emlrtStack *sp, real_T a[64], int32_T ia0, real_T b[64],
                   int32_T ib0, real_T safmin, real_T *scale1, real_T *scale2,
                   real_T *wr1, real_T *wr2, real_T *wi)
{
  emlrtStack st;
  real_T a11;
  real_T a12;
  real_T a21;
  real_T a22;
  real_T abi22;
  real_T anorm;
  real_T as12;
  real_T ascale;
  real_T b11;
  real_T b12;
  real_T b22;
  real_T b_s2;
  real_T binv11;
  real_T binv22;
  real_T bnorm;
  real_T bsize;
  real_T pp;
  real_T ss;
  st.prev = sp;
  st.tls = sp->tls;
  anorm = safmin;
  st.site = &pp_emlrtRSI;
  d_sqrt(&st, &anorm);
  anorm = muDoubleScalarAbs(a[ia0 - 1]) + muDoubleScalarAbs(a[ia0]);
  b12 = muDoubleScalarAbs(a[ia0 + 7]) + muDoubleScalarAbs(a[ia0 + 8]);
  if (b12 > anorm) {
    anorm = b12;
  }

  if (anorm < 2.2250738585072014E-306) {
    anorm = 2.2250738585072014E-306;
  }

  ascale = 1.0 / anorm;
  a11 = a[ia0 - 1] * ascale;
  a21 = a[ia0] * ascale;
  a12 = a[ia0 + 7] * ascale;
  a22 = a[ia0 + 8] * ascale;
  b11 = b[ib0 - 1];
  b22 = b[ib0 + 8];
  anorm = muDoubleScalarAbs(b[ib0 - 1]);
  b12 = muDoubleScalarAbs(b[ib0 + 7]);
  b_s2 = muDoubleScalarAbs(b[ib0 + 8]);
  if (b12 > anorm) {
    anorm = b12;
  }

  if (b_s2 > anorm) {
    anorm = b_s2;
  }

  if (anorm < 1.4916681462400413E-153) {
    anorm = 1.4916681462400413E-153;
  }

  anorm *= 1.4916681462400413E-153;
  if (muDoubleScalarAbs(b[ib0 - 1]) < anorm) {
    if (b[ib0 - 1] >= 0.0) {
      b11 = anorm;
    } else {
      b11 = -anorm;
    }
  }

  if (muDoubleScalarAbs(b[ib0 + 8]) < anorm) {
    if (b[ib0 + 8] >= 0.0) {
      b22 = anorm;
    } else {
      b22 = -anorm;
    }
  }

  bnorm = muDoubleScalarAbs(b11);
  b12 = muDoubleScalarAbs(b[ib0 + 7]) + muDoubleScalarAbs(b22);
  if (b12 > bnorm) {
    bnorm = b12;
  }

  if (bnorm < 2.2250738585072014E-306) {
    bnorm = 2.2250738585072014E-306;
  }

  bsize = muDoubleScalarAbs(b11);
  b12 = muDoubleScalarAbs(b22);
  if (b12 > bsize) {
    bsize = b12;
  }

  anorm = 1.0 / bsize;
  b11 *= anorm;
  b12 = b[ib0 + 7] * anorm;
  b22 *= anorm;
  binv11 = 1.0 / b11;
  binv22 = 1.0 / b22;
  anorm = a11 * binv11;
  b_s2 = a22 * binv22;
  if (muDoubleScalarAbs(anorm) <= muDoubleScalarAbs(b_s2)) {
    as12 = a12 - anorm * b12;
    ss = a21 * (binv11 * binv22);
    abi22 = (a22 - anorm * b22) * binv22 - ss * b12;
    pp = 0.5 * abi22;
    b_s2 = anorm;
  } else {
    as12 = a12 - b_s2 * b12;
    ss = a21 * (binv11 * binv22);
    abi22 = -ss * b12;
    pp = 0.5 * ((a11 - b_s2 * b11) * binv11 + abi22);
  }

  anorm = ss * as12;
  if (muDoubleScalarAbs(pp * 1.4916681462400413E-153) >= 1.0) {
    b12 = 1.4916681462400413E-153 * pp;
    b12 = b12 * b12 + anorm * 2.2250738585072014E-306;
    anorm = muDoubleScalarAbs(b12);
    st.site = &qp_emlrtRSI;
    d_sqrt(&st, &anorm);
    *wi = anorm * 6.7039039649712989E+152;
  } else if (pp * pp + muDoubleScalarAbs(anorm) <= 2.2250738585072014E-306) {
    b12 = 6.7039039649712989E+152 * pp;
    b12 = b12 * b12 + anorm * 4.49423283715579E+305;
    anorm = muDoubleScalarAbs(b12);
    st.site = &rp_emlrtRSI;
    d_sqrt(&st, &anorm);
    *wi = anorm * 1.4916681462400413E-153;
  } else {
    b12 = pp * pp + anorm;
    *wi = muDoubleScalarAbs(b12);
    st.site = &sp_emlrtRSI;
    d_sqrt(&st, wi);
  }

  if ((b12 >= 0.0) || (*wi == 0.0)) {
    if (pp >= 0.0) {
      anorm = muDoubleScalarAbs(*wi);
      b12 = muDoubleScalarAbs(*wi);
    } else {
      anorm = -muDoubleScalarAbs(*wi);
      b12 = -muDoubleScalarAbs(*wi);
    }

    as12 = b_s2 + (pp + anorm);
    anorm = b_s2 + (pp - b12);
    if (0.5 * muDoubleScalarAbs(as12) > maximum2(muDoubleScalarAbs(anorm),
         2.2250738585072014E-306)) {
      anorm = (a11 * a22 - a12 * a21) * (binv11 * binv22) / as12;
    }

    if (pp > abi22) {
      *wr1 = minimum2(as12, anorm);
      *wr2 = maximum2(as12, anorm);
    } else {
      *wr1 = maximum2(as12, anorm);
      *wr2 = minimum2(as12, anorm);
    }

    *wi = 0.0;
  } else {
    *wr1 = b_s2 + pp;
    *wr2 = *wr1;
  }

  abi22 = bsize * (2.2250738585072014E-306 * maximum2(1.0, ascale));
  ss = 2.2250738585072014E-306 * maximum2(1.0, bnorm);
  b22 = bsize * 2.2250738585072014E-306;
  if ((ascale <= 1.0) && (bsize <= 1.0)) {
    b11 = minimum2(1.0, ascale / 2.2250738585072014E-306 * bsize);
  } else {
    b11 = 1.0;
  }

  if ((ascale <= 1.0) || (bsize <= 1.0)) {
    pp = minimum2(1.0, ascale * bsize);
  } else {
    pp = 1.0;
  }

  anorm = muDoubleScalarAbs(*wr1) + muDoubleScalarAbs(*wi);
  b12 = minimum2(b11, 0.5 * maximum2(anorm, pp));
  b_s2 = 1.00001 * (anorm * ss + b22);
  as12 = 2.2250738585072014E-306;
  if (abi22 > 2.2250738585072014E-306) {
    as12 = abi22;
  }

  if (b_s2 > as12) {
    as12 = b_s2;
  }

  if (b12 > as12) {
    as12 = b12;
  }

  if (as12 != 1.0) {
    anorm = 1.0 / as12;
    if (as12 > 1.0) {
      *scale1 = maximum2(ascale, bsize) * anorm * minimum2(ascale, bsize);
    } else {
      *scale1 = minimum2(ascale, bsize) * anorm * maximum2(ascale, bsize);
    }

    *wr1 *= anorm;
    if (*wi != 0.0) {
      *wi *= anorm;
      *wr2 = *wr1;
    }
  } else {
    *scale1 = ascale * bsize;
  }

  *scale2 = *scale1;
  if (*wi == 0.0) {
    b12 = minimum2(b11, 0.5 * maximum2(muDoubleScalarAbs(*wr2), pp));
    b_s2 = 1.00001 * (muDoubleScalarAbs(*wr2) * ss + b22);
    as12 = 2.2250738585072014E-306;
    if (abi22 > 2.2250738585072014E-306) {
      as12 = abi22;
    }

    if (b_s2 > as12) {
      as12 = b_s2;
    }

    if (b12 > as12) {
      as12 = b12;
    }

    if (as12 != 1.0) {
      anorm = 1.0 / as12;
      if (as12 > 1.0) {
        *scale2 = maximum2(ascale, bsize) * anorm * minimum2(ascale, bsize);
      } else {
        *scale2 = minimum2(ascale, bsize) * anorm * maximum2(ascale, bsize);
      }

      *wr2 *= anorm;
    } else {
      *scale2 = ascale * bsize;
    }
  }
}

static void b_xzlartg(const emlrtStack *sp, real_T f, real_T g, real_T *cs,
                      real_T *sn)
{
  emlrtStack st;
  real_T b_f1;
  real_T g1;
  real_T gs;
  st.prev = sp;
  st.tls = sp->tls;
  g1 = 2.2250738585072014E-308;
  st.site = &ko_emlrtRSI;
  d_sqrt(&st, &g1);
  g1 = 2.2471164185778949E+307;
  st.site = &lo_emlrtRSI;
  d_sqrt(&st, &g1);
  b_f1 = muDoubleScalarAbs(f);
  g1 = muDoubleScalarAbs(g);
  if (g == 0.0) {
    *cs = 1.0;
    *sn = 0.0;
  } else if (f == 0.0) {
    *cs = 0.0;
    if (g >= 0.0) {
      *sn = 1.0;
    } else {
      *sn = -1.0;
    }
  } else if ((b_f1 > 1.4916681462400413E-154) && (b_f1 < 4.7403759540545887E+153)
             && (g1 > 1.4916681462400413E-154) && (g1 < 4.7403759540545887E+153))
  {
    g1 = f * f + g * g;
    st.site = &mo_emlrtRSI;
    d_sqrt(&st, &g1);
    *cs = b_f1 / g1;
    if (f >= 0.0) {
      g1 = muDoubleScalarAbs(g1);
    } else {
      g1 = -muDoubleScalarAbs(g1);
    }

    *sn = g / g1;
  } else {
    g1 = muDoubleScalarMin(4.49423283715579E+307, muDoubleScalarMax
      (2.2250738585072014E-308, muDoubleScalarMax(b_f1, g1)));
    b_f1 = f / g1;
    gs = g / g1;
    g1 = b_f1 * b_f1 + gs * gs;
    st.site = &no_emlrtRSI;
    d_sqrt(&st, &g1);
    *cs = muDoubleScalarAbs(b_f1) / g1;
    if (f >= 0.0) {
      g1 = muDoubleScalarAbs(g1);
    } else {
      g1 = -muDoubleScalarAbs(g1);
    }

    *sn = gs / g1;
  }
}

static int32_T b_minimum2(int32_T x, int32_T y)
{
  return muIntScalarMin_sint32(x, y);
}

static void xdlasv2(const emlrtStack *sp, real_T f, real_T g, real_T h, real_T
                    *ssmin, real_T *ssmax, real_T *snr, real_T *csr, real_T *snl,
                    real_T *csl)
{
  emlrtStack st;
  real_T a;
  real_T clt;
  real_T fa;
  real_T ft;
  real_T ht;
  real_T l;
  real_T m;
  real_T r;
  real_T slt;
  real_T temp;
  int32_T b_x;
  int32_T tsign;
  int32_T x;
  int8_T pmax;
  boolean_T guard1;
  boolean_T swap;
  st.prev = sp;
  st.tls = sp->tls;
  ft = f;
  fa = muDoubleScalarAbs(f);
  ht = h;
  *ssmin = muDoubleScalarAbs(h);
  pmax = 1;
  swap = (*ssmin > fa);
  if (swap) {
    pmax = 3;
    ft = h;
    ht = f;
    temp = fa;
    fa = *ssmin;
    *ssmin = temp;
  }

  temp = muDoubleScalarAbs(g);
  clt = 1.0;
  *csr = 1.0;
  slt = 0.0;
  *snr = 0.0;
  *ssmax = fa;
  if (temp != 0.0) {
    guard1 = false;
    if (temp > fa) {
      pmax = 2;
      if (fa / temp < 2.2204460492503131E-16) {
        *ssmax = temp;
        if (*ssmin > 1.0) {
          *ssmin = fa / (temp / *ssmin);
        } else {
          *ssmin *= fa / temp;
        }

        slt = ht / g;
        *snr = 1.0;
        *csr = ft / g;
      } else {
        guard1 = true;
      }
    } else {
      guard1 = true;
    }

    if (guard1) {
      temp = fa - *ssmin;
      if (temp == fa) {
        l = 1.0;
      } else {
        l = temp / fa;
      }

      m = g / ft;
      slt = m * m;
      clt = (2.0 - l) * (2.0 - l) + slt;
      st.site = &tp_emlrtRSI;
      d_sqrt(&st, &clt);
      if (l == 0.0) {
        r = muDoubleScalarAbs(m);
      } else {
        r = l * l + slt;
        st.site = &up_emlrtRSI;
        d_sqrt(&st, &r);
      }

      a = 0.5 * (clt + r);
      *ssmin /= a;
      *ssmax = fa * a;
      if (slt == 0.0) {
        if (l == 0.0) {
          if (ft >= 0.0) {
            x = 2;
          } else {
            x = -2;
          }

          if (g >= 0.0) {
            b_x = 1;
          } else {
            b_x = -1;
          }

          temp = (real_T)(x * b_x);
        } else {
          if (ft >= 0.0) {
            temp = muDoubleScalarAbs(temp);
          } else {
            temp = -muDoubleScalarAbs(temp);
          }

          temp = g / temp + m / (2.0 - l);
        }
      } else {
        temp = (m / (clt + (2.0 - l)) + m / (r + l)) * (a + 1.0);
      }

      l = temp * temp + 4.0;
      st.site = &vp_emlrtRSI;
      d_sqrt(&st, &l);
      *csr = 2.0 / l;
      *snr = temp / l;
      clt = (*csr + *snr * m) / a;
      slt = ht / ft * *snr / a;
    }
  }

  if (swap) {
    *csl = *snr;
    *snl = *csr;
    *csr = slt;
    *snr = clt;
  } else {
    *csl = clt;
    *snl = slt;
  }

  if (pmax == 1) {
    if (*csr >= 0.0) {
      x = 1;
    } else {
      x = -1;
    }

    if (*csl >= 0.0) {
      b_x = 1;
    } else {
      b_x = -1;
    }

    if (f >= 0.0) {
      tsign = 1;
    } else {
      tsign = -1;
    }

    tsign *= x * b_x;
  } else if (pmax == 2) {
    if (*snr >= 0.0) {
      x = 1;
    } else {
      x = -1;
    }

    if (*csl >= 0.0) {
      b_x = 1;
    } else {
      b_x = -1;
    }

    if (g >= 0.0) {
      tsign = 1;
    } else {
      tsign = -1;
    }

    tsign *= x * b_x;
  } else {
    if (*snr >= 0.0) {
      x = 1;
    } else {
      x = -1;
    }

    if (*snl >= 0.0) {
      b_x = 1;
    } else {
      b_x = -1;
    }

    if (h >= 0.0) {
      tsign = 1;
    } else {
      tsign = -1;
    }

    tsign *= x * b_x;
  }

  if (tsign >= 0) {
    *ssmax = muDoubleScalarAbs(*ssmax);
  } else {
    *ssmax = -muDoubleScalarAbs(*ssmax);
  }

  if (f >= 0.0) {
    x = 1;
  } else {
    x = -1;
  }

  if (h >= 0.0) {
    b_x = 1;
  } else {
    b_x = -1;
  }

  if (tsign * x * b_x >= 0) {
    *ssmin = muDoubleScalarAbs(*ssmin);
  } else {
    *ssmin = -muDoubleScalarAbs(*ssmin);
  }
}

static real_T xdlapy3(const emlrtStack *sp, real_T x1, real_T x2, real_T x3)
{
  emlrtStack st;
  real_T a;
  real_T b;
  real_T c;
  real_T y;
  st.prev = sp;
  st.tls = sp->tls;
  a = muDoubleScalarAbs(x1);
  b = muDoubleScalarAbs(x2);
  c = muDoubleScalarAbs(x3);
  if (a > b) {
    y = a;
  } else {
    y = b;
  }

  if (c > y) {
    y = c;
  }

  if ((y > 0.0) && (!muDoubleScalarIsInf(y))) {
    a /= y;
    b /= y;
    c /= y;
    a = (a * a + c * c) + b * b;
    st.site = &wp_emlrtRSI;
    d_sqrt(&st, &a);
    y *= a;
  } else {
    y = (a + b) + c;
  }

  return y;
}

static void xdladiv(real_T a, real_T b, real_T c, real_T d, real_T *p, real_T *q)
{
  real_T aa;
  real_T ab;
  real_T bb;
  real_T cc;
  real_T cd;
  real_T dd;
  real_T s;
  aa = a;
  bb = b;
  cc = c;
  dd = d;
  ab = muDoubleScalarMax(muDoubleScalarAbs(a), muDoubleScalarAbs(b));
  cd = muDoubleScalarMax(muDoubleScalarAbs(c), muDoubleScalarAbs(d));
  s = 1.0;
  if (ab >= 8.9884656743115785E+307) {
    aa = 0.5 * a;
    bb = 0.5 * b;
    s = 2.0;
  }

  if (cd >= 8.9884656743115785E+307) {
    cc = 0.5 * c;
    dd = 0.5 * d;
    s *= 0.5;
  }

  if (ab <= 2.0041683600089728E-292) {
    aa *= 4.0564819207303341E+31;
    bb *= 4.0564819207303341E+31;
    s /= 4.0564819207303341E+31;
  }

  if (cd <= 2.0041683600089728E-292) {
    cc *= 4.0564819207303341E+31;
    dd *= 4.0564819207303341E+31;
    s *= 4.0564819207303341E+31;
  }

  if (muDoubleScalarAbs(d) <= muDoubleScalarAbs(c)) {
    dladiv1(aa, bb, cc, dd, p, q);
  } else {
    dladiv1(bb, aa, dd, cc, p, q);
    *q = -*q;
  }

  *p *= s;
  *q *= s;
}

static void dladiv1(real_T a, real_T b, real_T c, real_T d, real_T *p, real_T *q)
{
  real_T br;
  real_T r;
  real_T t;
  r = d / c;
  t = 1.0 / (c + d * r);
  if (r != 0.0) {
    br = b * r;
    if (br != 0.0) {
      *p = (a + br) * t;
    } else {
      *p = a * t + b * t * r;
    }
  } else {
    *p = (a + d * (b / c)) * t;
  }

  a = -a;
  if (r != 0.0) {
    br = a * r;
    if (br != 0.0) {
      *q = (b + br) * t;
    } else {
      *q = b * t + a * t * r;
    }
  } else {
    *q = (b + d * (a / c)) * t;
  }
}

static void mrdiv(const emlrtStack *sp, creal_T A[16], creal_T B[16], creal_T Y
                  [16])
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  creal_T b_A[16];
  real_T bim;
  real_T brm;
  real_T s;
  real_T temp_im;
  real_T temp_re;
  int32_T ipiv[4];
  int32_T i;
  int32_T info;
  int32_T j;
  int32_T jAcol;
  int32_T jBcol;
  int32_T k;
  int32_T kBcol;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &aq_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  memcpy(&b_A[0], &B[0], sizeof(creal_T) << 4);
  xgetrf(b_A, ipiv, &info);
  memcpy(&Y[0], &A[0], sizeof(creal_T) << 4);
  for (j = 0; j < 4; j++) {
    jBcol = (j << 2) - 1;
    jAcol = (j << 2) - 1;
    for (k = 0; k < j; k++) {
      kBcol = (k << 2) - 1;
      if ((b_A[(k + jAcol) + 1].re != 0.0) || (b_A[(k + jAcol) + 1].im != 0.0))
      {
        for (i = 0; i < 4; i++) {
          bim = b_A[(k + jAcol) + 1].re * Y[(i + kBcol) + 1].im + b_A[(k + jAcol)
            + 1].im * Y[(i + kBcol) + 1].re;
          Y[(i + jBcol) + 1].re -= b_A[(k + jAcol) + 1].re * Y[(i + kBcol) + 1].
            re - b_A[(k + jAcol) + 1].im * Y[(i + kBcol) + 1].im;
          Y[(i + jBcol) + 1].im -= bim;
        }
      }
    }

    temp_re = b_A[(j + jAcol) + 1].re;
    temp_im = b_A[(j + jAcol) + 1].im;
    brm = muDoubleScalarAbs(temp_re);
    bim = muDoubleScalarAbs(temp_im);
    if (temp_im == 0.0) {
      temp_re = 1.0 / temp_re;
      temp_im = 0.0;
    } else if (temp_re == 0.0) {
      temp_re = 0.0;
      temp_im = -1.0 / temp_im;
    } else if (brm > bim) {
      s = temp_im / temp_re;
      bim = temp_re + s * temp_im;
      temp_re = 1.0 / bim;
      temp_im = -s / bim;
    } else if (brm == bim) {
      bim = 0.5;
      if (temp_re < 0.0) {
        bim = -0.5;
      }

      s = 0.5;
      if (temp_im < 0.0) {
        s = -0.5;
      }

      temp_re = bim / brm;
      temp_im = -s / brm;
    } else {
      s = temp_re / temp_im;
      bim = temp_im + s * temp_re;
      temp_re = s / bim;
      temp_im = -1.0 / bim;
    }

    for (i = 0; i < 4; i++) {
      bim = temp_re * Y[(i + jBcol) + 1].im + temp_im * Y[(i + jBcol) + 1].re;
      Y[(i + jBcol) + 1].re = temp_re * Y[(i + jBcol) + 1].re - temp_im * Y[(i +
        jBcol) + 1].im;
      Y[(i + jBcol) + 1].im = bim;
    }
  }

  for (j = 3; j >= 0; j--) {
    jBcol = (j << 2) - 1;
    jAcol = (j << 2) - 1;
    for (k = j + 2; k < 5; k++) {
      kBcol = ((k - 1) << 2) - 1;
      if ((b_A[k + jAcol].re != 0.0) || (b_A[k + jAcol].im != 0.0)) {
        for (i = 0; i < 4; i++) {
          bim = b_A[k + jAcol].re * Y[(i + kBcol) + 1].im + b_A[k + jAcol].im *
            Y[(i + kBcol) + 1].re;
          Y[(i + jBcol) + 1].re -= b_A[k + jAcol].re * Y[(i + kBcol) + 1].re -
            b_A[k + jAcol].im * Y[(i + kBcol) + 1].im;
          Y[(i + jBcol) + 1].im -= bim;
        }
      }
    }
  }

  for (j = 2; j >= 0; j--) {
    jBcol = ipiv[j];
    if (jBcol != j + 1) {
      for (i = 0; i < 4; i++) {
        temp_re = Y[i + (j << 2)].re;
        temp_im = Y[i + (j << 2)].im;
        Y[i + (j << 2)].re = Y[i + ((jBcol - 1) << 2)].re;
        Y[i + (j << 2)].im = Y[i + ((jBcol - 1) << 2)].im;
        Y[i + ((jBcol - 1) << 2)].re = temp_re;
        Y[i + ((jBcol - 1) << 2)].im = temp_im;
      }
    }
  }

  if (info > 0) {
    b_st.site = &bq_emlrtRSI;
    c_st.site = &rn_emlrtRSI;
    warning(&c_st);
  }
}

static void ensureSymmetricPositiveSemidefinite(const emlrtStack *sp, real_T
  Pin[16], real_T Pout[16])
{
  emlrtStack st;
  creal_T D[16];
  creal_T Q[16];
  creal_T b_Q[16];
  creal_T d[4];
  creal_T b_d;
  real_T b_Pin[16];
  real_T x;
  real_T y;
  int32_T i;
  int32_T i1;
  int32_T k;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  for (k = 0; k < 4; k++) {
    for (i = 0; i < 4; i++) {
      b_Pin[i + (k << 2)] = (Pin[i + (k << 2)] + Pin[k + (i << 2)]) / 2.0;
    }
  }

  st.site = &cq_emlrtRSI;
  b_eig(&st, b_Pin, Q, D);
  for (k = 0; k < 4; k++) {
    b_d.re = D[k + (k << 2)].re;
    b_d.im = D[k + (k << 2)].im;
    if (muDoubleScalarIsNaN(b_d.re) || muDoubleScalarIsNaN(b_d.im)) {
      p = true;
    } else {
      if ((muDoubleScalarAbs(b_d.re) > 8.9884656743115785E+307) ||
          (muDoubleScalarAbs(b_d.im) > 8.9884656743115785E+307)) {
        x = muDoubleScalarHypot(b_d.re / 2.0, b_d.im / 2.0);
        y = 0.0;
      } else {
        x = muDoubleScalarHypot(b_d.re, b_d.im);
        y = 0.0;
      }

      if (x == 0.0) {
        x = muDoubleScalarAtan2(b_d.im, b_d.re);
        if (x == 0.0) {
          if (b_d.re != 0.0) {
            x = 0.0;
            y = b_d.re;
          } else {
            x = b_d.im;
            y = 0.0;
          }

          if (x == y) {
            x = 0.0;
            y = 0.0;
          }
        }
      }

      p = (x < y);
    }

    if (p) {
      x = 0.0;
      y = 0.0;
    } else {
      x = b_d.re;
      y = b_d.im;
    }

    b_d.re = x;
    b_d.im = y;
    d[k] = b_d;
  }

  for (k = 0; k < 16; k++) {
    D[k].re = 0.0;
    D[k].im = 0.0;
  }

  for (k = 0; k < 4; k++) {
    D[k + (k << 2)].re = d[k].re;
    D[k + (k << 2)].im = d[k].im;
  }

  for (k = 0; k < 4; k++) {
    for (i = 0; i < 4; i++) {
      b_Q[k + (i << 2)].re = 0.0;
      b_Q[k + (i << 2)].im = 0.0;
      for (i1 = 0; i1 < 4; i1++) {
        b_Q[k + (i << 2)].re += Q[k + (i1 << 2)].re * D[i1 + (i << 2)].re - Q[k
          + (i1 << 2)].im * D[i1 + (i << 2)].im;
        b_Q[k + (i << 2)].im += Q[k + (i1 << 2)].re * D[i1 + (i << 2)].im + Q[k
          + (i1 << 2)].im * D[i1 + (i << 2)].re;
      }
    }

    for (i = 0; i < 4; i++) {
      x = 0.0;
      for (i1 = 0; i1 < 4; i1++) {
        x += b_Q[k + (i1 << 2)].re * Q[i + (i1 << 2)].re - b_Q[k + (i1 << 2)].im
          * -Q[i + (i1 << 2)].im;
      }

      Pout[k + (i << 2)] = x;
    }
  }

  for (k = 0; k < 4; k++) {
    for (i = 0; i < 4; i++) {
      b_Pin[i + (k << 2)] = (Pout[i + (k << 2)] + Pout[k + (i << 2)]) / 2.0;
    }
  }

  memcpy(&Pout[0], &b_Pin[0], sizeof(real_T) << 4);
}

static void b_eig(const emlrtStack *sp, real_T A[16], creal_T V[16], creal_T D
                  [16])
{
  ptrdiff_t ihi_t;
  ptrdiff_t ilo_t;
  ptrdiff_t info_t;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  creal_T W[4];
  real_T b_A[16];
  real_T vright[16];
  real_T scale[4];
  real_T wimag[4];
  real_T wreal[4];
  real_T abnrm;
  real_T rconde;
  real_T rcondv;
  real_T vleft;
  int32_T exitg1;
  int32_T i;
  int32_T k;
  boolean_T exitg2;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  for (k = 0; k < 16; k++) {
    vleft = A[k];
    if (p && ((!muDoubleScalarIsInf(vleft)) && (!muDoubleScalarIsNaN(vleft)))) {
      p = true;
    } else {
      p = false;
    }
  }

  if (!p) {
    for (k = 0; k < 16; k++) {
      V[k].re = rtNaN;
      V[k].im = 0.0;
      D[k].re = 0.0;
      D[k].im = 0.0;
    }

    for (k = 0; k < 4; k++) {
      D[k + (k << 2)].re = rtNaN;
      D[k + (k << 2)].im = 0.0;
    }
  } else {
    p = true;
    k = 0;
    exitg2 = false;
    while ((!exitg2) && (k < 4)) {
      i = 0;
      do {
        exitg1 = 0;
        if (i <= k) {
          if (!(A[i + (k << 2)] == A[k + (i << 2)])) {
            p = false;
            exitg1 = 1;
          } else {
            i++;
          }
        } else {
          k++;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }

    if (p) {
      st.site = &dq_emlrtRSI;
      b_st.site = &gq_emlrtRSI;
      c_st.site = &hq_emlrtRSI;
      memcpy(&b_A[0], &A[0], sizeof(real_T) << 4);
      ilo_t = (ptrdiff_t)4;
      info_t = LAPACKE_dsyev(102, 'V', 'L', ilo_t, &b_A[0], ilo_t, &scale[0]);
      if ((int32_T)info_t < 0) {
        for (i = 0; i < 4; i++) {
          scale[i] = rtNaN;
        }

        for (k = 0; k < 16; k++) {
          b_A[k] = rtNaN;
        }
      }

      for (k = 0; k < 16; k++) {
        D[k].re = 0.0;
        D[k].im = 0.0;
      }

      for (i = 0; i < 4; i++) {
        D[i + (i << 2)].re = scale[i];
        D[i + (i << 2)].im = 0.0;
      }

      if ((int32_T)info_t != 0) {
        b_st.site = &hi_emlrtRSI;
        c_warning(&b_st);
      }

      for (k = 0; k < 16; k++) {
        V[k].re = b_A[k];
        V[k].im = 0.0;
      }
    } else {
      p = true;
      k = 0;
      exitg2 = false;
      while ((!exitg2) && (k < 4)) {
        i = 0;
        do {
          exitg1 = 0;
          if (i <= k) {
            if (!(A[i + (k << 2)] == -A[k + (i << 2)])) {
              p = false;
              exitg1 = 1;
            } else {
              i++;
            }
          } else {
            k++;
            exitg1 = 2;
          }
        } while (exitg1 == 0);

        if (exitg1 == 1) {
          exitg2 = true;
        }
      }

      if (p) {
        st.site = &eq_emlrtRSI;
        b_eigSkewHermitianStandard(&st, A, V, D);
      } else {
        st.site = &fq_emlrtRSI;
        b_st.site = &oq_emlrtRSI;
        memcpy(&b_A[0], &A[0], sizeof(real_T) << 4);
        info_t = LAPACKE_dgeevx(102, 'B', 'N', 'V', 'N', (ptrdiff_t)4, &b_A[0],
          (ptrdiff_t)4, &wreal[0], &wimag[0], &vleft, (ptrdiff_t)1, &vright[0],
          (ptrdiff_t)4, &ilo_t, &ihi_t, &scale[0], &abnrm, &rconde, &rcondv);
        if ((int32_T)info_t < 0) {
          for (i = 0; i < 4; i++) {
            W[i].re = rtNaN;
            W[i].im = 0.0;
          }

          for (k = 0; k < 16; k++) {
            V[k].re = rtNaN;
            V[k].im = 0.0;
          }
        } else {
          for (i = 0; i < 4; i++) {
            W[i].re = wreal[i];
            W[i].im = wimag[i];
          }

          for (k = 0; k < 16; k++) {
            V[k].re = vright[k];
            V[k].im = 0.0;
          }

          for (i = 0; i < 3; i++) {
            if ((wimag[i] > 0.0) && (wimag[i + 1] < 0.0)) {
              for (k = 0; k < 4; k++) {
                V[k + (i << 2)].im = V[k + ((i + 1) << 2)].re;
                V[k + ((i + 1) << 2)].re = V[k + (i << 2)].re;
                V[k + ((i + 1) << 2)].im = -V[k + (i << 2)].im;
              }
            }
          }
        }

        for (k = 0; k < 16; k++) {
          D[k].re = 0.0;
          D[k].im = 0.0;
        }

        for (k = 0; k < 4; k++) {
          D[k + (k << 2)].re = W[k].re;
          D[k + (k << 2)].im = W[k].im;
        }

        if ((int32_T)info_t != 0) {
          b_st.site = &mj_emlrtRSI;
          c_warning(&b_st);
        }
      }
    }
  }
}

static real_T d_xnrm2(int32_T n, real_T x[16], int32_T ix0)
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  int32_T kend;
  y = 0.0;
  if (n < 1) {
  } else if (n == 1) {
    y = muDoubleScalarAbs(x[ix0 - 1]);
  } else {
    scale = 3.3121686421112381E-170;
    kend = ix0 + n;
    for (k = ix0; k < kend; k++) {
      absxk = muDoubleScalarAbs(x[k - 1]);
      if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
      } else {
        t = absxk / scale;
        y += t * t;
      }
    }

    y = scale * muDoubleScalarSqrt(y);
  }

  return y;
}

static void b_eigSkewHermitianStandard(const emlrtStack *sp, real_T A[16],
  creal_T V[16], creal_T D[16])
{
  __m128d r;
  ptrdiff_t info_t;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  real_T a[16];
  real_T b_a[16];
  real_T work[4];
  real_T tau[3];
  real_T alpha1;
  real_T beta1;
  real_T d;
  real_T xnorm;
  int32_T b_i;
  int32_T i;
  int32_T ia0;
  int32_T im1n;
  int32_T in;
  int32_T k;
  int32_T knt;
  int32_T scalarLB;
  int32_T vectorUB;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &iq_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &jq_emlrtRSI;
  p = true;
  for (k = 0; k < 16; k++) {
    xnorm = A[k];
    if (p && ((!muDoubleScalarIsInf(xnorm)) && (!muDoubleScalarIsNaN(xnorm)))) {
      p = true;
    } else {
      p = false;
    }
  }

  if (!p) {
    for (i = 0; i < 16; i++) {
      b_a[i] = rtNaN;
    }

    im1n = 2;
    for (in = 0; in < 3; in++) {
      for (b_i = im1n; b_i < 5; b_i++) {
        b_a[(b_i + (in << 2)) - 1] = 0.0;
      }

      im1n++;
    }

    for (i = 0; i < 16; i++) {
      a[i] = rtNaN;
    }
  } else {
    memcpy(&a[0], &A[0], sizeof(real_T) << 4);
    for (b_i = 0; b_i < 4; b_i++) {
      work[b_i] = 0.0;
    }

    for (b_i = 0; b_i < 3; b_i++) {
      im1n = (b_i << 2) + 2;
      in = ((b_i + 1) << 2) + 1;
      i = b_i + 3;
      ia0 = muIntScalarMin_sint32(i, 4) + (b_i << 2);
      memcpy(&b_a[0], &a[0], sizeof(real_T) << 4);
      alpha1 = a[(b_i + (b_i << 2)) + 1];
      d = 0.0;
      xnorm = d_xnrm2(2 - b_i, a, ia0);
      if (xnorm != 0.0) {
        beta1 = muDoubleScalarHypot(a[(b_i + (b_i << 2)) + 1], xnorm);
        if (a[(b_i + (b_i << 2)) + 1] >= 0.0) {
          beta1 = -beta1;
        }

        if (muDoubleScalarAbs(beta1) < 1.0020841800044864E-292) {
          knt = -1;
          do {
            knt++;
            i = ia0 - b_i;
            scalarLB = ((i - ia0) + 2) / 2 * 2 + ia0;
            vectorUB = scalarLB - 2;
            for (k = ia0; k <= vectorUB; k += 2) {
              r = _mm_loadu_pd(&b_a[k - 1]);
              _mm_storeu_pd(&b_a[k - 1], _mm_mul_pd(_mm_set1_pd
                (9.9792015476736E+291), r));
            }

            for (k = scalarLB; k <= i + 1; k++) {
              b_a[k - 1] *= 9.9792015476736E+291;
            }

            beta1 *= 9.9792015476736E+291;
            alpha1 *= 9.9792015476736E+291;
          } while ((muDoubleScalarAbs(beta1) < 1.0020841800044864E-292) && (knt
                    + 1 < 20));

          beta1 = muDoubleScalarHypot(alpha1, d_xnrm2(2 - b_i, b_a, ia0));
          if (alpha1 >= 0.0) {
            beta1 = -beta1;
          }

          d = (beta1 - alpha1) / beta1;
          alpha1 = 1.0 / (alpha1 - beta1);
          i = ia0 - b_i;
          scalarLB = ((i - ia0) + 2) / 2 * 2 + ia0;
          vectorUB = scalarLB - 2;
          for (k = ia0; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&b_a[k - 1]);
            _mm_storeu_pd(&b_a[k - 1], _mm_mul_pd(_mm_set1_pd(alpha1), r));
          }

          for (k = scalarLB; k <= i + 1; k++) {
            b_a[k - 1] *= alpha1;
          }

          for (k = 0; k <= knt; k++) {
            beta1 *= 1.0020841800044864E-292;
          }

          alpha1 = beta1;
        } else {
          d = (beta1 - a[(b_i + (b_i << 2)) + 1]) / beta1;
          alpha1 = 1.0 / (a[(b_i + (b_i << 2)) + 1] - beta1);
          memcpy(&b_a[0], &a[0], sizeof(real_T) << 4);
          i = ia0 - b_i;
          scalarLB = ((i - ia0) + 2) / 2 * 2 + ia0;
          vectorUB = scalarLB - 2;
          for (k = ia0; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&b_a[k - 1]);
            _mm_storeu_pd(&b_a[k - 1], _mm_mul_pd(_mm_set1_pd(alpha1), r));
          }

          for (k = scalarLB; k <= i + 1; k++) {
            b_a[k - 1] *= alpha1;
          }

          alpha1 = beta1;
        }
      }

      memcpy(&a[0], &b_a[0], sizeof(real_T) << 4);
      tau[b_i] = d;
      a[(b_i + (b_i << 2)) + 1] = 1.0;
      e_xzlarf(3 - b_i, b_i + im1n, tau[b_i], a, in, work);
      d_xzlarf(3 - b_i, 3 - b_i, b_i + im1n, tau[b_i], a, (b_i + in) + 1, work);
      a[(b_i + (b_i << 2)) + 1] = alpha1;
    }

    c_st.site = &kq_emlrtRSI;
    memcpy(&b_a[0], &a[0], sizeof(real_T) << 4);
    info_t = LAPACKE_dorghr(102, (ptrdiff_t)4, (ptrdiff_t)1, (ptrdiff_t)4, &b_a
      [0], (ptrdiff_t)4, &tau[0]);
    if ((int32_T)info_t != 0) {
      for (i = 0; i < 16; i++) {
        b_a[i] = rtNaN;
      }
    }

    c_st.site = &lq_emlrtRSI;
    im1n = b_xhseqr(&c_st, a, b_a);
    if (im1n != 0) {
      c_st.site = &aj_emlrtRSI;
      d_warning(&c_st);
    }
  }

  for (i = 0; i < 16; i++) {
    D[i].re = 0.0;
    D[i].im = 0.0;
  }

  b_i = 1;
  while (b_i <= 4) {
    if ((b_i != 4) && (a[b_i + ((b_i - 1) << 2)] != 0.0)) {
      xnorm = muDoubleScalarAbs(a[b_i + ((b_i - 1) << 2)]);
      D[(b_i + ((b_i - 1) << 2)) - 1].re = 0.0;
      D[(b_i + ((b_i - 1) << 2)) - 1].im = xnorm;
      D[b_i + (b_i << 2)].re = 0.0;
      D[b_i + (b_i << 2)].im = -xnorm;
      b_i += 2;
    } else {
      b_i++;
    }
  }

  for (i = 0; i < 16; i++) {
    V[i].re = b_a[i];
    V[i].im = 0.0;
  }

  in = 1;
  while (in <= 4) {
    if ((in != 4) && (a[in + ((in - 1) << 2)] != 0.0)) {
      if (a[in + ((in - 1) << 2)] < 0.0) {
        im1n = 1;
      } else {
        im1n = -1;
      }

      for (b_i = 0; b_i < 4; b_i++) {
        xnorm = V[b_i + ((in - 1) << 2)].re;
        beta1 = (real_T)im1n * V[b_i + (in << 2)].re;
        if (beta1 == 0.0) {
          V[b_i + ((in - 1) << 2)].re = xnorm / 1.4142135623730951;
          V[b_i + ((in - 1) << 2)].im = 0.0;
        } else if (xnorm == 0.0) {
          V[b_i + ((in - 1) << 2)].re = 0.0;
          V[b_i + ((in - 1) << 2)].im = beta1 / 1.4142135623730951;
        } else {
          V[b_i + ((in - 1) << 2)].re = xnorm / 1.4142135623730951;
          V[b_i + ((in - 1) << 2)].im = beta1 / 1.4142135623730951;
        }

        V[b_i + (in << 2)].re = V[b_i + ((in - 1) << 2)].re;
        V[b_i + (in << 2)].im = -V[b_i + ((in - 1) << 2)].im;
      }

      in += 2;
    } else {
      in++;
    }
  }
}

static real_T xzlangeM(real_T x[16])
{
  real_T absxk;
  real_T y;
  int32_T k;
  boolean_T exitg1;
  y = 0.0;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 16)) {
    absxk = muDoubleScalarAbs(x[k]);
    if (muDoubleScalarIsNaN(absxk)) {
      y = rtNaN;
      exitg1 = true;
    } else {
      if (absxk > y) {
        y = absxk;
      }

      k++;
    }
  }

  return y;
}

static void b_svd(const emlrtStack *sp, real_T A[16], real_T U[16], real_T b_S
                  [16], real_T V[16])
{
  emlrtStack b_st;
  emlrtStack st;
  real_T c_A[16];
  real_T s[4];
  real_T b_A;
  int32_T i;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  for (i = 0; i < 16; i++) {
    b_A = A[i];
    if (p && ((!muDoubleScalarIsInf(b_A)) && (!muDoubleScalarIsNaN(b_A)))) {
      p = true;
    } else {
      p = false;
    }
  }

  if (p) {
    st.site = &qq_emlrtRSI;
    memcpy(&c_A[0], &A[0], 16U * sizeof(real_T));
    b_st.site = &sq_emlrtRSI;
    xzsvdc(&b_st, c_A, U, s, V);
  } else {
    st.site = &rq_emlrtRSI;
    for (i = 0; i < 16; i++) {
      c_A[i] = 0.0;
    }

    b_st.site = &sq_emlrtRSI;
    xzsvdc(&b_st, c_A, U, s, V);
    for (i = 0; i < 16; i++) {
      U[i] = rtNaN;
    }

    for (i = 0; i < 4; i++) {
      s[i] = rtNaN;
    }

    for (i = 0; i < 16; i++) {
      V[i] = rtNaN;
    }
  }

  for (i = 0; i < 16; i++) {
    b_S[i] = 0.0;
  }

  for (i = 0; i < 4; i++) {
    b_S[i + (i << 2)] = s[i];
  }
}

static void xzsvdc(const emlrtStack *sp, real_T A[16], real_T U[16], real_T b_S
                   [4], real_T V[16])
{
  static char_T cv[30] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L', 'A',
    'B', ':', 's', 'v', 'd', '_', 'N', 'o', 'C', 'o', 'n', 'v', 'e', 'r', 'g',
    'e', 'n', 'c', 'e' };

  __m128d r;
  emlrtStack st;
  real_T e[4];
  real_T s[4];
  real_T work[4];
  real_T anrm;
  real_T b_r;
  real_T cscale;
  real_T f;
  real_T nrm;
  real_T rt;
  real_T scale;
  real_T snorm;
  real_T sqds;
  int32_T exitg2;
  int32_T i;
  int32_T jj;
  int32_T k;
  int32_T m;
  int32_T q;
  int32_T qp1;
  int32_T qp1jj;
  int32_T qq;
  boolean_T apply_transform;
  boolean_T doscale;
  boolean_T exitg1;
  boolean_T exitg3;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 4; i++) {
    s[i] = 0.0;
    e[i] = 0.0;
    work[i] = 0.0;
  }

  for (jj = 0; jj < 16; jj++) {
    U[jj] = 0.0;
    V[jj] = 0.0;
  }

  doscale = false;
  anrm = xzlangeM(A);
  cscale = anrm;
  if ((anrm > 0.0) && (anrm < 6.7178761075670888E-139)) {
    doscale = true;
    cscale = 6.7178761075670888E-139;
    c_xzlascl(anrm, cscale, A);
  } else if (anrm > 1.4885657073574029E+138) {
    doscale = true;
    cscale = 1.4885657073574029E+138;
    c_xzlascl(anrm, cscale, A);
  }

  for (q = 0; q < 3; q++) {
    qp1 = q + 2;
    qq = (q + (q << 2)) + 1;
    apply_transform = false;
    nrm = e_xnrm2(4 - q, A, qq);
    if (nrm > 0.0) {
      apply_transform = true;
      if (A[qq - 1] < 0.0) {
        nrm = -nrm;
      }

      s[q] = nrm;
      if (muDoubleScalarAbs(s[q]) >= 1.0020841800044864E-292) {
        xscal(4 - q, 1.0 / s[q], A, qq);
      } else {
        jj = qq - q;
        i = ((jj - qq) + 4) / 2 * 2 + qq;
        qp1jj = i - 2;
        for (k = qq; k <= qp1jj; k += 2) {
          r = _mm_loadu_pd(&A[k - 1]);
          _mm_storeu_pd(&A[k - 1], _mm_div_pd(r, _mm_set1_pd(s[q])));
        }

        for (k = i; k <= jj + 3; k++) {
          A[k - 1] /= s[q];
        }
      }

      A[qq - 1]++;
      s[q] = -s[q];
    } else {
      s[q] = 0.0;
    }

    for (jj = qp1; jj < 5; jj++) {
      i = (q + ((jj - 1) << 2)) + 1;
      if (apply_transform) {
        xaxpy(4 - q, -(xdotc(4 - q, A, qq, A, i) / A[q + (q << 2)]), qq, A, i);
      }

      e[jj - 1] = A[i - 1];
    }

    memcpy(&U[q + (q << 2)], &A[q + (q << 2)], (uint32_T)((((q << 2) - q) - (q <<
              2)) + 4) * sizeof(real_T));
    if (q + 1 <= 2) {
      nrm = f_xnrm2(3 - q, e, q + 2);
      if (nrm == 0.0) {
        e[q] = 0.0;
      } else {
        if (e[q + 1] < 0.0) {
          nrm = -nrm;
        }

        e[q] = nrm;
        nrm = e[q];
        if (muDoubleScalarAbs(e[q]) >= 1.0020841800044864E-292) {
          c_xscal(3 - q, 1.0 / e[q], e, q + 2);
        } else {
          i = ((3 - q) / 2 * 2 + q) + 2;
          qp1jj = i - 2;
          for (k = qp1; k <= qp1jj; k += 2) {
            r = _mm_loadu_pd(&e[k - 1]);
            _mm_storeu_pd(&e[k - 1], _mm_div_pd(r, _mm_set1_pd(nrm)));
          }

          for (k = i; k < 5; k++) {
            e[k - 1] /= nrm;
          }
        }

        e[q + 1]++;
        e[q] = -e[q];
        for (jj = qp1; jj < 5; jj++) {
          work[jj - 1] = 0.0;
        }

        for (jj = qp1; jj < 5; jj++) {
          b_xaxpy(3 - q, e[jj - 1], A, (q + ((jj - 1) << 2)) + 2, work, q + 2);
        }

        for (jj = qp1; jj < 5; jj++) {
          c_xaxpy(3 - q, -e[jj - 1] / e[q + 1], work, q + 2, A, (q + ((jj - 1) <<
                    2)) + 2);
        }
      }

      for (jj = qp1; jj < 5; jj++) {
        V[(jj + (q << 2)) - 1] = e[jj - 1];
      }
    }
  }

  m = 2;
  s[3] = A[15];
  e[2] = A[14];
  e[3] = 0.0;
  for (jj = 0; jj < 4; jj++) {
    U[jj + 12] = 0.0;
  }

  U[15] = 1.0;
  for (q = 2; q >= 0; q--) {
    qq = q + (q << 2);
    if (s[q] != 0.0) {
      for (jj = q + 2; jj < 5; jj++) {
        i = (q + ((jj - 1) << 2)) + 1;
        xaxpy(4 - q, -(xdotc(4 - q, U, qq + 1, U, i) / U[qq]), qq + 1, U, i);
      }

      for (jj = q + 1; jj < 5; jj++) {
        U[(jj + (q << 2)) - 1] = -U[(jj + (q << 2)) - 1];
      }

      U[qq]++;
      for (jj = 0; jj < q; jj++) {
        U[jj + (q << 2)] = 0.0;
      }
    } else {
      for (jj = 0; jj < 4; jj++) {
        U[jj + (q << 2)] = 0.0;
      }

      U[qq] = 1.0;
    }
  }

  for (q = 3; q >= 0; q--) {
    if ((q + 1 <= 2) && (e[q] != 0.0)) {
      i = (q + (q << 2)) + 2;
      for (jj = q + 2; jj < 5; jj++) {
        qp1jj = (q + ((jj - 1) << 2)) + 2;
        xaxpy(3 - q, -(xdotc(3 - q, V, i, V, qp1jj) / V[i - 1]), i, V, qp1jj);
      }
    }

    for (jj = 0; jj < 4; jj++) {
      V[jj + (q << 2)] = 0.0;
    }

    V[q + (q << 2)] = 1.0;
  }

  qp1 = 0;
  snorm = 0.0;
  for (q = 0; q < 4; q++) {
    nrm = e[q];
    if (s[q] != 0.0) {
      rt = muDoubleScalarAbs(s[q]);
      b_r = s[q] / rt;
      s[q] = rt;
      if (q + 1 < 4) {
        nrm /= b_r;
      }

      b_xscal(b_r, U, (q << 2) + 1);
    }

    if ((q + 1 < 4) && (nrm != 0.0)) {
      rt = muDoubleScalarAbs(nrm);
      b_r = rt / nrm;
      nrm = rt;
      s[q + 1] *= b_r;
      b_xscal(b_r, V, ((q + 1) << 2) + 1);
    }

    snorm = muDoubleScalarMax(snorm, muDoubleScalarMax(muDoubleScalarAbs(s[q]),
      muDoubleScalarAbs(nrm)));
    e[q] = nrm;
  }

  exitg1 = false;
  while ((!exitg1) && (m + 2 > 0)) {
    if (qp1 >= 75) {
      st.site = &pv_emlrtRSI;
      error(&st, b_emlrt_marshallOut(&st, cv), getString(&st, b_message(&st,
              b_emlrt_marshallOut(&st, cv), &ub_emlrtMCI), &ub_emlrtMCI),
            &ub_emlrtMCI);
      exitg1 = true;
    } else {
      jj = m;
      do {
        exitg2 = 0;
        q = jj + 1;
        if (jj + 1 == 0) {
          exitg2 = 1;
        } else {
          nrm = muDoubleScalarAbs(e[jj]);
          if ((nrm <= 2.2204460492503131E-16 * (muDoubleScalarAbs(s[jj]) +
                muDoubleScalarAbs(s[jj + 1]))) || (nrm <=
               1.0020841800044864E-292) || ((qp1 > 20) && (nrm <=
                2.2204460492503131E-16 * snorm))) {
            e[jj] = 0.0;
            exitg2 = 1;
          } else {
            jj--;
          }
        }
      } while (exitg2 == 0);

      if (jj + 1 == m + 1) {
        i = 4;
      } else {
        qp1jj = m + 2;
        i = m + 2;
        exitg3 = false;
        while ((!exitg3) && (i >= jj + 1)) {
          qp1jj = i;
          if (i == jj + 1) {
            exitg3 = true;
          } else {
            nrm = 0.0;
            if (i < m + 2) {
              nrm = muDoubleScalarAbs(e[i - 1]);
            }

            if (i > jj + 2) {
              nrm += muDoubleScalarAbs(e[i - 2]);
            }

            rt = muDoubleScalarAbs(s[i - 1]);
            if ((rt <= 2.2204460492503131E-16 * nrm) || (rt <=
                 1.0020841800044864E-292)) {
              s[i - 1] = 0.0;
              exitg3 = true;
            } else {
              i--;
            }
          }
        }

        if (qp1jj == jj + 1) {
          i = 3;
        } else if (qp1jj == m + 2) {
          i = 1;
        } else {
          i = 2;
          q = qp1jj;
        }
      }

      switch (i) {
       case 1:
        f = e[m];
        e[m] = 0.0;
        for (k = m + 1; k >= q + 1; k--) {
          nrm = s[k - 1];
          st.site = &xq_emlrtRSI;
          xrotg(&nrm, &f, &rt, &b_r);
          s[k - 1] = nrm;
          if (k > q + 1) {
            f = -b_r * e[k - 2];
            e[k - 2] *= rt;
          }

          d_xrot(V, ((k - 1) << 2) + 1, ((m + 1) << 2) + 1, rt, b_r);
        }
        break;

       case 2:
        f = e[q - 1];
        e[q - 1] = 0.0;
        for (k = q + 1; k <= m + 2; k++) {
          nrm = s[k - 1];
          st.site = &wq_emlrtRSI;
          xrotg(&nrm, &f, &rt, &b_r);
          s[k - 1] = nrm;
          f = -b_r * e[k - 1];
          e[k - 1] *= rt;
          d_xrot(U, ((k - 1) << 2) + 1, ((q - 1) << 2) + 1, rt, b_r);
        }
        break;

       case 3:
        i = m + 1;
        scale = muDoubleScalarMax(muDoubleScalarMax(muDoubleScalarMax
          (muDoubleScalarMax(muDoubleScalarAbs(s[m + 1]), muDoubleScalarAbs(s[m])),
           muDoubleScalarAbs(e[m])), muDoubleScalarAbs(s[q])), muDoubleScalarAbs
          (e[q]));
        f = s[m + 1] / scale;
        nrm = s[m] / scale;
        rt = e[m] / scale;
        sqds = s[q] / scale;
        b_r = ((nrm + f) * (nrm - f) + rt * rt) / 2.0;
        nrm = f * rt;
        nrm *= nrm;
        if ((b_r != 0.0) || (nrm != 0.0)) {
          rt = b_r * b_r + nrm;
          st.site = &vq_emlrtRSI;
          d_sqrt(&st, &rt);
          if (b_r < 0.0) {
            rt = -rt;
          }

          rt = nrm / (b_r + rt);
        } else {
          rt = 0.0;
        }

        f = (sqds + f) * (sqds - f) + rt;
        nrm = sqds * (e[q] / scale);
        for (k = q + 1; k <= i; k++) {
          st.site = &uq_emlrtRSI;
          xrotg(&f, &nrm, &rt, &b_r);
          if (k > q + 1) {
            e[k - 2] = f;
          }

          f = rt * s[k - 1] + b_r * e[k - 1];
          e[k - 1] = rt * e[k - 1] - b_r * s[k - 1];
          nrm = b_r * s[k];
          s[k] *= rt;
          d_xrot(V, ((k - 1) << 2) + 1, (k << 2) + 1, rt, b_r);
          st.site = &tq_emlrtRSI;
          xrotg(&f, &nrm, &rt, &b_r);
          s[k - 1] = f;
          f = rt * e[k - 1] + b_r * s[k];
          s[k] = -b_r * e[k - 1] + rt * s[k];
          nrm = b_r * e[k];
          e[k] *= rt;
          d_xrot(U, ((k - 1) << 2) + 1, (k << 2) + 1, rt, b_r);
        }

        e[m] = f;
        qp1++;
        break;

       default:
        if (s[q] < 0.0) {
          s[q] = -s[q];
          b_xscal(-1.0, V, (q << 2) + 1);
        }

        qp1 = q + 1;
        while ((q + 1 < 4) && (s[q] < s[qp1])) {
          rt = s[q];
          s[q] = s[qp1];
          s[qp1] = rt;
          xswap(V, (q << 2) + 1, ((q + 1) << 2) + 1);
          xswap(U, (q << 2) + 1, ((q + 1) << 2) + 1);
          q = qp1;
          qp1++;
        }

        qp1 = 0;
        m--;
        break;
      }
    }
  }

  for (k = 0; k < 4; k++) {
    b_S[k] = s[k];
  }

  if (doscale) {
    d_xzlascl(cscale, anrm, b_S);
  }
}

static real_T e_xnrm2(int32_T n, real_T x[16], int32_T ix0)
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  int32_T kend;
  y = 0.0;
  if (n < 1) {
  } else if (n == 1) {
    y = muDoubleScalarAbs(x[ix0 - 1]);
  } else {
    scale = 3.3121686421112381E-170;
    kend = ix0 + n;
    for (k = ix0; k < kend; k++) {
      absxk = muDoubleScalarAbs(x[k - 1]);
      if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
      } else {
        t = absxk / scale;
        y += t * t;
      }
    }

    y = scale * muDoubleScalarSqrt(y);
  }

  return y;
}

static real_T xdotc(int32_T n, real_T x[16], int32_T ix0, real_T y[16], int32_T
                    iy0)
{
  real_T d;
  int32_T i;
  int32_T ix;
  int32_T iy;
  int32_T k;
  d = 0.0;
  ix = ix0 - 1;
  iy = iy0 - 1;
  i = (uint8_T)n;
  for (k = 0; k < i; k++) {
    d += x[ix] * y[iy];
    ix++;
    iy++;
  }

  return d;
}

static real_T f_xnrm2(int32_T n, real_T x[4], int32_T ix0)
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  int32_T k;
  int32_T kend;
  y = 0.0;
  scale = 3.3121686421112381E-170;
  kend = ix0 + n;
  for (k = ix0; k < kend; k++) {
    absxk = muDoubleScalarAbs(x[k - 1]);
    if (absxk > scale) {
      t = scale / absxk;
      y = y * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }
  }

  return scale * muDoubleScalarSqrt(y);
}

static real_T c_maximum(real_T x[4])
{
  real_T ex;
  int32_T idx;
  int32_T k;
  boolean_T exitg1;
  if (!muDoubleScalarIsNaN(x[0])) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!muDoubleScalarIsNaN(x[k - 1])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    ex = x[0];
  } else {
    ex = x[idx - 1];
    for (k = idx + 1; k < 5; k++) {
      if (ex < x[k - 1]) {
        ex = x[k - 1];
      }
    }
  }

  return ex;
}

static void b_maximum2(real_T x[4], real_T y, real_T ex[4])
{
  int32_T k;
  for (k = 0; k < 4; k++) {
    ex[k] = muDoubleScalarMax(x[k], y);
  }
}

static void visionDetectionGenerator_addFalsePositives
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T dets_data[], int32_T dets_size[2],
   coder_array_real_T_3D *covmats, real_T tgtIDs_data[], int32_T tgtIDs_size[2],
   real_T classIDs_data[], int32_T classIDs_size[2], real_T detsOut_data[],
   int32_T detsOut_size[2], coder_array_real_T_3D *covmatsOut, real_T
   tgtIDsOut_data[], int32_T tgtIDsOut_size[2], real_T classIDsOut_data[],
   int32_T classIDsOut_size[2])
{
  static int32_T iv1[3] = { 2, 2, 1 };

  coder_array_real_T b_xyCoverageArea;
  coder_array_real_T c_xyCoverageArea;
  coder_array_real_T d_xyCoverageArea;
  coder_array_real_T e_xyCoverageArea;
  coder_array_real_T f_xyCoverageArea;
  coder_array_real_T g_xyCoverageArea;
  coder_array_real_T_2D xyCoverageArea;
  emlrtStack b_st;
  emlrtStack st;
  monoCamera r;
  real_T R1_data[4];
  real_T R_data[4];
  real_T Rv_data[4];
  real_T b_U_data[2];
  real_T monoCamSen_SensorLocation[2];
  real_T t18_SensorLocation[2];
  real_T xLim[2];
  real_T xFalse_data[1];
  real_T yFalse_data[1];
  real_T horzDist;
  real_T rnddraw;
  real_T xCntr;
  real_T xPt;
  real_T xSpan;
  real_T yCntr;
  real_T ySpan;
  int32_T R1_size[3];
  int32_T R_size[3];
  int32_T Rv_size[3];
  int32_T iv[2];
  int32_T tmp_size[2];
  int32_T xFalse_size[1];
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T loop_ub;
  int32_T m;
  boolean_T guard1;
  boolean_T onHorz;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &yq_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (obj->pUseRandSeed) {
    b_st.site = &rm_emlrtRSI;
    rnddraw = b_rand(moduleInstance, &b_st);
  } else {
    b_st.site = &sm_emlrtRSI;
    rnddraw = b_rand(moduleInstance, &b_st);
  }

  array_real_T_2D_Constructor(&xyCoverageArea);
  array_real_T_2D_SetSize(&xyCoverageArea, obj->pxyCoverageArea.size[0],
    obj->pxyCoverageArea.size[1]);
  loop_ub = obj->pxyCoverageArea.size[0] * obj->pxyCoverageArea.size[1];
  for (i = 0; i < loop_ub; i++) {
    xyCoverageArea.vector.data[i] = obj->pxyCoverageArea.vector.data[i];
  }

  array_real_T_Constructor(&b_xyCoverageArea);
  array_real_T_Constructor(&c_xyCoverageArea);
  array_real_T_Constructor(&d_xyCoverageArea);
  array_real_T_Constructor(&e_xyCoverageArea);
  array_real_T_Constructor(&f_xyCoverageArea);
  array_real_T_Constructor(&g_xyCoverageArea);
  if ((xyCoverageArea.size[0] != 0) && (xyCoverageArea.size[1] != 0) && (rnddraw
       < 0.1)) {
    detsOut_size[0] = 6;
    detsOut_size[1] = dets_size[1] + 1;
    loop_ub = 6 * (dets_size[1] + 1);
    for (i = 0; i < loop_ub; i++) {
      detsOut_data[i] = 0.0;
    }

    array_real_T_3D_SetSize(covmatsOut, 6, 6, dets_size[1] + 1);
    loop_ub = 36 * (dets_size[1] + 1);
    for (i = 0; i < loop_ub; i++) {
      covmatsOut->vector.data[i] = 0.0;
    }

    tgtIDsOut_size[0] = 1;
    tgtIDsOut_size[1] = dets_size[1] + 1;
    loop_ub = dets_size[1];
    classIDsOut_size[0] = 1;
    classIDsOut_size[1] = dets_size[1] + 1;
    for (i = 0; i <= loop_ub; i++) {
      tgtIDsOut_data[i] = 0.0;
      classIDsOut_data[i] = 0.0;
    }

    loop_ub = dets_size[1] + 1;
    for (i = 0; i < loop_ub; i++) {
      covmatsOut->vector.data[36 * i + 14] = 100.0;
    }

    loop_ub = covmatsOut->size[2];
    for (i = 0; i < loop_ub; i++) {
      covmatsOut->vector.data[36 * i + 35] = 100.0;
    }

    if (dets_size[1] < 1) {
      loop_ub = 0;
    } else {
      loop_ub = emlrtDynamicBoundsCheckR2012b(dets_size[1], 1, dets_size[1] + 1,
        &pg_emlrtBCI, (emlrtConstCTX)sp);
    }

    iv[0] = 6;
    iv[1] = loop_ub;
    emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &dets_size[0], 2, &ab_emlrtECI,
      (void *)sp);
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 6; i1++) {
        detsOut_data[i1 + 6 * i] = dets_data[i1 + 6 * i];
      }
    }

    if (dets_size[1] < 1) {
      loop_ub = 0;
    } else {
      loop_ub = emlrtDynamicBoundsCheckR2012b(dets_size[1], 1, covmatsOut->size
        [2], &kg_emlrtBCI, (emlrtConstCTX)sp);
    }

    R1_size[0] = 6;
    R1_size[1] = 6;
    R1_size[2] = loop_ub;
    emlrtSubAssignSizeCheckR2012b(&R1_size[0], 3, &covmats->size[0], 3,
      &w_emlrtECI, (void *)sp);
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < 6; i1++) {
        for (i2 = 0; i2 < 6; i2++) {
          covmatsOut->vector.data[(i2 + 6 * i1) + 36 * i] = covmats->
            vector.data[(i2 + 6 * i1) + 36 * i];
        }
      }
    }

    if (dets_size[1] < 1) {
      i = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1], 1, dets_size[1] + 1,
        &fg_emlrtBCI, (emlrtConstCTX)sp);
    }

    emlrtSubAssignSizeCheck1dR2017a(i, tgtIDs_size[1], &t_emlrtECI,
      (emlrtConstCTX)sp);
    if (tgtIDs_size[1] - 1 >= 0) {
      memcpy(&tgtIDsOut_data[0], &tgtIDs_data[0], (uint32_T)tgtIDs_size[1] *
             sizeof(real_T));
    }

    if (dets_size[1] < 1) {
      i = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1], 1, dets_size[1] + 1,
        &cg_emlrtBCI, (emlrtConstCTX)sp);
    }

    emlrtSubAssignSizeCheck1dR2017a(i, classIDs_size[1], &r_emlrtECI,
      (emlrtConstCTX)sp);
    if (classIDs_size[1] - 1 >= 0) {
      memcpy(&classIDsOut_data[0], &classIDs_data[0], (uint32_T)classIDs_size[1]
             * sizeof(real_T));
    }

    array_real_T_SetSize(&b_xyCoverageArea, xyCoverageArea.size[0]);
    loop_ub = xyCoverageArea.size[0];
    for (i = 0; i < loop_ub; i++) {
      b_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i];
    }

    st.site = &xm_emlrtRSI;
    rnddraw = c_minimum(&st, &b_xyCoverageArea);
    array_real_T_SetSize(&c_xyCoverageArea, xyCoverageArea.size[0]);
    loop_ub = xyCoverageArea.size[0];
    for (i = 0; i < loop_ub; i++) {
      c_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i];
    }

    st.site = &ym_emlrtRSI;
    horzDist = d_maximum(&st, &c_xyCoverageArea);
    xLim[0] = rnddraw;
    xLim[1] = horzDist;
    xSpan = diff(xLim);
    xCntr = c_mean(xLim);
    emlrtDynamicBoundsCheckR2012b(2, 1, xyCoverageArea.size[1], &sg_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(2, 1, xyCoverageArea.size[1], &rg_emlrtBCI,
      (emlrtConstCTX)sp);
    array_real_T_SetSize(&d_xyCoverageArea, xyCoverageArea.size[0]);
    loop_ub = xyCoverageArea.size[0];
    for (i = 0; i < loop_ub; i++) {
      d_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i +
        xyCoverageArea.size[0]];
    }

    st.site = &xm_emlrtRSI;
    rnddraw = c_minimum(&st, &d_xyCoverageArea);
    array_real_T_SetSize(&e_xyCoverageArea, xyCoverageArea.size[0]);
    loop_ub = xyCoverageArea.size[0];
    for (i = 0; i < loop_ub; i++) {
      e_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i +
        xyCoverageArea.size[0]];
    }

    st.site = &ym_emlrtRSI;
    horzDist = d_maximum(&st, &e_xyCoverageArea);
    xLim[0] = rnddraw;
    xLim[1] = horzDist;
    ySpan = diff(xLim);
    yCntr = c_mean(xLim);
    r = obj->pMonoCameraInSensorFrame;
    for (i = 0; i < 2; i++) {
      xLim[i] = r.SensorLocation[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      monoCamSen_SensorLocation[i] = xLim[i];
    }

    for (m = 0; m < 1; m++) {
      xPt = rtInf;
      rnddraw = rtInf;
      onHorz = true;
      do {
        exitg1 = 0;
        guard1 = false;
        if (onHorz) {
          guard1 = true;
        } else {
          emlrtDynamicBoundsCheckR2012b(2, 1, xyCoverageArea.size[1],
            &qg_emlrtBCI, (emlrtConstCTX)sp);
          array_real_T_SetSize(&f_xyCoverageArea, xyCoverageArea.size[0]);
          loop_ub = xyCoverageArea.size[0];
          for (i = 0; i < loop_ub; i++) {
            f_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i];
          }

          array_real_T_SetSize(&g_xyCoverageArea, xyCoverageArea.size[0]);
          loop_ub = xyCoverageArea.size[0];
          for (i = 0; i < loop_ub; i++) {
            g_xyCoverageArea.vector.data[i] = xyCoverageArea.vector.data[i +
              xyCoverageArea.size[0]];
          }

          st.site = &ar_emlrtRSI;
          if (!inpolygon(&st, xPt, rnddraw, &f_xyCoverageArea, &g_xyCoverageArea))
          {
            guard1 = true;
          } else {
            exitg1 = 1;
          }
        }

        if (guard1) {
          st.site = &br_emlrtRSI;
          if (obj->pUseRandSeed) {
            b_st.site = &sr_emlrtRSI;
            rnddraw = c_rand(moduleInstance, &b_st);
          } else {
            b_st.site = &tr_emlrtRSI;
            rnddraw = c_rand(moduleInstance, &b_st);
          }

          xPt = xSpan * (rnddraw - 0.5) + xCntr;
          st.site = &cr_emlrtRSI;
          if (obj->pUseRandSeed) {
            b_st.site = &sr_emlrtRSI;
            rnddraw = c_rand(moduleInstance, &b_st);
          } else {
            b_st.site = &tr_emlrtRSI;
            rnddraw = c_rand(moduleInstance, &b_st);
          }

          rnddraw = ySpan * (rnddraw - 0.5) + yCntr;
          b_U_data[0] = xPt;
          b_U_data[1] = rnddraw;
          st.site = &dr_emlrtRSI;
          b_monoCamera_vehicleToImage(&st, r.Intrinsics, r.Height, r.Pitch,
            r.Yaw, r.Roll, monoCamSen_SensorLocation, b_U_data, xLim);
          st.site = &er_emlrtRSI;
          horzDist = visionDetectionGenerator_distFromHorizon(obj, xLim);
          onHorz = (horzDist == 0.0);
        }
      } while (exitg1 == 0);

      xFalse_data[0] = xPt;
      yFalse_data[0] = rnddraw;
    }

    r = obj->pMonoCameraInSensorFrame;
    for (i = 0; i < 2; i++) {
      xLim[i] = r.SensorLocation[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      xLim[i] = b_U_data[i];
    }

    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    for (i = 0; i < 2; i++) {
      t18_SensorLocation[i] = b_U_data[i];
    }

    xLim[0] = xFalse_data[0];
    xLim[1] = yFalse_data[0];
    for (i = 0; i < 2; i++) {
      monoCamSen_SensorLocation[i] = t18_SensorLocation[i];
      b_U_data[i] = xLim[i];
    }

    st.site = &fr_emlrtRSI;
    c_monoCamera_vehicleToImage(&st, r.Intrinsics, r.Height, r.Pitch, r.Yaw,
      r.Roll, monoCamSen_SensorLocation, b_U_data, xLim, tmp_size);
    for (i = 0; i < 2; i++) {
      b_U_data[i] = xLim[i];
    }

    st.site = &gr_emlrtRSI;
    b_visionDetectionGenerator_imag2cam(&st, obj, b_U_data, xLim, tmp_size,
      R1_data, R1_size);
    st.site = &hr_emlrtRSI;
    b_visionDetectionGenerator_kalmanFilterModel(&st, R1_data, R_data, R_size,
      Rv_data, Rv_size);
    st.site = &ir_emlrtRSI;
    AbstractDetectionGenerator_rand(moduleInstance, &st, obj, xFalse_data,
      xFalse_size);
    xFalse_data[0] *= 100.0;
    st.site = &jr_emlrtRSI;
    AbstractDetectionGenerator_rand(moduleInstance, &st, obj, yFalse_data,
      xFalse_size);
    yFalse_data[0] *= 6.2831853071795862;
    rnddraw = yFalse_data[0];
    for (loop_ub = 0; loop_ub < 1; loop_ub++) {
      rnddraw = muDoubleScalarCos(rnddraw);
      yFalse_data[0] = muDoubleScalarSin(yFalse_data[0]);
    }

    yFalse_data[0] *= xFalse_data[0];
    if (dets_size[1] + 1 > detsOut_size[1]) {
      i = 0;
      i1 = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1] + 1, 1, detsOut_size[1],
        &og_emlrtBCI, (emlrtConstCTX)sp) - 1;
      i1 = emlrtDynamicBoundsCheckR2012b(detsOut_size[1], 1, detsOut_size[1],
        &ng_emlrtBCI, (emlrtConstCTX)sp);
    }

    iv[0] = 2;
    iv[1] = i1 - i;
    for (i2 = 0; i2 < 2; i2++) {
      tmp_size[i2] = 2 - i2;
    }

    emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &tmp_size[0], 2, &y_emlrtECI, (void
      *)sp);
    loop_ub = i1 - i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        detsOut_data[i2 + 6 * (i + i1)] = xLim[i2 + (i1 << 1)];
      }
    }

    if (dets_size[1] + 1 > detsOut_size[1]) {
      i = 0;
      i1 = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1] + 1, 1, detsOut_size[1],
        &mg_emlrtBCI, (emlrtConstCTX)sp) - 1;
      i1 = emlrtDynamicBoundsCheckR2012b(detsOut_size[1], 1, detsOut_size[1],
        &lg_emlrtBCI, (emlrtConstCTX)sp);
    }

    iv[0] = 2;
    iv[1] = i1 - i;
    for (i2 = 0; i2 < 2; i2++) {
      tmp_size[i2] = 2 - i2;
    }

    emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &tmp_size[0], 2, &x_emlrtECI, (void
      *)sp);
    xLim[0] = xFalse_data[0] * rnddraw;
    xLim[1] = yFalse_data[0];
    loop_ub = i1 - i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        detsOut_data[(i2 + 6 * (i + i1)) + 3] = xLim[i2 + (i1 << 1)];
      }
    }

    if (dets_size[1] + 1 > covmatsOut->size[2]) {
      i = 0;
      i1 = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1] + 1, 1, covmatsOut->size[2],
        &jg_emlrtBCI, (emlrtConstCTX)sp) - 1;
      i1 = emlrtDynamicBoundsCheckR2012b(covmatsOut->size[2], 1,
        covmatsOut->size[2], &ig_emlrtBCI, (emlrtConstCTX)sp);
    }

    R1_size[0] = 2;
    R1_size[1] = 2;
    R1_size[2] = i1 - i;
    emlrtSubAssignSizeCheckR2012b(&R1_size[0], 3, &iv1[0], 3, &v_emlrtECI, (void
      *)sp);
    loop_ub = i1 - i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        for (m = 0; m < 2; m++) {
          covmatsOut->vector.data[(m + 6 * i2) + 36 * (i + i1)] = R_data[(m +
            (i2 << 1)) + (i1 << 2)];
        }
      }
    }

    if (dets_size[1] + 1 > covmatsOut->size[2]) {
      i = 0;
      i1 = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1] + 1, 1, covmatsOut->size[2],
        &hg_emlrtBCI, (emlrtConstCTX)sp) - 1;
      i1 = emlrtDynamicBoundsCheckR2012b(covmatsOut->size[2], 1,
        covmatsOut->size[2], &gg_emlrtBCI, (emlrtConstCTX)sp);
    }

    R1_size[0] = 2;
    R1_size[1] = 2;
    R1_size[2] = i1 - i;
    emlrtSubAssignSizeCheckR2012b(&R1_size[0], 3, &iv1[0], 3, &u_emlrtECI, (void
      *)sp);
    loop_ub = i1 - i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        for (m = 0; m < 2; m++) {
          covmatsOut->vector.data[((m + 6 * (i2 + 3)) + 36 * (i + i1)) + 3] =
            Rv_data[(m + (i2 << 1)) + (i1 << 2)];
        }
      }
    }

    if (dets_size[1] + 1 > tgtIDsOut_size[1]) {
      i = 0;
      i1 = 0;
    } else {
      i = emlrtDynamicBoundsCheckR2012b(dets_size[1] + 1, 1, tgtIDsOut_size[1],
        &eg_emlrtBCI, (emlrtConstCTX)sp) - 1;
      i1 = emlrtDynamicBoundsCheckR2012b(tgtIDsOut_size[1], 1, tgtIDsOut_size[1],
        &dg_emlrtBCI, (emlrtConstCTX)sp);
    }

    emlrtSubAssignSizeCheck1dR2017a(i1 - i, 1, &s_emlrtECI, (emlrtConstCTX)sp);
    loop_ub = i1 - i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      tgtIDsOut_data[i + i1] = -1.0;
    }
  } else {
    detsOut_size[0] = 6;
    detsOut_size[1] = dets_size[1];
    loop_ub = 6 * dets_size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&detsOut_data[0], &dets_data[0], (uint32_T)loop_ub * sizeof(real_T));
    }

    array_real_T_3D_SetSize(covmatsOut, 6, 6, covmats->size[2]);
    loop_ub = 36 * covmats->size[2];
    for (i = 0; i < loop_ub; i++) {
      covmatsOut->vector.data[i] = covmats->vector.data[i];
    }

    tgtIDsOut_size[0] = 1;
    tgtIDsOut_size[1] = tgtIDs_size[1];
    if (tgtIDs_size[1] - 1 >= 0) {
      memcpy(&tgtIDsOut_data[0], &tgtIDs_data[0], (uint32_T)tgtIDs_size[1] *
             sizeof(real_T));
    }

    classIDsOut_size[0] = 1;
    classIDsOut_size[1] = classIDs_size[1];
    if (classIDs_size[1] - 1 >= 0) {
      memcpy(&classIDsOut_data[0], &classIDs_data[0], (uint32_T)classIDs_size[1]
             * sizeof(real_T));
    }
  }

  array_real_T_Destructor(&g_xyCoverageArea);
  array_real_T_Destructor(&f_xyCoverageArea);
  array_real_T_Destructor(&e_xyCoverageArea);
  array_real_T_Destructor(&d_xyCoverageArea);
  array_real_T_Destructor(&c_xyCoverageArea);
  array_real_T_Destructor(&b_xyCoverageArea);
  array_real_T_2D_Destructor(&xyCoverageArea);
}

static real_T c_minimum(const emlrtStack *sp, coder_array_real_T *x)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T ex;
  int32_T idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x->size[0] == 1) || (x->size[0] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x->size[0] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x->size[0];
  if (x->size[0] <= 2) {
    if (x->size[0] == 1) {
      ex = x->vector.data[0];
    } else if ((x->vector.data[0] > x->vector.data[x->size[0] - 1]) ||
               (muDoubleScalarIsNaN(x->vector.data[0]) && (!muDoubleScalarIsNaN
                 (x->vector.data[x->size[0] - 1])))) {
      ex = x->vector.data[x->size[0] - 1];
    } else {
      ex = x->vector.data[0];
    }
  } else {
    if (!muDoubleScalarIsNaN(x->vector.data[0])) {
      idx = 1;
    } else {
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x->vector.data[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (idx == 0) {
      ex = x->vector.data[0];
    } else {
      ex = x->vector.data[idx - 1];
      for (k = idx + 1; k <= last; k++) {
        if (ex > x->vector.data[k - 1]) {
          ex = x->vector.data[k - 1];
        }
      }
    }
  }

  return ex;
}

static real_T d_maximum(const emlrtStack *sp, coder_array_real_T *x)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  real_T ex;
  int32_T idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x->size[0] == 1) || (x->size[0] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x->size[0] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x->size[0];
  if (x->size[0] <= 2) {
    if (x->size[0] == 1) {
      ex = x->vector.data[0];
    } else if ((x->vector.data[0] < x->vector.data[x->size[0] - 1]) ||
               (muDoubleScalarIsNaN(x->vector.data[0]) && (!muDoubleScalarIsNaN
                 (x->vector.data[x->size[0] - 1])))) {
      ex = x->vector.data[x->size[0] - 1];
    } else {
      ex = x->vector.data[0];
    }
  } else {
    if (!muDoubleScalarIsNaN(x->vector.data[0])) {
      idx = 1;
    } else {
      idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x->vector.data[k - 1])) {
          idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (idx == 0) {
      ex = x->vector.data[0];
    } else {
      ex = x->vector.data[idx - 1];
      for (k = idx + 1; k <= last; k++) {
        if (ex < x->vector.data[k - 1]) {
          ex = x->vector.data[k - 1];
        }
      }
    }
  }

  return ex;
}

static boolean_T inpolygon(const emlrtStack *sp, real_T x, real_T y,
  coder_array_real_T *xv, coder_array_real_T *yv)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static const int32_T iv2[2] = { 1, 31 };

  static const int32_T iv3[2] = { 1, 31 };

  static char_T d_u[31] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'L',
    'o', 'o', 'p', 'D', 'e', 'f' };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  coder_array_int32_T first;
  coder_array_int32_T last;
  coder_array_real_T scale;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *m;
  int64_T sdq;
  real_T b_xv[2];
  real_T b_yv[2];
  real_T avxi;
  real_T avyi;
  real_T maxyv;
  real_T minyv;
  real_T xv1;
  real_T xv2;
  real_T yv1;
  real_T yv2;
  int32_T b_i;
  int32_T exitg2;
  int32_T exitg3;
  int32_T i;
  int32_T k;
  int32_T kfirst;
  int32_T nloops;
  int32_T nx;
  char_T c_u[31];
  char_T u[15];
  int8_T dquad;
  int8_T quad1;
  int8_T quad2;
  int8_T quadFirst;
  boolean_T exitg1;
  boolean_T in;
  boolean_T isnanxv;
  boolean_T isnanyv;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_xv[0] = (real_T)xv->size[0];
  b_xv[1] = 1.0;
  b_yv[0] = (real_T)yv->size[0];
  b_yv[1] = 1.0;
  if (!isequal(b_xv, b_yv)) {
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &jw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &jc_emlrtMCI),
           &jc_emlrtMCI), &jc_emlrtMCI);
  }

  in = false;
  array_real_T_Constructor(&scale);
  array_int32_T_Constructor(&first);
  array_int32_T_Constructor(&last);
  if (xv->size[0] == 0) {
  } else {
    st.site = &kr_emlrtRSI;
    nx = xv->size[0];
    nloops = -1;
    array_int32_T_SetSize(&first, xv->size[0]);
    kfirst = xv->size[0];
    for (i = 0; i < kfirst; i++) {
      first.vector.data[i] = 0;
    }

    array_int32_T_SetSize(&last, xv->size[0]);
    kfirst = xv->size[0];
    for (i = 0; i < kfirst; i++) {
      last.vector.data[i] = 0;
    }

    k = 1;
    b_st.site = &mr_emlrtRSI;
    skipNaNs(&b_st, &k, xv, yv, xv->size[0]);
    while (k <= nx) {
      nloops++;
      kfirst = k - 1;
      first.vector.data[nloops] = k;
      b_st.site = &nr_emlrtRSI;
      exitg1 = false;
      while ((!exitg1) && (k < nx)) {
        k++;
        isnanxv = muDoubleScalarIsNaN(xv->vector.data[k - 1]);
        isnanyv = muDoubleScalarIsNaN(yv->vector.data[k - 1]);
        if (isnanxv || isnanyv) {
          if ((int32_T)isnanxv != (int32_T)isnanyv) {
            for (i = 0; i < 31; i++) {
              c_u[i] = d_u[i];
            }

            d_y = NULL;
            m = emlrtCreateCharArray(2, &iv2[0]);
            emlrtInitCharArrayR2013a(&b_st, 31, m, &c_u[0]);
            emlrtAssign(&d_y, m);
            for (i = 0; i < 31; i++) {
              c_u[i] = d_u[i];
            }

            e_y = NULL;
            m = emlrtCreateCharArray(2, &iv3[0]);
            emlrtInitCharArrayR2013a(&b_st, 31, m, &c_u[0]);
            emlrtAssign(&e_y, m);
            c_st.site = &iw_emlrtRSI;
            error(&c_st, d_y, getString(&c_st, b_message(&c_st, e_y,
                    &lc_emlrtMCI), &lc_emlrtMCI), &lc_emlrtMCI);
          }

          k--;
          exitg1 = true;
        }
      }

      if ((xv->vector.data[k - 1] == xv->vector.data[kfirst]) &&
          (yv->vector.data[k - 1] == yv->vector.data[kfirst]) && (kfirst + 1 !=
           k)) {
        last.vector.data[nloops] = k - 1;
      } else {
        last.vector.data[nloops] = k;
      }

      k += 2;
      b_st.site = &or_emlrtRSI;
      skipNaNs(&b_st, &k, xv, yv, nx);
    }

    if (nloops + 1 == 0) {
    } else {
      st.site = &lr_emlrtRSI;
      xv1 = xv->vector.data[first.vector.data[0] - 1];
      yv1 = xv->vector.data[first.vector.data[0] - 1];
      minyv = yv->vector.data[first.vector.data[0] - 1];
      maxyv = yv->vector.data[first.vector.data[0] - 1];
      for (k = 0; k <= nloops; k++) {
        kfirst = first.vector.data[k];
        nx = last.vector.data[k];
        avxi = xv->vector.data[first.vector.data[k] - 1];
        avyi = xv->vector.data[first.vector.data[k] - 1];
        for (b_i = kfirst; b_i <= nx; b_i++) {
          if (avxi > xv->vector.data[b_i - 1]) {
            avxi = xv->vector.data[b_i - 1];
          }

          if (avyi < xv->vector.data[b_i - 1]) {
            avyi = xv->vector.data[b_i - 1];
          }
        }

        kfirst = first.vector.data[k];
        nx = last.vector.data[k];
        xv2 = yv->vector.data[first.vector.data[k] - 1];
        yv2 = yv->vector.data[first.vector.data[k] - 1];
        for (b_i = kfirst; b_i <= nx; b_i++) {
          if (xv2 > yv->vector.data[b_i - 1]) {
            xv2 = yv->vector.data[b_i - 1];
          }

          if (yv2 < yv->vector.data[b_i - 1]) {
            yv2 = yv->vector.data[b_i - 1];
          }
        }

        b_st.site = &pr_emlrtRSI;
        checkRange(&b_st, avxi, avyi, xv2, yv2);
        if (xv1 > avxi) {
          xv1 = avxi;
        }

        if (yv1 < avyi) {
          yv1 = avyi;
        }

        if (minyv > xv2) {
          minyv = xv2;
        }

        if (maxyv < yv2) {
          maxyv = yv2;
        }
      }

      array_real_T_SetSize(&scale, xv->size[0]);
      kfirst = xv->size[0];
      for (i = 0; i < kfirst; i++) {
        scale.vector.data[i] = 0.0;
      }

      for (nx = 0; nx <= nloops; nx++) {
        i = first.vector.data[nx];
        kfirst = last.vector.data[nx];
        for (b_i = i; b_i < kfirst; b_i++) {
          avxi = muDoubleScalarAbs(0.5 * (xv->vector.data[b_i - 1] +
            xv->vector.data[b_i]));
          avyi = muDoubleScalarAbs(0.5 * (yv->vector.data[b_i - 1] +
            yv->vector.data[b_i]));
          if ((avxi > 1.0) && (avyi > 1.0)) {
            avxi *= avyi;
          } else if ((avyi > avxi) || muDoubleScalarIsNaN(avxi)) {
            avxi = avyi;
          }

          scale.vector.data[b_i - 1] = avxi * 6.6613381477509392E-16;
        }

        avxi = muDoubleScalarAbs(0.5 * (xv->vector.data[last.vector.data[nx] - 1]
          + xv->vector.data[first.vector.data[nx] - 1]));
        avyi = muDoubleScalarAbs(0.5 * (yv->vector.data[last.vector.data[nx] - 1]
          + yv->vector.data[first.vector.data[nx] - 1]));
        if ((avxi > 1.0) && (avyi > 1.0)) {
          avxi *= avyi;
        } else if ((avyi > avxi) || muDoubleScalarIsNaN(avxi)) {
          avxi = avyi;
        }

        scale.vector.data[last.vector.data[nx] - 1] = avxi *
          6.6613381477509392E-16;
      }

      if ((x >= xv1) && (x <= yv1) && (y >= minyv) && (y <= maxyv)) {
        sdq = 0LL;
        k = 1;
        do {
          exitg3 = 0;
          if (k - 1 <= nloops) {
            avxi = xv->vector.data[first.vector.data[k - 1] - 1] - x;
            avyi = yv->vector.data[first.vector.data[k - 1] - 1] - y;
            if (avxi > 0.0) {
              if (avyi > 0.0) {
                quadFirst = 0;
              } else {
                quadFirst = 3;
              }
            } else if (avyi > 0.0) {
              quadFirst = 1;
            } else {
              quadFirst = 2;
            }

            xv2 = avxi;
            yv2 = avyi;
            quad2 = quadFirst;
            b_i = first.vector.data[k - 1];
            do {
              exitg2 = 0;
              if (b_i <= last.vector.data[k - 1] - 1) {
                xv1 = xv2;
                yv1 = yv2;
                xv2 = xv->vector.data[b_i] - x;
                yv2 = yv->vector.data[b_i] - y;
                quad1 = quad2;
                if (xv2 > 0.0) {
                  if (yv2 > 0.0) {
                    quad2 = 0;
                  } else {
                    quad2 = 3;
                  }
                } else if (yv2 > 0.0) {
                  quad2 = 1;
                } else {
                  quad2 = 2;
                }

                contrib(xv1, yv1, xv2, yv2, quad1, quad2, scale.vector.data[b_i
                        - 1], &dquad, &isnanxv);
                if (isnanxv) {
                  in = true;
                  exitg2 = 1;
                } else {
                  sdq += (int64_T)dquad;
                  b_i++;
                }
              } else {
                contrib(xv2, yv2, avxi, avyi, quad2, quadFirst,
                        scale.vector.data[last.vector.data[k - 1] - 1], &dquad,
                        &isnanxv);
                exitg2 = 2;
              }
            } while (exitg2 == 0);

            if (exitg2 == 1) {
              exitg3 = 1;
            } else if (isnanxv) {
              in = true;
              exitg3 = 1;
            } else {
              sdq += (int64_T)dquad;
              k++;
            }
          } else {
            in = (sdq != 0LL);
            exitg3 = 1;
          }
        } while (exitg3 == 0);
      }
    }
  }

  array_int32_T_Destructor(&last);
  array_int32_T_Destructor(&first);
  array_real_T_Destructor(&scale);
  return in;
}

static void checkRange(const emlrtStack *sp, real_T minxv, real_T maxxv, real_T
  minyv, real_T maxyv)
{
  emlrtStack st;
  real_T xrange;
  real_T yrange;
  st.prev = sp;
  st.tls = sp->tls;
  xrange = maxxv - minxv;
  yrange = maxyv - minyv;
  if ((xrange >= 1.0E-15) && (yrange >= 1.0E-15)) {
  } else {
    st.site = &qr_emlrtRSI;
    f_warning(&st);
  }

  if ((xrange <= 1.0E+150) && (yrange <= 1.0E+150)) {
  } else {
    st.site = &rr_emlrtRSI;
    g_warning(&st);
  }
}

static void f_warning(const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 35 };

  static char_T b_msgID[35] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'M', 'o', 'd', 'e', 'l', 'i', 'n', 'g',
    'W', 'o', 'r', 'l', 'd', 'L', 'o', 'w', 'e', 'r' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[35];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 35; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 35, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, feval(&st, b_y, c_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void g_warning(const emlrtStack *sp)
{
  static const int32_T iv[2] = { 1, 7 };

  static const int32_T iv1[2] = { 1, 7 };

  static const int32_T iv2[2] = { 1, 35 };

  static char_T b_msgID[35] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'M', 'o', 'd', 'e', 'l', 'i', 'n', 'g',
    'W', 'o', 'r', 'l', 'd', 'U', 'p', 'p', 'e', 'r' };

  static char_T b_u[7] = { 'w', 'a', 'r', 'n', 'i', 'n', 'g' };

  static char_T c_u[7] = { 'm', 'e', 's', 's', 'a', 'g', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T msgID[35];
  char_T u[7];
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 35; i++) {
    msgID[i] = b_msgID[i];
  }

  for (i = 0; i < 7; i++) {
    u[i] = b_u[i];
  }

  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&y, m);
  for (i = 0; i < 7; i++) {
    u[i] = c_u[i];
  }

  b_y = NULL;
  m = emlrtCreateCharArray(2, &iv1[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 7, m, &u[0]);
  emlrtAssign(&b_y, m);
  c_y = NULL;
  m = emlrtCreateCharArray(2, &iv2[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 35, m, &msgID[0]);
  emlrtAssign(&c_y, m);
  st.site = &sx_emlrtRSI;
  b_feval(&st, y, feval(&st, b_y, c_y, &v_emlrtMCI), &w_emlrtMCI);
}

static void contrib(real_T x1, real_T c_y1, real_T x2, real_T y2, int8_T quad1,
                    int8_T quad2, real_T scale, int8_T *diffQuad, boolean_T *onj)
{
  real_T cp;
  *onj = false;
  *diffQuad = (int8_T)(quad2 - quad1);
  cp = x1 * y2 - x2 * c_y1;
  if (muDoubleScalarAbs(cp) < scale) {
    *onj = (x1 * x2 + c_y1 * y2 <= 0.0);
    if ((*diffQuad == 2) || (*diffQuad == -2)) {
      *diffQuad = 0;
    } else if (*diffQuad == -3) {
      *diffQuad = 1;
    } else if (*diffQuad == 3) {
      *diffQuad = -1;
    }
  } else if (cp < 0.0) {
    if (*diffQuad == 2) {
      *diffQuad = -2;
    } else if (*diffQuad == -3) {
      *diffQuad = 1;
    } else if (*diffQuad == 3) {
      *diffQuad = -1;
    }
  } else if (*diffQuad == -2) {
    *diffQuad = 2;
  } else if (*diffQuad == -3) {
    *diffQuad = 1;
  } else if (*diffQuad == 3) {
    *diffQuad = -1;
  }
}

static real_T c_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                     emlrtStack *sp)
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tm_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &um_emlrtRSI;
  c_st.site = &vm_emlrtRSI;
  return eml_rand_mt19937ar(&c_st, moduleInstance->state);
}

static void b_monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T vehiclePoints[2],
  real_T imagePoints[2])
{
  __m128d r;
  emlrtStack b_st;
  emlrtStack st;
  real_T self_T[9];
  real_T X[3];
  real_T b_vehiclePoints[3];
  real_T b_X;
  int32_T i;
  int32_T i1;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &nd_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &od_emlrtRSI;
  monoCamera_tformToImage(&b_st, this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, self_T);
  for (i = 0; i < 2; i++) {
    b_vehiclePoints[i] = vehiclePoints[i];
  }

  b_vehiclePoints[2] = 1.0;
  for (i = 0; i < 3; i++) {
    X[i] = 0.0;
    for (i1 = 0; i1 < 3; i1++) {
      X[i] += b_vehiclePoints[i1] * self_T[i1 + 3 * i];
    }
  }

  b_X = X[2];
  for (i = 0; i <= 0; i += 2) {
    r = _mm_loadu_pd(&X[0]);
    r = _mm_div_pd(r, _mm_set1_pd(b_X));
    _mm_storeu_pd(&imagePoints[0], r);
    _mm_storeu_pd(&X[0], r);
  }
}

static real_T visionDetectionGenerator_distFromHorizon(visionDetectionGenerator *
  obj, real_T uvPt[2])
{
  __m128d r;
  __m128d r1;
  real_T horzLine[3];
  real_T b_rHorz[2];
  real_T rHorz[2];
  real_T vHorz[2];
  real_T b_vHorz;
  real_T c_rHorz;
  real_T d;
  real_T d_rHorz;
  int32_T i;
  for (i = 0; i < 3; i++) {
    horzLine[i] = obj->pHorizonLine[i];
  }

  b_rHorz[0] = 1.0;
  b_rHorz[1] = horzLine[0] * (1.0 - horzLine[1]) + horzLine[2];
  for (i = 0; i <= 0; i += 2) {
    r = _mm_loadu_pd(&b_rHorz[0]);
    r1 = _mm_loadu_pd(&horzLine[1]);
    _mm_storeu_pd(&vHorz[0], _mm_sub_pd(r, r1));
    _mm_storeu_pd(&rHorz[0], r1);
  }

  d = c_norm(vHorz);
  c_rHorz = 0.0;
  for (i = 0; i < 2; i++) {
    b_vHorz = vHorz[i] / d;
    d_rHorz = uvPt[i] - rHorz[i];
    c_rHorz += d_rHorz * b_vHorz;
    vHorz[i] = b_vHorz;
    rHorz[i] = d_rHorz;
  }

  for (i = 0; i <= 0; i += 2) {
    r = _mm_loadu_pd(&vHorz[0]);
    r1 = _mm_loadu_pd(&rHorz[0]);
    _mm_storeu_pd(&b_rHorz[0], _mm_sub_pd(r1, _mm_mul_pd(_mm_set1_pd(c_rHorz), r)));
  }

  return c_norm(b_rHorz);
}

static void c_monoCamera_vehicleToImage(const emlrtStack *sp, cameraIntrinsics
  *this_Intrinsics, real_T this_Height, real_T this_Pitch, real_T this_Yaw,
  real_T this_Roll, real_T this_SensorLocation[2], real_T vehiclePoints_data[],
  real_T imagePoints_data[], int32_T imagePoints_size[2])
{
  __m128d r;
  __m128d r1;
  emlrtStack b_st;
  emlrtStack st;
  real_T X_data[318];
  real_T b_U_data[318];
  real_T b_y_data[212];
  real_T varargout_1_data[212];
  real_T b_X_data[106];
  real_T self_T[9];
  int32_T U_size[2];
  int32_T X_size[2];
  int32_T varargout_1_size[2];
  int32_T b_X_size[1];
  int32_T i;
  int32_T loop_ub;
  int32_T scalarLB;
  int32_T vectorUB;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  st.site = &nd_emlrtRSI;
  b_st.site = &od_emlrtRSI;
  monoCamera_tformToImage(&b_st, this_Intrinsics, this_Height, this_Pitch,
    this_Yaw, this_Roll, this_SensorLocation, self_T);
  U_size[0] = 1;
  U_size[1] = 3;
  for (i = 0; i < 2; i++) {
    b_U_data[i] = vehiclePoints_data[i];
  }

  for (i = 0; i < 1; i++) {
    for (vectorUB = 0; vectorUB < 1; vectorUB++) {
      b_U_data[2] = 1.0;
    }
  }

  st.site = &yd_emlrtRSI;
  dynamic_size_checks(&st, U_size, 3);
  st.site = &md_emlrtRSI;
  e_mtimes(b_U_data, U_size, self_T, X_data, X_size);
  if (X_size[0] == 0) {
    varargout_1_size[0] = 0;
  } else {
    varargout_1_size[0] = X_size[0];
    varargout_1_size[1] = 2;
    for (i = 0; i < 2; i++) {
      loop_ub = X_size[0];
      for (vectorUB = 0; vectorUB < loop_ub; vectorUB++) {
        varargout_1_data[vectorUB + varargout_1_size[0] * i] = X_data[vectorUB +
          X_size[0] * i];
      }
    }

    b_X_size[0] = X_size[0];
    loop_ub = X_size[0];
    for (i = 0; i < loop_ub; i++) {
      b_X_data[i] = X_data[i + (X_size[0] << 1)];
    }

    st.site = &xd_emlrtRSI;
    repmat(b_X_data, b_X_size, b_y_data, U_size);
    st.site = &rd_emlrtRSI;
    b_assertCompatibleDims(&st, varargout_1_size, U_size);
    if (X_size[0] == U_size[0]) {
      loop_ub = (X_size[0] << 1) - 1;
      varargout_1_size[1] = 2;
      scalarLB = (loop_ub + 1) / 2 * 2;
      vectorUB = scalarLB - 2;
      for (i = 0; i <= vectorUB; i += 2) {
        r = _mm_loadu_pd(&varargout_1_data[i]);
        r1 = _mm_loadu_pd(&b_y_data[i]);
        _mm_storeu_pd(&varargout_1_data[i], _mm_div_pd(r, r1));
      }

      for (i = scalarLB; i <= loop_ub; i++) {
        varargout_1_data[i] /= b_y_data[i];
      }
    } else {
      rdivide(varargout_1_data, varargout_1_size, b_y_data, U_size);
    }

    U_size[0] = X_size[0];
    U_size[1] = 2;
    emlrtSubAssignSizeCheckR2012b(&U_size[0], 2, &varargout_1_size[0], 2,
      &d_emlrtECI, (void *)sp);
    scalarLB = X_size[0];
    for (i = 0; i < 2; i++) {
      for (vectorUB = 0; vectorUB < scalarLB; vectorUB++) {
        X_data[vectorUB + X_size[0] * i] = varargout_1_data[vectorUB +
          varargout_1_size[0] * i];
      }
    }

    varargout_1_size[0] = X_size[0];
    for (i = 0; i < 2; i++) {
      loop_ub = X_size[0];
      for (vectorUB = 0; vectorUB < loop_ub; vectorUB++) {
        varargout_1_data[vectorUB + varargout_1_size[0] * i] = X_data[vectorUB +
          X_size[0] * i];
      }
    }
  }

  imagePoints_size[0] = varargout_1_size[0];
  imagePoints_size[1] = 2;
  for (i = 0; i < 2; i++) {
    imagePoints_data[i] = varargout_1_data[i];
  }
}

static void b_visionDetectionGenerator_imag2cam(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T b_U_data[], real_T X_data[], int32_T
  X_size[2], real_T R_data[], int32_T R_size[3])
{
  emlrtStack st;
  real_T a_data[318];
  real_T b_y_data[318];
  real_T c_tmp_data[300];
  real_T b_z_data[100];
  real_T z_data[100];
  real_T M[9];
  real_T b_obj[2];
  real_T c_y_data[1];
  real_T cxx_data[1];
  real_T d_tmp_data[1];
  real_T dxdu_data[1];
  real_T dxdv_data[1];
  real_T dydu_data[1];
  real_T dydv_data[1];
  real_T zp_data[1];
  int32_T U_size[2];
  int32_T a_size[2];
  int32_T tmp_size[2];
  int32_T b_y_size[1];
  int32_T c_y_size[1];
  int32_T y_size[1];
  int32_T z_size[1];
  int32_T zp_size[1];
  int32_T i;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 2; i++) {
    b_obj[i] = obj->pMonoCameraInSensorFrame.SensorLocation[i];
  }

  st.site = &an_emlrtRSI;
  monoCamera_get_ImageToVehicleTransform(&st,
    obj->pMonoCameraInSensorFrame.Intrinsics,
    obj->pMonoCameraInSensorFrame.Height, obj->pMonoCameraInSensorFrame.Pitch,
    obj->pMonoCameraInSensorFrame.Yaw, obj->pMonoCameraInSensorFrame.Roll, b_obj,
    M);
  U_size[0] = 1;
  U_size[1] = 2;
  for (loop_ub = 0; loop_ub < 2; loop_ub++) {
    b_obj[loop_ub] = b_U_data[loop_ub];
  }

  st.site = &ur_emlrtRSI;
  c_padarray(&st, b_obj, U_size, c_tmp_data, tmp_size);
  a_size[0] = tmp_size[0];
  a_size[1] = 3;
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&a_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  st.site = &yd_emlrtRSI;
  dynamic_size_checks(&st, a_size, 3);
  st.site = &md_emlrtRSI;
  e_mtimes(a_data, a_size, M, b_y_data, U_size);
  zp_size[0] = 1;
  zp_data[0] = b_y_data[U_size[0] << 1];
  y_size[0] = 1;
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, y_size, zp_size);
  z_data[0] = b_y_data[0] / b_y_data[U_size[0] << 1];
  b_y_size[0] = 1;
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, b_y_size, zp_size);
  b_z_data[0] = b_y_data[U_size[0]] / b_y_data[U_size[0] << 1];
  for (loop_ub = 0; loop_ub < 1; loop_ub++) {
    b_obj[0] = z_data[0];
  }

  for (loop_ub = 0; loop_ub < 1; loop_ub++) {
    b_obj[1] = b_z_data[0];
  }

  X_size[0] = 2;
  X_size[1] = 1;
  for (loop_ub = 0; loop_ub < 2; loop_ub++) {
    X_data[loop_ub] = b_obj[loop_ub];
  }

  c_y_size[0] = 1;
  c_y_data[0] = b_y_data[0] * M[6];
  st.site = &vr_emlrtRSI;
  d_power(zp_data, d_tmp_data, y_size);
  z_size[0] = 1;
  z_data[0] = d_tmp_data[0];
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, c_y_size, z_size);
  dxdu_data[0] = M[0] / b_y_data[U_size[0] << 1] - c_y_data[0] / z_data[0];
  c_y_size[0] = 1;
  c_y_data[0] = b_y_data[0] * M[7];
  st.site = &wr_emlrtRSI;
  d_power(zp_data, d_tmp_data, y_size);
  z_size[0] = 1;
  z_data[0] = d_tmp_data[0];
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, c_y_size, z_size);
  dxdv_data[0] = M[1] / b_y_data[U_size[0] << 1] - c_y_data[0] / z_data[0];
  d_tmp_data[0] = 1.4433756729740645 * dxdu_data[0];
  st.site = &xr_emlrtRSI;
  d_power(d_tmp_data, cxx_data, y_size);
  c_y_data[0] = 1.4433756729740645 * dxdv_data[0];
  st.site = &xr_emlrtRSI;
  d_power(c_y_data, d_tmp_data, y_size);
  cxx_data[0] += d_tmp_data[0];
  c_y_size[0] = 1;
  c_y_data[0] = M[6] * b_y_data[U_size[0]];
  st.site = &yr_emlrtRSI;
  d_power(zp_data, d_tmp_data, y_size);
  z_size[0] = 1;
  z_data[0] = d_tmp_data[0];
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, c_y_size, z_size);
  dydu_data[0] = M[3] / b_y_data[U_size[0] << 1] - c_y_data[0] / z_data[0];
  c_y_size[0] = 1;
  c_y_data[0] = M[7] * b_y_data[U_size[0]];
  st.site = &as_emlrtRSI;
  d_power(zp_data, d_tmp_data, y_size);
  z_size[0] = 1;
  z_data[0] = d_tmp_data[0];
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, c_y_size, z_size);
  dydv_data[0] = M[4] / b_y_data[U_size[0] << 1] - c_y_data[0] / z_data[0];
  d_tmp_data[0] = 1.4433756729740645 * dydu_data[0];
  st.site = &bs_emlrtRSI;
  d_power(d_tmp_data, zp_data, zp_size);
  c_y_data[0] = 1.4433756729740645 * dydv_data[0];
  st.site = &bs_emlrtRSI;
  d_power(c_y_data, d_tmp_data, y_size);
  zp_data[0] += d_tmp_data[0];
  dxdu_data[0] = dxdu_data[0] * dydu_data[0] * 2.0833333333333339 + dxdv_data[0]
    * dydv_data[0] * 2.0833333333333339;
  R_size[0] = 2;
  R_size[1] = 2;
  R_size[2] = 1;
  for (loop_ub = 0; loop_ub < 1; loop_ub++) {
    R_data[0] = cxx_data[0];
    R_data[2] = dxdu_data[0];
    R_data[1] = dxdu_data[0];
    R_data[3] = zp_data[0];
  }
}

static void c_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T b_data[], int32_T b_size[2])
{
  coder_array_real_T_2D r;
  emlrtStack st;
  real_T varargin_1[2];
  int32_T b_i;
  int32_T i;
  int32_T j;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  if (varargin_1_size[0] == 0) {
    varargin_1[0] = 0.0;
    varargin_1[1] = 3.0;
    array_real_T_2D_Constructor(&r);
    st.site = &cm_emlrtRSI;
    c_repmat(&st, varargin_1, &r);
    b_size[0] = r.size[0];
    b_size[1] = r.size[1];
    loop_ub = r.size[0] * r.size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&b_data[0], &r.vector.data[0], (uint32_T)loop_ub * sizeof(real_T));
    }

    array_real_T_2D_Destructor(&r);
  } else {
    b_size[0] = (int8_T)varargin_1_size[0];
    b_size[1] = 3;
    for (j = 0; j < 1; j++) {
      loop_ub = b_size[0];
      for (i = 0; i < loop_ub; i++) {
        b_data[(emlrtDynamicBoundsCheckR2012b(i + 1, 1, b_size[0], &ff_emlrtBCI,
                 (emlrtConstCTX)sp) + (b_size[0] << 1)) - 1] = 1.0;
      }
    }

    for (j = 0; j < 2; j++) {
      loop_ub = varargin_1_size[0];
      b_i = b_size[0];
      for (i = loop_ub + 1; i <= b_i; i++) {
        b_data[(emlrtDynamicBoundsCheckR2012b(i, 1, b_size[0], &gf_emlrtBCI,
                 (emlrtConstCTX)sp) + b_size[0] * j) - 1] = 1.0;
      }
    }

    for (j = 0; j < 2; j++) {
      loop_ub = varargin_1_size[0];
      for (i = 0; i < loop_ub; i++) {
        b_data[(emlrtDynamicBoundsCheckR2012b(i + 1, 1, b_size[0], &if_emlrtBCI,
                 (emlrtConstCTX)sp) + b_size[0] * j) - 1] = varargin_1_data
          [(emlrtDynamicBoundsCheckR2012b(i + 1, 1, varargin_1_size[0],
             &hf_emlrtBCI, (emlrtConstCTX)sp) + varargin_1_size[0] * j) - 1];
      }
    }
  }
}

static void c_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[1],
  int32_T y_size[1])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 's', 'i', 'z',
    'e', 'D', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', 's', 'M', 'u', 's', 't',
    'M', 'a', 't', 'c', 'h' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[30];
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] == 1) || (y_size[0] == 1) || (x_size[0] == y_size[0])) {
  } else {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &kw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &q_emlrtMCI), &q_emlrtMCI),
          &q_emlrtMCI);
  }
}

static void d_power(real_T a_data[], real_T b_y_data[], int32_T y_size[1])
{
  y_size[0] = 1;
  b_y_data[0] = d_function_handle_parenReference(a_data[0]);
}

static real_T d_function_handle_parenReference(real_T varargin_1)
{
  return varargin_1 * varargin_1;
}

static void b_visionDetectionGenerator_kalmanFilterModel(const emlrtStack *sp,
  real_T R1_data[], real_T R_data[], int32_T R_size[3], real_T Rv_data[],
  int32_T Rv_size[3])
{
  static real_T b_dv[16] = { 1.0, 0.0, 0.0, 0.0, 0.05, 1.0, 0.0, 0.0, 0.0, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.05, 1.0 };

  static real_T dv1[16] = { 3.9062500000000008E-5, 0.0015625000000000003, 0.0,
    0.0, 0.0015625000000000003, 0.062500000000000014, 0.0, 0.0, 0.0, 0.0,
    3.9062500000000008E-5, 0.0015625000000000003, 0.0, 0.0,
    0.0015625000000000003, 0.062500000000000014 };

  static real_T dv2[8] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 };

  emlrtStack st;
  real_T Ps[16];
  real_T a__16[16];
  int32_T i;
  int32_T i1;
  int32_T m;
  st.prev = sp;
  st.tls = sp->tls;
  R_size[0] = 2;
  R_size[1] = 2;
  R_size[2] = 1;
  Rv_size[0] = 2;
  Rv_size[1] = 2;
  Rv_size[2] = 1;
  for (m = 0; m < 1; m++) {
    st.site = &fn_emlrtRSI;
    AbstractDetectionGenerator_steadyStateKalmanCovariance(&st, b_dv, dv1, dv2,
      &R1_data[0], a__16, Ps);
    for (i = 0; i < 2; i++) {
      for (i1 = 0; i1 < 2; i1++) {
        R_data[i1 + (i << 1)] = Ps[(i1 << 1) + (i << 3)];
        Rv_data[i1 + (i << 1)] = Ps[((i1 << 1) + (((i << 1) + 1) << 2)) + 1];
      }
    }
  }
}

static void AbstractDetectionGenerator_rand(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance, const emlrtStack *sp, visionDetectionGenerator *obj, real_T
  val_data[], int32_T val_size[1])
{
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;
  if (obj->pUseRandSeed) {
    st.site = &sr_emlrtRSI;
    d_rand(moduleInstance, &st, val_data, val_size);
  } else {
    st.site = &tr_emlrtRSI;
    d_rand(moduleInstance, &st, val_data, val_size);
  }
}

static void d_rand(InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const
                   emlrtStack *sp, real_T r_data[], int32_T r_size[1])
{
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  real_T d;
  int32_T k;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tm_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &um_emlrtRSI;
  r_size[0] = 1;
  for (k = 0; k < 1; k++) {
    c_st.site = &vm_emlrtRSI;
    d = eml_rand_mt19937ar(&c_st, moduleInstance->state);
    r_data[0] = d;
  }
}

static void sort(real_T x_data[], int32_T x_size[2], real_T b_x_data[], int32_T
                 b_x_size[2], int32_T idx_data[], int32_T idx_size[2])
{
  real_T c_x_data[500];
  int32_T b_idx_data[500];
  int32_T b_idx_size[2];
  int32_T c_x_size[2];
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  if (x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)x_size[1] * sizeof(real_T));
  }

  b_sortIdx(b_x_data, b_x_size, b_idx_data, b_idx_size, c_x_data, c_x_size);
  idx_size[0] = 1;
  idx_size[1] = b_idx_size[1];
  if (b_idx_size[1] - 1 >= 0) {
    memcpy(&idx_data[0], &b_idx_data[0], (uint32_T)b_idx_size[1] * sizeof
           (int32_T));
  }

  b_x_size[0] = 1;
  b_x_size[1] = c_x_size[1];
  if (c_x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &c_x_data[0], (uint32_T)c_x_size[1] * sizeof(real_T));
  }
}

static void b_sortIdx(real_T x_data[], int32_T x_size[2], int32_T idx_data[],
                      int32_T idx_size[2], real_T b_x_data[], int32_T b_x_size[2])
{
  real_T c_x_data[500];
  real_T d_x_data[500];
  real_T xwork_data[500];
  real_T x4[4];
  int32_T b_idx_data[500];
  int32_T iwork_data[500];
  int32_T perm[4];
  int32_T b_idx_size[2];
  int32_T c_x_size[2];
  int32_T b_i;
  int32_T i;
  int32_T i2;
  int32_T i3;
  int32_T i4;
  int32_T ib;
  int32_T k;
  int32_T n;
  int32_T nNaNs;
  int16_T idx4[4];
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  i = x_size[1];
  idx_size[0] = 1;
  idx_size[1] = x_size[1];
  for (b_i = 0; b_i < i; b_i++) {
    b_x_data[b_i] = x_data[b_i];
    idx_data[b_i] = 0;
  }

  if (x_size[1] != 0) {
    i = x_size[1];
    for (b_i = 0; b_i < i; b_i++) {
      c_x_data[b_i] = b_x_data[b_i];
      idx_data[b_i] = 0;
    }

    n = x_size[1];
    for (i = 0; i < 4; i++) {
      x4[i] = 0.0;
      idx4[i] = 0;
    }

    nNaNs = 0;
    ib = 0;
    b_i = x_size[1];
    for (k = 0; k < b_i; k++) {
      if (muDoubleScalarIsNaN(c_x_data[k])) {
        idx_data[(n - nNaNs) - 1] = k + 1;
        xwork_data[(n - nNaNs) - 1] = c_x_data[k];
        nNaNs++;
      } else {
        ib++;
        idx4[ib - 1] = (int16_T)(k + 1);
        x4[ib - 1] = c_x_data[k];
        if (ib == 4) {
          i = k - nNaNs;
          if (x4[0] <= x4[1]) {
            ib = 1;
            i2 = 2;
          } else {
            ib = 2;
            i2 = 1;
          }

          if (x4[2] <= x4[3]) {
            i3 = 3;
            i4 = 4;
          } else {
            i3 = 4;
            i4 = 3;
          }

          if (x4[ib - 1] <= x4[i3 - 1]) {
            if (x4[i2 - 1] <= x4[i3 - 1]) {
              perm[0] = ib;
              perm[1] = i2;
              perm[2] = i3;
              perm[3] = i4;
            } else if (x4[i2 - 1] <= x4[i4 - 1]) {
              perm[0] = ib;
              perm[1] = i3;
              perm[2] = i2;
              perm[3] = i4;
            } else {
              perm[0] = ib;
              perm[1] = i3;
              perm[2] = i4;
              perm[3] = i2;
            }
          } else if (x4[ib - 1] <= x4[i4 - 1]) {
            if (x4[i2 - 1] <= x4[i4 - 1]) {
              perm[0] = i3;
              perm[1] = ib;
              perm[2] = i2;
              perm[3] = i4;
            } else {
              perm[0] = i3;
              perm[1] = ib;
              perm[2] = i4;
              perm[3] = i2;
            }
          } else {
            perm[0] = i3;
            perm[1] = i4;
            perm[2] = ib;
            perm[3] = i2;
          }

          idx_data[i - 3] = idx4[perm[0] - 1];
          idx_data[i - 2] = idx4[perm[1] - 1];
          idx_data[i - 1] = idx4[perm[2] - 1];
          idx_data[i] = idx4[perm[3] - 1];
          c_x_data[i - 3] = x4[perm[0] - 1];
          c_x_data[i - 2] = x4[perm[1] - 1];
          c_x_data[i - 1] = x4[perm[2] - 1];
          c_x_data[i] = x4[perm[3] - 1];
          ib = 0;
        }
      }
    }

    i2 = (x_size[1] - nNaNs) - 1;
    if (ib > 0) {
      for (i = 0; i < 4; i++) {
        perm[i] = 0;
      }

      if (ib == 1) {
        perm[0] = 1;
      } else if (ib == 2) {
        if (x4[0] <= x4[1]) {
          perm[0] = 1;
          perm[1] = 2;
        } else {
          perm[0] = 2;
          perm[1] = 1;
        }
      } else if (x4[0] <= x4[1]) {
        if (x4[1] <= x4[2]) {
          perm[0] = 1;
          perm[1] = 2;
          perm[2] = 3;
        } else if (x4[0] <= x4[2]) {
          perm[0] = 1;
          perm[1] = 3;
          perm[2] = 2;
        } else {
          perm[0] = 3;
          perm[1] = 1;
          perm[2] = 2;
        }
      } else if (x4[0] <= x4[2]) {
        perm[0] = 2;
        perm[1] = 1;
        perm[2] = 3;
      } else if (x4[1] <= x4[2]) {
        perm[0] = 2;
        perm[1] = 3;
        perm[2] = 1;
      } else {
        perm[0] = 3;
        perm[1] = 2;
        perm[2] = 1;
      }

      b_i = (uint8_T)ib;
      for (k = 0; k < b_i; k++) {
        i = perm[k];
        idx_data[((i2 - ib) + k) + 1] = idx4[i - 1];
        c_x_data[((i2 - ib) + k) + 1] = x4[i - 1];
      }
    }

    ib = nNaNs >> 1;
    for (k = 0; k < ib; k++) {
      i = (int16_T)idx_data[(i2 + k) + 1];
      idx_data[(i2 + k) + 1] = (int16_T)idx_data[(n - k) - 1];
      idx_data[(n - k) - 1] = i;
      c_x_data[(i2 + k) + 1] = xwork_data[(n - k) - 1];
      c_x_data[(n - k) - 1] = xwork_data[(i2 + k) + 1];
    }

    if (((uint32_T)nNaNs & 1U) != 0U) {
      c_x_data[(i2 + ib) + 1] = xwork_data[(i2 + ib) + 1];
    }

    b_idx_size[0] = 1;
    b_idx_size[1] = x_size[1];
    i = x_size[1];
    c_x_size[0] = 1;
    c_x_size[1] = x_size[1];
    for (b_i = 0; b_i < i; b_i++) {
      b_idx_data[b_i] = idx_data[b_i];
      d_x_data[b_i] = c_x_data[b_i];
      iwork_data[b_i] = 0;
    }

    ib = x_size[1] - nNaNs;
    i = 2;
    if (ib > 1) {
      if ((x_size[1] >= 256) && ((ib >> 8) > 0)) {
        for (i = 0; i < 1; i++) {
          merge_pow2_block(b_idx_data, b_idx_size, d_x_data, c_x_size, 0,
                           idx_data, idx_size, c_x_data, b_x_size);
          b_idx_size[0] = 1;
          b_idx_size[1] = idx_size[1];
          if (idx_size[1] - 1 >= 0) {
            memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof
                   (int32_T));
          }

          c_x_size[0] = 1;
          c_x_size[1] = b_x_size[1];
          if (b_x_size[1] - 1 >= 0) {
            memcpy(&d_x_data[0], &c_x_data[0], (uint32_T)b_x_size[1] * sizeof
                   (real_T));
          }
        }

        if (ib - 256 > 0) {
          i = x_size[1];
          for (b_i = 0; b_i < i; b_i++) {
            iwork_data[b_i] = 0;
          }

          b_merge_block(b_idx_data, b_idx_size, d_x_data, c_x_size, 256, ib -
                        256, 2, iwork_data, xwork_data, idx_data, idx_size,
                        b_x_data, b_x_size);
          b_idx_size[0] = 1;
          b_idx_size[1] = idx_size[1];
          if (idx_size[1] - 1 >= 0) {
            memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof
                   (int32_T));
          }

          c_x_size[0] = 1;
          c_x_size[1] = b_x_size[1];
          if (b_x_size[1] - 1 >= 0) {
            memcpy(&d_x_data[0], &b_x_data[0], (uint32_T)b_x_size[1] * sizeof
                   (real_T));
          }
        }

        i = 8;
      }

      b_merge_block(b_idx_data, b_idx_size, d_x_data, c_x_size, 0, ib, i,
                    iwork_data, xwork_data, idx_data, idx_size, b_x_data,
                    b_x_size);
      b_idx_size[1] = idx_size[1];
      if (idx_size[1] - 1 >= 0) {
        memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof
               (int32_T));
      }

      c_x_size[1] = b_x_size[1];
      if (b_x_size[1] - 1 >= 0) {
        memcpy(&d_x_data[0], &b_x_data[0], (uint32_T)b_x_size[1] * sizeof(real_T));
      }
    }

    idx_size[0] = 1;
    idx_size[1] = b_idx_size[1];
    if (b_idx_size[1] - 1 >= 0) {
      memcpy(&idx_data[0], &b_idx_data[0], (uint32_T)b_idx_size[1] * sizeof
             (int32_T));
    }

    b_x_size[0] = 1;
    b_x_size[1] = c_x_size[1];
    if (c_x_size[1] - 1 >= 0) {
      memcpy(&b_x_data[0], &d_x_data[0], (uint32_T)c_x_size[1] * sizeof(real_T));
    }
  }
}

static void merge_pow2_block(int32_T idx_data[], int32_T idx_size[2], real_T
  x_data[], int32_T x_size[2], int32_T offset, int32_T b_idx_data[], int32_T
  b_idx_size[2], real_T b_x_data[], int32_T b_x_size[2])
{
  real_T xwork[256];
  int32_T iwork[256];
  int32_T b;
  int32_T bLen;
  int32_T bLen2;
  int32_T blockOffset;
  int32_T exitg1;
  int32_T i;
  int32_T j;
  int32_T k;
  int32_T p;
  int32_T q;
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  if (x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)x_size[1] * sizeof(real_T));
  }

  b_idx_size[0] = 1;
  b_idx_size[1] = idx_size[1];
  if (idx_size[1] - 1 >= 0) {
    memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof(int32_T));
  }

  for (b = 0; b < 6; b++) {
    bLen = 1 << (b + 2);
    bLen2 = bLen << 1;
    i = 256 >> (b + 3);
    for (k = 0; k < i; k++) {
      blockOffset = (offset + k * bLen2) - 1;
      for (j = 0; j < bLen2; j++) {
        iwork[j] = b_idx_data[(blockOffset + j) + 1];
        xwork[j] = b_x_data[(blockOffset + j) + 1];
      }

      p = 0;
      q = bLen;
      do {
        exitg1 = 0;
        blockOffset++;
        if (xwork[p] <= xwork[q]) {
          b_idx_data[blockOffset] = iwork[p];
          b_x_data[blockOffset] = xwork[p];
          if (p + 1 < bLen) {
            p++;
          } else {
            exitg1 = 1;
          }
        } else {
          b_idx_data[blockOffset] = iwork[q];
          b_x_data[blockOffset] = xwork[q];
          if (q + 1 < bLen2) {
            q++;
          } else {
            q = blockOffset - p;
            for (j = p + 1; j <= bLen; j++) {
              b_idx_data[q + j] = iwork[j - 1];
              b_x_data[q + j] = xwork[j - 1];
            }

            exitg1 = 1;
          }
        }
      } while (exitg1 == 0);
    }
  }
}

static void visionDetectionGenerator_cameraToSensor(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T detCam_data[], int32_T detCam_size[2],
  real_T covCam_data[], int32_T covCam_size[3], real_T detSen_data[], int32_T
  detSen_size[2], real_T covSen_data[], int32_T covSen_size[3])
{
  emlrtStack st;
  monoCamera r;
  real_T b_y_data[6300];
  real_T c_tmp_data[300];
  real_T b_detCam_data[150];
  real_T b_Rcam2sen[36];
  real_T c_Rcam2sen[36];
  real_T Rcam2sen[9];
  real_T b_monoCamSen_SensorLocation[3];
  real_T monoCamSen_SensorLocation[2];
  real_T t133_SensorLocation[2];
  int32_T b_detCam_size[2];
  int32_T c_detCam_size[2];
  int32_T tmp_size[2];
  int32_T y_size[2];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T m;
  detSen_size[0] = 6;
  detSen_size[1] = detCam_size[1];
  loop_ub = 6 * detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    detSen_data[i] = 0.0;
  }

  r = obj->pMonoCameraInSensorFrame;
  for (i = 0; i < 2; i++) {
    t133_SensorLocation[i] = r.SensorLocation[i];
  }

  for (i = 0; i < 2; i++) {
    monoCamSen_SensorLocation[i] = t133_SensorLocation[i];
  }

  rotParentToChild(r.Roll, r.Pitch, r.Yaw, Rcam2sen);
  b_detCam_size[0] = 3;
  b_detCam_size[1] = detCam_size[1];
  loop_ub = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detCam_data[i1 + 3 * i] = detCam_data[i1 + 6 * i];
    }
  }

  for (i = 0; i < 2; i++) {
    b_monoCamSen_SensorLocation[i] = monoCamSen_SensorLocation[i];
  }

  b_monoCamSen_SensorLocation[2] = r.Height;
  u_bsxfun(b_detCam_data, b_detCam_size, b_monoCamSen_SensorLocation, c_tmp_data,
           tmp_size);
  st.site = &md_emlrtRSI;
  h_mtimes(Rcam2sen, c_tmp_data, tmp_size, b_y_data, y_size);
  b_detCam_size[0] = 3;
  b_detCam_size[1] = detCam_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detCam_size[0], 2, &y_size[0], 2,
    &bb_emlrtECI, (void *)sp);
  loop_ub = detCam_size[1];
  c_detCam_size[0] = 3;
  c_detCam_size[1] = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen_data[i1 + 6 * i] = b_y_data[i1 + 3 * i];
      b_detCam_data[i1 + 3 * i] = detCam_data[(i1 + 6 * i) + 3];
    }
  }

  st.site = &md_emlrtRSI;
  h_mtimes(Rcam2sen, b_detCam_data, c_detCam_size, b_y_data, y_size);
  b_detCam_size[0] = 3;
  b_detCam_size[1] = detCam_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detCam_size[0], 2, &y_size[0], 2,
    &cb_emlrtECI, (void *)sp);
  loop_ub = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen_data[(i1 + 6 * i) + 3] = b_y_data[i1 + 3 * i];
    }
  }

  for (i = 0; i < 36; i++) {
    b_Rcam2sen[i] = 0.0;
  }

  for (i = 0; i < 3; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_Rcam2sen[i1 + 6 * i] = Rcam2sen[i1 + 3 * i];
      b_Rcam2sen[(i1 + 6 * (i + 3)) + 3] = Rcam2sen[i1 + 3 * i];
    }
  }

  i = detCam_size[1];
  covSen_size[0] = 6;
  covSen_size[1] = 6;
  covSen_size[2] = detCam_size[1];
  for (m = 0; m < i; m++) {
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, covCam_size[2], &tg_emlrtBCI,
      (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        c_Rcam2sen[i1 + 6 * i2] = 0.0;
        for (i3 = 0; i3 < 6; i3++) {
          c_Rcam2sen[i1 + 6 * i2] += b_Rcam2sen[i1 + 6 * i3] * covCam_data[(i3 +
            6 * i2) + 36 * m];
        }
      }
    }

    loop_ub = emlrtDynamicBoundsCheckR2012b(m + 1, 1, covSen_size[2],
      &ug_emlrtBCI, (emlrtConstCTX)sp) - 1;
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        covSen_data[(i1 + 6 * i2) + 36 * loop_ub] = 0.0;
        for (i3 = 0; i3 < 6; i3++) {
          covSen_data[(i1 + 6 * i2) + 36 * loop_ub] += c_Rcam2sen[i1 + 6 * i3] *
            b_Rcam2sen[i2 + 6 * i3];
        }
      }
    }
  }
}

static void u_bsxfun(real_T a_data[], int32_T a_size[2], real_T b[3], real_T
                     c_data[], int32_T c_size[2])
{
  __m128d r;
  __m128d r1;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 3;
  c_size[1] = (int8_T)a_size[1];
  if ((int8_T)a_size[1] != 0) {
    c_size[0] = 3;
    acoef = (a_size[1] != 1);
    i = (int8_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 3;
        r = _mm_loadu_pd(&a_data[3 * ia]);
        r1 = _mm_loadu_pd(&b[0]);
        _mm_storeu_pd(&c_data[3 * k], _mm_sub_pd(r, r1));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_size[0] = 3;
        c_data[3 * k + 2] = a_data[3 * ia + 2] - b[2];
      }
    }
  }
}

static void AbstractDetectionGenerator_sensorToEgo(const emlrtStack *sp, real_T
  detCart_data[], int32_T detCart_size[2], real_T covCart_data[], int32_T
  covCart_size[3], real_T detEgo_data[], int32_T detEgo_size[2], real_T
  covEgo_data[], int32_T covEgo_size[3])
{
  static int8_T b_a[36] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };

  coder_array_real_T_2D c_detCart_data;
  coder_array_real_T_2D e_detCart_data;
  coder_array_real_T_2D y;
  emlrtStack st;
  real_T c_tmp_data[300];
  real_T b_detCart_data[150];
  real_T d_detCart_data[150];
  real_T posEgo_data[150];
  real_T a[36];
  int32_T posEgo_size[2];
  int32_T tmp_size[2];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T m;
  detEgo_size[0] = 6;
  detEgo_size[1] = detCart_size[1];
  loop_ub = 6 * detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    detEgo_data[i] = 0.0;
  }

  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detCart_data[i1 + 3 * i] = detCart_data[i1 + 6 * i];
    }
  }

  c_detCart_data.vector.data = &b_detCart_data[0];
  c_detCart_data.vector.numel = 3 * detCart_size[1];
  c_detCart_data.vector.allocated = c_detCart_data.vector.numel;
  c_detCart_data.vector.owner = false;
  c_detCart_data.size[0] = 3;
  c_detCart_data.size[1] = detCart_size[1];
  array_real_T_2D_Constructor(&y);
  st.site = &md_emlrtRSI;
  f_mtimes(&c_detCart_data, &y);
  array_real_T_2D_Reserve(&y, 300);
  v_bsxfun((real_T *)y.vector.data, y.size, c_tmp_data, tmp_size);
  array_real_T_2D_SetSize(&y, y.size[0], y.size[1]);
  posEgo_size[0] = 3;
  posEgo_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&posEgo_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  tmp_size[0] = 3;
  tmp_size[1] = detCart_size[1];
  emlrtSubAssignSizeCheckR2012b(&tmp_size[0], 2, &posEgo_size[0], 2,
    &db_emlrtECI, (void *)sp);
  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detEgo_data[i1 + 6 * i] = posEgo_data[i1 + 3 * i];
    }
  }

  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      d_detCart_data[i1 + 3 * i] = detCart_data[(i1 + 6 * i) + 3];
    }
  }

  e_detCart_data.vector.data = &d_detCart_data[0];
  e_detCart_data.vector.numel = 3 * detCart_size[1];
  e_detCart_data.vector.allocated = e_detCart_data.vector.numel;
  e_detCart_data.vector.owner = false;
  e_detCart_data.size[0] = 3;
  e_detCart_data.size[1] = detCart_size[1];
  st.site = &md_emlrtRSI;
  f_mtimes(&e_detCart_data, &y);
  tmp_size[0] = 3;
  tmp_size[1] = detCart_size[1];
  emlrtSubAssignSizeCheckR2012b(&tmp_size[0], 2, &y.size[0], 2, &eb_emlrtECI,
    (void *)sp);
  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detEgo_data[(i1 + 6 * i) + 3] = y.vector.data[i1 + 3 * i];
    }
  }

  array_real_T_2D_Destructor(&y);
  i = detCart_size[1];
  covEgo_size[0] = 6;
  covEgo_size[1] = 6;
  covEgo_size[2] = detCart_size[1];
  for (m = 0; m < i; m++) {
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, covCart_size[2], &vg_emlrtBCI,
      (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        a[i1 + 6 * i2] = 0.0;
        for (i3 = 0; i3 < 6; i3++) {
          a[i1 + 6 * i2] += (real_T)b_a[i1 + 6 * i3] * covCart_data[(i3 + 6 * i2)
            + 36 * m];
        }
      }
    }

    loop_ub = emlrtDynamicBoundsCheckR2012b(m + 1, 1, covEgo_size[2],
      &wg_emlrtBCI, (emlrtConstCTX)sp) - 1;
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        covEgo_data[(i1 + 6 * i2) + 36 * loop_ub] = 0.0;
        for (i3 = 0; i3 < 6; i3++) {
          covEgo_data[(i1 + 6 * i2) + 36 * loop_ub] += a[i1 + 6 * i3] * (real_T)
            b_a[i3 + 6 * i2];
        }
      }
    }
  }
}

static void v_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static real_T b_dv[3] = { 0.0, 0.0, 1.1 };

  __m128d r;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 3;
  c_size[1] = (int8_T)a_size[1];
  if ((int8_T)a_size[1] != 0) {
    c_size[0] = 3;
    acoef = (a_size[1] != 1);
    i = (int8_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 3;
        r = _mm_loadu_pd(&a_data[3 * ia]);
        _mm_storeu_pd(&c_data[3 * k], _mm_add_pd(r, _mm_loadu_pd(&b_dv[0])));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_size[0] = 3;
        c_data[3 * k + 2] = a_data[3 * ia + 2] + 1.1;
      }
    }
  }
}

static void visionDetectionGenerator_assembleDetections(const emlrtStack *sp,
  real_T b_time, real_T dets_data[], int32_T dets_size[2], real_T covmats_data[],
  int32_T covmats_size[3], real_T attribs_f2_data[], int32_T attribs_f2_size[2],
  real_T classIDs_data[], int32_T classIDs_size[2], objectDetection
  detections_data[], int32_T detections_size[1])
{
  static real_T b_varargin_4[36] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static real_T varargin_4[36] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const int32_T iv[2] = { 1, 37 };

  static const int32_T iv1[2] = { 1, 42 };

  static const int32_T iv10[2] = { 1, 46 };

  static const int32_T iv11[2] = { 1, 13 };

  static const int32_T iv12[2] = { 1, 51 };

  static const int32_T iv13[2] = { 1, 13 };

  static const int32_T iv14[2] = { 1, 13 };

  static const int32_T iv2[2] = { 1, 46 };

  static const int32_T iv3[2] = { 1, 51 };

  static const int32_T iv4[2] = { 1, 4 };

  static const int32_T iv5[2] = { 1, 4 };

  static const int32_T iv6[2] = { 1, 38 };

  static const int32_T iv7[2] = { 1, 37 };

  static const int32_T iv8[2] = { 1, 47 };

  static const int32_T iv9[2] = { 1, 42 };

  static char_T i_u[51] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'N', 'o', 'n', 'n', 'e', 'g', 'a', 't', 'i', 'v', 'e' };

  static char_T n_u[47] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T f_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T e_u[42] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'o', 'b', 'j',
    'e', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', ':', 'e', 'x',
    'p', 'e', 'c', 't', 'e', 'd', 'N', 'o', 'n', 'n', 'e', 'g', 'a', 't', 'i',
    'v', 'e' };

  static char_T l_u[38] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'o', 'b', 'j',
    'e', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', ':', 'e', 'x',
    'p', 'e', 'c', 't', 'e', 'd', 'I', 'n', 't', 'e', 'g', 'e', 'r' };

  static char_T b_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'o', 'b', 'j',
    'e', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', ':', 'e', 'x',
    'p', 'e', 'c', 't', 'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T p_u[13] = { 'O', 'b', 'j', 'e', 'c', 't', 'C', 'l', 'a', 's',
    's', 'I', 'D' };

  static char_T j_u[4] = { 'T', 'i', 'm', 'e' };

  static int8_T b_orient[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  BusVisionDetectionsMeasurementParameters measParams0;
  BusVisionDetectionsObjectAttributes r;
  BusVisionDetectionsObjectAttributes r1;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack e_st;
  emlrtStack f_st;
  emlrtStack g_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *g_y;
  const mxArray *h_y;
  const mxArray *i_y;
  const mxArray *j_y;
  const mxArray *k_y;
  const mxArray *l_y;
  const mxArray *m;
  const mxArray *m_y;
  const mxArray *n_y;
  const mxArray *o_y;
  const mxArray *y;
  objectDetection b_oneObjDet[1];
  objectDetection oneObjDet;
  real_T Pin[36];
  real_T R[36];
  int32_T b_i;
  int32_T b_m;
  int32_T i;
  int32_T i1;
  int32_T i2;
  char_T g_u[51];
  char_T m_u[47];
  char_T d_u[46];
  char_T c_u[42];
  char_T k_u[38];
  char_T u[37];
  char_T o_u[13];
  char_T h_u[4];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &sh_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  e_st.prev = &d_st;
  e_st.tls = d_st.tls;
  f_st.prev = &e_st;
  f_st.tls = e_st.tls;
  g_st.prev = &f_st;
  g_st.tls = f_st.tls;
  measParams0.Frame = drivingCoordinateFrameType_Rectangular;
  for (i = 0; i < 3; i++) {
    measParams0.OriginPosition[i] = 0.0;
  }

  for (i = 0; i < 9; i++) {
    measParams0.Orientation[i] = (real_T)b_orient[i];
  }

  measParams0.HasVelocity = true;
  b_st.site = &ds_emlrtRSI;
  c_st.site = &hs_emlrtRSI;
  emlrtDynamicBoundsCheckR2012b(1, 1, attribs_f2_size[1], &dh_emlrtBCI, &c_st);
  r.TargetIndex = attribs_f2_data[0];
  b_st.site = &uh_emlrtRSI;
  c_st.site = &vh_emlrtRSI;
  for (b_i = 0; b_i < 6; b_i++) {
    oneObjDet.Measurement[b_i] = 0.0;
  }

  d_st.site = &is_emlrtRSI;
  e_st.site = &js_emlrtRSI;
  f_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(b_time)) || (!!muDoubleScalarIsNaN(b_time))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 37; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&f_st, 37, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      d_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&f_st, 46, m, &d_u[0]);
    emlrtAssign(&c_y, m);
    for (i = 0; i < 4; i++) {
      h_u[i] = j_u[i];
    }

    e_y = NULL;
    m = emlrtCreateCharArray(2, &iv4[0]);
    emlrtInitCharArrayR2013a(&f_st, 4, m, &h_u[0]);
    emlrtAssign(&e_y, m);
    g_st.site = &sv_emlrtRSI;
    error(&g_st, y, getString(&g_st, message(&g_st, c_y, e_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  f_st.site = &ib_emlrtRSI;
  p = true;
  if (b_time < 0.0) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 42; i++) {
      c_u[i] = e_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&f_st, 42, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 51; i++) {
      g_u[i] = i_u[i];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a(&f_st, 51, m, &g_u[0]);
    emlrtAssign(&d_y, m);
    for (i = 0; i < 4; i++) {
      h_u[i] = j_u[i];
    }

    f_y = NULL;
    m = emlrtCreateCharArray(2, &iv5[0]);
    emlrtInitCharArrayR2013a(&f_st, 4, m, &h_u[0]);
    emlrtAssign(&f_y, m);
    g_st.site = &uv_emlrtRSI;
    error(&g_st, b_y, getString(&g_st, message(&g_st, d_y, f_y, &mc_emlrtMCI),
           &mc_emlrtMCI), &mc_emlrtMCI);
  }

  oneObjDet.Time = b_time;
  d_st.site = &wh_emlrtRSI;
  e_st.site = &yh_emlrtRSI;
  j_validateattributes(&e_st, varargin_4);
  e_st.site = &ai_emlrtRSI;
  isSymmetricPositiveSemiDefinite(&e_st, varargin_4);
  memcpy(&oneObjDet.pMeasurementNoise[0], &b_varargin_4[0], 36U * sizeof(real_T));
  d_st.site = &xh_emlrtRSI;
  e_st.site = &oj_emlrtRSI;
  k_validateattributes();
  oneObjDet.SensorIndex = 4.0;
  oneObjDet.ObjectClassID = 0.0;
  oneObjDet.MeasurementParameters[0] = measParams0;
  oneObjDet.ObjectAttributes[0] = r;
  b_oneObjDet[0] = oneObjDet;
  b_st.site = &es_emlrtRSI;
  d_repmat(&b_st, b_oneObjDet, (real_T)dets_size[1], detections_data,
           detections_size);
  i = dets_size[1];
  for (b_m = 0; b_m < i; b_m++) {
    emlrtDynamicBoundsCheckR2012b(b_m, 0, detections_size[0] - 1, &ch_emlrtBCI,
      &st);
    emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, dets_size[1], &ah_emlrtBCI, &st);
    oneObjDet = detections_data[b_m];
    b_st.site = &th_emlrtRSI;
    objectDetection_set_Measurement(&b_st, &oneObjDet, &dets_data[6 * b_m]);
    b_i = emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, covmats_size[2],
      &bh_emlrtBCI, &st);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        Pin[i2 + 6 * i1] = covmats_data[(i2 + 6 * i1) + 36 * (b_i - 1)];
      }
    }

    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 6; i2++) {
        R[i2 + 6 * i1] = (Pin[i2 + 6 * i1] + Pin[i1 + 6 * i2]) / 2.0;
      }
    }

    b_st.site = &fs_emlrtRSI;
    c_st.site = &yh_emlrtRSI;
    j_validateattributes(&c_st, R);
    c_st.site = &ai_emlrtRSI;
    isSymmetricPositiveSemiDefinite(&c_st, R);
    memcpy(&oneObjDet.pMeasurementNoise[0], &R[0], 36U * sizeof(real_T));
    b_st.site = &gs_emlrtRSI;
    c_st.site = &hs_emlrtRSI;
    emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, attribs_f2_size[1], &dh_emlrtBCI,
      &c_st);
    r1.TargetIndex = attribs_f2_data[b_m];
    oneObjDet.ObjectAttributes[0] = r1;
    detections_data[emlrtDynamicBoundsCheckR2012b(b_m, 0, detections_size[0] - 1,
      &eh_emlrtBCI, &st)] = oneObjDet;
  }

  i = dets_size[1];
  for (b_m = 0; b_m < i; b_m++) {
    st.site = &cs_emlrtRSI;
    emlrtDynamicBoundsCheckR2012b(b_m, 0, detections_size[0] - 1, &yg_emlrtBCI,
      &st);
    emlrtDynamicBoundsCheckR2012b(b_m + 1, 1, classIDs_size[1], &xg_emlrtBCI,
      &st);
    oneObjDet = detections_data[b_m];
    b_st.site = &ks_emlrtRSI;
    c_st.site = &ib_emlrtRSI;
    p = true;
    if ((!muDoubleScalarIsInf(classIDs_data[b_m])) && (!muDoubleScalarIsNaN
         (classIDs_data[b_m])) && (muDoubleScalarFloor(classIDs_data[b_m]) ==
         classIDs_data[b_m])) {
    } else {
      p = false;
    }

    if (!p) {
      for (i1 = 0; i1 < 38; i1++) {
        k_u[i1] = l_u[i1];
      }

      g_y = NULL;
      m = emlrtCreateCharArray(2, &iv6[0]);
      emlrtInitCharArrayR2013a(&c_st, 38, m, &k_u[0]);
      emlrtAssign(&g_y, m);
      for (i1 = 0; i1 < 47; i1++) {
        m_u[i1] = n_u[i1];
      }

      i_y = NULL;
      m = emlrtCreateCharArray(2, &iv8[0]);
      emlrtInitCharArrayR2013a(&c_st, 47, m, &m_u[0]);
      emlrtAssign(&i_y, m);
      for (i1 = 0; i1 < 13; i1++) {
        o_u[i1] = p_u[i1];
      }

      l_y = NULL;
      m = emlrtCreateCharArray(2, &iv11[0]);
      emlrtInitCharArrayR2013a(&c_st, 13, m, &o_u[0]);
      emlrtAssign(&l_y, m);
      d_st.site = &vv_emlrtRSI;
      error(&d_st, g_y, getString(&d_st, message(&d_st, i_y, l_y, &db_emlrtMCI),
             &db_emlrtMCI), &db_emlrtMCI);
    }

    c_st.site = &ib_emlrtRSI;
    p = true;
    if ((!!muDoubleScalarIsInf(classIDs_data[b_m])) || (!!muDoubleScalarIsNaN
         (classIDs_data[b_m]))) {
      p = false;
    }

    if (!p) {
      for (i1 = 0; i1 < 37; i1++) {
        u[i1] = b_u[i1];
      }

      h_y = NULL;
      m = emlrtCreateCharArray(2, &iv7[0]);
      emlrtInitCharArrayR2013a(&c_st, 37, m, &u[0]);
      emlrtAssign(&h_y, m);
      for (i1 = 0; i1 < 46; i1++) {
        d_u[i1] = f_u[i1];
      }

      k_y = NULL;
      m = emlrtCreateCharArray(2, &iv10[0]);
      emlrtInitCharArrayR2013a(&c_st, 46, m, &d_u[0]);
      emlrtAssign(&k_y, m);
      for (i1 = 0; i1 < 13; i1++) {
        o_u[i1] = p_u[i1];
      }

      n_y = NULL;
      m = emlrtCreateCharArray(2, &iv13[0]);
      emlrtInitCharArrayR2013a(&c_st, 13, m, &o_u[0]);
      emlrtAssign(&n_y, m);
      d_st.site = &sv_emlrtRSI;
      error(&d_st, h_y, getString(&d_st, message(&d_st, k_y, n_y, &d_emlrtMCI),
             &d_emlrtMCI), &d_emlrtMCI);
    }

    c_st.site = &ib_emlrtRSI;
    p = true;
    if (classIDs_data[b_m] < 0.0) {
      p = false;
    }

    if (!p) {
      for (i1 = 0; i1 < 42; i1++) {
        c_u[i1] = e_u[i1];
      }

      j_y = NULL;
      m = emlrtCreateCharArray(2, &iv9[0]);
      emlrtInitCharArrayR2013a(&c_st, 42, m, &c_u[0]);
      emlrtAssign(&j_y, m);
      for (i1 = 0; i1 < 51; i1++) {
        g_u[i1] = i_u[i1];
      }

      m_y = NULL;
      m = emlrtCreateCharArray(2, &iv12[0]);
      emlrtInitCharArrayR2013a(&c_st, 51, m, &g_u[0]);
      emlrtAssign(&m_y, m);
      for (i1 = 0; i1 < 13; i1++) {
        o_u[i1] = p_u[i1];
      }

      o_y = NULL;
      m = emlrtCreateCharArray(2, &iv14[0]);
      emlrtInitCharArrayR2013a(&c_st, 13, m, &o_u[0]);
      emlrtAssign(&o_y, m);
      d_st.site = &uv_emlrtRSI;
      error(&d_st, j_y, getString(&d_st, message(&d_st, m_y, o_y, &mc_emlrtMCI),
             &mc_emlrtMCI), &mc_emlrtMCI);
    }

    oneObjDet.ObjectClassID = classIDs_data[b_m];
    detections_data[emlrtDynamicBoundsCheckR2012b(b_m, 0, detections_size[0] - 1,
      &yg_emlrtBCI, (emlrtConstCTX)sp)] = oneObjDet;
  }
}

static void d_repmat(const emlrtStack *sp, objectDetection a[1], real_T
                     varargin_1, objectDetection b_data[], int32_T b_size[1])
{
  emlrtStack st;
  int32_T i;
  int32_T itilerow;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &mf_emlrtRSI;
  b_assertValidSizeArg(&st, varargin_1);
  b_size[0] = (int32_T)varargin_1;
  i = (uint8_T)(int32_T)varargin_1;
  for (itilerow = 0; itilerow < i; itilerow++) {
    b_data[itilerow] = a[0];
  }
}

static void visionDetectionGenerator_detectOccludedLanes
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], coder_array_s_CP1nqD0d6aDeTm14G *lanebounds, real_T
   ldettime, real_T *lanesGen_Time, BusLaneDetections1LaneBoundaries
   lanesGen_LaneBoundaries[4], real_T *lanesGen_SensorIndex, real_T *numLaneDets,
   boolean_T *validLaneUpdateTime)
{
  BusLaneDetections1LaneBoundaries lbdets_data[500];
  emlrtStack st;
  real_T elapsedInterval;
  int32_T UfacesComb_size[3];
  int32_T lbdets_size[1];
  int32_T i;
  int32_T ilb;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ls_emlrtRSI;
  visionDetectionGenerator_initializeLaneDetections(&st, (real_T)
    lanebounds->size[0], lbdets_data, lbdets_size);
  st.site = &ms_emlrtRSI;
  elapsedInterval = ldettime - obj->pTimeLastLaneUpdate;
  if ((!obj->pHasFirstLaneUpdate) || ((ldettime > obj->pTimeLastLaneUpdate) &&
       (muDoubleScalarAbs(elapsedInterval - muDoubleScalarRound(elapsedInterval /
          0.05) * 0.05) <= 0.0001))) {
    *validLaneUpdateTime = true;
  } else {
    *validLaneUpdateTime = false;
  }

  if (*validLaneUpdateTime) {
    obj->pHasFirstLaneUpdate = true;
    obj->pTimeLastLaneUpdate = ldettime;
  }

  if (*validLaneUpdateTime) {
    st.site = &ns_emlrtRSI;
    visionDetectionGenerator_getActorFacesInImageCoords(moduleInstance, &st, obj,
      b_actors_data, actors_size, moduleInstance->UfacesComb_data,
      UfacesComb_size);
    i = lanebounds->size[0];
    for (ilb = 0; ilb < i; ilb++) {
      emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lanebounds->size[0],
        &fh_emlrtBCI, (emlrtConstCTX)sp);
      st.site = &os_emlrtRSI;
      visionDetectionGenerator_detectLane(moduleInstance, &st, obj,
        lanebounds->vector.data[ilb].Coordinates.data, lanebounds->
        vector.data[ilb].Coordinates.size, lanebounds->vector.data[ilb].
        BoundaryType, lanebounds->vector.data[ilb].Strength,
        lanebounds->vector.data[ilb].Length, lanebounds->vector.data[ilb].Width,
        moduleInstance->UfacesComb_data, UfacesComb_size,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].Curvature,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].CurvatureDerivative,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].CurveLength,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].HeadingAngle,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].LateralOffset,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].BoundaryType,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].Strength,
        &lbdets_data[emlrtDynamicBoundsCheckR2012b(ilb + 1, 1, lbdets_size[0],
        &gh_emlrtBCI, (emlrtConstCTX)sp) - 1].Width);
    }
  }

  st.site = &ps_emlrtRSI;
  visionDetectionGenerator_limitMaxNumLanes(&st, lbdets_data, lbdets_size,
    lanesGen_LaneBoundaries, &elapsedInterval);
  *numLaneDets = elapsedInterval;
  *lanesGen_Time = ldettime;
  *lanesGen_SensorIndex = 4.0;
}

static void visionDetectionGenerator_initializeLaneDetections(const emlrtStack
  *sp, real_T numDets, BusLaneDetections1LaneBoundaries laneDets_data[], int32_T
  laneDets_size[1])
{
  emlrtStack b_st;
  emlrtStack st;
  int32_T i;
  int32_T outsize_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &qs_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b_st.site = &mf_emlrtRSI;
  b_assertValidSizeArg(&b_st, numDets);
  outsize_idx_0 = (int32_T)numDets;
  laneDets_size[0] = (int32_T)numDets;
  for (i = 0; i < outsize_idx_0; i++) {
    laneDets_data[i].Curvature = rtNaN;
    laneDets_data[i].CurvatureDerivative = rtNaN;
    laneDets_data[i].CurveLength = rtNaN;
    laneDets_data[i].HeadingAngle = rtNaN;
    laneDets_data[i].LateralOffset = rtNaN;
    laneDets_data[i].BoundaryType = 0U;
    laneDets_data[i].Strength = rtNaN;
    laneDets_data[i].Width = rtNaN;
  }
}

static void visionDetectionGenerator_getActorFacesInImageCoords
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, syCnTpqdknhOEQKNq30nf4E b_actors_data[],
   int32_T actors_size[1], real_T Ufaces_data[], int32_T Ufaces_size[3])
{
  coder_array_real_T_2D actorIDs;
  coder_array_real_T_2D actorIdx;
  coder_array_real_T_2D b_actorIDs;
  coder_array_real_T_4D facesSen;
  emlrtStack st;
  real_T b_Ufaces_data[4200];
  real_T xSen_data[1800];
  real_T classIDs_data[300];
  real_T tgtIDs_data[300];
  int32_T facesVis[3];
  int32_T facesVis_size[3];
  int32_T b_facesVis_size[2];
  int32_T c_facesVis_size[2];
  int32_T classIDs_size[2];
  int32_T tgtIDs_size[2];
  int32_T xSen_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  boolean_T isInside;
  st.prev = sp;
  st.tls = sp->tls;
  array_real_T_4D_Constructor(&facesSen);
  st.site = &rs_emlrtRSI;
  AbstractDetectionGenerator_actorsFacesInSensorCoords(&st, obj, b_actors_data,
    actors_size, &facesSen, xSen_data, xSen_size, tgtIDs_data, tgtIDs_size,
    classIDs_data, classIDs_size);
  array_real_T_2D_Constructor(&actorIdx);
  st.site = &ss_emlrtRSI;
  AbstractDetectionGenerator_isSensorInsideActor(&st, &facesSen, &isInside,
    &actorIdx);
  if (isInside) {
    st.site = &ts_emlrtRSI;
    AbstractDetectionGenerator_concatFieldValues(&st, b_actors_data, actors_size,
      tgtIDs_data, tgtIDs_size);
    array_real_T_2D_Constructor(&actorIDs);
    array_real_T_2D_SetSize(&actorIDs, 1, tgtIDs_size[1]);
    loop_ub = tgtIDs_size[0] * tgtIDs_size[1];
    for (i = 0; i < loop_ub; i++) {
      actorIDs.vector.data[i] = tgtIDs_data[i];
    }

    array_real_T_2D_Constructor(&b_actorIDs);
    array_real_T_2D_SetSize(&b_actorIDs, 1, actorIdx.size[1]);
    loop_ub = actorIdx.size[0] * actorIdx.size[1];
    for (i = 0; i < loop_ub; i++) {
      i1 = (int32_T)actorIdx.vector.data[i];
      b_actorIDs.vector.data[i] =
        actorIDs.vector.data[emlrtDynamicBoundsCheckR2012b(i1, 1, actorIDs.size
        [1], &hh_emlrtBCI, (emlrtConstCTX)sp) - 1];
    }

    array_real_T_2D_SetSize(&actorIDs, 1, b_actorIDs.size[1]);
    loop_ub = b_actorIDs.size[0] * b_actorIDs.size[1];
    for (i = 0; i < loop_ub; i++) {
      actorIDs.vector.data[i] = b_actorIDs.vector.data[i];
    }

    array_real_T_2D_Destructor(&b_actorIDs);
    i = actorIDs.size[1];
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      st.site = &us_emlrtRSI;
      e_warning(&st, actorIDs.vector.data[emlrtDynamicBoundsCheckR2012b(loop_ub
                 + 1, 1, actorIDs.size[1], &ih_emlrtBCI, (emlrtConstCTX)sp) - 1]);
    }

    array_real_T_2D_Destructor(&actorIDs);
    Ufaces_size[0] = 2;
    Ufaces_size[1] = 0;
    Ufaces_size[2] = 0;
  } else {
    st.site = &vs_emlrtRSI;
    b_visionDetectionGenerator_findVisibleTargetFaces(moduleInstance, &st,
      &facesSen, xSen_size, tgtIDs_size, classIDs_size,
      moduleInstance->d_facesVis_data, facesVis_size);
    Ufaces_size[0] = 2;
    Ufaces_size[1] = 7;
    Ufaces_size[2] = facesVis_size[2];
    loop_ub = 14 * facesVis_size[2];
    for (i = 0; i < loop_ub; i++) {
      Ufaces_data[i] = 0.0;
    }

    if (facesVis_size[2] > 0) {
      loop_ub = 7 * facesVis_size[2];
      b_facesVis_size[0] = 3;
      b_facesVis_size[1] = loop_ub;
      for (i = 0; i < loop_ub; i++) {
        for (i1 = 0; i1 < 3; i1++) {
          moduleInstance->e_facesVis_data[i1 + 3 * i] =
            moduleInstance->d_facesVis_data[i1 + 3 * i];
        }
      }

      st.site = &ws_emlrtRSI;
      b_visionDetectionGenerator_sensorToCamera(moduleInstance, &st, obj,
        moduleInstance->e_facesVis_data, b_facesVis_size,
        moduleInstance->f_facesVis_data, xSen_size);
      emlrtSubAssignSizeCheck1dR2017a(21 * facesVis_size[2], 3 * xSen_size[1],
        &fb_emlrtECI, (emlrtConstCTX)sp);
      for (i = 0; i < 3; i++) {
        facesVis[i] = facesVis_size[i];
      }

      loop_ub = facesVis[0] * facesVis[1] * facesVis[2];
      if (loop_ub - 1 >= 0) {
        memcpy(&moduleInstance->d_facesVis_data[0],
               &moduleInstance->f_facesVis_data[0], (uint32_T)loop_ub * sizeof
               (real_T));
      }

      loop_ub = 7 * facesVis[2];
      c_facesVis_size[0] = 3;
      c_facesVis_size[1] = loop_ub;
      for (i = 0; i < loop_ub; i++) {
        for (i1 = 0; i1 < 3; i1++) {
          moduleInstance->e_facesVis_data[i1 + 3 * i] =
            moduleInstance->d_facesVis_data[i1 + 3 * i];
        }
      }

      st.site = &xs_emlrtRSI;
      b_visionDetectionGenerator_cameraToImageCoords(moduleInstance, &st, obj,
        moduleInstance->e_facesVis_data, c_facesVis_size, b_Ufaces_data,
        xSen_size);
      emlrtSubAssignSizeCheck1dR2017a(14 * facesVis_size[2], xSen_size[1] << 1,
        &gb_emlrtECI, (emlrtConstCTX)sp);
      Ufaces_size[0] = 2;
      Ufaces_size[1] = 7;
      Ufaces_size[2] = facesVis_size[2];
      loop_ub = 14 * facesVis_size[2];
      if (loop_ub - 1 >= 0) {
        memcpy(&Ufaces_data[0], &b_Ufaces_data[0], (uint32_T)loop_ub * sizeof
               (real_T));
      }
    }
  }

  array_real_T_2D_Destructor(&actorIdx);
  array_real_T_4D_Destructor(&facesSen);
}

static void b_visionDetectionGenerator_findVisibleTargetFaces
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   coder_array_real_T_4D *facesSen, int32_T xSen_size[2], int32_T tgtIDs_size[2],
   int32_T classIDs_size[2], real_T g_facesVis_data[], int32_T facesVis_size[3])
{
  coder_array_real_T_2D b_facesFront;
  coder_array_real_T_2D c_facesFront;
  coder_array_real_T_2D d_facesFront;
  coder_array_real_T_2D r;
  coder_array_real_T_2D r1;
  coder_array_real_T_4D faces2D;
  coder_array_real_T_4D facesCulled;
  coder_array_real_T_4D facesFront;
  emlrtStack st;
  real_T h_facesVis_data[6300];
  real_T e_facesFront[90];
  real_T theseFaces_data[90];
  real_T theseFaces[72];
  real_T iHull_data[62];
  real_T theseVerts[60];
  real_T theseVerts_data[60];
  real_T b_theseVerts[30];
  real_T b_theseVerts_data[30];
  real_T thisFront_data[15];
  int32_T b_theseVerts_size[2];
  int32_T iv[2];
  int32_T theseVerts_size[2];
  int32_T thisFront_size[2];
  int32_T iHull_size[1];
  int32_T b_i;
  int32_T b_iTgt;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T iTgt;
  int32_T loop_ub;
  int32_T noneVis_size_idx_0;
  int32_T trueCount;
  int16_T c_tmp_data[9000];
  int16_T d_tmp_data[300];
  int16_T i3;
  int8_T e_tmp_data[30];
  int8_T f_tmp_data[30];
  boolean_T noneVis_data[300];
  boolean_T b_isGd[30];
  boolean_T isGd;
  st.prev = sp;
  st.tls = sp->tls;
  array_real_T_4D_Constructor(&facesCulled);
  st.site = &ek_emlrtRSI;
  backfaceCull(moduleInstance, &st, facesSen, &facesCulled);
  array_real_T_4D_Constructor(&facesFront);
  array_real_T_4D_SetSize(&facesFront, 3, 5, 6, facesCulled.size[3]);
  loop_ub = 90 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    facesFront.vector.data[i] = rtNaN;
  }

  i = facesCulled.size[3];
  for (iTgt = 0; iTgt < i; iTgt++) {
    b_iTgt = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesCulled.size[3],
      &xd_emlrtBCI, (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 4; i2++) {
        for (b_i = 0; b_i < 3; b_i++) {
          theseFaces[(b_i + 3 * i2) + 12 * i1] = facesCulled.vector.data[((b_i +
            3 * i2) + 12 * i1) + 72 * (b_iTgt - 1)];
        }
      }
    }

    for (loop_ub = 0; loop_ub < 6; loop_ub++) {
      st.site = &dk_emlrtRSI;
      splitFace(&st, &theseFaces[12 * loop_ub], thisFront_data, thisFront_size);
      if (thisFront_size[1] < 1) {
        b_iTgt = 0;
      } else {
        b_iTgt = thisFront_size[1];
      }

      emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesFront.size[3],
        &wd_emlrtBCI, (emlrtConstCTX)sp);
      iv[0] = 3;
      iv[1] = b_iTgt;
      emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &thisFront_size[0], 2,
        &k_emlrtECI, (void *)sp);
      for (i1 = 0; i1 < b_iTgt; i1++) {
        for (i2 = 0; i2 < 3; i2++) {
          facesFront.vector.data[((i2 + 3 * i1) + 15 * loop_ub) + 90 * iTgt] =
            thisFront_data[i2 + 3 * i1];
        }
      }
    }
  }

  array_real_T_4D_Constructor(&faces2D);
  array_real_T_4D_SetSize(&faces2D, 2, 5, 6, facesCulled.size[3]);
  loop_ub = 60 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    faces2D.vector.data[i] = rtNaN;
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&b_facesFront);
  array_real_T_2D_SetSize(&b_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    b_facesFront.vector.data[i] = facesFront.vector.data[3 * i];
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&c_facesFront);
  array_real_T_2D_SetSize(&c_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    c_facesFront.vector.data[i] = facesFront.vector.data[3 * i + 1];
  }

  loop_ub = 30 * facesFront.size[3];
  array_real_T_2D_Constructor(&d_facesFront);
  array_real_T_2D_SetSize(&d_facesFront, 1, loop_ub);
  for (i = 0; i < loop_ub; i++) {
    d_facesFront.vector.data[i] = facesFront.vector.data[3 * i + 2];
  }

  array_real_T_2D_Constructor(&r);
  array_real_T_2D_Constructor(&r1);
  st.site = &ck_emlrtRSI;
  cart2sph(&st, &b_facesFront, &c_facesFront, &d_facesFront, &r, &r1);
  array_real_T_2D_Destructor(&d_facesFront);
  array_real_T_2D_Destructor(&c_facesFront);
  array_real_T_2D_Destructor(&b_facesFront);
  i3 = (int16_T)(30 * facesCulled.size[3] - 1);
  b_iTgt = i3 + 1;
  loop_ub = i3;
  for (i = 0; i <= loop_ub; i++) {
    c_tmp_data[i] = (int16_T)i;
  }

  iv[0] = 1;
  iv[1] = i3 + 1;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &r.size[0], 2, &j_emlrtECI, (void *)
    sp);
  for (i = 0; i < b_iTgt; i++) {
    faces2D.vector.data[c_tmp_data[i] << 1] = r.vector.data[i];
  }

  array_real_T_2D_Destructor(&r);
  i3 = (int16_T)(30 * faces2D.size[3] - 1);
  b_iTgt = i3 + 1;
  loop_ub = i3;
  for (i = 0; i <= loop_ub; i++) {
    c_tmp_data[i] = (int16_T)i;
  }

  iv[0] = 1;
  iv[1] = i3 + 1;
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &r1.size[0], 2, &i_emlrtECI, (void *)
    sp);
  for (i = 0; i < b_iTgt; i++) {
    faces2D.vector.data[(c_tmp_data[i] << 1) + 1] = r1.vector.data[i];
  }

  array_real_T_2D_Destructor(&r1);
  loop_ub = 21 * facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    g_facesVis_data[i] = rtNaN;
  }

  noneVis_size_idx_0 = facesCulled.size[3];
  loop_ub = facesCulled.size[3];
  for (i = 0; i < loop_ub; i++) {
    noneVis_data[i] = false;
  }

  i = facesCulled.size[3];
  array_real_T_4D_Destructor(&facesCulled);
  for (iTgt = 0; iTgt < i; iTgt++) {
    b_iTgt = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, faces2D.size[3],
      &vd_emlrtBCI, (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 6; i1++) {
      for (i2 = 0; i2 < 5; i2++) {
        for (b_i = 0; b_i < 2; b_i++) {
          theseVerts[(b_i + (i2 << 1)) + 10 * i1] = faces2D.vector.data[((b_i +
            (i2 << 1)) + 10 * i1) + 60 * (b_iTgt - 1)];
        }
      }
    }

    emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesFront.size[3], &ud_emlrtBCI,
      (emlrtConstCTX)sp);
    for (i1 = 0; i1 < 30; i1++) {
      b_theseVerts[i1] = theseVerts[i1 << 1];
    }

    b_isfinite(b_theseVerts, b_isGd);
    if (c_combineVectorElements(b_isGd) < 3) {
      noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, noneVis_size_idx_0,
        &yd_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
    } else {
      loop_ub = 0;
      b_iTgt = 0;
      for (b_i = 0; b_i < 30; b_i++) {
        isGd = b_isGd[b_i];
        if (isGd) {
          loop_ub++;
          e_tmp_data[b_iTgt] = (int8_T)b_i;
          b_iTgt++;
        }
      }

      for (i1 = 0; i1 < loop_ub; i1++) {
        for (i2 = 0; i2 < 2; i2++) {
          theseVerts_data[i2 + (i1 << 1)] = theseVerts[i2 + (e_tmp_data[i1] << 1)];
        }
      }

      trueCount = 0;
      b_iTgt = 0;
      for (b_i = 0; b_i < 30; b_i++) {
        isGd = b_isGd[b_i];
        if (isGd) {
          trueCount++;
          f_tmp_data[b_iTgt] = (int8_T)b_i;
          b_iTgt++;
        }
      }

      for (i1 = 0; i1 < 6; i1++) {
        for (i2 = 0; i2 < 5; i2++) {
          for (b_i = 0; b_i < 3; b_i++) {
            e_facesFront[(b_i + 3 * i2) + 15 * i1] = facesFront.vector.data
              [((b_i + 3 * i2) + 15 * i1) + 90 * iTgt];
          }
        }
      }

      for (i1 = 0; i1 < trueCount; i1++) {
        for (i2 = 0; i2 < 3; i2++) {
          theseFaces_data[i2 + 3 * i1] = e_facesFront[i2 + 3 * f_tmp_data[i1]];
        }
      }

      theseVerts_size[0] = 1;
      theseVerts_size[1] = loop_ub;
      b_theseVerts_size[0] = 1;
      b_theseVerts_size[1] = loop_ub;
      for (i1 = 0; i1 < loop_ub; i1++) {
        b_theseVerts[i1] = theseVerts_data[i1 << 1];
        b_theseVerts_data[i1] = theseVerts_data[(i1 << 1) + 1];
      }

      st.site = &bk_emlrtRSI;
      convhull(&st, b_theseVerts, theseVerts_size, b_theseVerts_data,
               b_theseVerts_size, iHull_data, iHull_size);
      if (iHull_size[0] == 0) {
        noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
          noneVis_size_idx_0, &ce_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
      } else {
        if (iHull_size[0] - 1 < 1) {
          loop_ub = 0;
        } else {
          loop_ub = emlrtDynamicBoundsCheckR2012b(iHull_size[0] - 1, 1,
            iHull_size[0], &td_emlrtBCI, (emlrtConstCTX)sp);
        }

        iv[0] = 1;
        iv[1] = loop_ub;
        st.site = &ak_emlrtRSI;
        indexShapeCheck(&st, iHull_size[0], iv);
        for (i1 = 0; i1 < loop_ub; i1++) {
          emlrtDynamicBoundsCheckR2012b((int32_T)iHull_data[i1], 1, trueCount,
            &de_emlrtBCI, (emlrtConstCTX)sp);
        }

        if (loop_ub < 3) {
          noneVis_data[emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1,
            noneVis_size_idx_0, &fe_emlrtBCI, (emlrtConstCTX)sp) - 1] = true;
        } else {
          emlrtDynamicBoundsCheckR2012b(loop_ub, 1, 7, &sd_emlrtBCI,
            (emlrtConstCTX)sp);
          emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, facesCulled.size[3],
            &rd_emlrtBCI, (emlrtConstCTX)sp);
          iv[0] = 3;
          iv[1] = loop_ub;
          thisFront_size[0] = 3;
          thisFront_size[1] = loop_ub;
          emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &thisFront_size[0], 2,
            &h_emlrtECI, (void *)sp);
          for (i1 = 0; i1 < loop_ub; i1++) {
            for (i2 = 0; i2 < 3; i2++) {
              g_facesVis_data[(i2 + 3 * i1) + 21 * iTgt] = theseFaces_data[i2 +
                3 * ((int32_T)iHull_data[i1] - 1)];
            }
          }
        }
      }
    }
  }

  array_real_T_4D_Destructor(&faces2D);
  array_real_T_4D_Destructor(&facesFront);
  loop_ub = 0;
  b_iTgt = 0;
  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    isGd = noneVis_data[b_i];
    if (!isGd) {
      loop_ub++;
      d_tmp_data[b_iTgt] = (int16_T)b_i;
      b_iTgt++;
    }
  }

  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 7; i1++) {
      for (i2 = 0; i2 < 3; i2++) {
        h_facesVis_data[(i2 + 3 * i1) + 21 * i] = g_facesVis_data[(i2 + 3 * i1)
          + 21 * emlrtDynamicBoundsCheckR2012b((int32_T)d_tmp_data[i], 0,
          facesCulled.size[3] - 1, &ae_emlrtBCI, (emlrtConstCTX)sp)];
      }
    }
  }

  facesVis_size[0] = 3;
  facesVis_size[1] = 7;
  facesVis_size[2] = loop_ub;
  loop_ub *= 21;
  if (loop_ub - 1 >= 0) {
    memcpy(&g_facesVis_data[0], &h_facesVis_data[0], (uint32_T)loop_ub * sizeof
           (real_T));
  }

  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      emlrtDynamicBoundsCheckR2012b(b_i, 0, tgtIDs_size[1] - 1, &be_emlrtBCI,
        (emlrtConstCTX)sp);
    }
  }

  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      emlrtDynamicBoundsCheckR2012b(b_i, 0, classIDs_size[1] - 1, &ee_emlrtBCI,
        (emlrtConstCTX)sp);
    }
  }

  for (b_i = 0; b_i < noneVis_size_idx_0; b_i++) {
    if (!noneVis_data[b_i]) {
      emlrtDynamicBoundsCheckR2012b(b_i, 0, xSen_size[1] - 1, &ge_emlrtBCI,
        (emlrtConstCTX)sp);
    }
  }
}

static void visionDetectionGenerator_detectLane
  (InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance, const emlrtStack *sp,
   visionDetectionGenerator *obj, real_T lb_Coordinates_data[], int32_T
   lb_Coordinates_size[2], uint8_T lb_BoundaryType, real_T lb_Strength, real_T
   lb_Length, real_T lb_Width, real_T b_UfacesComb_data[], int32_T
   UfacesComb_size[3], real_T *ldet_Curvature, real_T *ldet_CurvatureDerivative,
   real_T *ldet_CurveLength, real_T *ldet_HeadingAngle, real_T
   *ldet_LateralOffset, uint8_T *ldet_BoundaryType, real_T *ldet_Strength,
   real_T *ldet_Width)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 36 };

  static char_T b_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  creal_T b_lbcFinal_data[100];
  real_T c_tmp_data[6300];
  real_T lbcFinal_data[300];
  real_T lbcSensor_data[300];
  real_T b_lbcImage_data[200];
  real_T lbcImage_data[200];
  real_T b_lbcGain_data[100];
  real_T lbcGain_data[100];
  int32_T b_lb_Coordinates_size[2];
  int32_T b_lbcImage_size[2];
  int32_T lbcFinal_size[2];
  int32_T lbcGain_size[2];
  int32_T lbcImage_size[2];
  int32_T lbcSensor_size[2];
  int32_T tmp_size[2];
  int32_T isValid[1];
  int32_T b_trueCount;
  int32_T i;
  int32_T nz;
  int32_T partialTrueCount;
  int32_T trueCount;
  char_T u[36];
  int8_T d_tmp_data[100];
  int8_T e_tmp_data[100];
  int8_T f_tmp_data[100];
  int8_T g_tmp_data[100];
  boolean_T isValid_data[100];
  boolean_T b_isValid_data;
  st.prev = sp;
  st.tls = sp->tls;
  b_lb_Coordinates_size[0] = 3;
  b_lb_Coordinates_size[1] = lb_Coordinates_size[0];
  nz = lb_Coordinates_size[0];
  for (partialTrueCount = 0; partialTrueCount < nz; partialTrueCount++) {
    for (i = 0; i < 3; i++) {
      lbcFinal_data[i + 3 * partialTrueCount] =
        lb_Coordinates_data[partialTrueCount + lb_Coordinates_size[0] * i];
    }
  }

  st.site = &ys_emlrtRSI;
  visionDetectionGenerator_egoPosToSensor(&st, lbcFinal_data,
    b_lb_Coordinates_size, lbcSensor_data, lbcSensor_size);
  st.site = &at_emlrtRSI;
  b_visionDetectionGenerator_sensorToCamera(moduleInstance, &st, obj,
    lbcSensor_data, lbcSensor_size, c_tmp_data, tmp_size);
  lbcSensor_size[0] = 3;
  lbcSensor_size[1] = tmp_size[1];
  nz = tmp_size[0] * tmp_size[1];
  if (nz - 1 >= 0) {
    memcpy(&lbcSensor_data[0], &c_tmp_data[0], (uint32_T)nz * sizeof(real_T));
  }

  st.site = &bt_emlrtRSI;
  visionDetectionGenerator_cameraToImageCoordsWithGain(&st, obj, lbcSensor_data,
    lbcSensor_size, lbcImage_data, lbcImage_size, lbcGain_data, tmp_size);
  st.site = &ct_emlrtRSI;
  visionDetectionGenerator_isInFieldOfView(&st, obj, lbcImage_data,
    lbcImage_size, isValid_data, b_lb_Coordinates_size);
  nz = b_lb_Coordinates_size[1];
  trueCount = 0;
  partialTrueCount = 0;
  for (i = 0; i < nz; i++) {
    b_isValid_data = isValid_data[i];
    if (b_isValid_data) {
      trueCount++;
      d_tmp_data[partialTrueCount] = (int8_T)i;
      partialTrueCount++;
    }
  }

  for (partialTrueCount = 0; partialTrueCount < trueCount; partialTrueCount++) {
    for (i = 0; i < 2; i++) {
      b_lbcImage_data[i + (partialTrueCount << 1)] = lbcImage_data[i +
        (emlrtDynamicBoundsCheckR2012b((int32_T)d_tmp_data[partialTrueCount], 0,
          lbcImage_size[1] - 1, &jh_emlrtBCI, (emlrtConstCTX)sp) << 1)];
    }
  }

  nz = b_lb_Coordinates_size[1];
  b_trueCount = 0;
  partialTrueCount = 0;
  for (i = 0; i < nz; i++) {
    b_isValid_data = isValid_data[i];
    if (b_isValid_data) {
      b_trueCount++;
      e_tmp_data[partialTrueCount] = (int8_T)i;
      partialTrueCount++;
    }
  }

  lbcGain_size[0] = 1;
  lbcGain_size[1] = b_trueCount;
  for (partialTrueCount = 0; partialTrueCount < b_trueCount; partialTrueCount++)
  {
    b_lbcGain_data[partialTrueCount] =
      lbcGain_data[emlrtDynamicBoundsCheckR2012b((int32_T)
      e_tmp_data[partialTrueCount], 0, tmp_size[1] - 1, &kh_emlrtBCI,
      (emlrtConstCTX)sp)];
  }

  st.site = &dt_emlrtRSI;
  visionDetectionGenerator_isLaneMarkingBigEnough(&st, lb_BoundaryType,
    lb_Length, lb_Width, b_lbcGain_data, lbcGain_size, isValid_data,
    b_lb_Coordinates_size);
  nz = b_lb_Coordinates_size[1];
  b_trueCount = 0;
  partialTrueCount = 0;
  for (i = 0; i < nz; i++) {
    b_isValid_data = isValid_data[i];
    if (b_isValid_data) {
      b_trueCount++;
      f_tmp_data[partialTrueCount] = (int8_T)i;
      partialTrueCount++;
    }
  }

  for (partialTrueCount = 0; partialTrueCount < b_trueCount; partialTrueCount++)
  {
    for (i = 0; i < 2; i++) {
      lbcImage_data[i + (partialTrueCount << 1)] = b_lbcImage_data[i +
        (emlrtDynamicBoundsCheckR2012b((int32_T)f_tmp_data[partialTrueCount], 0,
          trueCount - 1, &lh_emlrtBCI, (emlrtConstCTX)sp) << 1)];
    }
  }

  b_lbcImage_size[0] = 2;
  b_lbcImage_size[1] = b_trueCount;
  nz = b_trueCount << 1;
  if (nz - 1 >= 0) {
    memcpy(&b_lbcImage_data[0], &lbcImage_data[0], (uint32_T)nz * sizeof(real_T));
  }

  st.site = &et_emlrtRSI;
  isVisibleBoundaryPoint(&st, b_lbcImage_data, b_lbcImage_size,
    b_UfacesComb_data, UfacesComb_size, isValid_data, b_lb_Coordinates_size);
  nz = b_lb_Coordinates_size[1];
  trueCount = 0;
  partialTrueCount = 0;
  for (i = 0; i < nz; i++) {
    b_isValid_data = isValid_data[i];
    if (b_isValid_data) {
      trueCount++;
      g_tmp_data[partialTrueCount] = (int8_T)i;
      partialTrueCount++;
    }
  }

  for (partialTrueCount = 0; partialTrueCount < trueCount; partialTrueCount++) {
    for (i = 0; i < 2; i++) {
      lbcImage_data[i + (partialTrueCount << 1)] = b_lbcImage_data[i +
        (emlrtDynamicBoundsCheckR2012b((int32_T)g_tmp_data[partialTrueCount], 0,
          b_trueCount - 1, &mh_emlrtBCI, (emlrtConstCTX)sp) << 1)];
    }
  }

  b_lbcImage_size[0] = 2;
  b_lbcImage_size[1] = trueCount;
  nz = trueCount << 1;
  if (nz - 1 >= 0) {
    memcpy(&b_lbcImage_data[0], &lbcImage_data[0], (uint32_T)nz * sizeof(real_T));
  }

  if ((b_lb_Coordinates_size[1] == 1) || (b_lb_Coordinates_size[1] != 1)) {
  } else {
    for (partialTrueCount = 0; partialTrueCount < 36; partialTrueCount++) {
      u[partialTrueCount] = b_u[partialTrueCount];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (partialTrueCount = 0; partialTrueCount < 36; partialTrueCount++) {
      u[partialTrueCount] = b_u[partialTrueCount];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &rv_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &kb_emlrtMCI), &kb_emlrtMCI),
          &kb_emlrtMCI);
  }

  isValid[0] = b_lb_Coordinates_size[1];
  nz = d_combineVectorElements(isValid_data, isValid);
  *ldet_Strength = lb_Strength * (real_T)nz / (real_T)lbcImage_size[1];
  if (nz < 2) {
    *ldet_Strength = 0.0;
  }

  st.site = &ft_emlrtRSI;
  visionDetectionGenerator_imageCoordsToCameraWithTol(&st, obj, b_lbcImage_data,
    b_lbcImage_size, lbcImage_data, lbcImage_size, lbcGain_data, isValid);
  st.site = &gt_emlrtRSI;
  d_padarray(&st, lbcImage_data, lbcImage_size, lbcFinal_data, lbcGain_size);
  st.site = &ht_emlrtRSI;
  b_visionDetectionGenerator_cameraToSensor(&st, obj, lbcFinal_data,
    lbcGain_size, lbcSensor_data, lbcSensor_size);
  st.site = &it_emlrtRSI;
  b_AbstractDetectionGenerator_sensorToEgo(&st, lbcSensor_data, lbcSensor_size,
    lbcFinal_data, lbcGain_size);
  *ldet_Width = lb_Width;
  *ldet_BoundaryType = lb_BoundaryType;
  st.site = &jt_emlrtRSI;
  b_st.site = &rt_emlrtRSI;
  b_lb_Coordinates_size[0] = 1;
  b_lb_Coordinates_size[1] = lbcGain_size[1];
  tmp_size[0] = 1;
  tmp_size[1] = lbcGain_size[1];
  emlrtSizeEqCheckNDR2012b(&b_lb_Coordinates_size[0], &tmp_size[0], &hb_emlrtECI,
    (void *)sp);
  lbcFinal_size[0] = 1;
  lbcFinal_size[1] = lbcGain_size[1];
  nz = lbcGain_size[1];
  for (partialTrueCount = 0; partialTrueCount < nz; partialTrueCount++) {
    b_lbcFinal_data[partialTrueCount].re = lbcFinal_data[3 * partialTrueCount];
    b_lbcFinal_data[partialTrueCount].im = lbcFinal_data[3 * partialTrueCount +
      1];
  }

  st.site = &kt_emlrtRSI;
  fitSingleClothoid(&st, b_lbcFinal_data, lbcFinal_size, lbcGain_data, isValid,
                    ldet_HeadingAngle, ldet_LateralOffset, ldet_Curvature,
                    ldet_CurvatureDerivative, ldet_CurveLength);
}

static void visionDetectionGenerator_egoPosToSensor(const emlrtStack *sp, real_T
  detEgo_data[], int32_T detEgo_size[2], real_T detSen_data[], int32_T
  detSen_size[2])
{
  coder_array_real_T_2D d_tmp_data;
  coder_array_real_T_2D y;
  emlrtStack st;
  real_T b_detEgo_data[300];
  real_T c_tmp_data[300];
  int32_T b_detEgo_size[2];
  int32_T tmp_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  detSen_size[0] = 3;
  detSen_size[1] = detEgo_size[1];
  loop_ub = 3 * detEgo_size[1];
  for (i = 0; i < loop_ub; i++) {
    detSen_data[i] = 0.0;
  }

  b_detEgo_size[0] = 3;
  b_detEgo_size[1] = detEgo_size[1];
  loop_ub = detEgo_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detEgo_data[i1 + 3 * i] = detEgo_data[i1 + 3 * i];
    }
  }

  w_bsxfun(b_detEgo_data, b_detEgo_size, c_tmp_data, tmp_size);
  d_tmp_data.vector.data = &c_tmp_data[0];
  d_tmp_data.vector.numel = tmp_size[0] * tmp_size[1];
  d_tmp_data.vector.allocated = d_tmp_data.vector.numel;
  d_tmp_data.vector.owner = false;
  d_tmp_data.size[0] = tmp_size[0];
  d_tmp_data.size[1] = tmp_size[1];
  array_real_T_2D_Constructor(&y);
  st.site = &md_emlrtRSI;
  f_mtimes(&d_tmp_data, &y);
  b_detEgo_size[0] = 3;
  b_detEgo_size[1] = detEgo_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detEgo_size[0], 2, &y.size[0], 2,
    &ib_emlrtECI, (void *)sp);
  loop_ub = detEgo_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen_data[i1 + 3 * i] = y.vector.data[i1 + 3 * i];
    }
  }

  array_real_T_2D_Destructor(&y);
}

static void w_bsxfun(real_T a_data[], int32_T a_size[2], real_T c_data[],
                     int32_T c_size[2])
{
  static real_T b_dv[3] = { 0.0, 0.0, 1.1 };

  __m128d r;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T ia;
  int32_T k;
  c_size[0] = 3;
  c_size[1] = (int8_T)a_size[1];
  if ((int8_T)a_size[1] != 0) {
    c_size[0] = 3;
    acoef = (a_size[1] != 1);
    i = (int8_T)a_size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      c_size[0] = 3;
      for (b_k = 0; b_k <= 0; b_k += 2) {
        c_size[0] = 3;
        r = _mm_loadu_pd(&a_data[3 * ia]);
        _mm_storeu_pd(&c_data[3 * k], _mm_sub_pd(r, _mm_loadu_pd(&b_dv[0])));
      }

      for (b_k = 2; b_k < 3; b_k++) {
        c_size[0] = 3;
        c_data[3 * k + 2] = a_data[3 * ia + 2] - 1.1;
      }
    }
  }
}

static void visionDetectionGenerator_cameraToImageCoordsWithGain(const
  emlrtStack *sp, visionDetectionGenerator *obj, real_T b_pos_data[], int32_T
  pos_size[2], real_T b_U_data[], int32_T U_size[2], real_T Ugain_data[],
  int32_T Ugain_size[2])
{
  coder_array_real_T_2D b_X_data;
  coder_array_real_T_2D r1;
  emlrtStack st;
  monoCamera r;
  real_T b_y_data[6300];
  real_T b_z_data[2100];
  real_T z_data[2100];
  real_T X_data[400];
  real_T b_Uprime_data[300];
  real_T camMtx[12];
  real_T x;
  int32_T Uprime_size[2];
  int32_T b_Uprime_size[2];
  int32_T b_pos_size[2];
  int32_T wp_size[2];
  int32_T Uprime_size_idx_1;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  r = obj->pMonoCameraInSensorFrame;
  st.site = &lt_emlrtRSI;
  visionDetectionGenerator_getCameraMatrix(r.Intrinsics, r.Height, r.Pitch,
    r.Yaw, r.Roll, camMtx);
  b_pos_size[0] = pos_size[1];
  b_pos_size[1] = 3;
  for (i = 0; i < 3; i++) {
    loop_ub = pos_size[1];
    for (i1 = 0; i1 < loop_ub; i1++) {
      b_Uprime_data[i1 + b_pos_size[0] * i] = b_pos_data[i + 3 * i1];
    }
  }

  array_real_T_2D_Constructor(&r1);
  st.site = &mt_emlrtRSI;
  b_padarray(&st, b_Uprime_data, b_pos_size, &r1);
  loop_ub = r1.size[0] * r1.size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&X_data[0], &r1.vector.data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  array_real_T_2D_Destructor(&r1);
  b_X_data.vector.data = &X_data[0];
  b_X_data.vector.numel = r1.size[0] << 2;
  b_X_data.vector.allocated = b_X_data.vector.numel;
  b_X_data.vector.owner = false;
  b_X_data.size[0] = r1.size[0];
  b_X_data.size[1] = 4;
  st.site = &md_emlrtRSI;
  i_mtimes(&b_X_data, camMtx, b_y_data, b_pos_size);
  Uprime_size_idx_1 = b_pos_size[0];
  loop_ub = b_pos_size[0];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_Uprime_data[i1 + 3 * i] = b_y_data[i + b_pos_size[0] * i1];
    }
  }

  wp_size[0] = 1;
  wp_size[1] = b_pos_size[0];
  Uprime_size[0] = 1;
  Uprime_size[1] = b_pos_size[0];
  st.site = &rd_emlrtRSI;
  assertCompatibleDims(&st, Uprime_size, wp_size);
  b_Uprime_size[0] = 1;
  b_Uprime_size[1] = b_pos_size[0];
  for (i = 0; i < Uprime_size_idx_1; i++) {
    z_data[i] = b_Uprime_data[3 * i] / b_Uprime_data[3 * i + 2];
  }

  st.site = &rd_emlrtRSI;
  assertCompatibleDims(&st, b_Uprime_size, wp_size);
  for (i = 0; i < Uprime_size_idx_1; i++) {
    b_z_data[i] = b_Uprime_data[3 * i + 1] / b_Uprime_data[3 * i + 2];
  }

  U_size[0] = 2;
  U_size[1] = b_pos_size[0];
  for (i = 0; i < Uprime_size_idx_1; i++) {
    b_U_data[i << 1] = z_data[i];
    b_U_data[(i << 1) + 1] = b_z_data[i];
  }

  x = r.Intrinsics->FocalLength[1];
  Ugain_size[0] = 1;
  Ugain_size[1] = b_pos_size[0];
  for (i = 0; i < Uprime_size_idx_1; i++) {
    Ugain_data[i] = x / b_Uprime_data[3 * i + 2];
  }
}

static void visionDetectionGenerator_isInFieldOfView(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T imgCoords_data[], int32_T
  imgCoords_size[2], boolean_T flag_data[], int32_T flag_size[2])
{
  real_T b_imageSize[2];
  int32_T b_tmp_size[2];
  int32_T tmp_size[2];
  int32_T i;
  int32_T loop_ub;
  boolean_T c_tmp_data[100];
  boolean_T d_tmp_data[100];
  for (i = 0; i < 2; i++) {
    b_imageSize[i] = obj->pMonoCameraInSensorFrame.Intrinsics->ImageSize[i];
  }

  tmp_size[0] = 1;
  tmp_size[1] = imgCoords_size[1];
  loop_ub = imgCoords_size[1];
  b_tmp_size[0] = 1;
  b_tmp_size[1] = imgCoords_size[1];
  for (i = 0; i < loop_ub; i++) {
    c_tmp_data[i] = (imgCoords_data[i << 1] > 0.0);
    d_tmp_data[i] = (imgCoords_data[i << 1] < b_imageSize[1]);
  }

  emlrtSizeEqCheckNDR2012b(&tmp_size[0], &b_tmp_size[0], &jb_emlrtECI, (void *)
    sp);
  flag_size[1] = imgCoords_size[1];
  loop_ub = imgCoords_size[1];
  for (i = 0; i < loop_ub; i++) {
    flag_data[i] = (c_tmp_data[i] && d_tmp_data[i]);
    c_tmp_data[i] = (imgCoords_data[(i << 1) + 1] > 0.0);
  }

  loop_ub = imgCoords_size[1] - 1;
  for (i = 0; i <= loop_ub; i++) {
    flag_data[i] = (flag_data[i] && c_tmp_data[i]);
  }

  loop_ub = imgCoords_size[1];
  for (i = 0; i < loop_ub; i++) {
    c_tmp_data[i] = (imgCoords_data[(i << 1) + 1] < b_imageSize[0]);
  }

  loop_ub = imgCoords_size[1] - 1;
  flag_size[0] = 1;
  for (i = 0; i <= loop_ub; i++) {
    flag_data[i] = (flag_data[i] && c_tmp_data[i]);
  }
}

static void visionDetectionGenerator_isLaneMarkingBigEnough(const emlrtStack *sp,
  uint8_T lb_BoundaryType, real_T lb_Length, real_T lb_Width, real_T
  lbcGain_data[], int32_T lbcGain_size[2], boolean_T flag_data[], int32_T
  flag_size[2])
{
  int32_T b_tmp_size[2];
  int32_T tmp_size[2];
  int32_T i;
  int32_T loop_ub;
  boolean_T c_tmp_data[100];
  boolean_T d_tmp_data[100];
  if ((lb_BoundaryType == LaneBoundaryType_Solid) || (lb_BoundaryType ==
       LaneBoundaryType_DoubleSolid)) {
    flag_size[0] = 1;
    flag_size[1] = lbcGain_size[1];
    loop_ub = lbcGain_size[1];
    for (i = 0; i < loop_ub; i++) {
      flag_data[i] = (lb_Width * lbcGain_data[i] > 3.0);
    }
  } else {
    tmp_size[0] = 1;
    tmp_size[1] = lbcGain_size[1];
    loop_ub = lbcGain_size[1];
    b_tmp_size[0] = 1;
    b_tmp_size[1] = lbcGain_size[1];
    for (i = 0; i < loop_ub; i++) {
      c_tmp_data[i] = (lb_Length * lbcGain_data[i] > 20.0);
      d_tmp_data[i] = (lb_Width * lbcGain_data[i] > 3.0);
    }

    emlrtSizeEqCheckNDR2012b(&tmp_size[0], &b_tmp_size[0], &kb_emlrtECI, (void *)
      sp);
    flag_size[0] = 1;
    flag_size[1] = lbcGain_size[1];
    loop_ub = lbcGain_size[1];
    for (i = 0; i < loop_ub; i++) {
      flag_data[i] = (c_tmp_data[i] && d_tmp_data[i]);
    }
  }
}

static void isVisibleBoundaryPoint(const emlrtStack *sp, real_T lbcImage_data[],
  int32_T lbcImage_size[2], real_T Uall_data[], int32_T Uall_size[3], boolean_T
  isVisible_data[], int32_T isVisible_size[2])
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static const int32_T iv2[2] = { 1, 31 };

  static const int32_T iv3[2] = { 1, 31 };

  static char_T d_u[31] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'L',
    'o', 'o', 'p', 'D', 'e', 'f' };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *m;
  int64_T sdq;
  real_T e_Utgt_data[14];
  real_T f_Utgt_data[14];
  real_T Upoly_data[7];
  real_T Vpoly_data[7];
  real_T scale_data[7];
  real_T b_dv[2];
  real_T dv1[2];
  real_T avxi;
  real_T avyi;
  real_T maxyv;
  real_T minyv;
  real_T x;
  real_T xv1;
  real_T xv2;
  real_T y;
  real_T yv1;
  real_T yv2;
  int32_T first_data[7];
  int32_T last_data[7];
  int32_T Utgt_size_idx_1;
  int32_T b_i;
  int32_T exitg2;
  int32_T exitg3;
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T iPoint;
  int32_T iTgt;
  int32_T k;
  int32_T kfirst;
  int32_T loop_ub;
  int32_T trueCount;
  char_T c_u[31];
  char_T u[15];
  int8_T d_tmp_data[7];
  int8_T dquad;
  int8_T quad1;
  int8_T quad2;
  int8_T quadFirst;
  boolean_T c_tmp_data;
  boolean_T exitg1;
  boolean_T isnanxv;
  boolean_T isnanyv;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  isVisible_size[0] = 1;
  isVisible_size[1] = lbcImage_size[1];
  loop_ub = lbcImage_size[1];
  for (i = 0; i < loop_ub; i++) {
    isVisible_data[i] = true;
  }

  i = Uall_size[2];
  for (iTgt = 0; iTgt < i; iTgt++) {
    kfirst = emlrtDynamicBoundsCheckR2012b(iTgt + 1, 1, Uall_size[2],
      &nh_emlrtBCI, (emlrtConstCTX)sp);
    Utgt_size_idx_1 = Uall_size[1];
    loop_ub = Uall_size[1];
    for (i1 = 0; i1 < loop_ub; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        e_Utgt_data[i2 + (i1 << 1)] = Uall_data[(i2 + (i1 << 1)) + (Uall_size[1]
          << 1) * (kfirst - 1)];
      }
    }

    trueCount = 0;
    kfirst = 0;
    for (b_i = 0; b_i < Utgt_size_idx_1; b_i++) {
      c_tmp_data = !muDoubleScalarIsNaN(e_Utgt_data[b_i << 1]);
      if (c_tmp_data) {
        trueCount++;
        d_tmp_data[kfirst] = (int8_T)b_i;
        kfirst++;
      }
    }

    for (i1 = 0; i1 < trueCount; i1++) {
      for (i2 = 0; i2 < 2; i2++) {
        f_Utgt_data[i2 + (i1 << 1)] = e_Utgt_data[i2 +
          (emlrtDynamicBoundsCheckR2012b((int32_T)d_tmp_data[i1], 0, Uall_size[1]
            - 1, &oh_emlrtBCI, (emlrtConstCTX)sp) << 1)];
      }
    }

    loop_ub = trueCount << 1;
    if (loop_ub - 1 >= 0) {
      memcpy(&e_Utgt_data[0], &f_Utgt_data[0], (uint32_T)loop_ub * sizeof(real_T));
    }

    for (i1 = 0; i1 < trueCount; i1++) {
      Upoly_data[i1] = e_Utgt_data[i1 << 1];
      Vpoly_data[i1] = e_Utgt_data[(i1 << 1) + 1];
    }

    i1 = lbcImage_size[1];
    for (iPoint = 0; iPoint < i1; iPoint++) {
      if (isVisible_data[emlrtDynamicBoundsCheckR2012b(iPoint + 1, 1,
           isVisible_size[1], &ph_emlrtBCI, (emlrtConstCTX)sp) - 1]) {
        st.site = &nt_emlrtRSI;
        x = lbcImage_data[(emlrtDynamicBoundsCheckR2012b(iPoint + 1, 1,
          lbcImage_size[1], &qh_emlrtBCI, &st) - 1) << 1];
        y = lbcImage_data[1 + ((emlrtDynamicBoundsCheckR2012b(iPoint + 1, 1,
          lbcImage_size[1], &rh_emlrtBCI, &st) - 1) << 1)];
        b_dv[0] = 1.0;
        b_dv[1] = ((real_T)trueCount - 1.0) + 1.0;
        dv1[0] = 1.0;
        dv1[1] = ((real_T)trueCount - 1.0) + 1.0;
        if (!isequal(b_dv, dv1)) {
          for (i2 = 0; i2 < 15; i2++) {
            u[i2] = b_u[i2];
          }

          b_y = NULL;
          m = emlrtCreateCharArray(2, &iv[0]);
          emlrtInitCharArrayR2013a(&st, 15, m, &u[0]);
          emlrtAssign(&b_y, m);
          for (i2 = 0; i2 < 15; i2++) {
            u[i2] = b_u[i2];
          }

          c_y = NULL;
          m = emlrtCreateCharArray(2, &iv1[0]);
          emlrtInitCharArrayR2013a(&st, 15, m, &u[0]);
          emlrtAssign(&c_y, m);
          b_st.site = &jw_emlrtRSI;
          error(&b_st, b_y, getString(&b_st, b_message(&b_st, c_y, &jc_emlrtMCI),
                 &jc_emlrtMCI), &jc_emlrtMCI);
        }

        c_tmp_data = false;
        if (trueCount == 0) {
        } else {
          b_st.site = &kr_emlrtRSI;
          Utgt_size_idx_1 = 0;
          for (i2 = 0; i2 < trueCount; i2++) {
            first_data[i2] = 0;
            last_data[i2] = 0;
          }

          k = 1;
          c_st.site = &mr_emlrtRSI;
          b_skipNaNs(&c_st, &k, Upoly_data, Vpoly_data, trueCount);
          while (k <= trueCount) {
            Utgt_size_idx_1++;
            kfirst = k - 1;
            first_data[Utgt_size_idx_1 - 1] = k;
            c_st.site = &nr_emlrtRSI;
            exitg1 = false;
            while ((!exitg1) && (k < trueCount)) {
              k++;
              isnanxv = muDoubleScalarIsNaN(e_Utgt_data[(k - 1) << 1]);
              isnanyv = muDoubleScalarIsNaN(e_Utgt_data[((k - 1) << 1) + 1]);
              if (isnanxv || isnanyv) {
                if ((int32_T)isnanxv != (int32_T)isnanyv) {
                  for (i2 = 0; i2 < 31; i2++) {
                    c_u[i2] = d_u[i2];
                  }

                  d_y = NULL;
                  m = emlrtCreateCharArray(2, &iv2[0]);
                  emlrtInitCharArrayR2013a(&c_st, 31, m, &c_u[0]);
                  emlrtAssign(&d_y, m);
                  for (i2 = 0; i2 < 31; i2++) {
                    c_u[i2] = d_u[i2];
                  }

                  e_y = NULL;
                  m = emlrtCreateCharArray(2, &iv3[0]);
                  emlrtInitCharArrayR2013a(&c_st, 31, m, &c_u[0]);
                  emlrtAssign(&e_y, m);
                  d_st.site = &iw_emlrtRSI;
                  error(&d_st, d_y, getString(&d_st, b_message(&d_st, e_y,
                          &lc_emlrtMCI), &lc_emlrtMCI), &lc_emlrtMCI);
                }

                k--;
                exitg1 = true;
              }
            }

            if ((e_Utgt_data[(k - 1) << 1] == e_Utgt_data[kfirst << 1]) &&
                (e_Utgt_data[((k - 1) << 1) + 1] == e_Utgt_data[(kfirst << 1) +
                 1]) && (kfirst + 1 != k)) {
              last_data[Utgt_size_idx_1 - 1] = k - 1;
            } else {
              last_data[Utgt_size_idx_1 - 1] = k;
            }

            k += 2;
            c_st.site = &or_emlrtRSI;
            b_skipNaNs(&c_st, &k, Upoly_data, Vpoly_data, trueCount);
          }

          if (Utgt_size_idx_1 == 0) {
          } else {
            b_st.site = &lr_emlrtRSI;
            xv1 = e_Utgt_data[(first_data[0] - 1) << 1];
            yv1 = e_Utgt_data[(first_data[0] - 1) << 1];
            minyv = e_Utgt_data[((first_data[0] - 1) << 1) + 1];
            maxyv = e_Utgt_data[((first_data[0] - 1) << 1) + 1];
            i2 = (uint8_T)Utgt_size_idx_1;
            for (k = 0; k < i2; k++) {
              loop_ub = last_data[k];
              kfirst = first_data[k];
              avxi = e_Utgt_data[(kfirst - 1) << 1];
              avyi = e_Utgt_data[(kfirst - 1) << 1];
              for (b_i = kfirst; b_i <= loop_ub; b_i++) {
                if (avxi > e_Utgt_data[(b_i - 1) << 1]) {
                  avxi = e_Utgt_data[(b_i - 1) << 1];
                }

                if (avyi < e_Utgt_data[(b_i - 1) << 1]) {
                  avyi = e_Utgt_data[(b_i - 1) << 1];
                }
              }

              xv2 = e_Utgt_data[((kfirst - 1) << 1) + 1];
              yv2 = e_Utgt_data[((kfirst - 1) << 1) + 1];
              for (b_i = kfirst; b_i <= loop_ub; b_i++) {
                if (xv2 > e_Utgt_data[((b_i - 1) << 1) + 1]) {
                  xv2 = e_Utgt_data[((b_i - 1) << 1) + 1];
                }

                if (yv2 < e_Utgt_data[((b_i - 1) << 1) + 1]) {
                  yv2 = e_Utgt_data[((b_i - 1) << 1) + 1];
                }
              }

              c_st.site = &pr_emlrtRSI;
              checkRange(&c_st, avxi, avyi, xv2, yv2);
              if (xv1 > avxi) {
                xv1 = avxi;
              }

              if (yv1 < avyi) {
                yv1 = avyi;
              }

              if (minyv > xv2) {
                minyv = xv2;
              }

              if (maxyv < yv2) {
                maxyv = yv2;
              }
            }

            for (i2 = 0; i2 < trueCount; i2++) {
              scale_data[i2] = 0.0;
            }

            i2 = (uint8_T)Utgt_size_idx_1;
            for (k = 0; k < i2; k++) {
              loop_ub = last_data[k];
              kfirst = first_data[k];
              for (b_i = kfirst; b_i < loop_ub; b_i++) {
                avxi = muDoubleScalarAbs(0.5 * (e_Utgt_data[(b_i - 1) << 1] +
                  e_Utgt_data[b_i << 1]));
                avyi = muDoubleScalarAbs(0.5 * (e_Utgt_data[((b_i - 1) << 1) + 1]
                  + e_Utgt_data[(b_i << 1) + 1]));
                if ((avxi > 1.0) && (avyi > 1.0)) {
                  avxi *= avyi;
                } else if ((avyi > avxi) || muDoubleScalarIsNaN(avxi)) {
                  avxi = avyi;
                }

                scale_data[b_i - 1] = avxi * 6.6613381477509392E-16;
              }

              avxi = muDoubleScalarAbs(0.5 * (e_Utgt_data[(loop_ub - 1) << 1] +
                e_Utgt_data[(kfirst - 1) << 1]));
              avyi = muDoubleScalarAbs(0.5 * (e_Utgt_data[((loop_ub - 1) << 1) +
                1] + e_Utgt_data[((kfirst - 1) << 1) + 1]));
              if ((avxi > 1.0) && (avyi > 1.0)) {
                avxi *= avyi;
              } else if ((avyi > avxi) || muDoubleScalarIsNaN(avxi)) {
                avxi = avyi;
              }

              scale_data[loop_ub - 1] = avxi * 6.6613381477509392E-16;
            }

            if ((x >= xv1) && (x <= yv1) && (y >= minyv) && (y <= maxyv)) {
              sdq = 0LL;
              k = 1;
              do {
                exitg3 = 0;
                if (k - 1 <= (uint8_T)Utgt_size_idx_1 - 1) {
                  avxi = e_Utgt_data[(first_data[k - 1] - 1) << 1] - x;
                  avyi = e_Utgt_data[((first_data[k - 1] - 1) << 1) + 1] - y;
                  if (avxi > 0.0) {
                    if (avyi > 0.0) {
                      quadFirst = 0;
                    } else {
                      quadFirst = 3;
                    }
                  } else if (avyi > 0.0) {
                    quadFirst = 1;
                  } else {
                    quadFirst = 2;
                  }

                  xv2 = avxi;
                  yv2 = avyi;
                  quad2 = quadFirst;
                  b_i = first_data[k - 1];
                  do {
                    exitg2 = 0;
                    if (b_i <= last_data[k - 1] - 1) {
                      xv1 = xv2;
                      yv1 = yv2;
                      xv2 = e_Utgt_data[b_i << 1] - x;
                      yv2 = e_Utgt_data[(b_i << 1) + 1] - y;
                      quad1 = quad2;
                      if (xv2 > 0.0) {
                        if (yv2 > 0.0) {
                          quad2 = 0;
                        } else {
                          quad2 = 3;
                        }
                      } else if (yv2 > 0.0) {
                        quad2 = 1;
                      } else {
                        quad2 = 2;
                      }

                      contrib(xv1, yv1, xv2, yv2, quad1, quad2, scale_data[b_i -
                              1], &dquad, &c_tmp_data);
                      if (c_tmp_data) {
                        c_tmp_data = true;
                        exitg2 = 1;
                      } else {
                        sdq += (int64_T)dquad;
                        b_i++;
                      }
                    } else {
                      contrib(xv2, yv2, avxi, avyi, quad2, quadFirst,
                              scale_data[last_data[k - 1] - 1], &dquad,
                              &c_tmp_data);
                      exitg2 = 2;
                    }
                  } while (exitg2 == 0);

                  if (exitg2 == 1) {
                    exitg3 = 1;
                  } else if (c_tmp_data) {
                    c_tmp_data = true;
                    exitg3 = 1;
                  } else {
                    sdq += (int64_T)dquad;
                    k++;
                  }
                } else {
                  c_tmp_data = (sdq != 0LL);
                  exitg3 = 1;
                }
              } while (exitg3 == 0);
            }
          }
        }

        isVisible_data[emlrtDynamicBoundsCheckR2012b(iPoint + 1, 1,
          isVisible_size[1], &sh_emlrtBCI, (emlrtConstCTX)sp) - 1] = !c_tmp_data;
      }
    }
  }
}

static int32_T d_combineVectorElements(boolean_T x_data[], int32_T x_size[1])
{
  int32_T k;
  int32_T vlen;
  int32_T y;
  vlen = x_size[0];
  if (x_size[0] == 0) {
    y = 0;
  } else {
    y = (int32_T)x_data[0];
    for (k = 2; k <= vlen; k++) {
      y += (int32_T)x_data[k - 1];
    }
  }

  return y;
}

static void visionDetectionGenerator_imageCoordsToCameraWithTol(const emlrtStack
  *sp, visionDetectionGenerator *obj, real_T b_U_data[], int32_T U_size[2],
  real_T X_data[], int32_T X_size[2], real_T tol_data[], int32_T tol_size[1])
{
  __m128d r;
  __m128d r1;
  emlrtStack st;
  real_T a_data[318];
  real_T b_y_data[318];
  real_T d_y_data[318];
  real_T c_tmp_data[300];
  real_T Utol_data[200];
  real_T b_Utol_data[200];
  real_T c_y_data[100];
  real_T z_data[100];
  real_T M[9];
  real_T b_obj[2];
  int32_T Utol_size[2];
  int32_T a_size[2];
  int32_T b_U_size[2];
  int32_T tmp_size[2];
  int32_T y_size[2];
  int32_T b_y_size[1];
  int32_T c_y_size[1];
  int32_T d_y_size[1];
  int32_T zp_size[1];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T scalarLB;
  int32_T vectorUB;
  int32_T z_size_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 2; i++) {
    b_obj[i] = obj->pMonoCameraInSensorFrame.SensorLocation[i];
  }

  st.site = &ot_emlrtRSI;
  monoCamera_get_ImageToVehicleTransform(&st,
    obj->pMonoCameraInSensorFrame.Intrinsics,
    obj->pMonoCameraInSensorFrame.Height, obj->pMonoCameraInSensorFrame.Pitch,
    obj->pMonoCameraInSensorFrame.Yaw, obj->pMonoCameraInSensorFrame.Roll, b_obj,
    M);
  b_U_size[0] = U_size[1];
  b_U_size[1] = 2;
  for (i1 = 0; i1 < 2; i1++) {
    loop_ub = U_size[1];
    for (z_size_idx_0 = 0; z_size_idx_0 < loop_ub; z_size_idx_0++) {
      Utol_data[z_size_idx_0 + b_U_size[0] * i1] = b_U_data[i1 + (z_size_idx_0 <<
        1)];
    }
  }

  st.site = &pt_emlrtRSI;
  c_padarray(&st, Utol_data, b_U_size, c_tmp_data, tmp_size);
  a_size[0] = tmp_size[0];
  a_size[1] = 3;
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&a_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  st.site = &yd_emlrtRSI;
  dynamic_size_checks(&st, a_size, 3);
  st.site = &md_emlrtRSI;
  e_mtimes(a_data, a_size, M, b_y_data, y_size);
  zp_size[0] = y_size[0];
  b_y_size[0] = y_size[0];
  if (y_size[0] - 1 >= 0) {
    memcpy(&c_y_data[0], &b_y_data[0], (uint32_T)y_size[0] * sizeof(real_T));
  }

  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, b_y_size, zp_size);
  z_size_idx_0 = y_size[0];
  loop_ub = y_size[0];
  c_y_size[0] = y_size[0];
  scalarLB = y_size[0] / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i1 = 0; i1 <= vectorUB; i1 += 2) {
    r = _mm_loadu_pd(&b_y_data[i1]);
    r1 = _mm_loadu_pd(&b_y_data[i1 + (y_size[0] << 1)]);
    _mm_storeu_pd(&z_data[i1], _mm_div_pd(r, r1));
    r = _mm_loadu_pd(&b_y_data[i1 + y_size[0]]);
    _mm_storeu_pd(&c_y_data[i1], r);
  }

  for (i1 = scalarLB; i1 < loop_ub; i1++) {
    z_data[i1] = b_y_data[i1] / b_y_data[i1 + (y_size[0] << 1)];
  }

  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, c_y_size, zp_size);
  loop_ub = y_size[0];
  scalarLB = y_size[0] / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i1 = 0; i1 <= vectorUB; i1 += 2) {
    r = _mm_loadu_pd(&b_y_data[i1 + y_size[0]]);
    r1 = _mm_loadu_pd(&b_y_data[i1 + (y_size[0] << 1)]);
    _mm_storeu_pd(&c_y_data[i1], _mm_div_pd(r, r1));
  }

  for (i1 = scalarLB; i1 < loop_ub; i1++) {
    c_y_data[i1] = b_y_data[i1 + y_size[0]] / b_y_data[i1 + (y_size[0] << 1)];
  }

  X_size[0] = 2;
  X_size[1] = y_size[0];
  for (i1 = 0; i1 < z_size_idx_0; i1++) {
    X_data[i1 << 1] = z_data[i1];
    X_data[(i1 << 1) + 1] = c_y_data[i1];
  }

  scalarLB = U_size[1];
  loop_ub = U_size[1] << 1;
  if (loop_ub - 1 >= 0) {
    memcpy(&Utol_data[0], &b_U_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  z_size_idx_0 = U_size[1];
  for (i1 = 0; i1 < z_size_idx_0; i1++) {
    Utol_data[i1 << 1] = 0.0;
    Utol_data[(i1 << 1) + 1] = 5.0;
  }

  Utol_size[0] = U_size[1];
  Utol_size[1] = 2;
  for (i1 = 0; i1 < 2; i1++) {
    for (z_size_idx_0 = 0; z_size_idx_0 < scalarLB; z_size_idx_0++) {
      b_Utol_data[z_size_idx_0 + scalarLB * i1] = Utol_data[i1 + (z_size_idx_0 <<
        1)];
    }
  }

  st.site = &qt_emlrtRSI;
  c_padarray(&st, b_Utol_data, Utol_size, c_tmp_data, tmp_size);
  a_size[0] = tmp_size[0];
  a_size[1] = 3;
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&a_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  st.site = &yd_emlrtRSI;
  dynamic_size_checks(&st, a_size, 3);
  st.site = &md_emlrtRSI;
  e_mtimes(a_data, a_size, M, d_y_data, b_U_size);
  d_y_size[0] = b_U_size[0];
  st.site = &rd_emlrtRSI;
  c_assertCompatibleDims(&st, d_y_size, zp_size);
  if (b_U_size[0] == y_size[0]) {
    tol_size[0] = b_U_size[0];
    loop_ub = b_U_size[0];
    scalarLB = b_U_size[0] / 2 * 2;
    vectorUB = scalarLB - 2;
    for (i1 = 0; i1 <= vectorUB; i1 += 2) {
      r = _mm_loadu_pd(&d_y_data[i1 + b_U_size[0]]);
      r1 = _mm_loadu_pd(&b_y_data[i1 + (y_size[0] << 1)]);
      _mm_storeu_pd(&tol_data[i1], _mm_div_pd(r, r1));
    }

    for (i1 = scalarLB; i1 < loop_ub; i1++) {
      tol_data[i1] = d_y_data[i1 + b_U_size[0]] / b_y_data[i1 + (y_size[0] << 1)];
    }
  } else {
    binary_expand_op_7(tol_data, tol_size, d_y_data, b_U_size, b_y_data, y_size);
  }
}

static void d_padarray(const emlrtStack *sp, real_T varargin_1_data[], int32_T
  varargin_1_size[2], real_T b_data[], int32_T b_size[2])
{
  emlrtStack b_st;
  emlrtStack st;
  real_T varargin_1[2];
  int32_T b_i;
  int32_T i;
  int32_T i1;
  int32_T j;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  if (varargin_1_size[1] == 0) {
    st.site = &cm_emlrtRSI;
    varargin_1[0] = 3.0;
    varargin_1[1] = 0.0;
    b_st.site = &mf_emlrtRSI;
    c_assertValidSizeArg(&b_st, varargin_1);
    b_size[0] = 3;
    b_size[1] = 0;
  } else {
    b_size[0] = 3;
    b_size[1] = (int8_T)varargin_1_size[1];
    i = varargin_1_size[1];
    i1 = (int8_T)varargin_1_size[1];
    for (j = i + 1; j <= i1; j++) {
      for (b_i = 0; b_i < 3; b_i++) {
        b_data[b_i + 3 * (emlrtDynamicBoundsCheckR2012b(j, 1, b_size[1],
          &th_emlrtBCI, (emlrtConstCTX)sp) - 1)] = 0.0;
      }
    }

    i = varargin_1_size[1];
    for (j = 0; j < i; j++) {
      for (b_i = 0; b_i < 1; b_i++) {
        b_data[2 + 3 * (emlrtDynamicBoundsCheckR2012b(j + 1, 1, b_size[1],
          &uh_emlrtBCI, (emlrtConstCTX)sp) - 1)] = 0.0;
      }
    }

    i = varargin_1_size[1];
    for (j = 0; j < i; j++) {
      for (b_i = 0; b_i < 2; b_i++) {
        b_data[b_i + 3 * (emlrtDynamicBoundsCheckR2012b(j + 1, 1, b_size[1],
          &wh_emlrtBCI, (emlrtConstCTX)sp) - 1)] = varargin_1_data[b_i +
          ((emlrtDynamicBoundsCheckR2012b(j + 1, 1, varargin_1_size[1],
             &vh_emlrtBCI, (emlrtConstCTX)sp) - 1) << 1)];
      }
    }
  }
}

static void b_visionDetectionGenerator_cameraToSensor(const emlrtStack *sp,
  visionDetectionGenerator *obj, real_T detCam_data[], int32_T detCam_size[2],
  real_T detSen_data[], int32_T detSen_size[2])
{
  emlrtStack st;
  monoCamera r;
  real_T b_y_data[6300];
  real_T b_detCam_data[300];
  real_T c_tmp_data[300];
  real_T b_dv[9];
  real_T b_monoCamSen_SensorLocation[3];
  real_T monoCamSen_SensorLocation[2];
  real_T t125_SensorLocation[2];
  int32_T b_detCam_size[2];
  int32_T tmp_size[2];
  int32_T y_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  detSen_size[0] = 3;
  detSen_size[1] = detCam_size[1];
  loop_ub = 3 * detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    detSen_data[i] = 0.0;
  }

  r = obj->pMonoCameraInSensorFrame;
  for (i = 0; i < 2; i++) {
    t125_SensorLocation[i] = r.SensorLocation[i];
  }

  for (i = 0; i < 2; i++) {
    monoCamSen_SensorLocation[i] = t125_SensorLocation[i];
  }

  b_detCam_size[0] = 3;
  b_detCam_size[1] = detCam_size[1];
  loop_ub = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detCam_data[i1 + 3 * i] = detCam_data[i1 + 3 * i];
    }
  }

  for (i = 0; i < 2; i++) {
    b_monoCamSen_SensorLocation[i] = monoCamSen_SensorLocation[i];
  }

  b_monoCamSen_SensorLocation[2] = r.Height;
  u_bsxfun(b_detCam_data, b_detCam_size, b_monoCamSen_SensorLocation, c_tmp_data,
           tmp_size);
  rotParentToChild(r.Roll, r.Pitch, r.Yaw, b_dv);
  st.site = &md_emlrtRSI;
  h_mtimes(b_dv, c_tmp_data, tmp_size, b_y_data, y_size);
  b_detCam_size[0] = 3;
  b_detCam_size[1] = detCam_size[1];
  emlrtSubAssignSizeCheckR2012b(&b_detCam_size[0], 2, &y_size[0], 2,
    &bb_emlrtECI, (void *)sp);
  loop_ub = detCam_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detSen_data[i1 + 3 * i] = b_y_data[i1 + 3 * i];
    }
  }
}

static void b_AbstractDetectionGenerator_sensorToEgo(const emlrtStack *sp,
  real_T detCart_data[], int32_T detCart_size[2], real_T detEgo_data[], int32_T
  detEgo_size[2])
{
  coder_array_real_T_2D c_detCart_data;
  coder_array_real_T_2D y;
  emlrtStack st;
  real_T b_detCart_data[300];
  real_T posEgo_data[300];
  int32_T iv[2];
  int32_T posEgo_size[2];
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  detEgo_size[0] = 3;
  detEgo_size[1] = detCart_size[1];
  loop_ub = 3 * detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    detEgo_data[i] = 0.0;
  }

  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      b_detCart_data[i1 + 3 * i] = detCart_data[i1 + 3 * i];
    }
  }

  c_detCart_data.vector.data = &b_detCart_data[0];
  c_detCart_data.vector.numel = 3 * detCart_size[1];
  c_detCart_data.vector.allocated = c_detCart_data.vector.numel;
  c_detCart_data.vector.owner = false;
  c_detCart_data.size[0] = 3;
  c_detCart_data.size[1] = detCart_size[1];
  array_real_T_2D_Constructor(&y);
  st.site = &md_emlrtRSI;
  f_mtimes(&c_detCart_data, &y);
  array_real_T_2D_Reserve(&y, 300);
  v_bsxfun((real_T *)y.vector.data, y.size, posEgo_data, posEgo_size);
  array_real_T_2D_SetSize(&y, y.size[0], y.size[1]);
  array_real_T_2D_Destructor(&y);
  iv[0] = 3;
  iv[1] = detCart_size[1];
  emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &posEgo_size[0], 2, &db_emlrtECI,
    (void *)sp);
  loop_ub = detCart_size[1];
  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      detEgo_data[i1 + 3 * i] = posEgo_data[i1 + 3 * i];
    }
  }
}

static void fitSingleClothoid(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T tol_data[], int32_T tol_size[1], real_T *heading, real_T
  *lateralOffset, real_T *curvature, real_T *derivativeCurvature, real_T
  *curveLength)
{
  coder_array_real_T_2D L0;
  emlrtStack b_st;
  emlrtStack st;
  creal_T a__1_data[100];
  creal_T d_z_data[100];
  creal_T b_z_data;
  creal_T c_z_data;
  creal_T x;
  real_T a__2_data[100];
  real_T dcp_data[100];
  real_T apnd;
  real_T cdiff;
  real_T dk;
  real_T k0;
  real_T l;
  real_T ndbl;
  real_T theta0;
  real_T y;
  int32_T a__1_size[2];
  int32_T a__2_size[2];
  int32_T b_z_size[2];
  int32_T c_z_size[2];
  int32_T dcp_size[2];
  int32_T exitg1;
  int32_T i;
  int32_T idxBreak;
  int32_T k;
  int32_T n;
  int32_T nm1d2;
  boolean_T exitg2;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  idxBreak = z_size[1];
  *heading = rtNaN;
  *lateralOffset = rtNaN;
  *curvature = rtNaN;
  *derivativeCurvature = rtNaN;
  *curveLength = rtNaN;
  array_real_T_2D_Constructor(&L0);
  do {
    exitg1 = 0;
    if (idxBreak > 1) {
      emlrtDynamicBoundsCheckR2012b(1, 1, z_size[1], &gi_emlrtBCI,
        (emlrtConstCTX)sp);
      emlrtDynamicBoundsCheckR2012b(idxBreak, 1, z_size[1], &fi_emlrtBCI,
        (emlrtConstCTX)sp);
      emlrtDynamicBoundsCheckR2012b(2, 1, z_size[1], &ei_emlrtBCI,
        (emlrtConstCTX)sp);
      emlrtDynamicBoundsCheckR2012b(1, 1, z_size[1], &di_emlrtBCI,
        (emlrtConstCTX)sp);
      theta0 = muDoubleScalarAtan2(z_data[1].im - z_data[0].im, z_data[1].re -
        z_data[0].re);
      x.re = z_data[emlrtDynamicBoundsCheckR2012b(idxBreak, 1, z_size[1],
        &hi_emlrtBCI, (emlrtConstCTX)sp) - 1].re -
        z_data[emlrtDynamicBoundsCheckR2012b(idxBreak - 1, 1, z_size[1],
        &ii_emlrtBCI, (emlrtConstCTX)sp) - 1].re;
      x.im = z_data[emlrtDynamicBoundsCheckR2012b(idxBreak, 1, z_size[1],
        &hi_emlrtBCI, (emlrtConstCTX)sp) - 1].im -
        z_data[emlrtDynamicBoundsCheckR2012b(idxBreak - 1, 1, z_size[1],
        &ii_emlrtBCI, (emlrtConstCTX)sp) - 1].im;
      b_z_data.re = z_data[0].re;
      b_z_data.im = z_data[0].im;
      c_z_data.re = z_data[idxBreak - 1].re;
      c_z_data.im = z_data[idxBreak - 1].im;
      st.site = &vt_emlrtRSI;
      clothoidG1fit(&st, b_z_data, theta0, c_z_data, muDoubleScalarAtan2(x.im,
        x.re), &k0, &cdiff, &l);
      dk = (cdiff - k0) / l;
      if (muDoubleScalarIsInf(dk) || muDoubleScalarIsNaN(dk) || (l < 0.1)) {
        idxBreak = 0;
      } else {
        if (muDoubleScalarIsNaN(l)) {
          array_real_T_2D_SetSize(&L0, 1, 1);
          L0.vector.data[0] = rtNaN;
        } else {
          st.site = &pl_emlrtRSI;
          ndbl = muDoubleScalarFloor(l / 0.1 + 0.5);
          apnd = ndbl * 0.1;
          cdiff = apnd - l;
          if (muDoubleScalarAbs(cdiff) < 4.4408920985006262E-16 * l) {
            ndbl++;
            apnd = l;
          } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * 0.1;
          } else {
            ndbl++;
          }

          n = (int32_T)ndbl - 1;
          b_st.site = &yl_emlrtRSI;
          assert_pmaxsize(&b_st, !(ndbl > 2.147483647E+9));
          array_real_T_2D_SetSize(&L0, 1, n + 1);
          if (n + 1 > 0) {
            L0.vector.data[0] = 0.0;
            if (n + 1 > 1) {
              L0.vector.data[n] = apnd;
              nm1d2 = div_nzp_s32(n, 2);
              i = nm1d2 - 2;
              for (k = 0; k <= i; k++) {
                ndbl = (real_T)(k + 1) * 0.1;
                L0.vector.data[k + 1] = ndbl;
                L0.vector.data[(n - k) - 1] = apnd - ndbl;
              }

              if (nm1d2 << 1 == n) {
                L0.vector.data[nm1d2] = apnd / 2.0;
              } else {
                ndbl = (real_T)nm1d2 * 0.1;
                L0.vector.data[nm1d2] = ndbl;
                L0.vector.data[nm1d2 + 1] = apnd - ndbl;
              }
            }
          }
        }

        emlrtDynamicBoundsCheckR2012b(1, 1, z_size[1], &ci_emlrtBCI,
          (emlrtConstCTX)sp);
        emlrtDynamicBoundsCheckR2012b(idxBreak, 1, z_size[1], &bi_emlrtBCI,
          (emlrtConstCTX)sp);
        cdiff = z_data[0].re;
        ndbl = z_data[0].im;
        b_z_size[0] = 1;
        b_z_size[1] = idxBreak;
        for (i = 0; i < idxBreak; i++) {
          d_z_data[i].re = z_data[i].re - cdiff;
          d_z_data[i].im = z_data[i].im - ndbl;
        }

        st.site = &ut_emlrtRSI;
        fresnelgcp(&st, d_z_data, b_z_size, dk, k0, theta0, &L0, a__1_data,
                   a__1_size, a__2_data, a__2_size, dcp_data, dcp_size);
        st.site = &yk_emlrtRSI;
        e_maximum(&st, dcp_data, dcp_size, &ndbl, &n);
        if (ndbl > tol_data[emlrtDynamicBoundsCheckR2012b(n, 1, tol_size[0],
             &ji_emlrtBCI, (emlrtConstCTX)sp) - 1]) {
          if (idxBreak != n) {
            idxBreak = n;
          } else {
            idxBreak = n - 1;
          }
        } else {
          if (idxBreak + 1 > z_size[1]) {
            i = 0;
            nm1d2 = 0;
          } else {
            i = emlrtDynamicBoundsCheckR2012b(idxBreak + 1, 1, z_size[1],
              &ai_emlrtBCI, (emlrtConstCTX)sp) - 1;
            nm1d2 = emlrtDynamicBoundsCheckR2012b(z_size[1], 1, z_size[1],
              &yh_emlrtBCI, (emlrtConstCTX)sp);
          }

          cdiff = z_data[0].re;
          ndbl = z_data[0].im;
          c_z_size[0] = 1;
          c_z_size[1] = nm1d2 - i;
          n = nm1d2 - i;
          for (nm1d2 = 0; nm1d2 < n; nm1d2++) {
            d_z_data[nm1d2].re = z_data[i + nm1d2].re - cdiff;
            d_z_data[nm1d2].im = z_data[i + nm1d2].im - ndbl;
          }

          st.site = &tt_emlrtRSI;
          fresnelgcp(&st, d_z_data, c_z_size, dk, k0, theta0, &L0, a__1_data,
                     a__1_size, a__2_data, a__2_size, dcp_data, dcp_size);
          i = (z_size[1] - idxBreak) - 1;
          n = 1;
          exitg2 = false;
          while ((!exitg2) && (n - 1 <= i)) {
            nm1d2 = idxBreak + n;
            if (dcp_data[emlrtDynamicBoundsCheckR2012b(nm1d2 - idxBreak, 1,
                 dcp_size[1], &ki_emlrtBCI, (emlrtConstCTX)sp) - 1] <
                tol_data[emlrtDynamicBoundsCheckR2012b(nm1d2, 1, tol_size[0],
                 &li_emlrtBCI, (emlrtConstCTX)sp) - 1]) {
              l = a__2_data[emlrtDynamicBoundsCheckR2012b(nm1d2 - idxBreak, 1,
                a__2_size[1], &mi_emlrtBCI, (emlrtConstCTX)sp) - 1];
              n++;
            } else {
              exitg2 = true;
            }
          }

          cdiff = z_data[0].re;
          ndbl = z_data[0].im;
          y = muDoubleScalarHypot(cdiff, ndbl);
          cdiff = -muDoubleScalarHypot(cdiff, ndbl);
          if (muDoubleScalarIsNaN(cdiff)) {
            array_real_T_2D_SetSize(&L0, 1, 1);
            L0.vector.data[0] = rtNaN;
          } else {
            st.site = &pl_emlrtRSI;
            ndbl = muDoubleScalarFloor(y / 0.1 + 0.5);
            apnd = -y + ndbl * 0.1;
            if (muDoubleScalarAbs(apnd) < 4.4408920985006262E-16 *
                muDoubleScalarAbs(cdiff)) {
              ndbl++;
              apnd = 0.0;
            } else if (apnd > 0.0) {
              apnd = -y + (ndbl - 1.0) * 0.1;
            } else {
              ndbl++;
            }

            if (ndbl >= 0.0) {
              n = (int32_T)ndbl - 1;
            } else {
              n = -1;
            }

            b_st.site = &yl_emlrtRSI;
            assert_pmaxsize(&b_st, !(ndbl > 2.147483647E+9));
            array_real_T_2D_SetSize(&L0, 1, n + 1);
            if (n + 1 > 0) {
              L0.vector.data[0] = -y;
              if (n + 1 > 1) {
                L0.vector.data[n] = apnd;
                nm1d2 = div_nzp_s32(n, 2);
                i = nm1d2 - 2;
                for (k = 0; k <= i; k++) {
                  ndbl = (real_T)(k + 1) * 0.1;
                  L0.vector.data[k + 1] = -y + ndbl;
                  L0.vector.data[(n - k) - 1] = apnd - ndbl;
                }

                if (nm1d2 << 1 == n) {
                  L0.vector.data[nm1d2] = (-y + apnd) / 2.0;
                } else {
                  ndbl = (real_T)nm1d2 * 0.1;
                  L0.vector.data[nm1d2] = -y + ndbl;
                  L0.vector.data[nm1d2 + 1] = apnd - ndbl;
                }
              }
            }
          }

          b_z_data.re = -z_data[0].re;
          b_z_data.im = -z_data[0].im;
          st.site = &st_emlrtRSI;
          b_fresnelgcp(&st, b_z_data, dk, k0, theta0, &L0, &x, &ndbl);
          emlrtDynamicBoundsCheckR2012b(1, 1, z_size[1], &xh_emlrtBCI,
            (emlrtConstCTX)sp);
          x.re += z_data[0].re;
          x.im += z_data[0].im;
          *heading = 57.295779513082323 * ((theta0 + ndbl * ndbl * dk / 2.0) +
            ndbl * k0);
          *lateralOffset = muDoubleScalarHypot(x.re, x.im) * muDoubleScalarSign
            (x.im);
          *curvature = 57.295779513082323 * (k0 + dk * ndbl);
          *derivativeCurvature = 57.295779513082323 * dk;
          *curveLength = l - ndbl;
          exitg1 = 1;
        }
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  array_real_T_2D_Destructor(&L0);
}

static void clothoidG1fit(const emlrtStack *sp, creal_T z0, real_T theta0,
  creal_T z1, real_T theta1, real_T *k0, real_T *k1, real_T *l)
{
  emlrtStack st;
  creal_T rsfa;
  real_T d;
  real_T phi;
  real_T phi0;
  real_T x;
  real_T xy;
  real_T y;
  real_T z_im;
  real_T z_re;
  st.prev = sp;
  st.tls = sp->tls;
  z_re = z1.re - z0.re;
  z_im = z1.im - z0.im;
  phi = muDoubleScalarAtan2(z_im, z_re);
  rsfa.re = (theta0 - phi) * 0.0;
  rsfa.im = theta0 - phi;
  if (rsfa.re == 0.0) {
    x = rsfa.im;
    y = rsfa.im;
    rsfa.re = muDoubleScalarCos(x);
    rsfa.im = muDoubleScalarSin(y);
  } else if (rsfa.im == 0.0) {
    rsfa.re = rtNaN;
    rsfa.im = 0.0;
  } else {
    rsfa.re = rtNaN;
    rsfa.im = rtNaN;
  }

  phi0 = muDoubleScalarAtan2(rsfa.im, rsfa.re);
  rsfa.re = (theta1 - phi) * 0.0;
  rsfa.im = theta1 - phi;
  if (rsfa.re == 0.0) {
    x = rsfa.im;
    y = rsfa.im;
    rsfa.re = muDoubleScalarCos(x);
    rsfa.im = muDoubleScalarSin(y);
  } else if (rsfa.im == 0.0) {
    rsfa.re = rtNaN;
    rsfa.im = 0.0;
  } else {
    rsfa.re = rtNaN;
    rsfa.im = rtNaN;
  }

  phi = muDoubleScalarAtan2(rsfa.im, rsfa.re);
  d = phi - phi0;
  st.site = &wt_emlrtRSI;
  x = phi0 / 3.1415926535897931;
  y = phi / 3.1415926535897931;
  xy = x * y;
  phi = (phi0 + phi) * (((xy * (xy * -0.458969738821509 + 0.716228953608281) +
    2.989696028701907) + (x * x + y * y) * (xy * 0.261062141752652 -
    0.502821153340377)) + (muDoubleScalarPower(x, 4.0) + muDoubleScalarPower(y,
    4.0)) * -0.045854475238709);
  st.site = &wt_emlrtRSI;
  findA(&st, &phi, phi0, d);
  st.site = &xt_emlrtRSI;
  rsfa = fresnelg(&st, 2.0 * phi, d - phi, phi0);
  *l = muDoubleScalarHypot(z_re, z_im) / rsfa.re;
  if (*l == 0.0) {
    *k0 = 0.0;
    *k1 = 0.0;
  } else {
    *k0 = (d - phi) / *l;
    *k1 = (d + phi) / *l;
  }
}

static creal_T fresnelr(const emlrtStack *sp, real_T x)
{
  __m128d r;
  __m128d r1;
  emlrtStack st;
  creal_T dcv[1];
  creal_T i_tmp_data[1];
  creal_T j_tmp_data[1];
  creal_T k_tmp_data[1];
  creal_T z;
  real_T b_y_data[1];
  real_T d_tmp_data[1];
  real_T e_tmp_data[1];
  real_T f_tmp_data[1];
  real_T g_tmp_data[1];
  real_T h_tmp_data[1];
  real_T u_data[1];
  real_T x4_data[1];
  real_T x_data[1];
  real_T b_x4_data;
  real_T tmp_data_im;
  real_T x2;
  real_T xabs;
  int32_T b_tmp_size[2];
  int32_T b_x_size[2];
  int32_T c_tmp_size[2];
  int32_T d_tmp_size[2];
  int32_T e_tmp_size[2];
  int32_T f_tmp_size[2];
  int32_T g_tmp_size[2];
  int32_T h_tmp_size[2];
  int32_T i_tmp_size[2];
  int32_T iv[2];
  int32_T tmp_size[2];
  int32_T u_size[2];
  int32_T x4_size[2];
  int32_T x_size[2];
  int32_T y_size[2];
  int32_T c_tmp_data[1];
  int32_T ismall_data[1];
  int32_T i;
  int32_T loop_ub;
  int32_T scalarLB;
  int32_T vectorUB;
  st.prev = sp;
  st.tls = sp->tls;
  xabs = muDoubleScalarAbs(x);
  x2 = xabs * xabs;
  c_eml_find(x2 < 2.5625, c_tmp_data, tmp_size);
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&ismall_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(int32_T));
  }

  x4_size[0] = tmp_size[0];
  x4_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    x4_data[i] = x2 * x2;
  }

  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_set1_pd(-4.9884311457357354E-8),
      r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = -4.9884311457357354E-8 * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &x4_size[0], &lb_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (9.5042806282985963E-6)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 9.5042806282985963E-6) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &x4_size[0], &mb_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_sub_pd(r, _mm_set1_pd
      (0.00064519143568396507)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (e_tmp_data[i] - 0.00064519143568396507) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &x4_size[0], &nb_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.018884331939670384)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 0.018884331939670384) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &x4_size[0], &ob_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_set1_pd(3.99982968972496E-12),
      r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = 3.99982968972496E-12 * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &x4_size[0], &pb_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (9.1543921577465745E-10)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (d_tmp_data[i] + 9.1543921577465745E-10) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &x4_size[0], &qb_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.2500186247959882E-7)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (f_tmp_data[i] + 1.2500186247959882E-7) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &x4_size[0], &rb_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.2226278902417902E-5)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (d_tmp_data[i] + 1.2226278902417902E-5) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &x4_size[0], &sb_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.00086802954294178428)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (f_tmp_data[i] + 0.00086802954294178428) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &x4_size[0], &tb_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_set1_pd(-2991.8191940101983), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = -2991.8191940101983 * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &x4_size[0], &ub_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (708840.04525773856)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (f_tmp_data[i] + 708840.04525773856) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &x4_size[0], &vb_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_sub_pd(r, _mm_set1_pd
      (6.2974148620586254E+7)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (g_tmp_data[i] - 6.2974148620586254E+7) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &x4_size[0], &wb_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (2.5489088057337637E+9)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (f_tmp_data[i] + 2.5489088057337637E+9) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &x4_size[0], &xb_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_sub_pd(r, _mm_set1_pd
      (4.429795180596978E+10)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (g_tmp_data[i] - 4.429795180596978E+10) * x4_data[i];
  }

  iv[0] = tmp_size[0];
  iv[1] = tmp_size[1];
  emlrtSizeEqCheckNDR2012b(&iv[0], &d_tmp_size[0], &yb_emlrtECI, (void *)sp);
  emlrtSizeEqCheckNDR2012b(&x4_size[0], &x4_size[0], &ac_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (281.37626888999432)), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_x4_data = x4_data[i];
    g_tmp_data[i] = (b_x4_data + 281.37626888999432) * b_x4_data;
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &x4_size[0], &bc_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (45584.781080653258)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (g_tmp_data[i] + 45584.781080653258) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &x4_size[0], &cc_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (5.1734388877009638E+6)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (h_tmp_data[i] + 5.1734388877009638E+6) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &x4_size[0], &dc_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (4.1932024589811122E+8)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (g_tmp_data[i] + 4.1932024589811122E+8) * x4_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &x4_size[0], &ec_emlrtECI, (void *)sp);
  x_size[0] = tmp_size[0];
  x_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&x_data[i], _mm_add_pd(_mm_mul_pd(_mm_sub_pd(r, _mm_set1_pd
      (0.20552590095501388)), r1), _mm_set1_pd(1.0)));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    x_data[i] = (e_tmp_data[i] - 0.20552590095501388) * x4_data[i] + 1.0;
  }

  y_size[0] = tmp_size[0];
  y_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&b_y_data[i], _mm_add_pd(_mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.041214209072219982)), r1), _mm_set1_pd(1.0)));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_y_data[i] = (d_tmp_data[i] + 0.041214209072219982) * x4_data[i] + 1.0;
  }

  st.site = &rd_emlrtRSI;
  d_assertCompatibleDims(&st, x_size, y_size);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x_data[i]);
    r1 = _mm_loadu_pd(&b_y_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_div_pd(r, r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = x_data[i] / b_y_data[i];
  }

  x_size[0] = tmp_size[0];
  x_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    _mm_storeu_pd(&x_data[i], _mm_mul_pd(_mm_set1_pd(x2), _mm_add_pd(r,
      _mm_set1_pd(3.1801629787656781E+11))));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    x_data[i] = x2 * (f_tmp_data[i] + 3.1801629787656781E+11);
  }

  y_size[0] = tmp_size[0];
  y_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&b_y_data[i], _mm_add_pd(_mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (2.2441179564534092E+10)), r1), _mm_set1_pd(6.0736638949008459E+11)));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_y_data[i] = (h_tmp_data[i] + 2.2441179564534092E+10) * x4_data[i] +
      6.0736638949008459E+11;
  }

  st.site = &rd_emlrtRSI;
  d_assertCompatibleDims(&st, x_size, y_size);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x_data[i]);
    r1 = _mm_loadu_pd(&b_y_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_div_pd(r, r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = x_data[i] / b_y_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &c_tmp_size[0], &fc_emlrtECI, (void *)
    sp);
  iv[0] = tmp_size[0];
  iv[1] = tmp_size[1];
  emlrtSizeEqCheckNDR2012b(&iv[0], &b_tmp_size[0], &gc_emlrtECI, (void *)sp);
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&c_tmp_data[0], &ismall_data[0], (uint32_T)loop_ub * sizeof(int32_T));
  }

  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    i_tmp_data[i].re = xabs * d_tmp_data[i];
    i_tmp_data[i].im = xabs * e_tmp_data[i];
  }

  emlrtSubAssignSizeCheck1dR2017a(tmp_size[0] * tmp_size[1], tmp_size[0] *
    tmp_size[1], &wd_emlrtECI, (emlrtConstCTX)sp);
  dcv[0].re = rtNaN;
  dcv[0].im = 0.0;
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    scalarLB = c_tmp_data[i];
    dcv[scalarLB - 1].re = i_tmp_data[i].re;
    dcv[scalarLB - 1].im = i_tmp_data[i].im;
  }

  c_eml_find((x2 >= 2.5625) && (x2 <= 1.367076676E+9), c_tmp_data, tmp_size);
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&ismall_data[0], &c_tmp_data[0], (uint32_T)loop_ub * sizeof(int32_T));
  }

  x4_size[0] = tmp_size[0];
  x4_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    x4_data[i] = 1.0 / (3.1415926535897931 * x2);
  }

  u_size[0] = tmp_size[0];
  u_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&u_data[i], _mm_mul_pd(r, r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_x4_data = x4_data[i];
    u_data[i] = b_x4_data * b_x4_data;
  }

  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_set1_pd(0.42154355504367752), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = 0.42154355504367752 * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &u_size[0], &hc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.1434079197807589)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 0.1434079197807589) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &ic_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.011522095507358577)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (e_tmp_data[i] + 0.011522095507358577) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &u_size[0], &jc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.000345017939782574)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 0.000345017939782574) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &kc_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (4.6361374928786735E-6)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (e_tmp_data[i] + 4.6361374928786735E-6) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &u_size[0], &lc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (3.0556898379025758E-8)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 3.0556898379025758E-8) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &mc_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.0230451416490724E-10)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (e_tmp_data[i] + 1.0230451416490724E-10) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &u_size[0], &nc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.7201074326816183E-13)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (d_tmp_data[i] + 1.7201074326816183E-13) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &oc_emlrtECI, (void *)sp);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.3428327623306275E-16)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = (e_tmp_data[i] + 1.3428327623306275E-16) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&u_size[0], &b_tmp_size[0], &pc_emlrtECI, (void *)sp);
  emlrtSizeEqCheckNDR2012b(&u_size[0], &u_size[0], &qc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.75158639835337893)), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_x4_data = u_data[i];
    e_tmp_data[i] = (b_x4_data + 0.75158639835337893) * b_x4_data;
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &rc_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.11688892585919138)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (e_tmp_data[i] + 0.11688892585919138) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &u_size[0], &sc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.0064405152650885865)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (f_tmp_data[i] + 0.0064405152650885865) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &tc_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.00015593440916415301)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (e_tmp_data[i] + 0.00015593440916415301) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &u_size[0], &uc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.8462756734893055E-6)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (f_tmp_data[i] + 1.8462756734893055E-6) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &vc_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.1269922476399903E-8)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (e_tmp_data[i] + 1.1269922476399903E-8) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &u_size[0], &wc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (3.6014002958937136E-11)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (f_tmp_data[i] + 3.6014002958937136E-11) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &xc_emlrtECI, (void *)sp);
  d_tmp_size[0] = tmp_size[0];
  d_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&f_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (5.8875453362157839E-14)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    f_tmp_data[i] = (e_tmp_data[i] + 5.8875453362157839E-14) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&d_tmp_size[0], &u_size[0], &yc_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_set1_pd(0.50444207364338323), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = 0.50444207364338323 * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &ad_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.19710283352552341)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (e_tmp_data[i] + 0.19710283352552341) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &u_size[0], &bd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.018764858409257526)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (g_tmp_data[i] + 0.018764858409257526) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &cd_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.00068407938091539307)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (e_tmp_data[i] + 0.00068407938091539307) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &u_size[0], &dd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.1513882611188428E-5)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (g_tmp_data[i] + 1.1513882611188428E-5) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &ed_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (9.8285244368842225E-8)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (e_tmp_data[i] + 9.8285244368842225E-8) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &u_size[0], &fd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (4.4534441586175015E-10)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (g_tmp_data[i] + 4.4534441586175015E-10) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &gd_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.0826804113902088E-12)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (e_tmp_data[i] + 1.0826804113902088E-12) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&e_tmp_size[0], &u_size[0], &hd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.375554606332618E-15)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (g_tmp_data[i] + 1.375554606332618E-15) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &id_emlrtECI, (void *)sp);
  e_tmp_size[0] = tmp_size[0];
  e_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&g_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (8.3635443563067741E-19)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    g_tmp_data[i] = (e_tmp_data[i] + 8.3635443563067741E-19) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&x4_size[0], &e_tmp_size[0], &jd_emlrtECI, (void *)sp);
  emlrtSizeEqCheckNDR2012b(&u_size[0], &u_size[0], &kd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.4749575992512833)), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_x4_data = u_data[i];
    e_tmp_data[i] = (b_x4_data + 1.4749575992512833) * b_x4_data;
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &ld_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.33774898912002)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (e_tmp_data[i] + 0.33774898912002) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &u_size[0], &md_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.025360374142033879)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (h_tmp_data[i] + 0.025360374142033879) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &nd_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (0.00081467910718430615)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (e_tmp_data[i] + 0.00081467910718430615) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &u_size[0], &od_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.2754507566772912E-5)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (h_tmp_data[i] + 1.2754507566772912E-5) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &pd_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.0431458965757199E-7)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (e_tmp_data[i] + 1.0431458965757199E-7) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &u_size[0], &qd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (4.6068072814652043E-10)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (h_tmp_data[i] + 4.6068072814652043E-10) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &rd_emlrtECI, (void *)sp);
  f_tmp_size[0] = tmp_size[0];
  f_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&h_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.1027321506624028E-12)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    h_tmp_data[i] = (e_tmp_data[i] + 1.1027321506624028E-12) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&f_tmp_size[0], &u_size[0], &sd_emlrtECI, (void *)sp);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&h_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (1.3879653125957886E-15)), r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = (h_tmp_data[i] + 1.3879653125957886E-15) * u_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&c_tmp_size[0], &u_size[0], &td_emlrtECI, (void *)sp);
  x_size[0] = tmp_size[0];
  x_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&d_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&x_data[i], _mm_mul_pd(r1, _mm_add_pd(r, _mm_set1_pd
      (3.763297112699879E-20))));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    x_data[i] = u_data[i] * (d_tmp_data[i] + 3.763297112699879E-20);
  }

  y_size[0] = tmp_size[0];
  y_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&f_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&b_y_data[i], _mm_add_pd(_mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (4.5200143407412973E-17)), r1), _mm_set1_pd(1.2544323709001127E-20)));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_y_data[i] = (f_tmp_data[i] + 4.5200143407412973E-17) * u_data[i] +
      1.2544323709001127E-20;
  }

  st.site = &rd_emlrtRSI;
  d_assertCompatibleDims(&st, x_size, y_size);
  b_tmp_size[0] = tmp_size[0];
  b_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x_data[i]);
    r1 = _mm_loadu_pd(&b_y_data[i]);
    _mm_storeu_pd(&d_tmp_data[i], _mm_div_pd(r, r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    d_tmp_data[i] = x_data[i] / b_y_data[i];
  }

  x_size[0] = tmp_size[0];
  x_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&g_tmp_data[i]);
    r1 = _mm_loadu_pd(&x4_data[i]);
    _mm_storeu_pd(&x_data[i], _mm_mul_pd(r1, _mm_add_pd(r, _mm_set1_pd
      (1.8695871016278324E-22))));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    x_data[i] = x4_data[i] * (g_tmp_data[i] + 1.8695871016278324E-22);
  }

  y_size[0] = tmp_size[0];
  y_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&e_tmp_data[i]);
    r1 = _mm_loadu_pd(&u_data[i]);
    _mm_storeu_pd(&b_y_data[i], _mm_add_pd(_mm_mul_pd(_mm_add_pd(r, _mm_set1_pd
      (8.3915881628311874E-19)), r1), _mm_set1_pd(1.8695871016278324E-22)));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    b_y_data[i] = (e_tmp_data[i] + 8.3915881628311874E-19) * u_data[i] +
      1.8695871016278324E-22;
  }

  st.site = &rd_emlrtRSI;
  d_assertCompatibleDims(&st, x_size, y_size);
  c_tmp_size[0] = tmp_size[0];
  c_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  scalarLB = loop_ub / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x_data[i]);
    r1 = _mm_loadu_pd(&b_y_data[i]);
    _mm_storeu_pd(&e_tmp_data[i], _mm_div_pd(r, r1));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    e_tmp_data[i] = x_data[i] / b_y_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&b_tmp_size[0], &c_tmp_size[0], &ud_emlrtECI, (void *)
    sp);
  g_tmp_size[0] = tmp_size[0];
  g_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x4_data = d_tmp_data[i] - 1.0;
    tmp_data_im = e_tmp_data[i];
    i_tmp_data[i].re = 0.0 * b_x4_data - tmp_data_im;
    i_tmp_data[i].im = 0.0 * tmp_data_im + b_x4_data;
  }

  h_tmp_size[0] = tmp_size[0];
  h_tmp_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    j_tmp_data[i].re = x2 * 0.0;
    j_tmp_data[i].im = x2 * 1.5707963267948966;
  }

  b_exp(j_tmp_data, h_tmp_size, k_tmp_data, b_tmp_size);
  emlrtSizeEqCheckNDR2012b(&g_tmp_size[0], &b_tmp_size[0], &vd_emlrtECI, (void *)
    sp);
  loop_ub = tmp_size[0] * tmp_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&c_tmp_data[0], &ismall_data[0], (uint32_T)loop_ub * sizeof(int32_T));
  }

  b_x_size[0] = tmp_size[0];
  b_x_size[1] = tmp_size[1];
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    j_tmp_data[i].re = i_tmp_data[i].re * k_tmp_data[i].re - i_tmp_data[i].im *
      k_tmp_data[i].im;
    j_tmp_data[i].im = i_tmp_data[i].re * k_tmp_data[i].im + i_tmp_data[i].im *
      k_tmp_data[i].re;
  }

  i_tmp_size[0] = tmp_size[0];
  i_tmp_size[1] = tmp_size[1];
  st.site = &rd_emlrtRSI;
  e_assertCompatibleDims(&st, b_x_size, i_tmp_size);
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x4_data = 3.1415926535897931 * xabs;
    if (j_tmp_data[i].im == 0.0) {
      i_tmp_data[i].re = j_tmp_data[i].re / b_x4_data;
      i_tmp_data[i].im = 0.0;
    } else if (j_tmp_data[i].re == 0.0) {
      i_tmp_data[i].re = 0.0;
      i_tmp_data[i].im = j_tmp_data[i].im / b_x4_data;
    } else {
      i_tmp_data[i].re = j_tmp_data[i].re / b_x4_data;
      i_tmp_data[i].im = j_tmp_data[i].im / b_x4_data;
    }
  }

  emlrtSubAssignSizeCheck1dR2017a(tmp_size[0] * tmp_size[1], tmp_size[0] *
    tmp_size[1], &xd_emlrtECI, (emlrtConstCTX)sp);
  j_tmp_data[0].re = dcv[0].re;
  j_tmp_data[0].im = dcv[0].im;
  loop_ub = tmp_size[0] * tmp_size[1];
  for (i = 0; i < loop_ub; i++) {
    scalarLB = c_tmp_data[i];
    j_tmp_data[scalarLB - 1].re = i_tmp_data[i].re + 0.5;
    j_tmp_data[scalarLB - 1].im = i_tmp_data[i].im + 0.5;
  }

  dcv[0].re = j_tmp_data[0].re;
  dcv[0].im = j_tmp_data[0].im;
  for (scalarLB = 0; scalarLB < 1; scalarLB++) {
    if (x2 > 1.367076676E+9) {
      dcv[0].re = 0.5;
      dcv[0].im = 0.5;
    }
  }

  vectorUB = 0;
  for (scalarLB = 0; scalarLB < 1; scalarLB++) {
    if (x < 0.0) {
      vectorUB++;
    }
  }

  loop_ub = 0;
  for (scalarLB = 0; scalarLB < 1; scalarLB++) {
    if (x < 0.0) {
      loop_ub++;
    }
  }

  for (i = 0; i < vectorUB; i++) {
    i_tmp_data[0].re = -dcv[0].re;
    i_tmp_data[0].im = -dcv[0].im;
  }

  emlrtSubAssignSizeCheck1dR2017a(loop_ub, vectorUB, &yd_emlrtECI,
    (emlrtConstCTX)sp);
  j_tmp_data[0].re = dcv[0].re;
  j_tmp_data[0].im = dcv[0].im;
  for (i = 0; i < vectorUB; i++) {
    j_tmp_data[0].re = i_tmp_data[0].re;
    j_tmp_data[0].im = i_tmp_data[0].im;
  }

  z.re = j_tmp_data[0].re;
  z.im = j_tmp_data[0].im;
  return z;
}

static void c_eml_find(boolean_T x, int32_T i_data[], int32_T i_size[2])
{
  if (x) {
    i_size[0] = 1;
    i_size[1] = 1;
    i_data[0] = 1;
  } else {
    i_size[0] = 0;
    i_size[1] = 0;
  }
}

static void d_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2])
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[15];
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] != y_size[0]) || (x_size[1] != y_size[1])) {
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &hw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &nc_emlrtMCI), &nc_emlrtMCI),
          &nc_emlrtMCI);
  }
}

static void b_exp(creal_T x_data[], int32_T x_size[2], creal_T b_x_data[],
                  int32_T b_x_size[2])
{
  creal_T c_x_data;
  real_T r;
  real_T x_re;
  int32_T k;
  int32_T loop_ub;
  b_x_size[0] = x_size[0];
  b_x_size[1] = x_size[1];
  loop_ub = x_size[0] * x_size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)loop_ub * sizeof(creal_T));
  }

  loop_ub = x_size[0] * x_size[1];
  for (k = 0; k < loop_ub; k++) {
    if (b_x_data[0].re == 0.0) {
      x_re = muDoubleScalarCos(b_x_data[0].im);
      r = muDoubleScalarSin(b_x_data[0].im);
    } else if (b_x_data[0].im == 0.0) {
      x_re = muDoubleScalarExp(b_x_data[0].re);
      r = 0.0;
    } else if (muDoubleScalarIsInf(b_x_data[0].im) && muDoubleScalarIsInf
               (b_x_data[0].re) && (b_x_data[0].re < 0.0)) {
      x_re = 0.0;
      r = 0.0;
    } else {
      r = muDoubleScalarExp(b_x_data[0].re / 2.0);
      x_re = r * (r * muDoubleScalarCos(b_x_data[0].im));
      r *= r * muDoubleScalarSin(b_x_data[0].im);
    }

    c_x_data.re = x_re;
    c_x_data.im = r;
    b_x_data[0] = c_x_data;
  }
}

static void e_assertCompatibleDims(const emlrtStack *sp, int32_T x_size[2],
  int32_T y_size[2])
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[15];
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[0] != y_size[0]) || (x_size[1] != y_size[1])) {
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &hw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &nc_emlrtMCI), &nc_emlrtMCI),
          &nc_emlrtMCI);
  }
}

static creal_T e_power(creal_T a)
{
  creal_T y;
  real_T b_im;
  real_T d;
  real_T r;
  if ((a.im == 0.0) && (a.re >= 0.0)) {
    y.re = muDoubleScalarPower(a.re, 3.0);
    y.im = 0.0;
  } else if (a.re == 0.0) {
    y.re = 0.0;
    y.im = -muDoubleScalarPower(a.im, 3.0);
  } else {
    if (a.im == 0.0) {
      if (a.re < 0.0) {
        r = muDoubleScalarLog(muDoubleScalarAbs(a.re));
        b_im = 3.1415926535897931;
      } else {
        r = muDoubleScalarLog(a.re);
        b_im = 0.0;
      }
    } else if ((muDoubleScalarAbs(a.re) > 8.9884656743115785E+307) ||
               (muDoubleScalarAbs(a.im) > 8.9884656743115785E+307)) {
      r = muDoubleScalarLog(muDoubleScalarHypot(a.re / 2.0, a.im / 2.0)) +
        0.69314718055994529;
      b_im = muDoubleScalarAtan2(a.im, a.re);
    } else {
      r = muDoubleScalarLog(muDoubleScalarHypot(a.re, a.im));
      b_im = muDoubleScalarAtan2(a.im, a.re);
    }

    y.re = 3.0 * r;
    y.im = 3.0 * b_im;
    if (y.re == 0.0) {
      b_im = y.im;
      d = y.im;
      y.re = muDoubleScalarCos(b_im);
      y.im = muDoubleScalarSin(d);
    } else if (y.im == 0.0) {
      b_im = y.re;
      y.re = muDoubleScalarExp(b_im);
      y.im = 0.0;
    } else if (muDoubleScalarIsInf(y.im) && muDoubleScalarIsInf(y.re) && (y.re <
                0.0)) {
      y.re = 0.0;
      y.im = 0.0;
    } else {
      r = muDoubleScalarExp(y.re / 2.0);
      b_im = y.im;
      d = y.im;
      y.re = r * (r * muDoubleScalarCos(b_im));
      y.im = r * (r * muDoubleScalarSin(d));
    }
  }

  return y;
}

static creal_T fresnelg(const emlrtStack *sp, real_T dk, real_T k, real_T theta)
{
  emlrtStack b_st;
  emlrtStack st;
  creal_T d_tmp_data[1];
  creal_T dcv[1];
  creal_T z;
  creal_T z0;
  creal_T z1;
  real_T c_tmp_data[1];
  real_T a;
  real_T a_re;
  real_T y_im;
  real_T y_re;
  int32_T tmp_size[2];
  int32_T b_tmp_size[1];
  int32_T ii_size_idx_0;
  int32_T ii_size_idx_1;
  int32_T loop_ub;
  int8_T ii_data[1];
  int8_T izero_data[1];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &du_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  l_validateattributes(&st, dk);
  st.site = &eu_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &fu_emlrtRSI;
  n_validateattributes(&st, theta);
  if (dk / (k * k) > 1.0E-6) {
    st.site = &gu_emlrtRSI;
    y_re = dk / 3.1415926535897931;
    b_st.site = &gu_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    y_im = 3.1415926535897931 * dk;
    b_st.site = &gu_emlrtRSI;
    d_sqrt(&b_st, &y_im);
    b_st.site = &ou_emlrtRSI;
    z1 = fresnelr(&b_st, y_re + k / y_im);
    st.site = &hu_emlrtRSI;
    y_re = 3.1415926535897931 * dk;
    b_st.site = &hu_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, k / y_re);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = theta - k * k / (2.0 * dk);
    a = 3.1415926535897931 / dk;
    st.site = &iu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    a_re = a * y_re;
    y_re = a * y_im;
    y_im = z1.re - z0.re;
    a = z1.im - z0.im;
    z.re = a_re * y_im - y_re * a;
    z.im = a_re * a + y_re * y_im;
  } else if (dk / (k * k) < -1.0E-6) {
    st.site = &ju_emlrtRSI;
    y_re = -dk / 3.1415926535897931;
    b_st.site = &ju_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    y_im = -3.1415926535897931 * dk;
    b_st.site = &ju_emlrtRSI;
    d_sqrt(&b_st, &y_im);
    b_st.site = &ou_emlrtRSI;
    z1 = fresnelr(&b_st, y_re - k / y_im);
    st.site = &ku_emlrtRSI;
    y_re = -3.1415926535897931 * dk;
    b_st.site = &ku_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, -k / y_re);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = -(theta - k * k / (2.0 * dk));
    a = -3.1415926535897931 / dk;
    st.site = &lu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    a_re = a * y_re;
    y_re = a * y_im;
    y_im = z1.re - z0.re;
    a = z1.im - z0.im;
    z.re = a_re * y_im - y_re * a;
    z.im = -(a_re * a + y_re * y_im);
  } else {
    st.site = &mu_emlrtRSI;
    z = fresnelgsma(1.0, dk, k, theta);
  }

  if ((muDoubleScalarAbs(dk) < 0.001) && (muDoubleScalarAbs(k) < 0.001)) {
    ii_size_idx_0 = 1;
    ii_size_idx_1 = 1;
    ii_data[0] = 1;
  } else {
    ii_size_idx_0 = 0;
    ii_size_idx_1 = 0;
  }

  loop_ub = ii_size_idx_0 * ii_size_idx_1;
  if (loop_ub - 1 >= 0) {
    memcpy(&izero_data[0], &ii_data[0], (uint32_T)loop_ub * sizeof(int8_T));
  }

  if ((ii_size_idx_0 != 0) && (ii_size_idx_1 != 0)) {
    tmp_size[0] = 1;
    tmp_size[1] = 1;
    for (ii_size_idx_0 = 0; ii_size_idx_0 < 1; ii_size_idx_0++) {
      c_tmp_data[0] = 1.0;
    }

    st.site = &nu_emlrtRSI;
    fresnelgzero(&st, c_tmp_data, tmp_size, dk, k, theta, d_tmp_data, b_tmp_size);
    emlrtSubAssignSizeCheck1dR2017a(1, b_tmp_size[0], &ae_emlrtECI,
      (emlrtConstCTX)sp);
    dcv[0].re = z.re;
    dcv[0].im = z.im;
    dcv[izero_data[0] - 1].re = d_tmp_data[0].re;
    dcv[izero_data[0] - 1].im = d_tmp_data[0].im;
    z.re = dcv[0].re;
    z.im = dcv[0].im;
  }

  return z;
}

static void l_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 19 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[19] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '2', ',', ' ', 'd', 'k', ',' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[30];
  char_T e_u[19];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 19; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 19, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void m_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 18 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '3', ',', ' ', 'k', ',' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[30];
  char_T e_u[18];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 18; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 18, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void n_validateattributes(const emlrtStack *sp, real_T a)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 22 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[22] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '4', ',', ' ', 't', 'h', 'e', 't', 'a', ',' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[30];
  char_T e_u[22];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  p = true;
  if ((!!muDoubleScalarIsInf(a)) || (!!muDoubleScalarIsNaN(a))) {
    p = false;
  }

  if (!p) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 22; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 22, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static creal_T fresnelgsma(real_T x, real_T dk, real_T k, real_T theta)
{
  emlrtStack st;
  creal_T z;
  real_T C_im;
  real_T C_re;
  real_T ai;
  real_T br;
  real_T c_im;
  real_T c_re;
  real_T e_im;
  real_T e_re;
  real_T nikx_im;
  real_T nikx_re;
  real_T r;
  real_T s_im;
  real_T s_re;
  real_T t_im;
  int32_T n;
  if (k == 0.0) {
    e_re = theta * 0.0;
    e_im = theta;
    if (e_re == 0.0) {
      e_re = muDoubleScalarCos(e_im);
      e_im = muDoubleScalarSin(e_im);
    } else if (e_im == 0.0) {
      e_re = rtNaN;
      e_im = 0.0;
    } else {
      e_re = rtNaN;
      e_im = rtNaN;
    }

    z.re = x * e_re;
    z.im = x * e_im;
  } else {
    st.site = &pu_emlrtRSI;
    r = 0.0 * dk;
    ai = 0.5 * dk;
    br = k * k;
    if (ai == 0.0) {
      C_re = r / br;
      C_im = 0.0;
    } else if (r == 0.0) {
      C_re = 0.0;
      C_im = ai / br;
    } else {
      C_re = rtNaN;
      C_im = ai / br;
    }

    nikx_re = x * (k * 0.0);
    nikx_im = x * -k;
    if (-nikx_re == 0.0) {
      e_re = muDoubleScalarCos(-nikx_im);
      e_im = muDoubleScalarSin(-nikx_im);
    } else if (-nikx_im == 0.0) {
      e_re = muDoubleScalarExp(-nikx_re);
      e_im = 0.0;
    } else {
      r = muDoubleScalarExp(-nikx_re / 2.0);
      e_re = r * (r * muDoubleScalarCos(-nikx_im));
      e_im = r * (r * muDoubleScalarSin(-nikx_im));
    }

    r = 1.0 - e_re;
    t_im = 0.0 - e_im;
    e_re = -e_re;
    e_im = -e_im;
    c_re = 1.0;
    c_im = 0.0;
    s_re = r - 0.0 * t_im;
    s_im = t_im + 0.0 * r;
    for (n = 0; n < 10; n++) {
      ai = e_re * nikx_re - e_im * nikx_im;
      br = e_re * nikx_im + e_im * nikx_re;
      e_re = ai * nikx_re - br * nikx_im;
      e_im = ai * nikx_im + br * nikx_re;
      r = ((real_T)((((n + 1) << 1) - 1) * ((n + 1) << 1)) * r + 2.0 * ((real_T)
            n + 1.0) * ai) + e_re;
      t_im = ((real_T)((((n + 1) << 1) - 1) * ((n + 1) << 1)) * t_im + 2.0 *
              ((real_T)n + 1.0) * br) + e_im;
      ai = c_re * C_re - c_im * C_im;
      c_im = c_re * C_im + c_im * C_re;
      if (c_im == 0.0) {
        c_re = ai / -((real_T)n + 1.0);
        c_im = 0.0;
      } else if (ai == 0.0) {
        c_re = 0.0;
        c_im /= -((real_T)n + 1.0);
      } else {
        c_re = ai / -((real_T)n + 1.0);
        c_im /= -((real_T)n + 1.0);
      }

      s_re += c_re * r - c_im * t_im;
      s_im += c_re * t_im + c_im * r;
    }

    e_re = theta * 0.0;
    e_im = theta;
    if (e_re == 0.0) {
      e_re = muDoubleScalarCos(e_im);
      e_im = muDoubleScalarSin(e_im);
    } else if (e_im == 0.0) {
      e_re = rtNaN;
      e_im = 0.0;
    } else {
      e_re = rtNaN;
      e_im = rtNaN;
    }

    r = s_re * 0.0 - s_im;
    s_im = s_re + s_im * 0.0;
    if (s_im == 0.0) {
      s_re = r / k;
      s_im = 0.0;
    } else if (r == 0.0) {
      s_re = 0.0;
      s_im /= k;
    } else {
      s_re = r / k;
      s_im /= k;
    }

    z.re = s_re * e_re - s_im * e_im;
    z.im = s_re * e_im + s_im * e_re;
  }

  return z;
}

static void fresnelgzero(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
  real_T dk, real_T k, real_T theta, creal_T z_data[], int32_T z_size[1])
{
  coder_array_creal_T b_y;
  coder_array_creal_T c_y_data;
  coder_array_creal_T z;
  coder_array_creal_T_2D b_A_data;
  coder_array_creal_T_2D b_x;
  coder_array_creal_T_2D c_A_data;
  coder_array_creal_T_2D d_A_data;
  coder_array_creal_T_2D e_A_data;
  coder_array_creal_T_2D x;
  coder_array_real_T b;
  coder_array_real_T b_x_data;
  emlrtStack st;
  creal_T A_data[2990];
  creal_T b_y_data[1];
  creal_T b_z_data;
  creal_T y;
  real_T ai;
  real_T im;
  real_T re;
  int32_T b_i;
  int32_T c_y;
  int32_T i;
  int32_T i1;
  int32_T j;
  int32_T n;
  int32_T x_idx_0;
  y.re = dk * 0.0;
  y.im = dk * 0.5;
  x_idx_0 = x_size[0] * x_size[1];
  b_x_data.vector.data = &x_data[0];
  b_x_data.vector.numel = x_idx_0;
  b_x_data.vector.allocated = x_idx_0;
  b_x_data.vector.owner = false;
  b_x_data.size[0] = x_idx_0;
  array_real_T_Constructor(&b);
  st.site = &qu_emlrtRSI;
  f_power(&b_x_data, &b);
  array_creal_T_Constructor(&b_y);
  array_creal_T_SetSize(&b_y, b.size[0]);
  x_idx_0 = b.size[0];
  for (i = 0; i < x_idx_0; i++) {
    b_y.vector.data[i].re = b.vector.data[i] * y.re;
    b_y.vector.data[i].im = b.vector.data[i] * y.im;
  }

  array_real_T_Destructor(&b);
  array_creal_T_2D_Constructor(&x);
  st.site = &ru_emlrtRSI;
  e_repmat(&b_y, &x);
  array_creal_T_Destructor(&b_y);
  x_idx_0 = x.size[0] * x.size[1];
  if (x_idx_0 - 1 >= 0) {
    memcpy(&A_data[0], &x.vector.data[0], (uint32_T)x_idx_0 * sizeof(creal_T));
  }

  b_A_data.vector.data = &A_data[0];
  b_A_data.vector.numel = x.size[0] * 5;
  b_A_data.vector.allocated = b_A_data.vector.numel;
  b_A_data.vector.owner = false;
  b_A_data.size[0] = x.size[0];
  b_A_data.size[1] = 5;
  x_bsxfun(&b_A_data, &x);
  x_idx_0 = x.size[0] * x.size[1];
  if (x_idx_0 - 1 >= 0) {
    memcpy(&A_data[0], &x.vector.data[0], (uint32_T)x_idx_0 * sizeof(creal_T));
  }

  c_A_data.vector.data = &A_data[0];
  c_A_data.vector.numel = x.size[0] * 5;
  c_A_data.vector.allocated = c_A_data.vector.numel;
  c_A_data.vector.owner = false;
  c_A_data.size[0] = x.size[0];
  c_A_data.size[1] = 5;
  array_creal_T_2D_Constructor(&b_x);
  useConstantDim(&c_A_data, &b_x);
  y.re = k * 0.0;
  y.im = k;
  x_idx_0 = x_size[0] * x_size[1];
  for (i = 0; i < x_idx_0; i++) {
    b_y_data[i].re = x_data[i] * y.re;
    b_y_data[i].im = x_data[i] * y.im;
  }

  c_y_data.vector.data = &b_y_data[0];
  c_y_data.vector.numel = x_idx_0;
  c_y_data.vector.allocated = x_idx_0;
  c_y_data.vector.owner = false;
  c_y_data.size[0] = x_idx_0;
  st.site = &su_emlrtRSI;
  e_repmat(&c_y_data, &x);
  x_idx_0 = x.size[0] * x.size[1];
  if (x_idx_0 - 1 >= 0) {
    memcpy(&A_data[0], &x.vector.data[0], (uint32_T)x_idx_0 * sizeof(creal_T));
  }

  d_A_data.vector.data = &A_data[0];
  d_A_data.vector.numel = x.size[0] * 5;
  d_A_data.vector.allocated = d_A_data.vector.numel;
  d_A_data.vector.owner = false;
  d_A_data.size[0] = x.size[0];
  d_A_data.size[1] = 5;
  x_bsxfun(&d_A_data, &x);
  x_idx_0 = x.size[0] * x.size[1];
  if (x_idx_0 - 1 >= 0) {
    memcpy(&A_data[0], &x.vector.data[0], (uint32_T)x_idx_0 * sizeof(creal_T));
  }

  e_A_data.vector.data = &A_data[0];
  e_A_data.vector.numel = x.size[0] * 5;
  e_A_data.vector.allocated = e_A_data.vector.numel;
  e_A_data.vector.owner = false;
  e_A_data.size[0] = x.size[0];
  e_A_data.size[1] = 5;
  useConstantDim(&e_A_data, &x);
  emlrtDynamicBoundsCheckR2012b(1, 1, x_size[0] * x_size[1], &ni_emlrtBCI,
    (emlrtConstCTX)sp);
  if ((x_size[0] == 0) || (x_size[1] == 0)) {
    n = -1;
  } else {
    n = 0;
  }

  z_size[0] = n + 1;
  for (i = 0; i <= n; i++) {
    z_data[0].re = 1.0;
    z_data[0].im = 0.0;
  }

  array_creal_T_Constructor(&z);
  for (b_i = 0; b_i < 5; b_i++) {
    c_y = (b_i + 1) << 1;
    array_creal_T_SetSize(&z, b_x.size[0]);
    x_idx_0 = b_x.size[0];
    for (i = 0; i < x_idx_0; i++) {
      im = b_x.vector.data[i + b_x.size[0] * b_i].re;
      ai = b_x.vector.data[i + b_x.size[0] * b_i].im;
      if (ai == 0.0) {
        re = im / ((real_T)c_y + 1.0);
        im = 0.0;
      } else if (im == 0.0) {
        re = 0.0;
        im = ai / ((real_T)c_y + 1.0);
      } else {
        re = im / ((real_T)c_y + 1.0);
        im = ai / ((real_T)c_y + 1.0);
      }

      z.vector.data[i].re = re;
      z.vector.data[i].im = im;
    }

    emlrtSizeEqCheck1DR2012b(n + 1, z.size[0], &be_emlrtECI, (emlrtConstCTX)sp);
    x_idx_0 = n + 1;
    for (i = 0; i < x_idx_0; i++) {
      b_z_data = z_data[0];
      b_z_data.re += z.vector.data[0].re;
      b_z_data.im += z.vector.data[0].im;
      z_data[0] = b_z_data;
    }
  }

  for (j = 0; j < 5; j++) {
    array_creal_T_SetSize(&z, x.size[0]);
    x_idx_0 = x.size[0];
    for (i = 0; i < x_idx_0; i++) {
      im = x.vector.data[i + x.size[0] * j].re;
      ai = x.vector.data[i + x.size[0] * j].im;
      if (ai == 0.0) {
        re = im / (((real_T)j + 1.0) + 1.0);
        im = 0.0;
      } else if (im == 0.0) {
        re = 0.0;
        im = ai / (((real_T)j + 1.0) + 1.0);
      } else {
        re = im / (((real_T)j + 1.0) + 1.0);
        im = ai / (((real_T)j + 1.0) + 1.0);
      }

      z.vector.data[i].re = re;
      z.vector.data[i].im = im;
    }

    emlrtSizeEqCheck1DR2012b(n + 1, z.size[0], &ce_emlrtECI, (emlrtConstCTX)sp);
    x_idx_0 = n + 1;
    for (i = 0; i < x_idx_0; i++) {
      b_z_data = z_data[0];
      b_z_data.re += z.vector.data[0].re;
      b_z_data.im += z.vector.data[0].im;
      z_data[0] = b_z_data;
    }
  }

  for (b_i = 0; b_i < 4; b_i++) {
    i = 5 - ((b_i + 1) << 1);
    for (j = 0; j < i; j++) {
      emlrtSizeEqCheck1DR2012b(b_x.size[0], x.size[0], &de_emlrtECI,
        (emlrtConstCTX)sp);
      c_y = ((b_i + 1) << 1) + j;
      array_creal_T_SetSize(&z, b_x.size[0]);
      x_idx_0 = b_x.size[0];
      for (i1 = 0; i1 < x_idx_0; i1++) {
        im = b_x.vector.data[i1 + b_x.size[0] * b_i].re * x.vector.data[i1 +
          x.size[0] * j].re - b_x.vector.data[i1 + b_x.size[0] * b_i].im *
          x.vector.data[i1 + x.size[0] * j].im;
        ai = b_x.vector.data[i1 + b_x.size[0] * b_i].re * x.vector.data[i1 +
          x.size[0] * j].im + b_x.vector.data[i1 + b_x.size[0] * b_i].im *
          x.vector.data[i1 + x.size[0] * j].re;
        if (ai == 0.0) {
          re = im / ((real_T)c_y + 2.0);
          im = 0.0;
        } else if (im == 0.0) {
          re = 0.0;
          im = ai / ((real_T)c_y + 2.0);
        } else {
          re = im / ((real_T)c_y + 2.0);
          im = ai / ((real_T)c_y + 2.0);
        }

        z.vector.data[i1].re = re;
        z.vector.data[i1].im = im;
      }

      emlrtSizeEqCheck1DR2012b(n + 1, z.size[0], &ee_emlrtECI, (emlrtConstCTX)sp);
      x_idx_0 = n + 1;
      for (i1 = 0; i1 < x_idx_0; i1++) {
        b_z_data = z_data[0];
        b_z_data.re += z.vector.data[0].re;
        b_z_data.im += z.vector.data[0].im;
        z_data[0] = b_z_data;
      }
    }
  }

  array_creal_T_Destructor(&z);
  array_creal_T_2D_Destructor(&x);
  array_creal_T_2D_Destructor(&b_x);
  emlrtSizeEqCheck1DR2012b(n + 1, x_size[0] * x_size[1], &fe_emlrtECI,
    (emlrtConstCTX)sp);
  y.re = theta * 0.0;
  y.im = theta;
  d_exp(&y);
  x_idx_0 = n + 1;
  for (i = 0; i < x_idx_0; i++) {
    b_z_data = z_data[0];
    im = x_data[0] * b_z_data.re;
    ai = x_data[0] * b_z_data.im;
    b_z_data.re = im * y.re - ai * y.im;
    b_z_data.im = im * y.im + ai * y.re;
    z_data[0] = b_z_data;
  }
}

static void f_power(coder_array_real_T *a, coder_array_real_T *y)
{
  int32_T k;
  int32_T nx;
  array_real_T_SetSize(y, a->size[0]);
  nx = a->size[0];
  for (k = 0; k < nx; k++) {
    y->vector.data[k] = a->vector.data[k] * a->vector.data[k];
  }
}

static void e_repmat(coder_array_creal_T *a, coder_array_creal_T_2D *b)
{
  int32_T ibtile;
  int32_T jtilecol;
  int32_T k;
  int32_T nrows;
  array_creal_T_2D_SetSize(b, a->size[0], 5);
  nrows = a->size[0];
  for (jtilecol = 0; jtilecol < 5; jtilecol++) {
    ibtile = jtilecol * nrows - 1;
    for (k = 0; k < nrows; k++) {
      b->vector.data[(ibtile + k) + 1].re = a->vector.data[k].re;
      b->vector.data[(ibtile + k) + 1].im = a->vector.data[k].im;
    }
  }
}

static void x_bsxfun(coder_array_creal_T_2D *a, coder_array_creal_T_2D *c)
{
  real_T ai;
  real_T im;
  real_T re;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T k;
  array_creal_T_2D_SetSize(c, a->size[0], 5);
  if (c->size[0] != 0) {
    array_creal_T_2D_SetSize(c, c->size[0], 5);
    for (k = 0; k < 5; k++) {
      array_creal_T_2D_SetSize(c, c->size[0], 5);
      acoef = (a->size[0] != 1);
      i = c->size[0];
      for (b_k = 0; b_k < i; b_k++) {
        array_creal_T_2D_SetSize(c, c->size[0], 5);
        im = a->vector.data[acoef * b_k + a->size[0] * k].re;
        ai = a->vector.data[acoef * b_k + a->size[0] * k].im;
        if (ai == 0.0) {
          re = im / ((real_T)k + 1.0);
          im = 0.0;
        } else if (im == 0.0) {
          re = 0.0;
          im = ai / ((real_T)k + 1.0);
        } else {
          re = im / ((real_T)k + 1.0);
          im = ai / ((real_T)k + 1.0);
        }

        c->vector.data[b_k + c->size[0] * k].re = re;
        c->vector.data[b_k + c->size[0] * k].im = im;
      }
    }
  }
}

static void useConstantDim(coder_array_creal_T_2D *varargin_2,
  coder_array_creal_T_2D *varargout_1)
{
  real_T im;
  real_T re;
  int32_T i;
  int32_T k;
  int32_T loop_ub;
  array_creal_T_2D_SetSize(varargout_1, varargin_2->size[0], 5);
  loop_ub = varargin_2->size[0] * 5;
  for (i = 0; i < loop_ub; i++) {
    varargout_1->vector.data[i].re = varargin_2->vector.data[i].re;
    varargout_1->vector.data[i].im = varargin_2->vector.data[i].im;
  }

  if (varargin_2->size[0] != 0) {
    for (loop_ub = 0; loop_ub < 4; loop_ub++) {
      array_creal_T_2D_SetSize(varargout_1, varargout_1->size[0], 5);
      i = varargout_1->size[0];
      for (k = 0; k < i; k++) {
        array_creal_T_2D_SetSize(varargout_1, varargout_1->size[0], 5);
        re = varargout_1->vector.data[k + varargout_1->size[0] * loop_ub].re *
          varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].re
          - varargout_1->vector.data[k + varargout_1->size[0] * loop_ub].im *
          varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].im;
        im = varargout_1->vector.data[k + varargout_1->size[0] * loop_ub].re *
          varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].im
          + varargout_1->vector.data[k + varargout_1->size[0] * loop_ub].im *
          varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].re;
        varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].re =
          re;
        varargout_1->vector.data[k + varargout_1->size[0] * (loop_ub + 1)].im =
          im;
      }
    }
  }
}

static creal_T dfresnelgsma1(real_T a, real_T d, real_T c)
{
  static real_T s[441] = { -0.16666666666666666, 0.033333333333333333,
    -0.0071428571428571426, 0.0015873015873015873, -0.00036075036075036075,
    8.325008325008325E-5, -1.9425019425019425E-5, 4.5705928058869239E-6,
    -1.0825088224469029E-6, 2.5774019582069117E-7, -6.1633525087556583E-8,
    1.4792046021013581E-8, -3.5610481161699359E-9, 8.5956333838584665E-10,
    -2.0795887219012417E-10, 5.0414272046090711E-11, -1.2243466068336316E-11,
    2.9781403950007255E-12, -7.2544445519248436E-13, 1.7693767199816693E-13,
    -4.3205710604203551E-14, -0.083333333333333329, 0.016666666666666666,
    -0.0035714285714285713, 0.00079365079365079365, -0.00018037518037518038,
    4.1625041625041625E-5, -9.7125097125097125E-6, 2.285296402943462E-6,
    -5.4125441122345144E-7, 1.2887009791034559E-7, -3.0816762543778292E-8,
    7.3960230105067906E-9, -1.780524058084968E-9, 4.2978166919292332E-10,
    -1.0397943609506209E-10, 2.5207136023045356E-11, -6.1217330341681582E-12,
    1.4890701975003627E-12, -3.6272222759624218E-13, 8.8468835999083466E-14,
    -2.1602855302101776E-14, -0.05, 0.0095238095238095247, -0.001984126984126984,
    0.0004329004329004329, -9.7125097125097125E-5, 2.22000222000222E-5,
    -5.1419169066227886E-6, 1.2027875804965589E-6, -2.8351421540276032E-7,
    6.7236572822789E-8, -1.6024716522764712E-8, 3.8349748943368539E-9,
    -9.2096071969912142E-10, 2.2182279700279912E-10, -5.3565164048971382E-11,
    1.2963669954709041E-11, -3.1435926391674324E-12, 7.6362574230787827E-13,
    -1.8578455559807527E-13, 4.5263125394879914E-14, -1.1041459376629797E-14,
    -0.033333333333333333, 0.0059523809523809521, -0.0011904761904761906,
    0.00025252525252525253, -5.55000555000555E-5, 1.2487512487512488E-5,
    -2.856620503679327E-6, 6.6153316927310733E-7, -1.5464411749241471E-7,
    3.6419810279010711E-8, -8.6286935122579223E-9, 2.0544508362518863E-9,
    -4.911790505061981E-10, 1.1784336090773705E-10, -2.8358028025926026E-11,
    6.8419369205408826E-12, -1.6545224416670697E-12, 4.0090351471163614E-13,
    -9.7315719598991807E-14, 2.3660270092778135E-14, -5.7607614138938071E-15,
    -0.023809523809523808, 0.003968253968253968, -0.00075757575757575758,
    0.0001554001554001554, -3.33000333000333E-5, 7.3455955808896989E-6,
    -1.6538329231827684E-6, 3.7801895387034706E-7, -8.74075446696257E-8,
    2.0395093756246E-8, -4.7937186179210676E-9, 1.1334901165527648E-9,
    -2.6935625350339892E-10, 6.4278196858765653E-11, -1.5394358071216984E-11,
    3.69834428137345E-12, -8.9089669935919138E-13, 2.1511895911356084E-13,
    -5.20525942041119E-14, 1.261881071614834E-14, -3.0642347946243654E-15,
    -0.017857142857142856, 0.0027777777777777779, -0.000505050505050505,
    9.99000999000999E-5, -2.0812520812520813E-5, 4.4889750772103715E-6,
    -9.92299753909661E-7, 2.2337483637793235E-7, -5.0987734390614995E-8,
    1.1766400243988075E-8, -2.7392677816691816E-9, 6.4231106604656671E-10,
    -1.515128925956619E-10, 3.592016883283963E-11, -8.5524211506761029E-12,
    2.0438218397063802E-12, -4.8999318464755524E-13, 1.1780323951456904E-13,
    -2.8392324111333764E-14, 6.8580493022545317E-15, -1.6597938470881978E-15,
    -0.013888888888888888, 0.00202020202020202, -0.00034965034965034965,
    6.66000666000666E-5, -1.3466925231631114E-5, 2.8351421540276031E-6,
    -6.14280800039314E-7, 1.3596729170830664E-7, -3.0592640634368993E-8,
    6.972681626067008E-9, -1.6057776651164168E-9, 3.7295481254316779E-10,
    -8.7234695736896248E-11, 2.0525810761622646E-11, -4.854076869302653E-12,
    1.1529251403471888E-12, -2.748742255339944E-13, 6.5750645310457132E-14,
    -1.5773513395185424E-14, 3.7938145076301664E-15, -9.14580283089415E-16,
    -0.011111111111111112, 0.0015151515151515152, -0.00024975024975024975,
    4.5787545787545788E-5, -8.9779501544207429E-6, 1.842842400117942E-6,
    -3.9090596366138161E-7, 8.497955731769165E-8, -1.8826240390380922E-8,
    4.233413844397826E-9, -9.6346659906985E-10, 2.2144191994750586E-10,
    -5.1314526904056617E-11, 1.1973389610946543E-11, -2.8102550295962728E-12,
    6.6293195569963358E-13, -1.5707098601942538E-13, 3.7358321199123371E-14,
    -8.915464092930892E-15, 2.1340206605419689E-15, -5.121649585300725E-16,
    -0.00909090909090909, 0.0011655011655011655, -0.00018315018315018315,
    3.2320620555914674E-5, -6.1428080003931394E-6, 1.228561600078628E-6,
    -2.54938671953075E-7, 5.4386916683322657E-8, -1.1853558764313913E-8,
    2.6276361792814094E-9, -5.9051178652668233E-10, 1.3420722421060961E-10,
    -3.0788716142433968E-11, 7.1193127416438912E-12, -1.657329889249084E-12,
    3.8805773016563919E-13, -9.1320340708968239E-14, 2.158480780393795E-14,
    -5.1216495853007248E-15, 1.2194403774525536E-15, -2.9123105485043336E-16,
    -0.007575757575757576, 0.00091575091575091575, -0.00013736263736263736,
    2.3342670401493929E-5, -4.2999656002751977E-6, 8.3765563641724636E-7,
    -1.699591146353833E-7, 3.5560676292941738E-8, -7.6201449199160868E-9,
    1.6641695802115591E-9, -3.6906986657917642E-10, 8.2892697306553E-11,
    -1.8815326531487428E-11, 4.3090577120476179E-12, -9.9439793354945033E-13,
    2.309867441462138E-13, -5.3962019509844868E-14, 1.2669343711007056E-14,
    -2.9876289247587563E-15, 7.07275418922481E-16, -1.6801791625986542E-16,
    -0.00641025641025641, 0.0007326007326007326, -0.0001050420168067227,
    1.7199862401100791E-5, -3.0714040001965697E-6, 5.8271696446417137E-7,
    -1.1557219795206065E-7, 2.3707117528627826E-8, -4.9925087406346778E-9,
    1.0736577936848769E-9, -2.3486264236856683E-10, 5.2103981164119028E-11,
    -1.1696013789843536E-11, 2.6517278227985343E-12, -6.0634020338381124E-13,
    1.3966640343724555E-13, -3.2377211705906924E-14, 7.5476941257063313E-15,
    -1.7681885473062026E-15, 4.1604436407204769E-16, -9.82746302652043E-17,
    -0.0054945054945054949, 0.00059523809523809529, -8.1699346405228753E-5,
    1.2899896800825593E-5, -2.2337483637793233E-6, 4.1275784982878805E-7,
    -8.0011521659118911E-8, 1.6086972608711739E-8, -3.3283391604231183E-9,
    7.0458792710570044E-10, -1.5196994506201384E-10, 3.32886546326316E-11,
    -7.3869560777959169E-12, 1.657329889249084E-12, -3.7535345923759743E-13,
    8.5704383927400673E-14, -1.9707867994899867E-14, 4.560065200947575E-15,
    -1.0609131283837216E-15, 2.4802644781218229E-16, -5.8236817934935876E-17,
    -0.0047619047619047623, 0.00049019607843137254, -6.4499484004127962E-5,
    9.8284928006290238E-6, -1.6510313993151522E-6, 2.9718565187672741E-7,
    -5.6304404130491086E-8, 1.1094463868077061E-8, -2.2546813667382416E-9,
    4.6972528473713366E-10, -9.98659638978948E-11, 2.1592640842788065E-11,
    -4.735228254997383E-12, 1.0509896858652728E-12, -2.3568705580035185E-13,
    5.3327172221493755E-14, -1.2160173869193534E-14, 2.7918766536413726E-15,
    -6.4486876431167389E-16, 1.4975181754697798E-16, -3.4942090760961527E-17,
    -0.0041666666666666666, 0.0004084967320261438, -5.1599587203302372E-5,
    7.5947444368497E-6, -1.2382735494863641E-6, 2.1717413021760849E-7,
    -4.0217431521779347E-8, 7.7661247076539435E-9, -1.5500934396325411E-9,
    3.1775533967511982E-10, -6.65773092652632E-11, 1.4205684764992148E-11,
    -3.0778983657482986E-12, 6.7563622662767534E-13, -1.4998267187295119E-13,
    3.3619304226593888E-14, -7.60010866824596E-15, 1.730963525257651E-15,
    -3.9684231649949164E-16, 9.15149996120421E-17, -2.1214840819155214E-17,
    -0.0036764705882352941, 0.00034399724802201581, -4.1771094402673352E-5,
    5.9437130375345482E-6, -9.4108789760963673E-7, 1.6086972608711739E-7,
    -2.9122967653702288E-8, 5.5114433409157019E-9, -1.0803681548954074E-9,
    2.1788937577722502E-10, -4.4984668422475133E-11, 9.470456509994766E-12,
    -2.026908679883026E-12, 4.3994917082732348E-13, -9.6655499651457426E-14,
    2.1459130357400356E-14, -4.8082320146045859E-15, 1.0860947609459771E-15,
    -2.4709049895251366E-16, 5.6572908851080563E-17, -1.3026656643340919E-17,
    -0.0032679738562091504, 0.00029239766081871346, -3.4176349965823647E-5,
    4.7054394880481834E-6, -7.2391376739202827E-7, 1.2065229456533805E-7,
    -2.1356842946048342E-8, 3.96134990128316E-9, -7.6261281522028755E-10,
    1.5131206651196181E-10, -3.0778983657482988E-11, 6.392558144246467E-12,
    -1.3512724532553507E-12, 2.8996649895437229E-13, -6.3036195424863544E-14,
    1.3859021689154396E-14, -3.0772684893469351E-15, 6.8925244444648545E-16,
    -1.5557549934047156E-16, 3.5358068031925358E-17, -8.08551102000471E-18,
    -0.0029239766081871343, 0.0002506265664160401, -2.8232636928289102E-5,
    3.7643515904385469E-6, -5.6304404130491083E-7, 9.1529326911635756E-8,
    -1.5845399605132641E-8, 2.880981746387753E-9, -5.4472343944306258E-10,
    1.0632739808948668E-10, -2.1308527147488221E-11, 4.3656494643634406E-12,
    -9.1132328242802724E-13, 1.9331099930291485E-13, -4.1577065067463185E-14,
    9.0507896745498087E-15, -1.9911737284009581E-15, 4.4216194549397185E-16,
    -9.9002590489391E-17, 2.2331411388584433E-17, -5.07057470746058E-18,
    -0.002631578947368421, 0.00021645021645021645, -2.3527197440240918E-5,
    3.0404378230465189E-6, -4.423917467395728E-7, 7.0172483965587417E-8,
    -1.1884049703849482E-8, 2.1183689311674653E-9, -3.9341137293110074E-10,
    7.55484144320037E-11, -1.4915969003241754E-11, 3.01437701110809E-12,
    -6.213567834736549E-13, 1.3027480387805132E-13, -2.7718043378308792E-14,
    5.9735211852028744E-15, -1.3019212839544726E-15, 2.8658644615350026E-16,
    -6.364452245746564E-17, 1.4245900368579726E-17, -3.211363981391701E-18,
    -0.0023809523809523812, 0.00018821757952192734, -1.9762845849802372E-5,
    2.4773937817416078E-6, -3.5086241982793706E-7, 5.4327084360454772E-8,
    -9.0030679574617289E-9, 1.573645491724403E-9, -2.8708397484161407E-10,
    5.4239887284515477E-11, -1.0550319538878315E-11, 2.1030537286800629E-12,
    -4.2804578417074E-13, 8.8697738810588135E-14, -1.8667253703758982E-14,
    3.9823474568019163E-15, -8.5975933846050078E-16, 1.8758385566410926E-16,
    -4.1313111068881204E-17, 9.1753256611191467E-18, -2.0531671356438745E-18,
    -0.0021645021645021645, 0.00016469038208168644, -1.6722408026755853E-5,
    2.0350020350020349E-6, -2.8068993586234967E-7, 4.2443034656605292E-8,
    -6.8846990262942627E-9, 1.1802341187933022E-9, -2.1153556040961035E-10,
    3.932391828127372E-11, -7.5359425277702248E-12, 1.4816969452064079E-12,
    -2.9777098029268875E-13, 6.0979695432279337E-14, -1.2693732518556108E-14,
    2.6804261728474435E-15, -5.7317289230700052E-16, 1.2393933320664362E-16,
    -2.706721070030148E-17, 5.9639616797274445E-18, -1.3246239584799189E-18,
    -0.001976284584980237, 0.00014492753623188405, -1.4245014245014244E-5,
    1.684139615174098E-6, -2.2636285150189488E-7, 3.3439966699143565E-8,
    -5.31105353456986E-9, 8.9315014395168815E-10, -1.5729567312509488E-10,
    2.8773598742395405E-11, -5.4328887990901623E-12, 1.0536511610356679E-12,
    -2.0907324148210059E-13, 4.2312441728520361E-14, -8.7113850617541914E-15,
    1.8206668343869429E-15, -3.8558903664289123E-16, 8.2626222137762407E-17,
    -1.7891885039182335E-17, 3.91079454408357E-18, -8.6205686186788382E-19 };

  creal_T z;
  real_T a2_im;
  real_T a2_re;
  real_T b_tk_re;
  real_T sk_im;
  real_T sk_re;
  real_T sn_im;
  real_T sn_re;
  real_T tk_im;
  real_T tk_re;
  real_T tn_im;
  real_T tn_re;
  int32_T k;
  int32_T n;
  tk_re = 0.0 * a;
  if (a == 0.0) {
    a2_re = tk_re / 2.0;
    a2_im = 0.0;
  } else if (tk_re == 0.0) {
    a2_re = 0.0;
    a2_im = a / 2.0;
  } else {
    a2_re = rtNaN;
    a2_im = a / 2.0;
  }

  tn_re = 1.0;
  tn_im = 0.0;
  sn_re = 0.0;
  sn_im = 0.0;
  for (n = 0; n < 21; n++) {
    tk_re = 1.0;
    tk_im = 0.0;
    sk_re = s[n];
    sk_im = s[n] * 0.0;
    for (k = 0; k < 20; k++) {
      b_tk_re = tk_re * 0.0 - tk_im;
      tk_im = tk_re + tk_im * 0.0;
      tk_re = b_tk_re * d;
      tk_im *= d;
      if (tk_im == 0.0) {
        tk_re /= (real_T)k + 1.0;
        tk_im = 0.0;
      } else if (tk_re == 0.0) {
        tk_re = 0.0;
        tk_im /= (real_T)k + 1.0;
      } else {
        tk_re /= (real_T)k + 1.0;
        tk_im /= (real_T)k + 1.0;
      }

      sk_re += tk_re * s[n + 21 * (k + 1)];
      sk_im += tk_im * s[n + 21 * (k + 1)];
    }

    sn_re += tn_re * sk_re - tn_im * sk_im;
    sn_im += tn_re * sk_im + tn_im * sk_re;
    if (a2_im == 0.0) {
      tk_re = a2_re / ((real_T)n + 1.0);
      b_tk_re = 0.0;
    } else if (a2_re == 0.0) {
      tk_re = 0.0;
      b_tk_re = a2_im / ((real_T)n + 1.0);
    } else {
      tk_re = rtNaN;
      b_tk_re = a2_im / ((real_T)n + 1.0);
    }

    tk_im = tn_re * tk_re - tn_im * b_tk_re;
    tn_im = tn_re * b_tk_re + tn_im * tk_re;
    tn_re = tk_im;
  }

  a2_re = c * 0.0;
  a2_im = c;
  if (a2_re == 0.0) {
    a2_re = muDoubleScalarCos(a2_im);
    a2_im = muDoubleScalarSin(a2_im);
  } else if (a2_im == 0.0) {
    a2_re = rtNaN;
    a2_im = 0.0;
  } else {
    a2_re = rtNaN;
    a2_im = rtNaN;
  }

  tk_re = sn_re * 0.0 - sn_im;
  sn_im = sn_re + sn_im * 0.0;
  z.re = tk_re * a2_re - sn_im * a2_im;
  z.im = tk_re * a2_im + sn_im * a2_re;
  return z;
}

static void fresnelgcp(const emlrtStack *sp, creal_T z_data[], int32_T z_size[2],
  real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0, creal_T
  zcp_data[], int32_T zcp_size[2], real_T x_data[], int32_T x_size[2], real_T
  d_data[], int32_T d_size[2])
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 18 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '1', ',', ' ', 'z', ',' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  creal_T b_zcp_data[100];
  real_T b_d_data[100];
  real_T b_x_data[100];
  int32_T b_d_size[2];
  int32_T b_x_size[2];
  int32_T b_zcp_size[2];
  int32_T b_k;
  char_T c_u[46];
  char_T u[30];
  char_T e_u[18];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tu_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &ib_emlrtRSI;
  p = true;
  b_k = 0;
  exitg1 = false;
  while ((!exitg1) && (b_k <= z_size[1] - 1)) {
    if ((!muDoubleScalarIsInf(z_data[b_k].re)) && (!muDoubleScalarIsInf
         (z_data[b_k].im)) && ((!muDoubleScalarIsNaN(z_data[b_k].re)) &&
         (!muDoubleScalarIsNaN(z_data[b_k].im)))) {
      b_k++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (b_k = 0; b_k < 30; b_k++) {
      u[b_k] = b_u[b_k];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (b_k = 0; b_k < 46; b_k++) {
      c_u[b_k] = d_u[b_k];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (b_k = 0; b_k < 18; b_k++) {
      e_u[b_k] = f_u[b_k];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 18, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &uu_emlrtRSI;
  l_validateattributes(&st, dk);
  st.site = &vu_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &wu_emlrtRSI;
  n_validateattributes(&st, theta);
  st.site = &xu_emlrtRSI;
  fresnelgcp_impl(&st, z_data, z_size, dk, k, theta, x0, b_zcp_data, b_zcp_size,
                  b_x_data, b_x_size, b_d_data, b_d_size);
  zcp_size[0] = 1;
  zcp_size[1] = b_zcp_size[1];
  if (b_zcp_size[1] - 1 >= 0) {
    memcpy(&zcp_data[0], &b_zcp_data[0], (uint32_T)b_zcp_size[1] * sizeof
           (creal_T));
  }

  x_size[0] = 1;
  x_size[1] = b_x_size[1];
  if (b_x_size[1] - 1 >= 0) {
    memcpy(&x_data[0], &b_x_data[0], (uint32_T)b_x_size[1] * sizeof(real_T));
  }

  d_size[0] = 1;
  d_size[1] = b_d_size[1];
  if (b_d_size[1] - 1 >= 0) {
    memcpy(&d_data[0], &b_d_data[0], (uint32_T)b_d_size[1] * sizeof(real_T));
  }
}

static void fresnelgcp_impl(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0,
  creal_T zcp_data[], int32_T zcp_size[2], real_T x_data[], int32_T x_size[2],
  real_T d_data[], int32_T d_size[2])
{
  static cuint8_T uc = { 1U,           /* re */
    0U                                 /* im */
  };

  __m128d r2;
  __m128d r3;
  coder_array_creal_T_2D b_zd_data;
  coder_array_creal_T_2D r;
  coder_array_real_T_2D b_x_data;
  coder_array_real_T_2D d_x_data;
  coder_array_real_T_2D r1;
  emlrtStack st;
  creal_T d_tmp_data[100];
  creal_T zd_data[100];
  creal_T e_tmp_data;
  real_T b_y_data[2100];
  real_T c_x_data[2100];
  real_T c_tmp_data[100];
  real_T im;
  real_T re;
  int32_T b_tmp_size[2];
  int32_T b_x_size[2];
  int32_T tmp_size[2];
  int32_T y_size[2];
  int32_T zd_size[2];
  int32_T i;
  int32_T iter;
  int32_T loop_ub;
  int32_T scalarLB;
  int32_T vectorUB;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &yu_emlrtRSI;
  o_validateattributes(&st, x0);
  st.site = &av_emlrtRSI;
  initializeGuess(&st, z_data, z_size, dk, k, theta, x0, x_data, x_size);
  b_x_data.vector.data = &x_data[0];
  b_x_data.vector.numel = x_size[0] * x_size[1];
  b_x_data.vector.allocated = b_x_data.vector.numel;
  b_x_data.vector.owner = false;
  b_x_data.size[0] = x_size[0];
  b_x_data.size[1] = x_size[1];
  array_creal_T_2D_Constructor(&r);
  st.site = &bv_emlrtRSI;
  b_fresnelg(&st, &b_x_data, dk, k, theta, &r);
  zcp_size[0] = 1;
  zcp_size[1] = r.size[1];
  loop_ub = r.size[0] * r.size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&zcp_data[0], &r.vector.data[0], (uint32_T)loop_ub * sizeof(creal_T));
  }

  if (r.size[1] == z_size[1]) {
    zd_size[0] = 1;
    zd_size[1] = r.size[1];
    loop_ub = r.size[1];
    for (i = 0; i < loop_ub; i++) {
      zd_data[i].re = zcp_data[i].re - z_data[i].re;
      zd_data[i].im = zcp_data[i].im - z_data[i].im;
    }
  } else {
    minus(zd_data, zd_size, zcp_data, zcp_size, z_data, z_size);
  }

  for (iter = 0; iter < 20; iter++) {
    st.site = &cv_emlrtRSI;
    dfresnelg(&st, x_data, x_size, dk, k, theta, d_tmp_data, tmp_size);
    i = tmp_size[0] * tmp_size[1];
    tmp_size[0] = 1;
    loop_ub = i - 1;
    for (i = 0; i <= loop_ub; i++) {
      e_tmp_data = d_tmp_data[i];
      e_tmp_data.im = -e_tmp_data.im;
      d_tmp_data[i] = e_tmp_data;
    }

    if (zd_size[1] == tmp_size[1]) {
      loop_ub = zd_size[0] * zd_size[1] - 1;
      zd_size[0] = 1;
      for (i = 0; i <= loop_ub; i++) {
        re = zd_data[i].re * d_tmp_data[i].re - zd_data[i].im * d_tmp_data[i].im;
        im = zd_data[i].re * d_tmp_data[i].im + zd_data[i].im * d_tmp_data[i].re;
        zd_data[i].re = re;
        zd_data[i].im = im;
      }
    } else {
      times(zd_data, zd_size, d_tmp_data, tmp_size);
    }

    tmp_size[0] = 1;
    tmp_size[1] = zd_size[1];
    loop_ub = zd_size[1];
    for (i = 0; i < loop_ub; i++) {
      d_tmp_data[i].re = zd_data[i].re * 0.0 - zd_data[i].im;
      d_tmp_data[i].im = zd_data[i].re + zd_data[i].im * 0.0;
    }

    b_tmp_size[0] = 1;
    b_tmp_size[1] = x_size[1];
    loop_ub = x_size[1];
    scalarLB = x_size[1] / 2 * 2;
    vectorUB = scalarLB - 2;
    for (i = 0; i <= vectorUB; i += 2) {
      r2 = _mm_loadu_pd(&x_data[i]);
      _mm_storeu_pd(&c_tmp_data[i], _mm_mul_pd(_mm_set1_pd(dk), r2));
    }

    for (i = scalarLB; i < loop_ub; i++) {
      c_tmp_data[i] = dk * x_data[i];
    }

    b_x_size[0] = 1;
    b_x_size[1] = zd_size[1];
    loop_ub = zd_size[1];
    for (i = 0; i < loop_ub; i++) {
      c_x_data[i] = zd_data[i].re;
    }

    if (zd_size[1] == x_size[1]) {
      y_size[0] = 1;
      y_size[1] = zd_size[1];
      loop_ub = zd_size[1];
      for (i = 0; i < loop_ub; i++) {
        b_y_data[i] = 1.0 - d_tmp_data[i].re * (c_tmp_data[i] + k);
      }
    } else {
      binary_expand_op_9(b_y_data, y_size, uc, d_tmp_data, tmp_size, c_tmp_data,
                         b_tmp_size, k);
    }

    st.site = &rd_emlrtRSI;
    assertCompatibleDims(&st, b_x_size, y_size);
    if (zd_size[1] == y_size[1]) {
      loop_ub = zd_size[1] - 1;
      b_x_size[0] = 1;
      scalarLB = zd_size[1] / 2 * 2;
      vectorUB = scalarLB - 2;
      for (i = 0; i <= vectorUB; i += 2) {
        r2 = _mm_loadu_pd(&c_x_data[i]);
        r3 = _mm_loadu_pd(&b_y_data[i]);
        _mm_storeu_pd(&c_x_data[i], _mm_div_pd(r2, r3));
      }

      for (i = scalarLB; i <= loop_ub; i++) {
        c_x_data[i] /= b_y_data[i];
      }
    } else {
      b_rdivide(c_x_data, b_x_size, b_y_data, y_size);
    }

    if (x_size[1] == b_x_size[1]) {
      loop_ub = x_size[0] * x_size[1] - 1;
      x_size[0] = 1;
      scalarLB = (loop_ub + 1) / 2 * 2;
      vectorUB = scalarLB - 2;
      for (i = 0; i <= vectorUB; i += 2) {
        r2 = _mm_loadu_pd(&x_data[i]);
        r3 = _mm_loadu_pd(&c_x_data[i]);
        _mm_storeu_pd(&x_data[i], _mm_sub_pd(r2, r3));
      }

      for (i = scalarLB; i <= loop_ub; i++) {
        x_data[i] -= c_x_data[i];
      }
    } else {
      binary_expand_op_8(x_data, x_size, c_x_data, b_x_size);
    }

    d_x_data.vector.data = &x_data[0];
    d_x_data.vector.numel = x_size[0] * x_size[1];
    d_x_data.vector.allocated = d_x_data.vector.numel;
    d_x_data.vector.owner = false;
    d_x_data.size[0] = x_size[0];
    d_x_data.size[1] = x_size[1];
    st.site = &dv_emlrtRSI;
    b_fresnelg(&st, &d_x_data, dk, k, theta, &r);
    zcp_size[0] = 1;
    zcp_size[1] = r.size[1];
    loop_ub = r.size[0] * r.size[1];
    if (loop_ub - 1 >= 0) {
      memcpy(&zcp_data[0], &r.vector.data[0], (uint32_T)loop_ub * sizeof(creal_T));
    }

    if (r.size[1] == z_size[1]) {
      zd_size[0] = 1;
      zd_size[1] = r.size[1];
      loop_ub = r.size[1];
      for (i = 0; i < loop_ub; i++) {
        zd_data[i].re = zcp_data[i].re - z_data[i].re;
        zd_data[i].im = zcp_data[i].im - z_data[i].im;
      }
    } else {
      minus(zd_data, zd_size, zcp_data, zcp_size, z_data, z_size);
    }
  }

  array_creal_T_2D_Destructor(&r);
  b_zd_data.vector.data = &zd_data[0];
  b_zd_data.vector.numel = zd_size[0] * zd_size[1];
  b_zd_data.vector.allocated = b_zd_data.vector.numel;
  b_zd_data.vector.owner = false;
  b_zd_data.size[0] = zd_size[0];
  b_zd_data.size[1] = zd_size[1];
  array_real_T_2D_Constructor(&r1);
  e_abs(&b_zd_data, &r1);
  d_size[0] = 1;
  d_size[1] = r1.size[1];
  loop_ub = r1.size[0] * r1.size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&d_data[0], &r1.vector.data[0], (uint32_T)loop_ub * sizeof(real_T));
  }

  array_real_T_2D_Destructor(&r1);
}

static void o_validateattributes(const emlrtStack *sp, coder_array_real_T_2D *a)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 18 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '5', ',', ' ', 'x', ',' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[30];
  char_T e_u[18];
  boolean_T b;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ib_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  b = b_all(a);
  if (!b) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 18; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&st, 18, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    b_st.site = &sv_emlrtRSI;
    error(&b_st, y, getString(&b_st, message(&b_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }
}

static void initializeGuess(const emlrtStack *sp, creal_T z_data[], int32_T
  z_size[2], real_T dk, real_T k, real_T theta, coder_array_real_T_2D *x0,
  real_T x_data[], int32_T x_size[2])
{
  coder_array_creal_T_2D r;
  coder_array_creal_T_2D zcp0;
  coder_array_real_T_2D b_x0;
  coder_array_real_T_2D ztest;
  emlrtStack st;
  real_T i_data[100];
  int32_T idx_data[100];
  int32_T i_size[1];
  int32_T z[1];
  int32_T c_x0;
  int32_T i;
  int32_T x0_idx_0;
  st.prev = sp;
  st.tls = sp->tls;
  x0_idx_0 = x0->size[1];
  array_real_T_2D_Constructor(&b_x0);
  array_real_T_2D_SetSize(&b_x0, 1, x0_idx_0);
  for (i = 0; i < x0_idx_0; i++) {
    b_x0.vector.data[i] = x0->vector.data[i];
  }

  array_creal_T_2D_Constructor(&zcp0);
  st.site = &ev_emlrtRSI;
  b_fresnelg(&st, &b_x0, dk, k, theta, &zcp0);
  array_real_T_2D_Destructor(&b_x0);
  z[0] = z_size[1];
  array_creal_T_2D_Constructor(&r);
  y_bsxfun(&zcp0, z_data, z, &r);
  array_creal_T_2D_Destructor(&zcp0);
  array_real_T_2D_Constructor(&ztest);
  d_abs(&r, &ztest);
  array_creal_T_2D_Destructor(&r);
  if ((ztest.size[0] == 1) && (ztest.size[1] == 1)) {
    i_size[0] = 1;
    i_data[0] = 1.0;
  } else {
    st.site = &ol_emlrtRSI;
    d_minimum(&st, &ztest, i_data, i_size, idx_data, z);
    i_size[0] = z[0];
    x0_idx_0 = z[0];
    for (i = 0; i < x0_idx_0; i++) {
      i_data[i] = (real_T)idx_data[i];
    }
  }

  array_real_T_2D_Destructor(&ztest);
  st.site = &fv_emlrtRSI;
  b_indexShapeCheck(&st, x0->size, i_size[0]);
  c_x0 = x0->size[1];
  x_size[0] = 1;
  x_size[1] = i_size[0];
  x0_idx_0 = i_size[0];
  for (i = 0; i < x0_idx_0; i++) {
    x_data[i] = x0->vector.data[emlrtDynamicBoundsCheckR2012b((int32_T)i_data[i],
      1, c_x0, &oi_emlrtBCI, (emlrtConstCTX)sp) - 1];
  }
}

static void b_fresnelg(const emlrtStack *sp, coder_array_real_T_2D *x, real_T dk,
  real_T k, real_T theta, coder_array_creal_T_2D *z)
{
  coder_array_boolean_T_2D r;
  coder_array_boolean_T_2D r1;
  coder_array_boolean_T_2D r2;
  coder_array_creal_T b_y;
  coder_array_creal_T r3;
  coder_array_creal_T r4;
  coder_array_creal_T y;
  coder_array_creal_T_2D A;
  coder_array_creal_T_2D b_A;
  coder_array_creal_T_2D c_A;
  coder_array_creal_T_2D d_x;
  coder_array_creal_T_2D e_x;
  coder_array_creal_T_2D z1;
  coder_array_int32_T_2D ii;
  coder_array_real_T b;
  coder_array_real_T c_x;
  coder_array_real_T_2D b_a;
  coder_array_real_T_2D b_x;
  coder_array_real_T_2D izero;
  emlrtStack b_st;
  emlrtStack st;
  creal_T z0;
  real_T a;
  real_T b_k;
  real_T re;
  real_T y_im;
  real_T y_re;
  int32_T b_i;
  int32_T i;
  int32_T i1;
  int32_T j;
  int32_T loop_ub;
  int32_T nx;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &du_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  l_validateattributes(&st, dk);
  st.site = &eu_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &fu_emlrtRSI;
  n_validateattributes(&st, theta);
  array_creal_T_2D_Constructor(&z1);
  if (dk / (k * k) > 1.0E-6) {
    a = dk / 3.1415926535897931;
    st.site = &gu_emlrtRSI;
    d_sqrt(&st, &a);
    b_k = 3.1415926535897931 * dk;
    st.site = &gu_emlrtRSI;
    d_sqrt(&st, &b_k);
    b_k = k / b_k;
    array_real_T_2D_Constructor(&b_a);
    array_real_T_2D_SetSize(&b_a, 1, x->size[1]);
    loop_ub = x->size[0] * x->size[1];
    for (i = 0; i < loop_ub; i++) {
      b_a.vector.data[i] = a * x->vector.data[i] + b_k;
    }

    st.site = &gu_emlrtRSI;
    fresnel(&st, &b_a, &z1);
    array_real_T_2D_Destructor(&b_a);
    st.site = &hu_emlrtRSI;
    b_k = 3.1415926535897931 * dk;
    b_st.site = &hu_emlrtRSI;
    d_sqrt(&b_st, &b_k);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, k / b_k);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = theta - k * k / (2.0 * dk);
    a = 3.1415926535897931 / dk;
    st.site = &iu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    y_re *= a;
    y_im *= a;
    array_creal_T_2D_SetSize(z, 1, z1.size[1]);
    loop_ub = z1.size[1];
    for (i = 0; i < loop_ub; i++) {
      b_k = z1.vector.data[i].re - z0.re;
      a = z1.vector.data[i].im - z0.im;
      z->vector.data[i].re = y_re * b_k - y_im * a;
      z->vector.data[i].im = y_re * a + y_im * b_k;
    }
  } else if (dk / (k * k) < -1.0E-6) {
    a = -dk / 3.1415926535897931;
    st.site = &ju_emlrtRSI;
    d_sqrt(&st, &a);
    b_k = -3.1415926535897931 * dk;
    st.site = &ju_emlrtRSI;
    d_sqrt(&st, &b_k);
    b_k = k / b_k;
    array_real_T_2D_Constructor(&b_a);
    array_real_T_2D_SetSize(&b_a, 1, x->size[1]);
    loop_ub = x->size[0] * x->size[1];
    for (i = 0; i < loop_ub; i++) {
      b_a.vector.data[i] = a * x->vector.data[i] - b_k;
    }

    st.site = &ju_emlrtRSI;
    fresnel(&st, &b_a, &z1);
    array_real_T_2D_Destructor(&b_a);
    st.site = &ku_emlrtRSI;
    b_k = -3.1415926535897931 * dk;
    b_st.site = &ku_emlrtRSI;
    d_sqrt(&b_st, &b_k);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, -k / b_k);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = -(theta - k * k / (2.0 * dk));
    a = -3.1415926535897931 / dk;
    st.site = &lu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    y_re *= a;
    y_im *= a;
    array_creal_T_2D_SetSize(z, 1, z1.size[1]);
    loop_ub = z1.size[1];
    for (i = 0; i < loop_ub; i++) {
      b_k = z1.vector.data[i].re - z0.re;
      a = z1.vector.data[i].im - z0.im;
      z->vector.data[i].re = y_re * b_k - y_im * a;
      z->vector.data[i].im = -(y_re * a + y_im * b_k);
    }
  } else {
    st.site = &mu_emlrtRSI;
    b_fresnelgsma(&st, x, dk, k, theta, z);
  }

  array_creal_T_2D_Destructor(&z1);
  b_k = muDoubleScalarAbs(dk);
  array_real_T_2D_Constructor(&izero);
  st.site = &gv_emlrtRSI;
  array_real_T_2D_SetSize(&izero, 1, x->size[1]);
  nx = x->size[1];
  for (loop_ub = 0; loop_ub < nx; loop_ub++) {
    izero.vector.data[loop_ub] = x->vector.data[loop_ub] * x->
      vector.data[loop_ub];
  }

  array_boolean_T_2D_Constructor(&r);
  array_boolean_T_2D_SetSize(&r, 1, izero.size[1]);
  loop_ub = izero.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (b_k * izero.vector.data[i] < 0.001);
  }

  array_real_T_2D_Constructor(&b_x);
  array_real_T_2D_SetSize(&b_x, 1, x->size[1]);
  loop_ub = x->size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x.vector.data[i] = k * x->vector.data[i];
  }

  nx = b_x.size[1];
  array_real_T_2D_SetSize(&izero, 1, b_x.size[1]);
  for (loop_ub = 0; loop_ub < nx; loop_ub++) {
    izero.vector.data[loop_ub] = muDoubleScalarAbs(b_x.vector.data[loop_ub]);
  }

  array_boolean_T_2D_Constructor(&r1);
  array_boolean_T_2D_SetSize(&r1, 1, izero.size[1]);
  loop_ub = izero.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (izero.vector.data[i] < 0.001);
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &r1.size[0], &ge_emlrtECI, (void *)sp);
  array_boolean_T_2D_Constructor(&r2);
  array_boolean_T_2D_SetSize(&r2, 1, r.size[1]);
  loop_ub = r.size[0] * r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r.vector.data[i] && r1.vector.data[i]);
  }

  array_boolean_T_2D_Destructor(&r1);
  array_boolean_T_2D_Destructor(&r);
  array_int32_T_2D_Constructor(&ii);
  st.site = &nl_emlrtRSI;
  b_eml_find(&st, &r2, &ii);
  array_boolean_T_2D_Destructor(&r2);
  array_real_T_2D_SetSize(&izero, 1, ii.size[1]);
  loop_ub = ii.size[1];
  for (i = 0; i < loop_ub; i++) {
    izero.vector.data[i] = (real_T)ii.vector.data[i];
  }

  if (izero.size[1] != 0) {
    array_int32_T_2D_SetSize(&ii, 1, izero.size[1]);
    nx = z->size[1];
    loop_ub = izero.size[1];
    for (i = 0; i < loop_ub; i++) {
      i1 = (int32_T)izero.vector.data[i];
      ii.vector.data[i] = emlrtDynamicBoundsCheckR2012b(i1, 1, nx, &pi_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    st.site = &nu_emlrtRSI;
    array_real_T_2D_SetSize(&b_x, 1, izero.size[1]);
    nx = x->size[1];
    loop_ub = izero.size[1];
    for (i = 0; i < loop_ub; i++) {
      i1 = (int32_T)izero.vector.data[i];
      b_x.vector.data[i] = x->vector.data[emlrtDynamicBoundsCheckR2012b(i1, 1,
        nx, &qi_emlrtBCI, &st) - 1];
    }

    y_re = dk * 0.0;
    y_im = dk * 0.5;
    c_x.vector.data = b_x.vector.data;
    c_x.vector.numel = b_x.vector.numel;
    c_x.vector.allocated = b_x.vector.allocated;
    c_x.vector.owner = false;
    c_x.size[0] = izero.size[1];
    array_real_T_Constructor(&b);
    b_st.site = &qu_emlrtRSI;
    f_power(&c_x, &b);
    array_creal_T_Constructor(&y);
    array_creal_T_SetSize(&y, b.size[0]);
    loop_ub = b.size[0];
    for (i = 0; i < loop_ub; i++) {
      y.vector.data[i].re = b.vector.data[i] * y_re;
      y.vector.data[i].im = b.vector.data[i] * y_im;
    }

    array_real_T_Destructor(&b);
    array_creal_T_2D_Constructor(&A);
    b_st.site = &ru_emlrtRSI;
    e_repmat(&y, &A);
    array_creal_T_Destructor(&y);
    array_creal_T_2D_Constructor(&b_A);
    array_creal_T_2D_SetSize(&b_A, A.size[0], 5);
    for (i = 0; i < 5; i++) {
      loop_ub = A.size[0];
      for (i1 = 0; i1 < loop_ub; i1++) {
        b_A.vector.data[i1 + b_A.size[0] * i].re = A.vector.data[i1 + A.size[0] *
          i].re;
        b_A.vector.data[i1 + b_A.size[0] * i].im = A.vector.data[i1 + A.size[0] *
          i].im;
      }
    }

    x_bsxfun(&b_A, &A);
    array_creal_T_2D_Destructor(&b_A);
    array_creal_T_2D_Constructor(&d_x);
    useConstantDim(&A, &d_x);
    y_re = k * 0.0;
    y_im = k;
    nx = izero.size[1];
    array_creal_T_Constructor(&b_y);
    array_creal_T_SetSize(&b_y, izero.size[1]);
    for (i = 0; i < nx; i++) {
      b_y.vector.data[i].re = b_x.vector.data[i] * y_re;
      b_y.vector.data[i].im = b_x.vector.data[i] * y_im;
    }

    b_st.site = &su_emlrtRSI;
    e_repmat(&b_y, &A);
    array_creal_T_Destructor(&b_y);
    array_creal_T_2D_Constructor(&c_A);
    array_creal_T_2D_SetSize(&c_A, A.size[0], 5);
    for (i = 0; i < 5; i++) {
      loop_ub = A.size[0];
      for (i1 = 0; i1 < loop_ub; i1++) {
        c_A.vector.data[i1 + c_A.size[0] * i].re = A.vector.data[i1 + A.size[0] *
          i].re;
        c_A.vector.data[i1 + c_A.size[0] * i].im = A.vector.data[i1 + A.size[0] *
          i].im;
      }
    }

    x_bsxfun(&c_A, &A);
    array_creal_T_2D_Destructor(&c_A);
    array_creal_T_2D_Constructor(&e_x);
    useConstantDim(&A, &e_x);
    array_creal_T_2D_Destructor(&A);
    array_creal_T_Constructor(&r3);
    array_creal_T_SetSize(&r3, izero.size[1]);
    loop_ub = izero.size[1];
    for (i = 0; i < loop_ub; i++) {
      r3.vector.data[i].re = 1.0;
      r3.vector.data[i].im = 0.0;
    }

    array_creal_T_Constructor(&r4);
    for (b_i = 0; b_i < 5; b_i++) {
      nx = (b_i + 1) << 1;
      array_creal_T_SetSize(&r4, d_x.size[0]);
      loop_ub = d_x.size[0];
      for (i = 0; i < loop_ub; i++) {
        b_k = d_x.vector.data[i + d_x.size[0] * b_i].re;
        a = d_x.vector.data[i + d_x.size[0] * b_i].im;
        if (a == 0.0) {
          re = b_k / ((real_T)nx + 1.0);
          b_k = 0.0;
        } else if (b_k == 0.0) {
          re = 0.0;
          b_k = a / ((real_T)nx + 1.0);
        } else {
          re = b_k / ((real_T)nx + 1.0);
          b_k = a / ((real_T)nx + 1.0);
        }

        r4.vector.data[i].re = re;
        r4.vector.data[i].im = b_k;
      }

      emlrtSizeEqCheck1DR2012b(r3.size[0], r4.size[0], &be_emlrtECI, &st);
      array_creal_T_SetSize(&r3, r3.size[0]);
      loop_ub = r3.size[0];
      for (i = 0; i < loop_ub; i++) {
        r3.vector.data[i].re += r4.vector.data[i].re;
        r3.vector.data[i].im += r4.vector.data[i].im;
      }
    }

    for (j = 0; j < 5; j++) {
      array_creal_T_SetSize(&r4, e_x.size[0]);
      loop_ub = e_x.size[0];
      for (i = 0; i < loop_ub; i++) {
        b_k = e_x.vector.data[i + e_x.size[0] * j].re;
        a = e_x.vector.data[i + e_x.size[0] * j].im;
        if (a == 0.0) {
          re = b_k / (((real_T)j + 1.0) + 1.0);
          b_k = 0.0;
        } else if (b_k == 0.0) {
          re = 0.0;
          b_k = a / (((real_T)j + 1.0) + 1.0);
        } else {
          re = b_k / (((real_T)j + 1.0) + 1.0);
          b_k = a / (((real_T)j + 1.0) + 1.0);
        }

        r4.vector.data[i].re = re;
        r4.vector.data[i].im = b_k;
      }

      emlrtSizeEqCheck1DR2012b(r3.size[0], r4.size[0], &ce_emlrtECI, &st);
      array_creal_T_SetSize(&r3, r3.size[0]);
      loop_ub = r3.size[0];
      for (i = 0; i < loop_ub; i++) {
        r3.vector.data[i].re += r4.vector.data[i].re;
        r3.vector.data[i].im += r4.vector.data[i].im;
      }
    }

    for (b_i = 0; b_i < 4; b_i++) {
      i = 5 - ((b_i + 1) << 1);
      for (j = 0; j < i; j++) {
        emlrtSizeEqCheck1DR2012b(d_x.size[0], e_x.size[0], &de_emlrtECI, &st);
        nx = ((b_i + 1) << 1) + j;
        array_creal_T_SetSize(&r4, d_x.size[0]);
        loop_ub = d_x.size[0];
        for (i1 = 0; i1 < loop_ub; i1++) {
          b_k = d_x.vector.data[i1 + d_x.size[0] * b_i].re * e_x.vector.data[i1
            + e_x.size[0] * j].re - d_x.vector.data[i1 + d_x.size[0] * b_i].im *
            e_x.vector.data[i1 + e_x.size[0] * j].im;
          a = d_x.vector.data[i1 + d_x.size[0] * b_i].re * e_x.vector.data[i1 +
            e_x.size[0] * j].im + d_x.vector.data[i1 + d_x.size[0] * b_i].im *
            e_x.vector.data[i1 + e_x.size[0] * j].re;
          if (a == 0.0) {
            re = b_k / ((real_T)nx + 2.0);
            b_k = 0.0;
          } else if (b_k == 0.0) {
            re = 0.0;
            b_k = a / ((real_T)nx + 2.0);
          } else {
            re = b_k / ((real_T)nx + 2.0);
            b_k = a / ((real_T)nx + 2.0);
          }

          r4.vector.data[i1].re = re;
          r4.vector.data[i1].im = b_k;
        }

        emlrtSizeEqCheck1DR2012b(r3.size[0], r4.size[0], &ee_emlrtECI, &st);
        array_creal_T_SetSize(&r3, r3.size[0]);
        loop_ub = r3.size[0];
        for (i1 = 0; i1 < loop_ub; i1++) {
          r3.vector.data[i1].re += r4.vector.data[i1].re;
          r3.vector.data[i1].im += r4.vector.data[i1].im;
        }
      }
    }

    array_creal_T_2D_Destructor(&e_x);
    array_creal_T_2D_Destructor(&d_x);
    array_creal_T_Destructor(&r4);
    emlrtSizeEqCheck1DR2012b(r3.size[0], izero.size[1], &fe_emlrtECI, &st);
    y_re = theta * 0.0;
    y_im = theta;
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    array_creal_T_SetSize(&r3, r3.size[0]);
    loop_ub = r3.size[0];
    for (i = 0; i < loop_ub; i++) {
      re = b_x.vector.data[i] * r3.vector.data[i].re;
      b_k = b_x.vector.data[i] * r3.vector.data[i].im;
      r3.vector.data[i].re = re * y_re - b_k * y_im;
      r3.vector.data[i].im = re * y_im + b_k * y_re;
    }

    emlrtSubAssignSizeCheck1dR2017a(ii.size[1], r3.size[0], &ae_emlrtECI,
      (emlrtConstCTX)sp);
    loop_ub = ii.size[1];
    for (i = 0; i < loop_ub; i++) {
      z->vector.data[ii.vector.data[i] - 1].re = r3.vector.data[i].re;
      z->vector.data[ii.vector.data[i] - 1].im = r3.vector.data[i].im;
    }

    array_creal_T_Destructor(&r3);
  }

  array_real_T_2D_Destructor(&b_x);
  array_int32_T_2D_Destructor(&ii);
  array_real_T_2D_Destructor(&izero);
}

static void fresnel(const emlrtStack *sp, coder_array_real_T_2D *x,
                    coder_array_creal_T_2D *z)
{
  coder_array_boolean_T_2D b_x2;
  coder_array_boolean_T_2D r6;
  coder_array_boolean_T_2D r7;
  coder_array_boolean_T_2D r8;
  coder_array_creal_T_2D c_x;
  coder_array_creal_T_2D r10;
  coder_array_creal_T_2D r5;
  coder_array_creal_T_2D r9;
  coder_array_int32_T_2D ii;
  coder_array_int32_T_2D ismall;
  coder_array_int32_T_2D r11;
  coder_array_int32_T_2D r12;
  coder_array_real_T_2D b_x;
  coder_array_real_T_2D r;
  coder_array_real_T_2D r1;
  coder_array_real_T_2D r2;
  coder_array_real_T_2D r3;
  coder_array_real_T_2D r4;
  coder_array_real_T_2D u;
  coder_array_real_T_2D x2;
  coder_array_real_T_2D x4;
  coder_array_real_T_2D xabs;
  coder_array_real_T_2D y;
  emlrtStack b_st;
  emlrtStack st;
  real_T ai;
  real_T br;
  real_T im;
  real_T re;
  int32_T iv[2];
  int32_T b_i;
  int32_T c_x2;
  int32_T i;
  int32_T loop_ub;
  uint32_T uv[2];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &ou_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  for (i = 0; i < 2; i++) {
    uv[i] = (uint32_T)x->size[i];
  }

  array_creal_T_2D_SetSize(z, 1, (int32_T)uv[1]);
  loop_ub = (int32_T)uv[1];
  for (i = 0; i < loop_ub; i++) {
    z->vector.data[i].re = rtNaN;
    z->vector.data[i].im = 0.0;
  }

  array_real_T_2D_Constructor(&xabs);
  b_abs(x, &xabs);
  array_real_T_2D_Constructor(&x2);
  array_real_T_2D_SetSize(&x2, 1, xabs.size[1]);
  loop_ub = xabs.size[1];
  for (i = 0; i < loop_ub; i++) {
    x2.vector.data[i] = xabs.vector.data[i] * xabs.vector.data[i];
  }

  array_boolean_T_2D_Constructor(&b_x2);
  array_boolean_T_2D_SetSize(&b_x2, 1, x2.size[1]);
  loop_ub = x2.size[0] * x2.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x2.vector.data[i] = (x2.vector.data[i] < 2.5625);
  }

  array_int32_T_2D_Constructor(&ii);
  b_st.site = &nl_emlrtRSI;
  b_eml_find(&b_st, &b_x2, &ii);
  array_boolean_T_2D_Destructor(&b_x2);
  array_int32_T_2D_Constructor(&ismall);
  array_int32_T_2D_SetSize(&ismall, 1, ii.size[1]);
  loop_ub = ii.size[1];
  for (i = 0; i < loop_ub; i++) {
    ismall.vector.data[i] = ii.vector.data[i];
  }

  array_real_T_2D_Constructor(&x4);
  array_real_T_2D_SetSize(&x4, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    x4.vector.data[i] = x2.vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 1,
      x2.size[1], &ri_emlrtBCI, &st) - 1];
  }

  i = x4.size[1];
  array_real_T_2D_SetSize(&x4, 1, x4.size[1]);
  loop_ub = i - 1;
  for (i = 0; i <= loop_ub; i++) {
    x4.vector.data[i] *= x4.vector.data[i];
  }

  array_real_T_2D_Constructor(&r);
  array_real_T_2D_SetSize(&r, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = -4.9884311457357354E-8 * x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &x4.size[0], &lb_emlrtECI, &st);
  array_real_T_2D_Constructor(&r1);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 9.5042806282985963E-6) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &x4.size[0], &mb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r1.vector.data[i] - 0.00064519143568396507) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &x4.size[0], &nb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 0.018884331939670384) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &x4.size[0], &ob_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = 3.99982968972496E-12 * x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &x4.size[0], &pb_emlrtECI, &st);
  array_real_T_2D_Constructor(&r2);
  array_real_T_2D_SetSize(&r2, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r.vector.data[i] + 9.1543921577465745E-10) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &x4.size[0], &qb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r2.vector.data[i] + 1.2500186247959882E-7) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &x4.size[0], &rb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r.vector.data[i] + 1.2226278902417902E-5) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &x4.size[0], &sb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r2.vector.data[i] + 0.00086802954294178428) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &x4.size[0], &tb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = -2991.8191940101983 * x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &x4.size[0], &ub_emlrtECI, &st);
  array_real_T_2D_Constructor(&r3);
  array_real_T_2D_SetSize(&r3, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r2.vector.data[i] + 708840.04525773856) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &x4.size[0], &vb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r3.vector.data[i] - 6.2974148620586254E+7) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &x4.size[0], &wb_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r2.vector.data[i] + 2.5489088057337637E+9) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &x4.size[0], &xb_emlrtECI, &st);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    emlrtDynamicBoundsCheckR2012b(b_i, 1, x2.size[1], &si_emlrtBCI, &st);
  }

  array_real_T_2D_SetSize(&r2, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r3.vector.data[i] - 4.429795180596978E+10) *
      x4.vector.data[i];
  }

  iv[0] = 1;
  iv[1] = ismall.size[1];
  emlrtSizeEqCheckNDR2012b(&iv[0], &r2.size[0], &yb_emlrtECI, &st);
  emlrtSizeEqCheckNDR2012b(&x4.size[0], &x4.size[0], &ac_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (x4.vector.data[i] + 281.37626888999432) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &x4.size[0], &bc_emlrtECI, &st);
  array_real_T_2D_Constructor(&r4);
  array_real_T_2D_SetSize(&r4, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r3.vector.data[i] + 45584.781080653258) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &x4.size[0], &cc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r4.vector.data[i] + 5.1734388877009638E+6) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &x4.size[0], &dc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r4, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r3.vector.data[i] + 4.1932024589811122E+8) *
      x4.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &x4.size[0], &ec_emlrtECI, &st);
  array_real_T_2D_Constructor(&b_x);
  array_real_T_2D_SetSize(&b_x, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x.vector.data[i] = (r1.vector.data[i] - 0.20552590095501388) *
      x4.vector.data[i] + 1.0;
  }

  array_real_T_2D_Constructor(&y);
  array_real_T_2D_SetSize(&y, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    y.vector.data[i] = (r.vector.data[i] + 0.041214209072219982) *
      x4.vector.data[i] + 1.0;
  }

  b_st.site = &rd_emlrtRSI;
  f_assertCompatibleDims(&b_st, &b_x, &y);
  array_real_T_2D_SetSize(&r, 1, b_x.size[1]);
  loop_ub = b_x.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = b_x.vector.data[i] / y.vector.data[i];
  }

  array_real_T_2D_SetSize(&b_x, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x.vector.data[i] = x2.vector.data[ismall.vector.data[i] - 1] *
      (r2.vector.data[i] + 3.1801629787656781E+11);
  }

  array_real_T_2D_SetSize(&y, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    y.vector.data[i] = (r4.vector.data[i] + 2.2441179564534092E+10) *
      x4.vector.data[i] + 6.0736638949008459E+11;
  }

  b_st.site = &rd_emlrtRSI;
  f_assertCompatibleDims(&b_st, &b_x, &y);
  array_real_T_2D_SetSize(&r1, 1, b_x.size[1]);
  loop_ub = b_x.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = b_x.vector.data[i] / y.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &r1.size[0], &fc_emlrtECI, &st);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    emlrtDynamicBoundsCheckR2012b(b_i, 1, xabs.size[1], &ti_emlrtBCI, &st);
  }

  iv[0] = 1;
  iv[1] = ismall.size[1];
  emlrtSizeEqCheckNDR2012b(&iv[0], &r.size[0], &gc_emlrtECI, &st);
  array_int32_T_2D_SetSize(&ii, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    ii.vector.data[i] = emlrtDynamicBoundsCheckR2012b(b_i, 1, (int32_T)uv[1],
      &ui_emlrtBCI, &st);
  }

  array_creal_T_2D_Constructor(&r5);
  array_creal_T_2D_SetSize(&r5, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    re = r.vector.data[i];
    im = r1.vector.data[i];
    r5.vector.data[i].re = xabs.vector.data[ismall.vector.data[i] - 1] * re;
    r5.vector.data[i].im = xabs.vector.data[ismall.vector.data[i] - 1] * im;
  }

  emlrtSubAssignSizeCheck1dR2017a(ii.size[1], r5.size[1], &wd_emlrtECI, &st);
  loop_ub = r5.size[1];
  for (i = 0; i < loop_ub; i++) {
    z->vector.data[ii.vector.data[i] - 1].re = r5.vector.data[i].re;
    z->vector.data[ii.vector.data[i] - 1].im = r5.vector.data[i].im;
  }

  array_boolean_T_2D_Constructor(&r6);
  array_boolean_T_2D_SetSize(&r6, 1, x2.size[1]);
  loop_ub = x2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r6.vector.data[i] = (x2.vector.data[i] >= 2.5625);
  }

  array_boolean_T_2D_Constructor(&r7);
  array_boolean_T_2D_SetSize(&r7, 1, x2.size[1]);
  loop_ub = x2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r7.vector.data[i] = (x2.vector.data[i] <= 1.367076676E+9);
  }

  emlrtSizeEqCheckNDR2012b(&r6.size[0], &r7.size[0], &he_emlrtECI, &st);
  array_boolean_T_2D_Constructor(&r8);
  array_boolean_T_2D_SetSize(&r8, 1, r6.size[1]);
  loop_ub = r6.size[0] * r6.size[1];
  for (i = 0; i < loop_ub; i++) {
    r8.vector.data[i] = (r6.vector.data[i] && r7.vector.data[i]);
  }

  array_boolean_T_2D_Destructor(&r7);
  array_boolean_T_2D_Destructor(&r6);
  b_st.site = &nl_emlrtRSI;
  b_eml_find(&b_st, &r8, &ii);
  array_boolean_T_2D_Destructor(&r8);
  array_int32_T_2D_SetSize(&ismall, 1, ii.size[1]);
  loop_ub = ii.size[1];
  for (i = 0; i < loop_ub; i++) {
    ismall.vector.data[i] = ii.vector.data[i];
  }

  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    emlrtDynamicBoundsCheckR2012b(b_i, 1, x2.size[1], &vi_emlrtBCI, &st);
  }

  array_real_T_2D_SetSize(&x4, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    x4.vector.data[i] = 1.0 / (3.1415926535897931 *
      x2.vector.data[ismall.vector.data[i] - 1]);
  }

  array_real_T_2D_Constructor(&u);
  array_real_T_2D_SetSize(&u, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    u.vector.data[i] = x4.vector.data[i] * x4.vector.data[i];
  }

  array_real_T_2D_SetSize(&r, 1, u.size[1]);
  loop_ub = u.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = 0.42154355504367752 * u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &u.size[0], &hc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 0.1434079197807589) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &ic_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r1.vector.data[i] + 0.011522095507358577) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &u.size[0], &jc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 0.000345017939782574) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &kc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r1.vector.data[i] + 4.6361374928786735E-6) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &u.size[0], &lc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 3.0556898379025758E-8) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &mc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r1.vector.data[i] + 1.0230451416490724E-10) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r.size[0], &u.size[0], &nc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r.vector.data[i] + 1.7201074326816183E-13) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &oc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = (r1.vector.data[i] + 1.3428327623306275E-16) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&u.size[0], &r.size[0], &pc_emlrtECI, &st);
  emlrtSizeEqCheckNDR2012b(&u.size[0], &u.size[0], &qc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, u.size[1]);
  loop_ub = u.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (u.vector.data[i] + 0.75158639835337893) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &rc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r1.vector.data[i] + 0.11688892585919138) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &u.size[0], &sc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r2.vector.data[i] + 0.0064405152650885865) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &tc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r1.vector.data[i] + 0.00015593440916415301) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &u.size[0], &uc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r2.vector.data[i] + 1.8462756734893055E-6) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &vc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r1.vector.data[i] + 1.1269922476399903E-8) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &u.size[0], &wc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r2.vector.data[i] + 3.6014002958937136E-11) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &xc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r2, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r2.vector.data[i] = (r1.vector.data[i] + 5.8875453362157839E-14) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r2.size[0], &u.size[0], &yc_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, u.size[1]);
  loop_ub = u.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = 0.50444207364338323 * u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &ad_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r1.vector.data[i] + 0.19710283352552341) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &u.size[0], &bd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r3.vector.data[i] + 0.018764858409257526) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &cd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r1.vector.data[i] + 0.00068407938091539307) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &u.size[0], &dd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r3.vector.data[i] + 1.1513882611188428E-5) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &ed_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r1.vector.data[i] + 9.8285244368842225E-8) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &u.size[0], &fd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r3.vector.data[i] + 4.4534441586175015E-10) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &gd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r1.vector.data[i] + 1.0826804113902088E-12) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r3.size[0], &u.size[0], &hd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r3.size[1]);
  loop_ub = r3.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r3.vector.data[i] + 1.375554606332618E-15) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &id_emlrtECI, &st);
  array_real_T_2D_SetSize(&r3, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r3.vector.data[i] = (r1.vector.data[i] + 8.3635443563067741E-19) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&x4.size[0], &r3.size[0], &jd_emlrtECI, &st);
  emlrtSizeEqCheckNDR2012b(&u.size[0], &u.size[0], &kd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, u.size[1]);
  loop_ub = u.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (u.vector.data[i] + 1.4749575992512833) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &ld_emlrtECI, &st);
  array_real_T_2D_SetSize(&r4, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r1.vector.data[i] + 0.33774898912002) * u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &u.size[0], &md_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r4.vector.data[i] + 0.025360374142033879) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &nd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r4, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r1.vector.data[i] + 0.00081467910718430615) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &u.size[0], &od_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r4.vector.data[i] + 1.2754507566772912E-5) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &pd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r4, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r1.vector.data[i] + 1.0431458965757199E-7) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &u.size[0], &qd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r4.vector.data[i] + 4.6068072814652043E-10) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &rd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r4, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    r4.vector.data[i] = (r1.vector.data[i] + 1.1027321506624028E-12) *
      u.vector.data[i];
  }

  emlrtSizeEqCheckNDR2012b(&r4.size[0], &u.size[0], &sd_emlrtECI, &st);
  array_real_T_2D_SetSize(&r1, 1, r4.size[1]);
  loop_ub = r4.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = (r4.vector.data[i] + 1.3879653125957886E-15) *
      u.vector.data[i];
  }

  array_real_T_2D_Destructor(&r4);
  emlrtSizeEqCheckNDR2012b(&r1.size[0], &u.size[0], &td_emlrtECI, &st);
  array_real_T_2D_SetSize(&b_x, 1, u.size[1]);
  loop_ub = u.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x.vector.data[i] = u.vector.data[i] * (r.vector.data[i] +
      3.763297112699879E-20);
  }

  array_real_T_2D_SetSize(&y, 1, r2.size[1]);
  loop_ub = r2.size[1];
  for (i = 0; i < loop_ub; i++) {
    y.vector.data[i] = (r2.vector.data[i] + 4.5200143407412973E-17) *
      u.vector.data[i] + 1.2544323709001127E-20;
  }

  array_real_T_2D_Destructor(&r2);
  b_st.site = &rd_emlrtRSI;
  f_assertCompatibleDims(&b_st, &b_x, &y);
  array_real_T_2D_SetSize(&r, 1, b_x.size[1]);
  loop_ub = b_x.size[1];
  for (i = 0; i < loop_ub; i++) {
    r.vector.data[i] = b_x.vector.data[i] / y.vector.data[i];
  }

  array_real_T_2D_SetSize(&b_x, 1, x4.size[1]);
  loop_ub = x4.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_x.vector.data[i] = x4.vector.data[i] * (r3.vector.data[i] +
      1.8695871016278324E-22);
  }

  array_real_T_2D_Destructor(&r3);
  array_real_T_2D_Destructor(&x4);
  array_real_T_2D_SetSize(&y, 1, r1.size[1]);
  loop_ub = r1.size[1];
  for (i = 0; i < loop_ub; i++) {
    y.vector.data[i] = (r1.vector.data[i] + 8.3915881628311874E-19) *
      u.vector.data[i] + 1.8695871016278324E-22;
  }

  array_real_T_2D_Destructor(&u);
  b_st.site = &rd_emlrtRSI;
  f_assertCompatibleDims(&b_st, &b_x, &y);
  array_real_T_2D_SetSize(&r1, 1, b_x.size[1]);
  loop_ub = b_x.size[1];
  for (i = 0; i < loop_ub; i++) {
    r1.vector.data[i] = b_x.vector.data[i] / y.vector.data[i];
  }

  array_real_T_2D_Destructor(&b_x);
  emlrtSizeEqCheckNDR2012b(&r.size[0], &r1.size[0], &ud_emlrtECI, &st);
  array_creal_T_2D_SetSize(&r5, 1, r.size[1]);
  loop_ub = r.size[1];
  for (i = 0; i < loop_ub; i++) {
    re = r.vector.data[i] - 1.0;
    im = r1.vector.data[i];
    r5.vector.data[i].re = 0.0 * re - im;
    r5.vector.data[i].im = 0.0 * im + re;
  }

  array_real_T_2D_Destructor(&r1);
  array_real_T_2D_Destructor(&r);
  c_x2 = x2.size[1];
  array_creal_T_2D_Constructor(&r9);
  array_creal_T_2D_SetSize(&r9, 1, ismall.size[1]);
  loop_ub = ismall.size[0] * ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    r9.vector.data[i].re = x2.vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 1,
      c_x2, &cj_emlrtBCI, &st) - 1] * 0.0;
    b_i = ismall.vector.data[i];
    r9.vector.data[i].im = x2.vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 1,
      c_x2, &cj_emlrtBCI, &st) - 1] * 1.5707963267948966;
  }

  array_creal_T_2D_Constructor(&r10);
  c_exp(&r9, &r10);
  array_creal_T_2D_Destructor(&r9);
  emlrtSizeEqCheckNDR2012b(&r5.size[0], &r10.size[0], &vd_emlrtECI, &st);
  array_int32_T_2D_SetSize(&ii, 1, ismall.size[1]);
  c_x2 = z->size[1];
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    ii.vector.data[i] = emlrtDynamicBoundsCheckR2012b(b_i, 1, c_x2, &wi_emlrtBCI,
      &st);
  }

  array_creal_T_2D_Constructor(&c_x);
  array_creal_T_2D_SetSize(&c_x, 1, r5.size[1]);
  loop_ub = r5.size[1];
  for (i = 0; i < loop_ub; i++) {
    re = r5.vector.data[i].re * r10.vector.data[i].re - r5.vector.data[i].im *
      r10.vector.data[i].im;
    im = r5.vector.data[i].re * r10.vector.data[i].im + r5.vector.data[i].im *
      r10.vector.data[i].re;
    c_x.vector.data[i].re = re;
    c_x.vector.data[i].im = im;
  }

  array_creal_T_2D_Destructor(&r10);
  array_real_T_2D_SetSize(&y, 1, ismall.size[1]);
  loop_ub = ismall.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = ismall.vector.data[i];
    y.vector.data[i] = 3.1415926535897931 *
      xabs.vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 1, xabs.size[1],
      &xi_emlrtBCI, &st) - 1];
  }

  array_int32_T_2D_Destructor(&ismall);
  array_real_T_2D_Destructor(&xabs);
  b_st.site = &rd_emlrtRSI;
  g_assertCompatibleDims(&b_st, &c_x, &y);
  array_creal_T_2D_SetSize(&r5, 1, c_x.size[1]);
  loop_ub = c_x.size[1];
  for (i = 0; i < loop_ub; i++) {
    im = c_x.vector.data[i].re;
    ai = c_x.vector.data[i].im;
    br = y.vector.data[i];
    if (ai == 0.0) {
      re = im / br;
      im = 0.0;
    } else if (im == 0.0) {
      re = 0.0;
      im = ai / br;
    } else {
      re = im / br;
      im = ai / br;
    }

    r5.vector.data[i].re = re;
    r5.vector.data[i].im = im;
  }

  array_creal_T_2D_Destructor(&c_x);
  array_real_T_2D_Destructor(&y);
  emlrtSubAssignSizeCheck1dR2017a(ii.size[1], r5.size[1], &xd_emlrtECI, &st);
  loop_ub = r5.size[1];
  for (i = 0; i < loop_ub; i++) {
    z->vector.data[ii.vector.data[i] - 1].re = r5.vector.data[i].re + 0.5;
    z->vector.data[ii.vector.data[i] - 1].im = r5.vector.data[i].im + 0.5;
  }

  array_int32_T_2D_Destructor(&ii);
  loop_ub = x2.size[1];
  for (b_i = 0; b_i < loop_ub; b_i++) {
    if (x2.vector.data[b_i] > 1.367076676E+9) {
      z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0, z->size[1] - 1,
        &yi_emlrtBCI, &st)].re = 0.5;
      z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0, z->size[1] - 1,
        &yi_emlrtBCI, &st)].im = 0.5;
    }
  }

  array_real_T_2D_Destructor(&x2);
  loop_ub = x->size[1];
  c_x2 = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    if (x->vector.data[b_i] < 0.0) {
      c_x2++;
    }
  }

  array_int32_T_2D_Constructor(&r11);
  array_int32_T_2D_SetSize(&r11, 1, c_x2);
  c_x2 = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    if (x->vector.data[b_i] < 0.0) {
      r11.vector.data[c_x2] = b_i;
      c_x2++;
    }
  }

  loop_ub = x->size[1];
  c_x2 = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    if (x->vector.data[b_i] < 0.0) {
      c_x2++;
    }
  }

  array_int32_T_2D_Constructor(&r12);
  array_int32_T_2D_SetSize(&r12, 1, c_x2);
  c_x2 = 0;
  for (b_i = 0; b_i < loop_ub; b_i++) {
    if (x->vector.data[b_i] < 0.0) {
      r12.vector.data[c_x2] = b_i;
      c_x2++;
    }
  }

  array_creal_T_2D_SetSize(&r5, 1, r12.size[1]);
  c_x2 = z->size[1];
  loop_ub = r12.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = r12.vector.data[i];
    r5.vector.data[i].re = -z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0,
      c_x2 - 1, &aj_emlrtBCI, &st)].re;
    b_i = r12.vector.data[i];
    r5.vector.data[i].im = -z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0,
      c_x2 - 1, &aj_emlrtBCI, &st)].im;
  }

  array_int32_T_2D_Destructor(&r12);
  emlrtSubAssignSizeCheck1dR2017a(r11.size[1], r5.size[1], &yd_emlrtECI, &st);
  c_x2 = z->size[1];
  loop_ub = r5.size[1];
  for (i = 0; i < loop_ub; i++) {
    b_i = r11.vector.data[i];
    z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0, c_x2 - 1, &bj_emlrtBCI,
      &st)].re = r5.vector.data[i].re;
    b_i = r11.vector.data[i];
    z->vector.data[emlrtDynamicBoundsCheckR2012b(b_i, 0, c_x2 - 1, &bj_emlrtBCI,
      &st)].im = r5.vector.data[i].im;
  }

  array_int32_T_2D_Destructor(&r11);
  array_creal_T_2D_Destructor(&r5);
}

static void f_assertCompatibleDims(const emlrtStack *sp, coder_array_real_T_2D
  *x, coder_array_real_T_2D *y)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T i;
  char_T u[15];
  st.prev = sp;
  st.tls = sp->tls;
  if (x->size[1] != y->size[1]) {
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &hw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &nc_emlrtMCI),
           &nc_emlrtMCI), &nc_emlrtMCI);
  }
}

static void c_exp(coder_array_creal_T_2D *x, coder_array_creal_T_2D *b_x)
{
  real_T r;
  real_T x_re;
  int32_T k;
  int32_T nx;
  array_creal_T_2D_SetSize(b_x, 1, x->size[1]);
  nx = x->size[1];
  for (k = 0; k < nx; k++) {
    b_x->vector.data[k].re = x->vector.data[k].re;
    b_x->vector.data[k].im = x->vector.data[k].im;
  }

  array_creal_T_2D_SetSize(b_x, 1, b_x->size[1]);
  nx = b_x->size[1];
  for (k = 0; k < nx; k++) {
    if (b_x->vector.data[k].re == 0.0) {
      x_re = muDoubleScalarCos(b_x->vector.data[k].im);
      r = muDoubleScalarSin(b_x->vector.data[k].im);
    } else if (b_x->vector.data[k].im == 0.0) {
      x_re = muDoubleScalarExp(b_x->vector.data[k].re);
      r = 0.0;
    } else if (muDoubleScalarIsInf(b_x->vector.data[k].im) &&
               muDoubleScalarIsInf(b_x->vector.data[k].re) && (b_x->
                vector.data[k].re < 0.0)) {
      x_re = 0.0;
      r = 0.0;
    } else {
      r = muDoubleScalarExp(b_x->vector.data[k].re / 2.0);
      x_re = r * (r * muDoubleScalarCos(b_x->vector.data[k].im));
      r *= r * muDoubleScalarSin(b_x->vector.data[k].im);
    }

    b_x->vector.data[k].re = x_re;
    b_x->vector.data[k].im = r;
  }
}

static void g_assertCompatibleDims(const emlrtStack *sp, coder_array_creal_T_2D *
  x, coder_array_real_T_2D *y)
{
  static const int32_T iv[2] = { 1, 15 };

  static const int32_T iv1[2] = { 1, 15 };

  static char_T b_u[15] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'd', 'i', 'm',
    'a', 'g', 'r', 'e', 'e' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T i;
  char_T u[15];
  st.prev = sp;
  st.tls = sp->tls;
  if (x->size[1] != y->size[1]) {
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 15; i++) {
      u[i] = b_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 15, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &hw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, c_y, &nc_emlrtMCI),
           &nc_emlrtMCI), &nc_emlrtMCI);
  }
}

static void b_fresnelgsma(const emlrtStack *sp, coder_array_real_T_2D *x, real_T
  dk, real_T k, real_T theta, coder_array_creal_T_2D *z)
{
  coder_array_creal_T_2D b_nikx;
  coder_array_creal_T_2D e;
  coder_array_creal_T_2D m;
  coder_array_creal_T_2D nikx;
  coder_array_creal_T_2D r;
  coder_array_creal_T_2D s;
  coder_array_creal_T_2D t;
  emlrtStack st;
  real_T C_im;
  real_T C_re;
  real_T ai;
  real_T ar;
  real_T c_im;
  real_T c_re;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T n;
  st.prev = sp;
  st.tls = sp->tls;
  if (k == 0.0) {
    c_re = theta * 0.0;
    c_im = theta;
    if (c_re == 0.0) {
      c_re = muDoubleScalarCos(c_im);
      c_im = muDoubleScalarSin(c_im);
    } else if (c_im == 0.0) {
      c_re = rtNaN;
      c_im = 0.0;
    } else {
      c_re = rtNaN;
      c_im = rtNaN;
    }

    array_creal_T_2D_SetSize(z, 1, x->size[1]);
    loop_ub = x->size[1];
    for (i = 0; i < loop_ub; i++) {
      z->vector.data[i].re = x->vector.data[i] * c_re;
      z->vector.data[i].im = x->vector.data[i] * c_im;
    }
  } else {
    st.site = &pu_emlrtRSI;
    ar = 0.0 * dk;
    ai = 0.5 * dk;
    C_im = k * k;
    if (ai == 0.0) {
      C_re = ar / C_im;
      C_im = 0.0;
    } else if (ar == 0.0) {
      C_re = 0.0;
      C_im = ai / C_im;
    } else {
      C_re = rtNaN;
      C_im = ai / C_im;
    }

    c_re = k * 0.0;
    c_im = -k;
    array_creal_T_2D_Constructor(&nikx);
    array_creal_T_2D_SetSize(&nikx, 1, x->size[1]);
    loop_ub = x->size[1];
    for (i = 0; i < loop_ub; i++) {
      nikx.vector.data[i].re = x->vector.data[i] * c_re;
      nikx.vector.data[i].im = x->vector.data[i] * c_im;
    }

    array_creal_T_2D_Constructor(&b_nikx);
    array_creal_T_2D_SetSize(&b_nikx, 1, nikx.size[1]);
    loop_ub = nikx.size[0] * nikx.size[1];
    for (i = 0; i < loop_ub; i++) {
      b_nikx.vector.data[i].re = -nikx.vector.data[i].re;
      b_nikx.vector.data[i].im = -nikx.vector.data[i].im;
    }

    array_creal_T_2D_Constructor(&e);
    c_exp(&b_nikx, &e);
    array_creal_T_2D_Destructor(&b_nikx);
    array_creal_T_2D_Constructor(&t);
    array_creal_T_2D_SetSize(&t, 1, e.size[1]);
    loop_ub = e.size[1];
    for (i = 0; i < loop_ub; i++) {
      t.vector.data[i].re = 1.0 - e.vector.data[i].re;
      t.vector.data[i].im = 0.0 - e.vector.data[i].im;
    }

    array_creal_T_2D_Constructor(&m);
    array_creal_T_2D_SetSize(&m, 1, e.size[1]);
    loop_ub = e.size[1];
    for (i = 0; i < loop_ub; i++) {
      m.vector.data[i].re = -e.vector.data[i].re;
      m.vector.data[i].im = -e.vector.data[i].im;
    }

    c_re = 1.0;
    c_im = 0.0;
    array_creal_T_2D_Constructor(&s);
    array_creal_T_2D_SetSize(&s, 1, t.size[1]);
    loop_ub = t.size[1];
    for (i = 0; i < loop_ub; i++) {
      ar = t.vector.data[i].re - 0.0 * t.vector.data[i].im;
      ai = t.vector.data[i].im + 0.0 * t.vector.data[i].re;
      s.vector.data[i].re = ar;
      s.vector.data[i].im = ai;
    }

    array_creal_T_2D_Constructor(&r);
    for (n = 0; n < 10; n++) {
      emlrtSizeEqCheckNDR2012b(&m.size[0], &nikx.size[0], &le_emlrtECI, &st);
      i = m.size[1];
      array_creal_T_2D_SetSize(&m, 1, m.size[1]);
      loop_ub = i - 1;
      for (i = 0; i <= loop_ub; i++) {
        ar = m.vector.data[i].re * nikx.vector.data[i].re - m.vector.data[i].im *
          nikx.vector.data[i].im;
        ai = m.vector.data[i].re * nikx.vector.data[i].im + m.vector.data[i].im *
          nikx.vector.data[i].re;
        m.vector.data[i].re = ar;
        m.vector.data[i].im = ai;
      }

      array_creal_T_2D_SetSize(&e, 1, m.size[1]);
      i = 2 * (n + 1);
      loop_ub = m.size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        e.vector.data[i1].re = (real_T)i * m.vector.data[i1].re;
        e.vector.data[i1].im = (real_T)i * m.vector.data[i1].im;
      }

      emlrtSizeEqCheckNDR2012b(&m.size[0], &nikx.size[0], &ke_emlrtECI, &st);
      i = m.size[1];
      array_creal_T_2D_SetSize(&m, 1, m.size[1]);
      loop_ub = i - 1;
      for (i = 0; i <= loop_ub; i++) {
        ar = m.vector.data[i].re * nikx.vector.data[i].re - m.vector.data[i].im *
          nikx.vector.data[i].im;
        ai = m.vector.data[i].re * nikx.vector.data[i].im + m.vector.data[i].im *
          nikx.vector.data[i].re;
        m.vector.data[i].re = ar;
        m.vector.data[i].im = ai;
      }

      array_creal_T_2D_SetSize(&r, 1, t.size[1]);
      i = (((n + 1) << 1) - 1) * ((n + 1) << 1);
      loop_ub = t.size[1];
      for (i1 = 0; i1 < loop_ub; i1++) {
        r.vector.data[i1].re = (real_T)i * t.vector.data[i1].re;
        r.vector.data[i1].im = (real_T)i * t.vector.data[i1].im;
      }

      emlrtSizeEqCheckNDR2012b(&r.size[0], &e.size[0], &je_emlrtECI, &st);
      emlrtSizeEqCheckNDR2012b(&r.size[0], &m.size[0], &je_emlrtECI, &st);
      array_creal_T_2D_SetSize(&t, 1, r.size[1]);
      loop_ub = r.size[1];
      for (i = 0; i < loop_ub; i++) {
        t.vector.data[i].re = (r.vector.data[i].re + e.vector.data[i].re) +
          m.vector.data[i].re;
        t.vector.data[i].im = (r.vector.data[i].im + e.vector.data[i].im) +
          m.vector.data[i].im;
      }

      ar = c_re * C_re - c_im * C_im;
      c_im = c_re * C_im + c_im * C_re;
      if (c_im == 0.0) {
        c_re = ar / -((real_T)n + 1.0);
        c_im = 0.0;
      } else if (ar == 0.0) {
        c_re = 0.0;
        c_im /= -((real_T)n + 1.0);
      } else {
        c_re = ar / -((real_T)n + 1.0);
        c_im /= -((real_T)n + 1.0);
      }

      array_creal_T_2D_SetSize(&r, 1, t.size[1]);
      loop_ub = t.size[1];
      for (i = 0; i < loop_ub; i++) {
        ar = c_re * t.vector.data[i].re - c_im * t.vector.data[i].im;
        ai = c_re * t.vector.data[i].im + c_im * t.vector.data[i].re;
        r.vector.data[i].re = ar;
        r.vector.data[i].im = ai;
      }

      emlrtSizeEqCheckNDR2012b(&s.size[0], &r.size[0], &ie_emlrtECI, &st);
      i = s.size[1];
      array_creal_T_2D_SetSize(&s, 1, s.size[1]);
      loop_ub = i - 1;
      for (i = 0; i <= loop_ub; i++) {
        s.vector.data[i].re += r.vector.data[i].re;
        s.vector.data[i].im += r.vector.data[i].im;
      }
    }

    array_creal_T_2D_Destructor(&r);
    array_creal_T_2D_Destructor(&m);
    array_creal_T_2D_Destructor(&t);
    array_creal_T_2D_Destructor(&e);
    array_creal_T_2D_Destructor(&nikx);
    c_re = theta * 0.0;
    c_im = theta;
    if (c_re == 0.0) {
      c_re = muDoubleScalarCos(c_im);
      c_im = muDoubleScalarSin(c_im);
    } else if (c_im == 0.0) {
      c_re = rtNaN;
      c_im = 0.0;
    } else {
      c_re = rtNaN;
      c_im = rtNaN;
    }

    array_creal_T_2D_SetSize(z, 1, s.size[1]);
    loop_ub = s.size[1];
    for (i = 0; i < loop_ub; i++) {
      ar = s.vector.data[i].re * 0.0 - s.vector.data[i].im;
      ai = s.vector.data[i].re + s.vector.data[i].im * 0.0;
      if (ai == 0.0) {
        ar /= k;
        ai = 0.0;
      } else if (ar == 0.0) {
        ar = 0.0;
        ai /= k;
      } else {
        ar /= k;
        ai /= k;
      }

      z->vector.data[i].re = ar * c_re - ai * c_im;
      z->vector.data[i].im = ar * c_im + ai * c_re;
    }

    array_creal_T_2D_Destructor(&s);
  }
}

static void y_bsxfun(coder_array_creal_T_2D *a, creal_T b_data[], int32_T
                     b_size[1], coder_array_creal_T_2D *c)
{
  int32_T acoef;
  int32_T b_k;
  int32_T bcoef;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T k;
  array_creal_T_2D_SetSize(c, b_size[0], a->size[1]);
  if ((c->size[0] != 0) && (c->size[1] != 0)) {
    acoef = (a->size[1] != 1);
    i = c->size[1];
    for (k = 0; k < i; k++) {
      ia = acoef * k;
      bcoef = (b_size[0] != 1);
      i1 = c->size[0];
      for (b_k = 0; b_k < i1; b_k++) {
        c->vector.data[b_k + c->size[0] * k].re = a->vector.data[ia].re -
          b_data[bcoef * b_k].re;
        c->vector.data[b_k + c->size[0] * k].im = a->vector.data[ia].im -
          b_data[bcoef * b_k].im;
      }
    }
  }
}

static void d_abs(coder_array_creal_T_2D *x, coder_array_real_T_2D *y)
{
  int32_T k;
  int32_T nx;
  uint32_T uv[2];
  nx = x->size[0] * x->size[1];
  for (k = 0; k < 2; k++) {
    uv[k] = (uint32_T)x->size[k];
  }

  array_real_T_2D_SetSize(y, (int32_T)uv[0], (int32_T)uv[1]);
  for (k = 0; k < nx; k++) {
    y->vector.data[k] = muDoubleScalarHypot(x->vector.data[k].re, x->
      vector.data[k].im);
  }
}

static void d_minimum(const emlrtStack *sp, coder_array_real_T_2D *x, real_T
                      ex_data[], int32_T ex_size[1], int32_T idx_data[], int32_T
                      idx_size[1])
{
  static const int32_T iv[2] = { 1, 39 };

  static const int32_T iv1[2] = { 1, 39 };

  static char_T b_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  real_T b;
  real_T b_ex_data;
  int32_T i;
  int32_T j;
  int32_T loop_ub;
  int32_T n;
  char_T u[39];
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  if (x->size[1] < 1) {
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 39; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
    emlrtAssign(&b_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, b_y, &wb_emlrtMCI), &wb_emlrtMCI),
          &wb_emlrtMCI);
  }

  n = x->size[1];
  ex_size[0] = x->size[0];
  idx_size[0] = x->size[0];
  loop_ub = x->size[0];
  for (i = 0; i < loop_ub; i++) {
    idx_data[i] = 1;
  }

  if (x->size[0] >= 1) {
    i = x->size[0];
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      ex_data[loop_ub] = x->vector.data[loop_ub];
    }

    for (j = 2; j <= n; j++) {
      i = x->size[0];
      for (loop_ub = 0; loop_ub < i; loop_ub++) {
        b_ex_data = ex_data[loop_ub];
        b = x->vector.data[loop_ub + x->size[0] * (j - 1)];
        if (muDoubleScalarIsNaN(b)) {
          p = false;
        } else if (muDoubleScalarIsNaN(b_ex_data)) {
          p = true;
        } else {
          p = (b_ex_data > b);
        }

        if (p) {
          b_ex_data = x->vector.data[loop_ub + x->size[0] * (j - 1)];
          idx_data[loop_ub] = j;
        }

        ex_data[loop_ub] = b_ex_data;
      }
    }
  }
}

static void b_indexShapeCheck(const emlrtStack *sp, int32_T matrixSize[2],
  int32_T indexSize)
{
  emlrtStack st;
  boolean_T c;
  st.prev = sp;
  st.tls = sp->tls;
  if ((matrixSize[1] == 1) && (indexSize != 1)) {
    c = true;
  } else {
    c = false;
  }

  st.site = &sf_emlrtRSI;
  errOrWarnIf(&st, c);
}

static void dfresnelg(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                      real_T dk, real_T k, real_T theta, creal_T dz_data[],
                      int32_T dz_size[2])
{
  __m128d r;
  coder_array_creal_T_2D e_tmp_data;
  coder_array_creal_T_2D r1;
  emlrtStack st;
  creal_T d_tmp_data[100];
  real_T c_tmp_data[100];
  real_T b_dk;
  int32_T tmp_size[2];
  int32_T i;
  int32_T loop_ub;
  int32_T scalarLB;
  int32_T vectorUB;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &hv_emlrtRSI;
  l_validateattributes(&st, dk);
  st.site = &iv_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &jv_emlrtRSI;
  n_validateattributes(&st, theta);
  tmp_size[0] = 1;
  tmp_size[1] = x_size[1];
  b_dk = dk / 2.0;
  loop_ub = x_size[1];
  scalarLB = x_size[1] / 2 * 2;
  vectorUB = scalarLB - 2;
  for (i = 0; i <= vectorUB; i += 2) {
    r = _mm_loadu_pd(&x_data[i]);
    _mm_storeu_pd(&c_tmp_data[i], _mm_mul_pd(_mm_set1_pd(b_dk), r));
  }

  for (i = scalarLB; i < loop_ub; i++) {
    c_tmp_data[i] = b_dk * x_data[i];
  }

  emlrtSizeEqCheckNDR2012b(&tmp_size[0], &x_size[0], &me_emlrtECI, (void *)sp);
  loop_ub = x_size[1];
  for (i = 0; i < loop_ub; i++) {
    b_dk = c_tmp_data[i];
    d_tmp_data[i].re = ((b_dk + k) * x_data[i] + theta) * 0.0;
    d_tmp_data[i].im = (b_dk + k) * x_data[i] + theta;
  }

  e_tmp_data.vector.data = &d_tmp_data[0];
  e_tmp_data.vector.numel = x_size[1];
  e_tmp_data.vector.allocated = x_size[1];
  e_tmp_data.vector.owner = false;
  e_tmp_data.size[0] = 1;
  e_tmp_data.size[1] = x_size[1];
  array_creal_T_2D_Constructor(&r1);
  c_exp(&e_tmp_data, &r1);
  dz_size[0] = 1;
  dz_size[1] = r1.size[1];
  loop_ub = r1.size[0] * r1.size[1];
  if (loop_ub - 1 >= 0) {
    memcpy(&dz_data[0], &r1.vector.data[0], (uint32_T)loop_ub * sizeof(creal_T));
  }

  array_creal_T_2D_Destructor(&r1);
}

static void e_abs(coder_array_creal_T_2D *x, coder_array_real_T_2D *y)
{
  int32_T k;
  int32_T nx;
  nx = x->size[1];
  array_real_T_2D_SetSize(y, 1, x->size[1]);
  for (k = 0; k < nx; k++) {
    y->vector.data[k] = muDoubleScalarHypot(x->vector.data[k].re, x->
      vector.data[k].im);
  }
}

static void e_maximum(const emlrtStack *sp, real_T x_data[], int32_T x_size[2],
                      real_T *ex, int32_T *idx)
{
  static const int32_T iv[2] = { 1, 36 };

  static const int32_T iv1[2] = { 1, 39 };

  static const int32_T iv2[2] = { 1, 36 };

  static const int32_T iv3[2] = { 1, 39 };

  static char_T d_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T c_u[36] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'a', 'u', 't', 'o', 'D', 'i', 'm', 'I', 'n', 'c', 'o',
    'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *m;
  const mxArray *y;
  int32_T b_idx;
  int32_T k;
  int32_T last;
  char_T b_u[39];
  char_T u[36];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if ((x_size[1] == 1) || (x_size[1] != 1)) {
  } else {
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&y, m);
    for (last = 0; last < 36; last++) {
      u[last] = c_u[last];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
    emlrtAssign(&c_y, m);
    st.site = &gw_emlrtRSI;
    error(&st, y, getString(&st, b_message(&st, c_y, &vb_emlrtMCI), &vb_emlrtMCI),
          &vb_emlrtMCI);
  }

  if (x_size[1] < 1) {
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&b_y, m);
    for (last = 0; last < 39; last++) {
      b_u[last] = d_u[last];
    }

    d_y = NULL;
    m = emlrtCreateCharArray(2, &iv3[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &b_u[0]);
    emlrtAssign(&d_y, m);
    st.site = &fw_emlrtRSI;
    error(&st, b_y, getString(&st, b_message(&st, d_y, &wb_emlrtMCI),
           &wb_emlrtMCI), &wb_emlrtMCI);
  }

  last = x_size[1];
  if (x_size[1] <= 2) {
    if (x_size[1] == 1) {
      *ex = x_data[0];
      *idx = 1;
    } else if ((x_data[0] < x_data[x_size[1] - 1]) || (muDoubleScalarIsNaN
                (x_data[0]) && (!muDoubleScalarIsNaN(x_data[x_size[1] - 1])))) {
      *ex = x_data[x_size[1] - 1];
      *idx = x_size[1];
    } else {
      *ex = x_data[0];
      *idx = 1;
    }
  } else {
    if (!muDoubleScalarIsNaN(x_data[0])) {
      *idx = 1;
    } else {
      *idx = 0;
      k = 2;
      exitg1 = false;
      while ((!exitg1) && (k <= last)) {
        if (!muDoubleScalarIsNaN(x_data[k - 1])) {
          *idx = k;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    if (*idx == 0) {
      *ex = x_data[0];
      *idx = 1;
    } else {
      *ex = x_data[*idx - 1];
      b_idx = *idx;
      for (k = *idx + 1; k <= last; k++) {
        if (*ex < x_data[k - 1]) {
          *ex = x_data[k - 1];
          b_idx = k;
        }
      }

      *idx = b_idx;
    }
  }
}

static void b_fresnelgcp(const emlrtStack *sp, creal_T z, real_T dk, real_T k,
  real_T theta, coder_array_real_T_2D *x0, creal_T *zcp, real_T *x)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 18 };

  static const int32_T iv3[2] = { 1, 39 };

  static const int32_T iv4[2] = { 1, 39 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T h_u[39] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'e', 'm', 'l', '_', 'm', 'i', 'n', '_', 'o', 'r', '_',
    'm', 'a', 'x', '_', 'v', 'a', 'r', 'D', 'i', 'm', 'Z', 'e', 'r', 'o' };

  static char_T b_u[30] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'f', 'r', 'e',
    's', 'n', 'e', 'l', 'g', ':', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', 'F',
    'i', 'n', 'i', 't', 'e' };

  static char_T f_u[18] = { 'i', 'n', 'p', 'u', 't', ' ', 'n', 'u', 'm', 'b',
    'e', 'r', ' ', '1', ',', ' ', 'z', ',' };

  coder_array_creal_T_2D c;
  coder_array_creal_T_2D zcp0;
  coder_array_real_T_2D b_x0;
  coder_array_real_T_2D ztest;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack d_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *m;
  const mxArray *y;
  real_T b_dzdx_re;
  real_T dzdx_im;
  real_T dzdx_re;
  real_T zd_im;
  real_T zd_re;
  int32_T acoef;
  int32_T b_k;
  int32_T i;
  int32_T idx;
  char_T c_u[46];
  char_T g_u[39];
  char_T u[30];
  char_T e_u[18];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &tu_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  d_st.prev = &c_st;
  d_st.tls = c_st.tls;
  b_st.site = &ib_emlrtRSI;
  p = true;
  if ((!!muDoubleScalarIsInf(z.re)) || (!!muDoubleScalarIsInf(z.im)) ||
      ((!!muDoubleScalarIsNaN(z.re)) || (!!muDoubleScalarIsNaN(z.im)))) {
    p = false;
  }

  if (!p) {
    for (idx = 0; idx < 30; idx++) {
      u[idx] = b_u[idx];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (idx = 0; idx < 46; idx++) {
      c_u[idx] = d_u[idx];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (idx = 0; idx < 18; idx++) {
      e_u[idx] = f_u[idx];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 18, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  st.site = &uu_emlrtRSI;
  l_validateattributes(&st, dk);
  st.site = &vu_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &wu_emlrtRSI;
  n_validateattributes(&st, theta);
  st.site = &xu_emlrtRSI;
  b_st.site = &yu_emlrtRSI;
  o_validateattributes(&b_st, x0);
  b_st.site = &av_emlrtRSI;
  acoef = x0->size[1];
  array_real_T_2D_Constructor(&b_x0);
  array_real_T_2D_SetSize(&b_x0, 1, acoef);
  for (idx = 0; idx < acoef; idx++) {
    b_x0.vector.data[idx] = x0->vector.data[idx];
  }

  array_creal_T_2D_Constructor(&zcp0);
  c_st.site = &ev_emlrtRSI;
  b_fresnelg(&c_st, &b_x0, dk, k, theta, &zcp0);
  array_real_T_2D_Destructor(&b_x0);
  array_creal_T_2D_Constructor(&c);
  array_creal_T_2D_SetSize(&c, 1, zcp0.size[1]);
  if (c.size[1] != 0) {
    array_creal_T_2D_SetSize(&c, 1, c.size[1]);
    acoef = (zcp0.size[1] != 1);
    idx = c.size[1];
    for (b_k = 0; b_k < idx; b_k++) {
      array_creal_T_2D_SetSize(&c, 1, c.size[1]);
      array_creal_T_2D_SetSize(&c, 1, c.size[1]);
      c.vector.data[b_k].re = zcp0.vector.data[acoef * b_k].re - z.re;
      c.vector.data[b_k].im = zcp0.vector.data[acoef * b_k].im - z.im;
    }
  }

  array_creal_T_2D_Destructor(&zcp0);
  acoef = c.size[1];
  array_real_T_2D_Constructor(&ztest);
  array_real_T_2D_SetSize(&ztest, 1, c.size[1]);
  for (b_k = 0; b_k < acoef; b_k++) {
    ztest.vector.data[b_k] = muDoubleScalarHypot(c.vector.data[b_k].re,
      c.vector.data[b_k].im);
  }

  array_creal_T_2D_Destructor(&c);
  if (ztest.size[1] == 1) {
    i = 1;
  } else {
    c_st.site = &ol_emlrtRSI;
    if (ztest.size[1] < 1) {
      for (idx = 0; idx < 39; idx++) {
        g_u[idx] = h_u[idx];
      }

      d_y = NULL;
      m = emlrtCreateCharArray(2, &iv3[0]);
      emlrtInitCharArrayR2013a(&c_st, 39, m, &g_u[0]);
      emlrtAssign(&d_y, m);
      for (idx = 0; idx < 39; idx++) {
        g_u[idx] = h_u[idx];
      }

      e_y = NULL;
      m = emlrtCreateCharArray(2, &iv4[0]);
      emlrtInitCharArrayR2013a(&c_st, 39, m, &g_u[0]);
      emlrtAssign(&e_y, m);
      d_st.site = &fw_emlrtRSI;
      error(&d_st, d_y, getString(&d_st, b_message(&d_st, e_y, &wb_emlrtMCI),
             &wb_emlrtMCI), &wb_emlrtMCI);
    }

    acoef = ztest.size[1];
    if (ztest.size[1] <= 2) {
      if (ztest.size[1] == 1) {
        i = 1;
      } else if ((ztest.vector.data[0] > ztest.vector.data[ztest.size[1] - 1]) ||
                 (muDoubleScalarIsNaN(ztest.vector.data[0]) &&
                  (!muDoubleScalarIsNaN(ztest.vector.data[ztest.size[1] - 1]))))
      {
        i = ztest.size[1];
      } else {
        i = 1;
      }
    } else {
      if (!muDoubleScalarIsNaN(ztest.vector.data[0])) {
        i = 1;
      } else {
        i = 0;
        b_k = 2;
        exitg1 = false;
        while ((!exitg1) && (b_k <= acoef)) {
          if (!muDoubleScalarIsNaN(ztest.vector.data[b_k - 1])) {
            i = b_k;
            exitg1 = true;
          } else {
            b_k++;
          }
        }
      }

      if (i == 0) {
        i = 1;
      } else {
        zd_re = ztest.vector.data[i - 1];
        idx = i;
        for (b_k = i + 1; b_k <= acoef; b_k++) {
          if (zd_re > ztest.vector.data[b_k - 1]) {
            zd_re = ztest.vector.data[b_k - 1];
            idx = b_k;
          }
        }

        i = idx;
      }
    }
  }

  array_real_T_2D_Destructor(&ztest);
  *x = x0->vector.data[emlrtDynamicBoundsCheckR2012b(i, 1, x0->size[1],
    &oi_emlrtBCI, &b_st) - 1];
  b_st.site = &bv_emlrtRSI;
  *zcp = c_fresnelg(&b_st, x0->vector.data[i - 1], dk, k, theta);
  zd_re = zcp->re - z.re;
  zd_im = zcp->im - z.im;
  for (acoef = 0; acoef < 20; acoef++) {
    b_st.site = &cv_emlrtRSI;
    c_st.site = &hv_emlrtRSI;
    l_validateattributes(&c_st, dk);
    c_st.site = &iv_emlrtRSI;
    m_validateattributes(&c_st, k);
    c_st.site = &jv_emlrtRSI;
    n_validateattributes(&c_st, theta);
    dzdx_re = ((dk / 2.0 * *x + k) * *x + theta) * 0.0;
    dzdx_im = (dk / 2.0 * *x + k) * *x + theta;
    if (dzdx_re == 0.0) {
      dzdx_re = muDoubleScalarCos(dzdx_im);
      dzdx_im = muDoubleScalarSin(dzdx_im);
    } else if (dzdx_im == 0.0) {
      dzdx_re = rtNaN;
      dzdx_im = 0.0;
    } else {
      dzdx_re = rtNaN;
      dzdx_im = rtNaN;
    }

    b_dzdx_re = dzdx_re;
    dzdx_im = -dzdx_im;
    dzdx_re = zd_re * b_dzdx_re - zd_im * dzdx_im;
    *x -= dzdx_re / (1.0 - (dzdx_re * 0.0 - (zd_re * dzdx_im + zd_im * b_dzdx_re))
                     * (dk * *x + k));
    b_st.site = &dv_emlrtRSI;
    *zcp = c_fresnelg(&b_st, *x, dk, k, theta);
    zd_re = zcp->re - z.re;
    zd_im = zcp->im - z.im;
  }
}

static creal_T c_fresnelg(const emlrtStack *sp, real_T x, real_T dk, real_T k,
  real_T theta)
{
  emlrtStack b_st;
  emlrtStack st;
  creal_T c_tmp_data[1];
  creal_T dcv[1];
  creal_T z;
  creal_T z0;
  creal_T z1;
  real_T x_data[1];
  real_T a;
  real_T a_re;
  real_T y_im;
  real_T y_re;
  int32_T x_size[2];
  int32_T tmp_size[1];
  int32_T ii_size_idx_0;
  int32_T ii_size_idx_1;
  int32_T loop_ub;
  int8_T ii_data[1];
  int8_T izero_data[1];
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &du_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  l_validateattributes(&st, dk);
  st.site = &eu_emlrtRSI;
  m_validateattributes(&st, k);
  st.site = &fu_emlrtRSI;
  n_validateattributes(&st, theta);
  if (dk / (k * k) > 1.0E-6) {
    st.site = &gu_emlrtRSI;
    y_re = dk / 3.1415926535897931;
    b_st.site = &gu_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    y_im = 3.1415926535897931 * dk;
    b_st.site = &gu_emlrtRSI;
    d_sqrt(&b_st, &y_im);
    b_st.site = &ou_emlrtRSI;
    z1 = fresnelr(&b_st, y_re * x + k / y_im);
    st.site = &hu_emlrtRSI;
    y_re = 3.1415926535897931 * dk;
    b_st.site = &hu_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, k / y_re);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = theta - k * k / (2.0 * dk);
    a = 3.1415926535897931 / dk;
    st.site = &iu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    a_re = a * y_re;
    y_re = a * y_im;
    y_im = z1.re - z0.re;
    a = z1.im - z0.im;
    z.re = a_re * y_im - y_re * a;
    z.im = a_re * a + y_re * y_im;
  } else if (dk / (k * k) < -1.0E-6) {
    st.site = &ju_emlrtRSI;
    y_re = -dk / 3.1415926535897931;
    b_st.site = &ju_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    y_im = -3.1415926535897931 * dk;
    b_st.site = &ju_emlrtRSI;
    d_sqrt(&b_st, &y_im);
    b_st.site = &ou_emlrtRSI;
    z1 = fresnelr(&b_st, y_re * x - k / y_im);
    st.site = &ku_emlrtRSI;
    y_re = -3.1415926535897931 * dk;
    b_st.site = &ku_emlrtRSI;
    d_sqrt(&b_st, &y_re);
    b_st.site = &ou_emlrtRSI;
    z0 = fresnelr(&b_st, -k / y_re);
    y_re = (theta - k * k / (2.0 * dk)) * 0.0;
    y_im = -(theta - k * k / (2.0 * dk));
    a = -3.1415926535897931 / dk;
    st.site = &lu_emlrtRSI;
    d_sqrt(&st, &a);
    if (y_re == 0.0) {
      y_re = muDoubleScalarCos(y_im);
      y_im = muDoubleScalarSin(y_im);
    } else if (y_im == 0.0) {
      y_re = rtNaN;
      y_im = 0.0;
    } else {
      y_re = rtNaN;
      y_im = rtNaN;
    }

    a_re = a * y_re;
    y_re = a * y_im;
    y_im = z1.re - z0.re;
    a = z1.im - z0.im;
    z.re = a_re * y_im - y_re * a;
    z.im = -(a_re * a + y_re * y_im);
  } else {
    st.site = &mu_emlrtRSI;
    z = fresnelgsma(x, dk, k, theta);
  }

  if ((muDoubleScalarAbs(dk) * (x * x) < 0.001) && (muDoubleScalarAbs(k * x) <
       0.001)) {
    ii_size_idx_0 = 1;
    ii_size_idx_1 = 1;
    ii_data[0] = 1;
  } else {
    ii_size_idx_0 = 0;
    ii_size_idx_1 = 0;
  }

  loop_ub = ii_size_idx_0 * ii_size_idx_1;
  if (loop_ub - 1 >= 0) {
    memcpy(&izero_data[0], &ii_data[0], (uint32_T)loop_ub * sizeof(int8_T));
  }

  if ((ii_size_idx_0 != 0) && (ii_size_idx_1 != 0)) {
    x_size[0] = 1;
    x_size[1] = 1;
    for (ii_size_idx_0 = 0; ii_size_idx_0 < 1; ii_size_idx_0++) {
      x_data[0] = x;
    }

    st.site = &nu_emlrtRSI;
    fresnelgzero(&st, x_data, x_size, dk, k, theta, c_tmp_data, tmp_size);
    emlrtSubAssignSizeCheck1dR2017a(1, tmp_size[0], &ae_emlrtECI, (emlrtConstCTX)
      sp);
    dcv[0].re = z.re;
    dcv[0].im = z.im;
    dcv[izero_data[0] - 1].re = c_tmp_data[0].re;
    dcv[izero_data[0] - 1].im = c_tmp_data[0].im;
    z.re = dcv[0].re;
    z.im = dcv[0].im;
  }

  return z;
}

static void visionDetectionGenerator_limitMaxNumLanes(const emlrtStack *sp,
  BusLaneDetections1LaneBoundaries lbdets_data[], int32_T lbdets_size[1],
  BusLaneDetections1LaneBoundaries lbdetOut[4], real_T *numLaneDets)
{
  BusLaneDetections1LaneBoundaries b_lbdets_data[500];
  coder_array_real_T_2D b_latDist_data;
  coder_array_real_T_2D r;
  emlrtStack st;
  real_T b_dv[500];
  real_T latDist_data[500];
  real_T b_y_data[301];
  real_T c_latDist_data[100];
  int32_T iidx_data[500];
  int32_T b_latDist_size[2];
  int32_T iidx_size[2];
  int32_T latDist_size[2];
  int32_T b_i;
  int32_T i;
  int32_T i1;
  st.prev = sp;
  st.tls = sp->tls;
  for (i = 0; i < 4; i++) {
    lbdetOut[i].Curvature = rtNaN;
    lbdetOut[i].CurvatureDerivative = rtNaN;
    lbdetOut[i].CurveLength = rtNaN;
    lbdetOut[i].HeadingAngle = rtNaN;
    lbdetOut[i].LateralOffset = rtNaN;
    lbdetOut[i].BoundaryType = 0U;
    lbdetOut[i].Strength = rtNaN;
    lbdetOut[i].Width = rtNaN;
  }

  *numLaneDets = muDoubleScalarMin((real_T)lbdets_size[0], 4.0);
  if (*numLaneDets > 0.0) {
    st.site = &mv_emlrtRSI;
    d_AbstractDetectionGenerator_concatFieldValues(&st, lbdets_data, lbdets_size,
      b_dv, latDist_size);
    memcpy(&latDist_data[0], &b_dv[0], 500U * sizeof(real_T));
    b_latDist_data.vector.data = &latDist_data[0];
    b_latDist_data.vector.numel = latDist_size[0] * latDist_size[1];
    b_latDist_data.vector.allocated = b_latDist_data.vector.numel;
    b_latDist_data.vector.owner = false;
    b_latDist_data.size[0] = latDist_size[0];
    b_latDist_data.size[1] = latDist_size[1];
    array_real_T_2D_Constructor(&r);
    b_abs(&b_latDist_data, &r);
    array_real_T_2D_Reserve(&r, 500);
    sort((real_T *)r.vector.data, r.size, latDist_data, latDist_size, iidx_data,
         iidx_size);
    array_real_T_2D_SetSize(&r, r.size[0], r.size[1]);
    array_real_T_2D_Destructor(&r);
    i = iidx_size[1];
    for (b_i = 0; b_i < i; b_i++) {
      latDist_data[b_i] = (real_T)iidx_data[b_i];
    }

    emlrtDynamicBoundsCheckR2012b(1, 1, iidx_size[1], &ej_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b((int32_T)*numLaneDets, 1, iidx_size[1],
      &dj_emlrtBCI, (emlrtConstCTX)sp);
    b_latDist_size[0] = 1;
    b_latDist_size[1] = (int32_T)*numLaneDets;
    i = (int32_T)*numLaneDets;
    for (b_i = 0; b_i < i; b_i++) {
      c_latDist_data[b_i] = (real_T)(int32_T)latDist_data[b_i];
    }

    b_sort(c_latDist_data, b_latDist_size, b_y_data, latDist_size);
    st.site = &lv_emlrtRSI;
    indexShapeCheck(&st, lbdets_size[0], latDist_size);
    i = latDist_size[1];
    for (b_i = 0; b_i < i; b_i++) {
      i1 = (int32_T)emlrtIntegerCheckR2012b(b_y_data[b_i], &l_emlrtDCI,
        (emlrtConstCTX)sp);
      b_lbdets_data[b_i] = lbdets_data[emlrtDynamicBoundsCheckR2012b(i1, 1,
        lbdets_size[0], &fj_emlrtBCI, (emlrtConstCTX)sp) - 1];
    }

    lbdets_size[0] = latDist_size[1];
    if (latDist_size[1] - 1 >= 0) {
      memcpy(&lbdets_data[0], &b_lbdets_data[0], (uint32_T)latDist_size[1] *
             sizeof(BusLaneDetections1LaneBoundaries));
    }

    i = (int32_T)*numLaneDets;
  } else {
    st.site = &kv_emlrtRSI;
    c_indexShapeCheck(&st, lbdets_size[0]);
    lbdets_size[0] = 0;
    i = 0;
  }

  emlrtSubAssignSizeCheck1dR2017a(i, lbdets_size[0], &ne_emlrtECI,
    (emlrtConstCTX)sp);
  if (i - 1 >= 0) {
    memcpy(&lbdetOut[0], &lbdets_data[0], (uint32_T)i * sizeof
           (BusLaneDetections1LaneBoundaries));
  }
}

static void d_AbstractDetectionGenerator_concatFieldValues(const emlrtStack *sp,
  BusLaneDetections1LaneBoundaries s_data[], int32_T s_size[1], real_T
  vals_data[], int32_T vals_size[2])
{
  emlrtStack st;
  real_T b_vals_data[500];
  int32_T b_vals_size[1];
  int32_T i;
  int32_T loop_ub;
  st.prev = sp;
  st.tls = sp->tls;
  if (s_size[0] == 0) {
    vals_size[0] = 1;
    vals_size[1] = 0;
  } else {
    b_vals_size[0] = s_size[0];
    loop_ub = s_size[0];
    for (i = 0; i < loop_ub; i++) {
      b_vals_data[i] = 0.0;
    }

    i = s_size[0];
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      b_vals_data[emlrtDynamicBoundsCheckR2012b(loop_ub + 1, 1, b_vals_size[0],
        &lb_emlrtBCI, (emlrtConstCTX)sp) - 1] =
        s_data[emlrtDynamicBoundsCheckR2012b(loop_ub + 1, 1, s_size[0],
        &kb_emlrtBCI, (emlrtConstCTX)sp) - 1].LateralOffset;
    }

    st.site = &ng_emlrtRSI;
    shiftdim(&st, b_vals_data, b_vals_size, vals_data, vals_size);
  }
}

static void b_sort(real_T x_data[], int32_T x_size[2], real_T b_x_data[],
                   int32_T b_x_size[2])
{
  real_T c_x_data[500];
  int32_T idx_data[500];
  int32_T c_x_size[2];
  int32_T idx_size[2];
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  if (x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)x_size[1] * sizeof(real_T));
  }

  b_sortIdx(b_x_data, b_x_size, idx_data, idx_size, c_x_data, c_x_size);
  b_x_size[0] = 1;
  b_x_size[1] = c_x_size[1];
  if (c_x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &c_x_data[0], (uint32_T)c_x_size[1] * sizeof(real_T));
  }
}

static void c_indexShapeCheck(const emlrtStack *sp, int32_T matrixSize)
{
  emlrtStack st;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &sf_emlrtRSI;
  errOrWarnIf(&st, matrixSize == 1);
}

static void nullify(real_T *out_Time, real_T out_Measurement[6], real_T
                    out_MeasurementNoise[36], real_T *out_SensorIndex, real_T
                    *out_ObjectClassID, drivingCoordinateFrameType
                    *out_MeasurementParameters_Frame, real_T
                    out_MeasurementParameters_OriginPosition[3], real_T
                    out_MeasurementParameters_Orientation[9], boolean_T
                    *out_MeasurementParameters_HasVelocity, real_T
                    *out_ObjectAttributes_TargetIndex)
{
  int32_T i;
  *out_Time = 0.0;
  for (i = 0; i < 6; i++) {
    out_Measurement[i] = 0.0;
  }

  for (i = 0; i < 36; i++) {
    out_MeasurementNoise[i] = 0.0;
  }

  *out_SensorIndex = 0.0;
  *out_ObjectClassID = 0.0;
  *out_MeasurementParameters_Frame = drivingCoordinateFrameType_Rectangular;
  for (i = 0; i < 3; i++) {
    out_MeasurementParameters_OriginPosition[i] = 0.0;
  }

  for (i = 0; i < 9; i++) {
    out_MeasurementParameters_Orientation[i] = 0.0;
  }

  *out_MeasurementParameters_HasVelocity = false;
  *out_ObjectAttributes_TargetIndex = 0.0;
}

static void visionDetectionGenerator_sendToBus(const emlrtStack *sp,
  objectDetection dets[50], real_T numDets, boolean_T isValidTime, real_T
  *out_NumDetections, boolean_T *out_IsValidTime, BusObjectDetections1Detections
  out_Detections[50])
{
  BusObjectDetections1Detections oneDet;
  emlrtStack st;
  int32_T b_i;
  int32_T i;
  int32_T m;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &nv_emlrtRSI;
  nullify(&oneDet.Time, oneDet.Measurement, oneDet.MeasurementNoise,
          &oneDet.SensorIndex, &oneDet.ObjectClassID,
          &oneDet.MeasurementParameters.Frame,
          oneDet.MeasurementParameters.OriginPosition,
          oneDet.MeasurementParameters.Orientation,
          &oneDet.MeasurementParameters.HasVelocity,
          &oneDet.ObjectAttributes.TargetIndex);
  for (i = 0; i < 50; i++) {
    out_Detections[i] = oneDet;
  }

  b_i = (int32_T)numDets;
  emlrtForLoopVectorCheckR2021a(1.0, 1.0, numDets, mxDOUBLE_CLASS, (int32_T)
    numDets, &emlrtRTEI, &st);
  for (m = 0; m < b_i; m++) {
    out_Detections[m].Time = dets[m].Time;
    for (i = 0; i < 6; i++) {
      out_Detections[m].Measurement[i] = dets[m].Measurement[i];
    }

    memcpy(&out_Detections[m].MeasurementNoise[0], &dets[m].pMeasurementNoise[0],
           36U * sizeof(real_T));
    out_Detections[m].SensorIndex = 4.0;
    out_Detections[m].ObjectClassID = dets[m].ObjectClassID;
    out_Detections[m].MeasurementParameters = dets[m].MeasurementParameters[0];
    out_Detections[m].ObjectAttributes = dets[m].ObjectAttributes[0];
  }

  *out_NumDetections = numDets;
  *out_IsValidTime = isValidTime;
}

static const mxArray *emlrt_marshallOut(const emlrtStack *sp, const char_T u[40])
{
  static const int32_T iv[2] = { 1, 40 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 40, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *b_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [30])
{
  static const int32_T iv[2] = { 1, 30 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *c_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [39])
{
  static const int32_T iv[2] = { 1, 39 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 39, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static void emlrt_marshallIn(const emlrtStack *sp, const mxArray
  *a__output_of_sprintf_, const char_T *identifier, char_T y[14])
{
  emlrtMsgIdentifier thisId;
  thisId.fIdentifier = (const char_T *)identifier;
  thisId.fParent = NULL;
  thisId.bParentIsCell = false;
  b_emlrt_marshallIn(sp, emlrtAlias(a__output_of_sprintf_), &thisId, y);
  emlrtDestroyArray(&a__output_of_sprintf_);
}

static void b_emlrt_marshallIn(const emlrtStack *sp, const mxArray *u, const
  emlrtMsgIdentifier *parentId, char_T y[14])
{
  c_emlrt_marshallIn(sp, emlrtAlias(u), parentId, y);
  emlrtDestroyArray(&u);
}

static const mxArray *d_emlrt_marshallOut(const emlrtStack *sp, const char_T u
  [36])
{
  static const int32_T iv[2] = { 1, 36 };

  const mxArray *m;
  const mxArray *y;
  y = NULL;
  m = emlrtCreateCharArray(2, &iv[0]);
  emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 36, m, &u[0]);
  emlrtAssign(&y, m);
  return y;
}

static const mxArray *message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 2, &pArrays[0],
    "message", true, location);
}

static const mxArray *getString(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 1, &pArray, "getString",
    true, location);
}

static void error(const emlrtStack *sp, const mxArray *m, const mxArray *m1,
                  emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = m;
  pArrays[1] = m1;
  emlrtCallMATLABR2012b((emlrtConstCTX)sp, 0, NULL, 2, &pArrays[0], "error",
                        true, location);
}

static const mxArray *num2str(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 1, &pArray, "num2str",
    true, location);
}

static void coder_internal_warningIf(const emlrtStack *sp, const mxArray *m,
  const mxArray *m1, const mxArray *m2, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  pArrays[0] = m;
  pArrays[1] = m1;
  pArrays[2] = m2;
  emlrtCallMATLABR2012b((emlrtConstCTX)sp, 0, NULL, 3, &pArrays[0],
                        "coder.internal.warningIf", true, location);
}

static const mxArray *b_message(const emlrtStack *sp, const mxArray *m1,
  emlrtMCInfo *location)
{
  const mxArray *m;
  const mxArray *pArray;
  pArray = m1;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 1, &pArray, "message",
    true, location);
}

static const mxArray *c_message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 3, &pArrays[0],
    "message", true, location);
}

static void coder_internal_errorIf(const emlrtStack *sp, const mxArray *m, const
  mxArray *m1, const mxArray *m2, const mxArray *m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[4];
  pArrays[0] = m;
  pArrays[1] = m1;
  pArrays[2] = m2;
  pArrays[3] = m3;
  emlrtCallMATLABR2012b((emlrtConstCTX)sp, 0, NULL, 4, &pArrays[0],
                        "coder.internal.errorIf", true, location);
}

static const mxArray *feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 2, &pArrays[0], "feval",
    true, location);
}

static void b_feval(const emlrtStack *sp, const mxArray *m, const mxArray *m1,
                    emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  pArrays[0] = m;
  pArrays[1] = m1;
  emlrtCallMATLABR2012b((emlrtConstCTX)sp, 0, NULL, 2, &pArrays[0], "feval",
                        true, location);
}

static const mxArray *b_sprintf(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, emlrtMCInfo *location)
{
  const mxArray *pArrays[2];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 2, &pArrays[0],
    "sprintf", true, location);
}

static const mxArray *c_feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, emlrtMCInfo *location)
{
  const mxArray *pArrays[3];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 3, &pArrays[0], "feval",
    true, location);
}

static const mxArray *d_message(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, const mxArray *m4, emlrtMCInfo *location)
{
  const mxArray *pArrays[4];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  pArrays[3] = m4;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 4, &pArrays[0],
    "message", true, location);
}

static const mxArray *d_feval(const emlrtStack *sp, const mxArray *m1, const
  mxArray *m2, const mxArray *m3, const mxArray *m4, emlrtMCInfo *location)
{
  const mxArray *pArrays[4];
  const mxArray *m;
  pArrays[0] = m1;
  pArrays[1] = m2;
  pArrays[2] = m3;
  pArrays[3] = m4;
  return emlrtCallMATLABR2012b((emlrtConstCTX)sp, 1, &m, 4, &pArrays[0], "feval",
    true, location);
}

static void c_emlrt_marshallIn(const emlrtStack *sp, const mxArray *src, const
  emlrtMsgIdentifier *msgId, char_T ret[14])
{
  static const int32_T dims[2] = { 1, 14 };

  emlrtCheckBuiltInR2012b((emlrtConstCTX)sp, msgId, src, "char", false, 2U, (
    const void *)&dims[0]);
  emlrtImportCharArrayR2015b((emlrtConstCTX)sp, src, &ret[0], 14);
  emlrtDestroyArray(&src);
}

static void d_sqrt(const emlrtStack *sp, real_T *x)
{
  static const int32_T iv[2] = { 1, 30 };

  static const int32_T iv1[2] = { 1, 30 };

  static const int32_T iv2[2] = { 1, 4 };

  static char_T b_u[30] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'E', 'l', 'F', 'u', 'n', 'D', 'o', 'm', 'a', 'i', 'n',
    'E', 'r', 'r', 'o', 'r' };

  static char_T d_u[4] = { 's', 'q', 'r', 't' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[30];
  char_T c_u[4];
  st.prev = sp;
  st.tls = sp->tls;
  if (*x < 0.0) {
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 30; i++) {
      u[i] = b_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 30, m, &u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 4; i++) {
      c_u[i] = d_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 4, m, &c_u[0]);
    emlrtAssign(&c_y, m);
    st.site = &tv_emlrtRSI;
    error(&st, y, getString(&st, message(&st, b_y, c_y, &j_emlrtMCI),
           &j_emlrtMCI), &j_emlrtMCI);
  }

  *x = muDoubleScalarSqrt(*x);
}

static void c_sort(real_T x_data[], int32_T x_size[1], int32_T idx_data[],
                   int32_T idx_size[1])
{
  real_T vwork_data[300];
  int32_T iidx_data[300];
  int32_T iidx_size[1];
  int32_T vwork_size[1];
  int32_T b_dim;
  int32_T i;
  int32_T j;
  int32_T k;
  int32_T vstride;
  b_dim = 1;
  if (x_size[0] != 1) {
    b_dim = 0;
    i = x_size[0];
  } else {
    i = 1;
  }

  vwork_size[0] = i;
  idx_size[0] = x_size[0];
  vstride = 1;
  for (k = 0; k < b_dim; k++) {
    vstride *= x_size[0];
  }

  for (b_dim = 0; b_dim < 1; b_dim++) {
    for (j = 0; j < vstride; j++) {
      for (k = 0; k < i; k++) {
        vwork_data[k] = x_data[j + k * vstride];
      }

      c_sortIdx(vwork_data, vwork_size, iidx_data, iidx_size);
      for (k = 0; k < i; k++) {
        x_data[j + k * vstride] = vwork_data[k];
        idx_data[j + k * vstride] = iidx_data[k];
      }
    }
  }
}

static void c_sortIdx(real_T x_data[], int32_T x_size[1], int32_T idx_data[],
                      int32_T idx_size[1])
{
  real_T b_x_data[300];
  real_T xwork_data[300];
  real_T x4[4];
  int32_T iwork_data[300];
  int32_T perm[4];
  int32_T b_x_size[1];
  int32_T b_i;
  int32_T i;
  int32_T i3;
  int32_T i4;
  int32_T ib;
  int32_T k;
  int32_T n;
  int32_T nNaNs;
  int32_T quartetOffset;
  int16_T idx4[4];
  idx_size[0] = x_size[0];
  i = x_size[0];
  for (b_i = 0; b_i < i; b_i++) {
    idx_data[b_i] = 0;
  }

  if (x_size[0] != 0) {
    b_x_size[0] = x_size[0];
    i = x_size[0];
    idx_size[0] = x_size[0];
    for (b_i = 0; b_i < i; b_i++) {
      b_x_data[b_i] = x_data[b_i];
      idx_data[b_i] = 0;
    }

    n = x_size[0];
    for (i = 0; i < 4; i++) {
      x4[i] = 0.0;
      idx4[i] = 0;
    }

    nNaNs = 0;
    ib = 0;
    b_i = x_size[0];
    for (k = 0; k < b_i; k++) {
      if (muDoubleScalarIsNaN(b_x_data[k])) {
        idx_data[(n - nNaNs) - 1] = k + 1;
        xwork_data[(n - nNaNs) - 1] = b_x_data[k];
        nNaNs++;
      } else {
        ib++;
        idx4[ib - 1] = (int16_T)(k + 1);
        x4[ib - 1] = b_x_data[k];
        if (ib == 4) {
          quartetOffset = k - nNaNs;
          if (x4[0] <= x4[1]) {
            i = 1;
            ib = 2;
          } else {
            i = 2;
            ib = 1;
          }

          if (x4[2] <= x4[3]) {
            i3 = 3;
            i4 = 4;
          } else {
            i3 = 4;
            i4 = 3;
          }

          if (x4[i - 1] <= x4[i3 - 1]) {
            if (x4[ib - 1] <= x4[i3 - 1]) {
              perm[0] = i;
              perm[1] = ib;
              perm[2] = i3;
              perm[3] = i4;
            } else if (x4[ib - 1] <= x4[i4 - 1]) {
              perm[0] = i;
              perm[1] = i3;
              perm[2] = ib;
              perm[3] = i4;
            } else {
              perm[0] = i;
              perm[1] = i3;
              perm[2] = i4;
              perm[3] = ib;
            }
          } else if (x4[i - 1] <= x4[i4 - 1]) {
            if (x4[ib - 1] <= x4[i4 - 1]) {
              perm[0] = i3;
              perm[1] = i;
              perm[2] = ib;
              perm[3] = i4;
            } else {
              perm[0] = i3;
              perm[1] = i;
              perm[2] = i4;
              perm[3] = ib;
            }
          } else {
            perm[0] = i3;
            perm[1] = i4;
            perm[2] = i;
            perm[3] = ib;
          }

          idx_data[quartetOffset - 3] = idx4[perm[0] - 1];
          idx_data[quartetOffset - 2] = idx4[perm[1] - 1];
          idx_data[quartetOffset - 1] = idx4[perm[2] - 1];
          idx_data[quartetOffset] = idx4[perm[3] - 1];
          b_x_data[quartetOffset - 3] = x4[perm[0] - 1];
          b_x_data[quartetOffset - 2] = x4[perm[1] - 1];
          b_x_data[quartetOffset - 1] = x4[perm[2] - 1];
          b_x_data[quartetOffset] = x4[perm[3] - 1];
          ib = 0;
        }
      }
    }

    i3 = (x_size[0] - nNaNs) - 1;
    if (ib > 0) {
      for (i = 0; i < 4; i++) {
        perm[i] = 0;
      }

      if (ib == 1) {
        perm[0] = 1;
      } else if (ib == 2) {
        if (x4[0] <= x4[1]) {
          perm[0] = 1;
          perm[1] = 2;
        } else {
          perm[0] = 2;
          perm[1] = 1;
        }
      } else if (x4[0] <= x4[1]) {
        if (x4[1] <= x4[2]) {
          perm[0] = 1;
          perm[1] = 2;
          perm[2] = 3;
        } else if (x4[0] <= x4[2]) {
          perm[0] = 1;
          perm[1] = 3;
          perm[2] = 2;
        } else {
          perm[0] = 3;
          perm[1] = 1;
          perm[2] = 2;
        }
      } else if (x4[0] <= x4[2]) {
        perm[0] = 2;
        perm[1] = 1;
        perm[2] = 3;
      } else if (x4[1] <= x4[2]) {
        perm[0] = 2;
        perm[1] = 3;
        perm[2] = 1;
      } else {
        perm[0] = 3;
        perm[1] = 2;
        perm[2] = 1;
      }

      b_i = (uint8_T)ib;
      for (k = 0; k < b_i; k++) {
        quartetOffset = perm[k];
        idx_data[((i3 - ib) + k) + 1] = idx4[quartetOffset - 1];
        b_x_data[((i3 - ib) + k) + 1] = x4[quartetOffset - 1];
      }
    }

    i = nNaNs >> 1;
    for (k = 0; k < i; k++) {
      quartetOffset = idx_data[(i3 + k) + 1];
      idx_data[(i3 + k) + 1] = idx_data[(n - k) - 1];
      idx_data[(n - k) - 1] = quartetOffset;
      b_x_data[(i3 + k) + 1] = xwork_data[(n - k) - 1];
      b_x_data[(n - k) - 1] = xwork_data[(i3 + k) + 1];
    }

    if (((uint32_T)nNaNs & 1U) != 0U) {
      b_x_data[(i3 + i) + 1] = xwork_data[(i3 + i) + 1];
    }

    i = x_size[0];
    for (b_i = 0; b_i < i; b_i++) {
      iwork_data[b_i] = 0;
    }

    quartetOffset = x_size[0] - nNaNs;
    i = 2;
    if (quartetOffset > 1) {
      if ((x_size[0] >= 256) && ((quartetOffset >> 8) > 0)) {
        for (i = 0; i < 1; i++) {
          b_merge_pow2_block(idx_data, b_x_data, 0);
        }

        if (quartetOffset - 256 > 0) {
          i = x_size[0];
          for (b_i = 0; b_i < i; b_i++) {
            iwork_data[b_i] = 0;
          }

          merge_block(idx_data, b_x_data, 256, quartetOffset - 256, 2,
                      iwork_data, xwork_data);
        }

        i = 8;
      }

      merge_block(idx_data, b_x_data, 0, quartetOffset, i, iwork_data,
                  xwork_data);
    }

    x_size[0] = b_x_size[0];
    if (b_x_size[0] - 1 >= 0) {
      memcpy(&x_data[0], &b_x_data[0], (uint32_T)b_x_size[0] * sizeof(real_T));
    }
  }
}

static void b_merge_pow2_block(int32_T idx_data[], real_T x_data[], int32_T
  offset)
{
  real_T xwork[256];
  int32_T iwork[256];
  int32_T b;
  int32_T bLen;
  int32_T bLen2;
  int32_T blockOffset;
  int32_T exitg1;
  int32_T i;
  int32_T j;
  int32_T k;
  int32_T p;
  int32_T q;
  for (b = 0; b < 6; b++) {
    bLen = 1 << (b + 2);
    bLen2 = bLen << 1;
    i = 256 >> (b + 3);
    for (k = 0; k < i; k++) {
      blockOffset = (offset + k * bLen2) - 1;
      for (j = 0; j < bLen2; j++) {
        iwork[j] = idx_data[(blockOffset + j) + 1];
        xwork[j] = x_data[(blockOffset + j) + 1];
      }

      p = 0;
      q = bLen;
      do {
        exitg1 = 0;
        blockOffset++;
        if (xwork[p] <= xwork[q]) {
          idx_data[blockOffset] = iwork[p];
          x_data[blockOffset] = xwork[p];
          if (p + 1 < bLen) {
            p++;
          } else {
            exitg1 = 1;
          }
        } else {
          idx_data[blockOffset] = iwork[q];
          x_data[blockOffset] = xwork[q];
          if (q + 1 < bLen2) {
            q++;
          } else {
            q = blockOffset - p;
            for (j = p + 1; j <= bLen; j++) {
              idx_data[q + j] = iwork[j - 1];
              x_data[q + j] = xwork[j - 1];
            }

            exitg1 = 1;
          }
        }
      } while (exitg1 == 0);
    }
  }
}

static void merge_block(int32_T idx_data[], real_T x_data[], int32_T offset,
  int32_T n, int32_T preSortLevel, int32_T iwork_data[], real_T xwork_data[])
{
  int32_T bLen;
  int32_T nPairs;
  int32_T nTail;
  int32_T tailOffset;
  nPairs = n >> preSortLevel;
  bLen = 1 << preSortLevel;
  while (nPairs > 1) {
    if (((uint32_T)nPairs & 1U) != 0U) {
      nPairs--;
      tailOffset = bLen * nPairs;
      nTail = n - tailOffset;
      if (nTail > bLen) {
        merge(idx_data, x_data, offset + tailOffset, bLen, nTail - bLen,
              iwork_data, xwork_data);
      }
    }

    tailOffset = bLen << 1;
    nPairs >>= 1;
    for (nTail = 0; nTail < nPairs; nTail++) {
      merge(idx_data, x_data, offset + nTail * tailOffset, bLen, bLen,
            iwork_data, xwork_data);
    }

    bLen = tailOffset;
  }

  if (n > bLen) {
    merge(idx_data, x_data, offset, bLen, n - bLen, iwork_data, xwork_data);
  }
}

static void merge(int32_T idx_data[], real_T x_data[], int32_T offset, int32_T
                  np, int32_T nq, int32_T iwork_data[], real_T xwork_data[])
{
  int32_T exitg1;
  int32_T iout;
  int32_T n;
  int32_T p;
  int32_T qend;
  if (nq != 0) {
    n = np + nq;
    for (qend = 0; qend < n; qend++) {
      iwork_data[qend] = idx_data[offset + qend];
      xwork_data[qend] = x_data[offset + qend];
    }

    p = 0;
    n = np;
    qend = np + nq;
    iout = offset - 1;
    do {
      exitg1 = 0;
      iout++;
      if (xwork_data[p] <= xwork_data[n]) {
        idx_data[iout] = iwork_data[p];
        x_data[iout] = xwork_data[p];
        if (p + 1 < np) {
          p++;
        } else {
          exitg1 = 1;
        }
      } else {
        idx_data[iout] = iwork_data[n];
        x_data[iout] = xwork_data[n];
        if (n + 1 < qend) {
          n++;
        } else {
          n = iout - p;
          for (qend = p + 1; qend <= np; qend++) {
            idx_data[n + qend] = iwork_data[qend - 1];
            x_data[n + qend] = xwork_data[qend - 1];
          }

          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

static void visionDetectionGenerator_copyStructField2D(const emlrtStack *sp,
  coder_array_BusLaneBoundary_2D *s1, coder_array_s_CP1nqD0d6aDeTm14G *b_s2)
{
  int32_T iv[2];
  int32_T iv1[2];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T lenr;
  int32_T m;
  i = s1->size[1];
  for (m = 0; m < i; m++) {
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, b_s2->size[0], &qb_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, s1->size[1], &pb_emlrtBCI,
      (emlrtConstCTX)sp);
    lenr = b_s2->vector.data[m].Coordinates.size[0];
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, b_s2->size[0], &ob_emlrtBCI,
      (emlrtConstCTX)sp);
    emlrtDynamicBoundsCheckR2012b(m + 1, 1, s1->size[1], &nb_emlrtBCI,
      (emlrtConstCTX)sp);
    if (lenr < 1) {
      i1 = 0;
    } else {
      i1 = lenr;
    }

    emlrtDynamicBoundsCheckR2012b(m + 1, 1, b_s2->size[0], &tb_emlrtBCI,
      (emlrtConstCTX)sp);
    if (lenr < 1) {
      lenr = 0;
    } else {
      i2 = b_s2->vector.data[m].Coordinates.size[0];
      emlrtDynamicBoundsCheckR2012b(1, 1, i2, &gj_emlrtBCI, (emlrtConstCTX)sp);
      i2 = b_s2->vector.data[m].Coordinates.size[0];
      lenr = emlrtDynamicBoundsCheckR2012b(lenr, 1, i2, &hj_emlrtBCI,
        (emlrtConstCTX)sp);
    }

    emlrtDynamicBoundsCheckR2012b(m + 1, 1, s1->size[1], &sb_emlrtBCI,
      (emlrtConstCTX)sp);
    iv[0] = lenr;
    iv[1] = 3;
    iv1[0] = i1;
    iv1[1] = 3;
    emlrtSubAssignSizeCheckR2012b(&iv[0], 2, &iv1[0], 2, &oe_emlrtECI, (void *)
      sp);
    for (i1 = 0; i1 < 3; i1++) {
      for (i2 = 0; i2 < lenr; i2++) {
        b_s2->vector.data[m].Coordinates.data[i2 + b_s2->vector.data[m].
          Coordinates.size[0] * i1] = s1->vector.data[m].Coordinates[i2 + 100 *
          i1];
      }
    }
  }
}

static void xzlarf(int32_T n, int32_T iv0, real_T tau, real_T C[36], int32_T ic0,
                   real_T work[6])
{
  real_T temp;
  int32_T b_i;
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ix;
  int32_T jy;
  int32_T lastc;
  int32_T lastv;
  boolean_T exitg2;
  if (tau != 0.0) {
    lastv = n;
    i = (iv0 + n) - 2;
    while ((lastv > 0) && (C[i] == 0.0)) {
      lastv--;
      i--;
    }

    lastc = 6;
    exitg2 = false;
    while ((!exitg2) && (lastc > 0)) {
      i = (ic0 + lastc) - 1;
      ia = i;
      do {
        exitg1 = 0;
        if (ia <= i + (lastv - 1) * 6) {
          if (C[ia - 1] != 0.0) {
            exitg1 = 1;
          } else {
            ia += 6;
          }
        } else {
          lastc--;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }
  } else {
    lastv = 0;
    lastc = 0;
  }

  if (lastv > 0) {
    if (lastc != 0) {
      for (i = 0; i < lastc; i++) {
        work[i] = 0.0;
      }

      ix = iv0 - 1;
      b_i = ic0 + 6 * (lastv - 1);
      for (jy = ic0; jy <= b_i; jy += 6) {
        i = 0;
        i1 = jy + lastc;
        for (ia = jy; ia < i1; ia++) {
          work[i] += C[ia - 1] * C[ix];
          i++;
        }

        ix++;
      }
    }

    if (!(-tau == 0.0)) {
      i = ic0;
      jy = iv0 - 1;
      b_i = (uint8_T)lastv;
      for (ia = 0; ia < b_i; ia++) {
        if (C[jy] != 0.0) {
          temp = C[jy] * -tau;
          ix = 0;
          i1 = lastc + i;
          for (lastv = i; lastv < i1; lastv++) {
            C[lastv - 1] += work[ix] * temp;
            ix++;
          }
        }

        jy++;
        i += 6;
      }
    }
  }
}

static void b_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[36],
                     int32_T ic0, real_T work[6])
{
  real_T c;
  int32_T b_i;
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ix;
  int32_T jy;
  int32_T lastc;
  int32_T lastv;
  boolean_T exitg2;
  if (tau != 0.0) {
    lastv = m;
    i = (iv0 + m) - 2;
    while ((lastv > 0) && (C[i] == 0.0)) {
      lastv--;
      i--;
    }

    lastc = n;
    exitg2 = false;
    while ((!exitg2) && (lastc > 0)) {
      i = ic0 + (lastc - 1) * 6;
      ia = i;
      do {
        exitg1 = 0;
        if (ia <= (i + lastv) - 1) {
          if (C[ia - 1] != 0.0) {
            exitg1 = 1;
          } else {
            ia++;
          }
        } else {
          lastc--;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }
  } else {
    lastv = 0;
    lastc = 0;
  }

  if (lastv > 0) {
    if (lastc != 0) {
      b_i = (uint8_T)lastc;
      for (i = 0; i < b_i; i++) {
        work[i] = 0.0;
      }

      i = 0;
      b_i = ic0 + 6 * (lastc - 1);
      for (jy = ic0; jy <= b_i; jy += 6) {
        ix = iv0 - 1;
        c = 0.0;
        i1 = jy + lastv;
        for (ia = jy; ia < i1; ia++) {
          c += C[ia - 1] * C[ix];
          ix++;
        }

        work[i] += c;
        i++;
      }
    }

    if (!(-tau == 0.0)) {
      i = ic0;
      jy = 0;
      b_i = (uint8_T)lastc;
      for (lastc = 0; lastc < b_i; lastc++) {
        if (work[jy] != 0.0) {
          c = work[jy] * -tau;
          ix = iv0 - 1;
          i1 = lastv + i;
          for (ia = i; ia < i1; ia++) {
            C[ia - 1] += C[ix] * c;
            ix++;
          }
        }

        jy++;
        i += 6;
      }
    }
  }
}

static int32_T xhseqr(const emlrtStack *sp, real_T h[36])
{
  __m128d r;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  real_T v[3];
  real_T bb;
  real_T cs;
  real_T h12;
  real_T h22;
  real_T rt1r;
  real_T rt2r;
  real_T s;
  real_T sn;
  real_T tr;
  real_T tst;
  int32_T b_k;
  int32_T c_k;
  int32_T i;
  int32_T ih;
  int32_T info;
  int32_T its;
  int32_T k;
  int32_T kdefl;
  int32_T l;
  int32_T m;
  int32_T nr;
  boolean_T converged;
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T exitg3;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &bj_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &cj_emlrtRSI;
  info = 0;
  for (nr = 0; nr < 3; nr++) {
    h[(nr + 6 * nr) + 2] = 0.0;
    h[(nr + 6 * nr) + 3] = 0.0;
  }

  h[23] = 0.0;
  kdefl = 0;
  i = 5;
  exitg1 = false;
  while ((!exitg1) && (i + 1 >= 1)) {
    l = 1;
    converged = false;
    its = 0;
    exitg2 = false;
    while ((!exitg2) && (its < 301)) {
      k = i;
      exitg3 = false;
      while ((!exitg3) && ((k + 1 > l) && (!(muDoubleScalarAbs(h[k + 6 * (k - 1)])
                <= 6.0125050800269183E-292)))) {
        tst = muDoubleScalarAbs(h[(k + 6 * (k - 1)) - 1]) + muDoubleScalarAbs
          (h[k + 6 * k]);
        if (tst == 0.0) {
          if (k - 1 >= 1) {
            tst = muDoubleScalarAbs(h[(k + 6 * (k - 2)) - 1]);
          }

          if (k + 2 <= 6) {
            tst += muDoubleScalarAbs(h[(k + 6 * k) + 1]);
          }
        }

        if (muDoubleScalarAbs(h[k + 6 * (k - 1)]) <= 2.2204460492503131E-16 *
            tst) {
          tst = muDoubleScalarMax(muDoubleScalarAbs(h[k + 6 * k]),
            muDoubleScalarAbs(h[(k + 6 * (k - 1)) - 1] - h[k + 6 * k]));
          bb = muDoubleScalarMin(muDoubleScalarAbs(h[k + 6 * k]),
            muDoubleScalarAbs(h[(k + 6 * (k - 1)) - 1] - h[k + 6 * k]));
          s = tst + bb;
          if (muDoubleScalarMin(muDoubleScalarAbs(h[k + 6 * (k - 1)]),
                                muDoubleScalarAbs(h[(k + 6 * k) - 1])) *
              (muDoubleScalarMax(muDoubleScalarAbs(h[k + 6 * (k - 1)]),
                                 muDoubleScalarAbs(h[(k + 6 * k) - 1])) / s) <=
              muDoubleScalarMax(6.0125050800269183E-292, 2.2204460492503131E-16 *
                                (bb * (tst / s)))) {
            exitg3 = true;
          } else {
            k--;
          }
        } else {
          k--;
        }
      }

      l = k + 1;
      if (k + 1 > 1) {
        h[k + 6 * (k - 1)] = 0.0;
      }

      if (k + 1 >= i) {
        converged = true;
        exitg2 = true;
      } else {
        kdefl++;
        if (kdefl - div_nzp_s32(kdefl, 20) * 20 == 0) {
          s = muDoubleScalarAbs(h[i + 6 * (i - 1)]) + muDoubleScalarAbs(h[(i + 6
            * (i - 2)) - 1]);
          tst = 0.75 * s + h[i + 6 * i];
          h12 = -0.4375 * s;
          bb = s;
          h22 = tst;
        } else if (kdefl - div_nzp_s32(kdefl, 10) * 10 == 0) {
          s = muDoubleScalarAbs(h[(k + 6 * k) + 1]) + muDoubleScalarAbs(h[(k + 6
            * (k + 1)) + 2]);
          tst = 0.75 * s + h[k + 6 * k];
          h12 = -0.4375 * s;
          bb = s;
          h22 = tst;
        } else {
          tst = h[(i + 6 * (i - 1)) - 1];
          bb = h[i + 6 * (i - 1)];
          h12 = h[(i + 6 * i) - 1];
          h22 = h[i + 6 * i];
        }

        s = ((muDoubleScalarAbs(tst) + muDoubleScalarAbs(h12)) +
             muDoubleScalarAbs(bb)) + muDoubleScalarAbs(h22);
        if (s == 0.0) {
          rt1r = 0.0;
          tst = 0.0;
          rt2r = 0.0;
          bb = 0.0;
        } else {
          tst /= s;
          bb /= s;
          h12 /= s;
          h22 /= s;
          tr = (tst + h22) / 2.0;
          tst = (tst - tr) * (h22 - tr) - h12 * bb;
          bb = muDoubleScalarAbs(tst);
          c_st.site = &ej_emlrtRSI;
          d_sqrt(&c_st, &bb);
          if (tst >= 0.0) {
            rt1r = tr * s;
            rt2r = rt1r;
            tst = bb * s;
            bb = -tst;
          } else {
            rt1r = tr + bb;
            rt2r = tr - bb;
            if (muDoubleScalarAbs(rt1r - h22) <= muDoubleScalarAbs(rt2r - h22))
            {
              rt1r *= s;
              rt2r = rt1r;
            } else {
              rt2r *= s;
              rt1r = rt2r;
            }

            tst = 0.0;
            bb = 0.0;
          }
        }

        m = i - 2;
        exitg3 = false;
        while ((!exitg3) && (m + 1 >= k + 1)) {
          s = (muDoubleScalarAbs(h[m + 6 * m] - rt2r) + muDoubleScalarAbs(bb)) +
            muDoubleScalarAbs(h[(m + 6 * m) + 1]);
          h12 = h[(m + 6 * m) + 1] / s;
          v[0] = (h12 * h[m + 6 * (m + 1)] + (h[m + 6 * m] - rt1r) * ((h[m + 6 *
                    m] - rt2r) / s)) - tst * (bb / s);
          v[1] = h12 * (((h[m + 6 * m] + h[(m + 6 * (m + 1)) + 1]) - rt1r) -
                        rt2r);
          v[2] = h12 * h[(m + 6 * (m + 1)) + 2];
          s = (muDoubleScalarAbs(v[0]) + muDoubleScalarAbs(v[1])) +
            muDoubleScalarAbs(v[2]);
          for (b_k = 0; b_k <= 0; b_k += 2) {
            r = _mm_loadu_pd(&v[0]);
            _mm_storeu_pd(&v[0], _mm_div_pd(r, _mm_set1_pd(s)));
          }

          for (b_k = 2; b_k < 3; b_k++) {
            v[2] /= s;
          }

          if ((m + 1 == k + 1) || (muDoubleScalarAbs(h[m + 6 * (m - 1)]) *
               (muDoubleScalarAbs(v[1]) + muDoubleScalarAbs(v[2])) <=
               2.2204460492503131E-16 * muDoubleScalarAbs(v[0]) *
               ((muDoubleScalarAbs(h[(m + 6 * (m - 1)) - 1]) + muDoubleScalarAbs
                 (h[m + 6 * m])) + muDoubleScalarAbs(h[(m + 6 * (m + 1)) + 1]))))
          {
            exitg3 = true;
          } else {
            m--;
          }
        }

        for (c_k = m + 1; c_k <= i; c_k++) {
          ih = (i - c_k) + 2;
          nr = muIntScalarMin_sint32(3, ih);
          if (c_k > m + 1) {
            ih = ((c_k - 2) * 6 + c_k) - 2;
            for (b_k = 0; b_k < nr; b_k++) {
              v[b_k] = h[(ih + b_k) + 1];
            }
          }

          tst = v[0];
          rt1r = xzlarfg(nr, &tst, v);
          if (c_k > m + 1) {
            h[(c_k + 6 * (c_k - 2)) - 1] = tst;
            h[c_k + 6 * (c_k - 2)] = 0.0;
            if (c_k < i) {
              h[(c_k + 6 * (c_k - 2)) + 1] = 0.0;
            }
          } else if (m + 1 > k + 1) {
            h[(c_k + 6 * (c_k - 2)) - 1] *= 1.0 - rt1r;
          }

          tst = v[1];
          bb = rt1r * v[1];
          if (nr == 3) {
            rt2r = v[2];
            tr = rt1r * v[2];
            for (nr = c_k; nr < 7; nr++) {
              h12 = (h[(c_k + 6 * (nr - 1)) - 1] + tst * h[c_k + 6 * (nr - 1)])
                + rt2r * h[(c_k + 6 * (nr - 1)) + 1];
              h[(c_k + 6 * (nr - 1)) - 1] -= h12 * rt1r;
              h[c_k + 6 * (nr - 1)] -= h12 * bb;
              h[(c_k + 6 * (nr - 1)) + 1] -= h12 * tr;
            }

            ih = c_k + 3;
            nr = i + 1;
            b_k = muIntScalarMin_sint32(ih, nr);
            for (nr = 0; nr < b_k; nr++) {
              h12 = (h[nr + 6 * (c_k - 1)] + tst * h[nr + 6 * c_k]) + rt2r *
                h[nr + 6 * (c_k + 1)];
              h[nr + 6 * (c_k - 1)] -= h12 * rt1r;
              h[nr + 6 * c_k] -= h12 * bb;
              h[nr + 6 * (c_k + 1)] -= h12 * tr;
            }
          } else if (nr == 2) {
            for (nr = c_k; nr < 7; nr++) {
              h12 = h[(c_k + 6 * (nr - 1)) - 1] + tst * h[c_k + 6 * (nr - 1)];
              h[(c_k + 6 * (nr - 1)) - 1] -= h12 * rt1r;
              h[c_k + 6 * (nr - 1)] -= h12 * bb;
            }

            for (nr = 0; nr <= i; nr++) {
              h12 = h[nr + 6 * (c_k - 1)] + tst * h[nr + 6 * c_k];
              h[nr + 6 * (c_k - 1)] -= h12 * rt1r;
              h[nr + 6 * c_k] -= h12 * bb;
            }
          }
        }

        its++;
      }
    }

    if (!converged) {
      info = i + 1;
      exitg1 = true;
    } else {
      if ((l != i + 1) && (l == i)) {
        tst = h[(i + 6 * (i - 1)) - 1];
        bb = h[(i + 6 * i) - 1];
        h12 = h[i + 6 * (i - 1)];
        rt2r = h[i + 6 * i];
        c_st.site = &dj_emlrtRSI;
        xdlanv2(&c_st, &tst, &bb, &h12, &rt2r, &tr, &rt1r, &h22, &s, &cs, &sn);
        h[(i + 6 * (i - 1)) - 1] = tst;
        h[(i + 6 * i) - 1] = bb;
        h[i + 6 * (i - 1)] = h12;
        h[i + 6 * i] = rt2r;
        if (i + 1 < 6) {
          nr = ((i + 1) * 6 + i) - 1;
          ih = (i + 1) * 6 + i;
          b_k = 4 - i;
          for (k = 0; k <= b_k; k++) {
            tst = cs * h[nr] + sn * h[ih];
            h[ih] = cs * h[ih] - sn * h[nr];
            h[nr] = tst;
            ih += 6;
            nr += 6;
          }
        }

        if (i - 1 >= 1) {
          nr = (i - 1) * 6;
          ih = i * 6;
          b_k = (uint8_T)(i - 1);
          for (k = 0; k < b_k; k++) {
            tst = cs * h[nr] + sn * h[ih];
            h[ih] = cs * h[ih] - sn * h[nr];
            h[nr] = tst;
            ih++;
            nr++;
          }
        }
      }

      kdefl = 0;
      i = l - 2;
    }
  }

  for (nr = 0; nr < 4; nr++) {
    for (i = nr + 3; i < 7; i++) {
      h[(i + 6 * nr) - 1] = 0.0;
    }
  }

  return info;
}

static real_T xzlarfg(int32_T n, real_T *alpha1, real_T x[3])
{
  __m128d r;
  real_T tau;
  real_T xnorm;
  int32_T k;
  int32_T knt;
  int32_T scalarLB;
  int32_T vectorUB;
  tau = 0.0;
  if (n > 0) {
    xnorm = b_xnrm2(n - 1, x);
    if (xnorm != 0.0) {
      xnorm = muDoubleScalarHypot(*alpha1, xnorm);
      if (*alpha1 >= 0.0) {
        xnorm = -xnorm;
      }

      if (muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) {
        knt = -1;
        do {
          knt++;
          scalarLB = (n - 1) / 2 * 2 + 2;
          vectorUB = scalarLB - 2;
          for (k = 2; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&x[k - 1]);
            _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(9.9792015476736E+291),
              r));
          }

          for (k = scalarLB; k <= n; k++) {
            x[k - 1] *= 9.9792015476736E+291;
          }

          xnorm *= 9.9792015476736E+291;
          *alpha1 *= 9.9792015476736E+291;
        } while ((muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) && (knt +
                  1 < 20));

        xnorm = muDoubleScalarHypot(*alpha1, b_xnrm2(n - 1, x));
        if (*alpha1 >= 0.0) {
          xnorm = -xnorm;
        }

        tau = (xnorm - *alpha1) / xnorm;
        *alpha1 = 1.0 / (*alpha1 - xnorm);
        scalarLB = (n - 1) / 2 * 2 + 2;
        vectorUB = scalarLB - 2;
        for (k = 2; k <= vectorUB; k += 2) {
          r = _mm_loadu_pd(&x[k - 1]);
          _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(*alpha1), r));
        }

        for (k = scalarLB; k <= n; k++) {
          x[k - 1] *= *alpha1;
        }

        for (k = 0; k <= knt; k++) {
          xnorm *= 1.0020841800044864E-292;
        }

        *alpha1 = xnorm;
      } else {
        tau = (xnorm - *alpha1) / xnorm;
        *alpha1 = 1.0 / (*alpha1 - xnorm);
        scalarLB = (n - 1) / 2 * 2 + 2;
        vectorUB = scalarLB - 2;
        for (k = 2; k <= vectorUB; k += 2) {
          r = _mm_loadu_pd(&x[k - 1]);
          _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(*alpha1), r));
        }

        for (k = scalarLB; k <= n; k++) {
          x[k - 1] *= *alpha1;
        }

        *alpha1 = xnorm;
      }
    }
  }

  return tau;
}

static void xdlanv2(const emlrtStack *sp, real_T *a, real_T *b, real_T *c,
                    real_T *d, real_T *rt1r, real_T *rt1i, real_T *rt2r, real_T *
                    rt2i, real_T *cs, real_T *sn)
{
  emlrtStack st;
  real_T bcmax;
  real_T bcmis;
  real_T p;
  real_T scale;
  real_T tau;
  real_T temp;
  real_T z;
  int32_T count;
  int32_T y;
  st.prev = sp;
  st.tls = sp->tls;
  if (*c == 0.0) {
    *cs = 1.0;
    *sn = 0.0;
  } else if (*b == 0.0) {
    *cs = 0.0;
    *sn = 1.0;
    temp = *d;
    *d = *a;
    *a = temp;
    *b = -*c;
    *c = 0.0;
  } else if ((*a - *d == 0.0) && ((*b < 0.0) != (*c < 0.0))) {
    *cs = 1.0;
    *sn = 0.0;
  } else {
    temp = *a - *d;
    p = 0.5 * temp;
    bcmax = muDoubleScalarMax(muDoubleScalarAbs(*b), muDoubleScalarAbs(*c));
    if (!(*b < 0.0)) {
      count = 1;
    } else {
      count = -1;
    }

    if (!(*c < 0.0)) {
      y = 1;
    } else {
      y = -1;
    }

    bcmis = muDoubleScalarMin(muDoubleScalarAbs(*b), muDoubleScalarAbs(*c)) *
      (real_T)count * (real_T)y;
    scale = muDoubleScalarMax(muDoubleScalarAbs(p), bcmax);
    z = p / scale * p + bcmax / scale * bcmis;
    if (z >= 8.8817841970012523E-16) {
      st.site = &fj_emlrtRSI;
      d_sqrt(&st, &scale);
      st.site = &fj_emlrtRSI;
      d_sqrt(&st, &z);
      *a = scale * z;
      if (p < 0.0) {
        *a = -*a;
      }

      z = p + *a;
      *a = *d + z;
      *d -= bcmax / z * bcmis;
      tau = muDoubleScalarHypot(*c, z);
      *cs = z / tau;
      *sn = *c / tau;
      *b -= *c;
      *c = 0.0;
    } else {
      bcmax = *b + *c;
      scale = muDoubleScalarMax(muDoubleScalarAbs(temp), muDoubleScalarAbs(bcmax));
      count = 0;
      while ((scale >= 7.4428285367870146E+137) && (count <= 20)) {
        bcmax *= 1.3435752215134178E-138;
        temp *= 1.3435752215134178E-138;
        scale = muDoubleScalarMax(muDoubleScalarAbs(temp), muDoubleScalarAbs
          (bcmax));
        count++;
      }

      while ((scale <= 1.3435752215134178E-138) && (count <= 20)) {
        bcmax *= 7.4428285367870146E+137;
        temp *= 7.4428285367870146E+137;
        scale = muDoubleScalarMax(muDoubleScalarAbs(temp), muDoubleScalarAbs
          (bcmax));
        count++;
      }

      tau = muDoubleScalarHypot(bcmax, temp);
      *cs = 0.5 * (muDoubleScalarAbs(bcmax) / tau + 1.0);
      st.site = &gj_emlrtRSI;
      d_sqrt(&st, cs);
      if (!(bcmax < 0.0)) {
        count = 1;
      } else {
        count = -1;
      }

      *sn = -(0.5 * temp / (tau * *cs)) * (real_T)count;
      z = *a * *cs + *b * *sn;
      bcmis = -*a * *sn + *b * *cs;
      scale = *c * *cs + *d * *sn;
      bcmax = -*c * *sn + *d * *cs;
      *b = bcmis * *cs + bcmax * *sn;
      *c = -z * *sn + scale * *cs;
      temp = 0.5 * ((z * *cs + scale * *sn) + (-bcmis * *sn + bcmax * *cs));
      *a = temp;
      *d = temp;
      if (*c != 0.0) {
        if (*b != 0.0) {
          if ((*b < 0.0) == (*c < 0.0)) {
            bcmax = muDoubleScalarAbs(*b);
            st.site = &hj_emlrtRSI;
            d_sqrt(&st, &bcmax);
            scale = muDoubleScalarAbs(*c);
            st.site = &ij_emlrtRSI;
            d_sqrt(&st, &scale);
            p = bcmax * scale;
            if (*c < 0.0) {
              p = -p;
            }

            bcmis = muDoubleScalarAbs(*b + *c);
            st.site = &jj_emlrtRSI;
            d_sqrt(&st, &bcmis);
            tau = 1.0 / bcmis;
            *a = temp + p;
            *d = temp - p;
            *b -= *c;
            *c = 0.0;
            bcmis = bcmax * tau;
            bcmax = scale * tau;
            temp = *cs * bcmis - *sn * bcmax;
            *sn = *cs * bcmax + *sn * bcmis;
            *cs = temp;
          }
        } else {
          *b = -*c;
          *c = 0.0;
          temp = *cs;
          *cs = -*sn;
          *sn = temp;
        }
      }
    }
  }

  *rt1r = *a;
  *rt2r = *d;
  if (*c == 0.0) {
    *rt1i = 0.0;
    *rt2i = 0.0;
  } else {
    bcmis = muDoubleScalarAbs(*b);
    st.site = &kj_emlrtRSI;
    d_sqrt(&st, &bcmis);
    scale = muDoubleScalarAbs(*c);
    st.site = &kj_emlrtRSI;
    d_sqrt(&st, &scale);
    *rt1i = bcmis * scale;
    *rt2i = -*rt1i;
  }
}

static void objectDetection_set_Measurement(const emlrtStack *sp,
  objectDetection *detection, real_T b_value[6])
{
  static const int32_T iv[2] = { 1, 37 };

  static const int32_T iv1[2] = { 1, 46 };

  static const int32_T iv2[2] = { 1, 11 };

  static char_T d_u[46] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'e', 'a', 't', 't',
    'r', 'i', 'b', 'u', 't', 'e', 's', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
    'F', 'i', 'n', 'i', 't', 'e' };

  static char_T b_u[37] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'o', 'b', 'j',
    'e', 'c', 't', 'D', 'e', 't', 'e', 'c', 't', 'i', 'o', 'n', ':', 'e', 'x',
    'p', 'e', 'c', 't', 'e', 'd', 'F', 'i', 'n', 'i', 't', 'e' };

  static char_T f_u[11] = { 'M', 'e', 'a', 's', 'u', 'r', 'e', 'm', 'e', 'n',
    't' };

  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T c_u[46];
  char_T u[37];
  char_T e_u[11];
  boolean_T exitg1;
  boolean_T p;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &pj_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &ib_emlrtRSI;
  p = true;
  i = 0;
  exitg1 = false;
  while ((!exitg1) && (i < 6)) {
    if ((!muDoubleScalarIsInf(b_value[i])) && (!muDoubleScalarIsNaN(b_value[i])))
    {
      i++;
    } else {
      p = false;
      exitg1 = true;
    }
  }

  if (!p) {
    for (i = 0; i < 37; i++) {
      u[i] = b_u[i];
    }

    y = NULL;
    m = emlrtCreateCharArray(2, &iv[0]);
    emlrtInitCharArrayR2013a(&b_st, 37, m, &u[0]);
    emlrtAssign(&y, m);
    for (i = 0; i < 46; i++) {
      c_u[i] = d_u[i];
    }

    b_y = NULL;
    m = emlrtCreateCharArray(2, &iv1[0]);
    emlrtInitCharArrayR2013a(&b_st, 46, m, &c_u[0]);
    emlrtAssign(&b_y, m);
    for (i = 0; i < 11; i++) {
      e_u[i] = f_u[i];
    }

    c_y = NULL;
    m = emlrtCreateCharArray(2, &iv2[0]);
    emlrtInitCharArrayR2013a(&b_st, 11, m, &e_u[0]);
    emlrtAssign(&c_y, m);
    c_st.site = &sv_emlrtRSI;
    error(&c_st, y, getString(&c_st, message(&c_st, b_y, c_y, &d_emlrtMCI),
           &d_emlrtMCI), &d_emlrtMCI);
  }

  for (i = 0; i < 6; i++) {
    detection->Measurement[i] = b_value[i];
  }
}

static void xrotg(real_T *a, real_T *b, real_T *c, real_T *s)
{
  *c = 0.0;
  *s = 0.0;
  drotg(a, b, c, s);
}

static void introsort(const emlrtStack *sp, real_T x_data[], int32_T b_xstart,
                      int32_T b_xend, real_T cmp_workspace_pts_data[], int32_T
                      cmp_workspace_pts_size[2])
{
  static const int32_T iv[2] = { 1, 28 };

  static const int32_T iv1[2] = { 1, 28 };

  static const int32_T iv2[2] = { 1, 28 };

  static const int32_T iv3[2] = { 1, 28 };

  static const int32_T iv4[2] = { 1, 28 };

  static const int32_T iv5[2] = { 1, 28 };

  static char_T b_u[28] = { 'C', 'o', 'd', 'e', 'r', ':', 't', 'o', 'o', 'l',
    'b', 'o', 'x', ':', 'S', 't', 'a', 'c', 'k', 'P', 'u', 's', 'h', 'L', 'i',
    'm', 'i', 't' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *d_y;
  const mxArray *e_y;
  const mxArray *f_y;
  const mxArray *m;
  const mxArray *y;
  sBaHy6MF1FZJsDHxMqvBaiH b_st_d_data[120];
  sBaHy6MF1FZJsDHxMqvBaiH st_d_data[120];
  sBaHy6MF1FZJsDHxMqvBaiH c_st_d_data;
  int32_T st_d_size[1];
  int32_T i;
  int32_T nsort;
  int32_T p;
  int32_T pmax;
  int32_T pmin;
  int32_T pow2p;
  char_T u[28];
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  if (b_xstart >= b_xend) {
  } else {
    nsort = (b_xend - b_xstart) + 1;
    if (nsort <= 32) {
      insertionsort(x_data, b_xstart, b_xend, cmp_workspace_pts_data,
                    cmp_workspace_pts_size);
    } else {
      pmax = 31;
      pmin = 0;
      exitg1 = false;
      while ((!exitg1) && (pmax - pmin > 1)) {
        p = (pmin + pmax) >> 1;
        pow2p = 1 << p;
        if (pow2p == nsort) {
          pmax = p;
          exitg1 = true;
        } else if (pow2p > nsort) {
          pmax = p;
        } else {
          pmin = p;
        }
      }

      pmax = (pmax - 1) << 1;
      st.site = &xl_emlrtRSI;
      stack_stack(&st, pmax << 1, st_d_data, st_d_size, &pmin);
      if (st_d_size[0] <= 0) {
        for (i = 0; i < 28; i++) {
          u[i] = b_u[i];
        }

        y = NULL;
        m = emlrtCreateCharArray(2, &iv[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
        emlrtAssign(&y, m);
        for (i = 0; i < 28; i++) {
          u[i] = b_u[i];
        }

        b_y = NULL;
        m = emlrtCreateCharArray(2, &iv1[0]);
        emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
        emlrtAssign(&b_y, m);
        st.site = &ew_emlrtRSI;
        error(&st, y, getString(&st, b_message(&st, b_y, &cc_emlrtMCI),
               &cc_emlrtMCI), &cc_emlrtMCI);
      }

      st_d_data[0].xstart = b_xstart;
      st_d_data[0].xend = b_xend;
      st_d_data[0].depth = 0;
      pmin = 1;
      while (pmin > 0) {
        nsort = st_d_size[0];
        pow2p = pmin - 1;
        for (i = 0; i < nsort; i++) {
          c_st_d_data = st_d_data[i];
          st_d_data[i] = c_st_d_data;
          b_st_d_data[i] = c_st_d_data;
        }

        nsort = b_st_d_data[pmin - 1].depth;
        pmin--;
        if ((b_st_d_data[pow2p].xend - b_st_d_data[pow2p].xstart) + 1 <= 32) {
          insertionsort(x_data, b_st_d_data[pow2p].xstart, b_st_d_data[pow2p].
                        xend, cmp_workspace_pts_data, cmp_workspace_pts_size);
        } else if (nsort == pmax) {
          b_heapsort(x_data, b_st_d_data[pow2p].xstart, b_st_d_data[pow2p].xend,
                     cmp_workspace_pts_data, cmp_workspace_pts_size);
        } else {
          p = sortpartition(x_data, b_st_d_data[pow2p].xstart, b_st_d_data[pow2p]
                            .xend, cmp_workspace_pts_data,
                            cmp_workspace_pts_size);
          if (p + 1 < b_st_d_data[pow2p].xend) {
            if (pow2p >= st_d_size[0]) {
              for (i = 0; i < 28; i++) {
                u[i] = b_u[i];
              }

              c_y = NULL;
              m = emlrtCreateCharArray(2, &iv2[0]);
              emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
              emlrtAssign(&c_y, m);
              for (i = 0; i < 28; i++) {
                u[i] = b_u[i];
              }

              e_y = NULL;
              m = emlrtCreateCharArray(2, &iv4[0]);
              emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
              emlrtAssign(&e_y, m);
              st.site = &ew_emlrtRSI;
              error(&st, c_y, getString(&st, b_message(&st, e_y, &cc_emlrtMCI),
                     &cc_emlrtMCI), &cc_emlrtMCI);
            }

            st_d_data[pow2p].xstart = p + 1;
            st_d_data[pow2p].xend = b_st_d_data[pow2p].xend;
            st_d_data[pow2p].depth = nsort + 1;
            pmin = pow2p + 1;
          }

          if (b_st_d_data[pow2p].xstart < p) {
            if (pmin >= st_d_size[0]) {
              for (i = 0; i < 28; i++) {
                u[i] = b_u[i];
              }

              d_y = NULL;
              m = emlrtCreateCharArray(2, &iv3[0]);
              emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
              emlrtAssign(&d_y, m);
              for (i = 0; i < 28; i++) {
                u[i] = b_u[i];
              }

              f_y = NULL;
              m = emlrtCreateCharArray(2, &iv5[0]);
              emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 28, m, &u[0]);
              emlrtAssign(&f_y, m);
              st.site = &ew_emlrtRSI;
              error(&st, d_y, getString(&st, b_message(&st, f_y, &cc_emlrtMCI),
                     &cc_emlrtMCI), &cc_emlrtMCI);
            }

            st_d_data[pmin].xstart = b_st_d_data[pow2p].xstart;
            st_d_data[pmin].xend = p;
            st_d_data[pmin].depth = nsort + 1;
            pmin++;
          }
        }
      }
    }
  }
}

static void insertionsort(real_T x_data[], int32_T b_xstart, int32_T b_xend,
  real_T cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2])
{
  real_T xc;
  int32_T idx;
  int32_T k;
  boolean_T exitg1;
  boolean_T varargout_1;
  for (k = b_xstart + 1; k <= b_xend; k++) {
    xc = x_data[k - 1];
    idx = k - 2;
    exitg1 = false;
    while ((!exitg1) && (idx + 1 >= b_xstart)) {
      if (cmp_workspace_pts_data[((int32_T)x_data[idx] + cmp_workspace_pts_size
           [0]) - 1] > cmp_workspace_pts_data[((int32_T)xc +
           cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = true;
      } else if (cmp_workspace_pts_data[((int32_T)x_data[idx] +
                  cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data
                 [((int32_T)xc + cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = false;
      } else {
        varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[idx] - 1] >
                       cmp_workspace_pts_data[(int32_T)xc - 1]);
      }

      if (varargout_1) {
        x_data[idx + 1] = x_data[idx];
        idx--;
      } else {
        exitg1 = true;
      }
    }

    x_data[idx + 1] = xc;
  }
}

static void b_heapsort(real_T x_data[], int32_T b_xstart, int32_T b_xend, real_T
  cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2])
{
  real_T t;
  int32_T idx;
  int32_T n;
  n = b_xend - b_xstart;
  for (idx = n + 1; idx >= 1; idx--) {
    heapify(x_data, idx, b_xstart, b_xend, cmp_workspace_pts_data,
            cmp_workspace_pts_size);
  }

  for (idx = 0; idx < n; idx++) {
    t = x_data[b_xend - 1];
    x_data[b_xend - 1] = x_data[b_xstart - 1];
    x_data[b_xstart - 1] = t;
    b_xend--;
    heapify(x_data, 1, b_xstart, b_xend, cmp_workspace_pts_data,
            cmp_workspace_pts_size);
  }
}

static void heapify(real_T x_data[], int32_T idx, int32_T b_xstart, int32_T
                    b_xend, real_T cmp_workspace_pts_data[], int32_T
                    cmp_workspace_pts_size[2])
{
  real_T extremum;
  real_T xcmp;
  int32_T cmpIdx;
  int32_T extremumIdx;
  int32_T leftIdx;
  boolean_T changed;
  boolean_T exitg1;
  boolean_T varargout_1;
  changed = true;
  extremumIdx = (idx + b_xstart) - 2;
  leftIdx = ((idx << 1) + b_xstart) - 2;
  exitg1 = false;
  while ((!exitg1) && (leftIdx + 1 < b_xend)) {
    changed = false;
    extremum = x_data[extremumIdx];
    cmpIdx = leftIdx + 1;
    xcmp = x_data[leftIdx];
    if (cmp_workspace_pts_data[((int32_T)x_data[leftIdx + 1] +
         cmp_workspace_pts_size[0]) - 1] > cmp_workspace_pts_data[((int32_T)
         x_data[leftIdx] + cmp_workspace_pts_size[0]) - 1]) {
      varargout_1 = true;
    } else if (cmp_workspace_pts_data[((int32_T)x_data[leftIdx + 1] +
                cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data
               [((int32_T)x_data[leftIdx] + cmp_workspace_pts_size[0]) - 1]) {
      varargout_1 = false;
    } else {
      varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[leftIdx + 1] - 1] >
                     cmp_workspace_pts_data[(int32_T)x_data[leftIdx] - 1]);
    }

    if (varargout_1) {
      cmpIdx = leftIdx + 2;
      xcmp = x_data[leftIdx + 1];
    }

    if (cmp_workspace_pts_data[((int32_T)xcmp + cmp_workspace_pts_size[0]) - 1] >
        cmp_workspace_pts_data[((int32_T)x_data[extremumIdx] +
         cmp_workspace_pts_size[0]) - 1]) {
      varargout_1 = true;
    } else if (cmp_workspace_pts_data[((int32_T)xcmp + cmp_workspace_pts_size[0])
               - 1] < cmp_workspace_pts_data[((int32_T)x_data[extremumIdx] +
                cmp_workspace_pts_size[0]) - 1]) {
      varargout_1 = false;
    } else {
      varargout_1 = (cmp_workspace_pts_data[(int32_T)xcmp - 1] >
                     cmp_workspace_pts_data[(int32_T)x_data[extremumIdx] - 1]);
    }

    if (varargout_1) {
      x_data[extremumIdx] = xcmp;
      x_data[cmpIdx - 1] = extremum;
      extremumIdx = cmpIdx - 1;
      leftIdx = ((((cmpIdx - b_xstart) + 1) << 1) + b_xstart) - 2;
      changed = true;
    } else {
      exitg1 = true;
    }
  }

  if (changed && (leftIdx + 1 <= b_xend)) {
    extremum = x_data[extremumIdx];
    if (cmp_workspace_pts_data[((int32_T)x_data[leftIdx] +
         cmp_workspace_pts_size[0]) - 1] > cmp_workspace_pts_data[((int32_T)
         x_data[extremumIdx] + cmp_workspace_pts_size[0]) - 1]) {
      varargout_1 = true;
    } else if (cmp_workspace_pts_data[((int32_T)x_data[leftIdx] +
                cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data
               [((int32_T)x_data[extremumIdx] + cmp_workspace_pts_size[0]) - 1])
    {
      varargout_1 = false;
    } else {
      varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[leftIdx] - 1] >
                     cmp_workspace_pts_data[(int32_T)x_data[extremumIdx] - 1]);
    }

    if (varargout_1) {
      x_data[extremumIdx] = x_data[leftIdx];
      x_data[leftIdx] = extremum;
    }
  }
}

static int32_T sortpartition(real_T x_data[], int32_T b_xstart, int32_T b_xend,
  real_T cmp_workspace_pts_data[], int32_T cmp_workspace_pts_size[2])
{
  real_T pivot;
  real_T t;
  int32_T exitg1;
  int32_T exitg2;
  int32_T i;
  int32_T p;
  int32_T xmid;
  boolean_T varargout_1;
  xmid = (b_xstart + div_nzp_s32(b_xend - b_xstart, 2)) - 1;
  if (cmp_workspace_pts_data[((int32_T)x_data[b_xstart - 1] +
       cmp_workspace_pts_size[0]) - 1] > cmp_workspace_pts_data[((int32_T)
       x_data[xmid] + cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = true;
  } else if (cmp_workspace_pts_data[((int32_T)x_data[b_xstart - 1] +
              cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data[((int32_T)
              x_data[xmid] + cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = false;
  } else {
    varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[b_xstart - 1] - 1] >
                   cmp_workspace_pts_data[(int32_T)x_data[xmid] - 1]);
  }

  if (varargout_1) {
    t = x_data[b_xstart - 1];
    x_data[b_xstart - 1] = x_data[xmid];
    x_data[xmid] = t;
  }

  if (cmp_workspace_pts_data[((int32_T)x_data[b_xstart - 1] +
       cmp_workspace_pts_size[0]) - 1] > cmp_workspace_pts_data[((int32_T)
       x_data[b_xend - 1] + cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = true;
  } else if (cmp_workspace_pts_data[((int32_T)x_data[b_xstart - 1] +
              cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data[((int32_T)
              x_data[b_xend - 1] + cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = false;
  } else {
    varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[b_xstart - 1] - 1] >
                   cmp_workspace_pts_data[(int32_T)x_data[b_xend - 1] - 1]);
  }

  if (varargout_1) {
    t = x_data[b_xstart - 1];
    x_data[b_xstart - 1] = x_data[b_xend - 1];
    x_data[b_xend - 1] = t;
  }

  if (cmp_workspace_pts_data[((int32_T)x_data[xmid] + cmp_workspace_pts_size[0])
      - 1] > cmp_workspace_pts_data[((int32_T)x_data[b_xend - 1] +
       cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = true;
  } else if (cmp_workspace_pts_data[((int32_T)x_data[xmid] +
              cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data[((int32_T)
              x_data[b_xend - 1] + cmp_workspace_pts_size[0]) - 1]) {
    varargout_1 = false;
  } else {
    varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[xmid] - 1] >
                   cmp_workspace_pts_data[(int32_T)x_data[b_xend - 1] - 1]);
  }

  if (varargout_1) {
    t = x_data[xmid];
    x_data[xmid] = x_data[b_xend - 1];
    x_data[b_xend - 1] = t;
  }

  pivot = x_data[xmid];
  x_data[xmid] = x_data[b_xend - 2];
  x_data[b_xend - 2] = pivot;
  i = b_xstart - 1;
  xmid = b_xend - 2;
  do {
    exitg1 = 0;
    i++;
    do {
      exitg2 = 0;
      if (cmp_workspace_pts_data[((int32_T)pivot + cmp_workspace_pts_size[0]) -
          1] > cmp_workspace_pts_data[((int32_T)x_data[i] +
           cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = true;
      } else if (cmp_workspace_pts_data[((int32_T)pivot +
                  cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data
                 [((int32_T)x_data[i] + cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = false;
      } else {
        varargout_1 = (cmp_workspace_pts_data[(int32_T)pivot - 1] >
                       cmp_workspace_pts_data[(int32_T)x_data[i] - 1]);
      }

      if (varargout_1) {
        i++;
      } else {
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    xmid--;
    do {
      exitg2 = 0;
      if (cmp_workspace_pts_data[((int32_T)x_data[xmid] +
           cmp_workspace_pts_size[0]) - 1] > cmp_workspace_pts_data[((int32_T)
           pivot + cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = true;
      } else if (cmp_workspace_pts_data[((int32_T)x_data[xmid] +
                  cmp_workspace_pts_size[0]) - 1] < cmp_workspace_pts_data
                 [((int32_T)pivot + cmp_workspace_pts_size[0]) - 1]) {
        varargout_1 = false;
      } else {
        varargout_1 = (cmp_workspace_pts_data[(int32_T)x_data[xmid] - 1] >
                       cmp_workspace_pts_data[(int32_T)pivot - 1]);
      }

      if (varargout_1) {
        xmid--;
      } else {
        exitg2 = 1;
      }
    } while (exitg2 == 0);

    if (i + 1 >= xmid + 1) {
      exitg1 = 1;
    } else {
      t = x_data[i];
      x_data[i] = x_data[xmid];
      x_data[xmid] = t;
    }
  } while (exitg1 == 0);

  p = i + 1;
  x_data[b_xend - 2] = x_data[i];
  x_data[i] = pivot;
  return p;
}

static real_T eml_rand_mt19937ar(const emlrtStack *sp, uint32_T e_state[625])
{
  static const int32_T iv[2] = { 1, 37 };

  static const int32_T iv1[2] = { 1, 37 };

  static char_T c_u[37] = { 'C', 'o', 'd', 'e', 'r', ':', 'M', 'A', 'T', 'L',
    'A', 'B', ':', 'r', 'a', 'n', 'd', '_', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
    'T', 'w', 'i', 's', 't', 'e', 'r', 'S', 't', 'a', 't', 'e' };

  emlrtStack b_st;
  emlrtStack st;
  const mxArray *b_y;
  const mxArray *c_y;
  const mxArray *m;
  int32_T exitg1;
  int32_T k;
  int32_T kk;
  uint32_T u[2];
  uint32_T mti;
  uint32_T y;
  char_T b_u[37];
  boolean_T exitg2;
  boolean_T isvalid;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &wm_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;

  /* ========================= COPYRIGHT NOTICE ============================ */
  /*  This is a uniform (0,1) pseudorandom number generator based on: */
  /*  */
  /*  A C-program for MT19937, with initialization improved 2002/1/26. */
  /*  Coded by Takuji Nishimura and Makoto Matsumoto. */
  /*  */
  /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, */
  /*  All rights reserved. */
  /*  */
  /*  Redistribution and use in source and binary forms, with or without */
  /*  modification, are permitted provided that the following conditions */
  /*  are met: */
  /*  */
  /*    1. Redistributions of source code must retain the above copyright */
  /*       notice, this list of conditions and the following disclaimer. */
  /*  */
  /*    2. Redistributions in binary form must reproduce the above copyright */
  /*       notice, this list of conditions and the following disclaimer */
  /*       in the documentation and/or other materials provided with the */
  /*       distribution. */
  /*  */
  /*    3. The names of its contributors may not be used to endorse or */
  /*       promote products derived from this software without specific */
  /*       prior written permission. */
  /*  */
  /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS */
  /*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT */
  /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR */
  /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT */
  /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, */
  /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT */
  /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, */
  /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY */
  /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT */
  /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */
  /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
  /*  */
  /* =============================   END   ================================= */
  do {
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = e_state[624] + 1U;
      if (mti >= 625U) {
        for (kk = 0; kk < 227; kk++) {
          y = (e_state[kk] & 2147483648U) | (e_state[kk + 1] & 2147483647U);
          if ((y & 1U) == 0U) {
            y >>= 1U;
          } else {
            y = y >> 1U ^ 2567483615U;
          }

          e_state[kk] = e_state[kk + 397] ^ y;
        }

        for (kk = 0; kk < 396; kk++) {
          y = (e_state[kk + 227] & 2147483648U) | (e_state[kk + 228] &
            2147483647U);
          if ((y & 1U) == 0U) {
            y >>= 1U;
          } else {
            y = y >> 1U ^ 2567483615U;
          }

          e_state[kk + 227] = e_state[kk] ^ y;
        }

        y = (e_state[623] & 2147483648U) | (e_state[0] & 2147483647U);
        if ((y & 1U) == 0U) {
          y >>= 1U;
        } else {
          y = y >> 1U ^ 2567483615U;
        }

        e_state[623] = e_state[396] ^ y;
        mti = 1U;
      }

      y = e_state[(int32_T)mti - 1];
      e_state[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      y ^= y >> 18U;
      u[k] = y;
    }

    mti = u[0] >> 5U;
    y = u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      if ((e_state[624] >= 1U) && (e_state[624] < 625U)) {
        isvalid = true;
      } else {
        isvalid = false;
      }

      if (isvalid) {
        isvalid = false;
        k = 0;
        exitg2 = false;
        while ((!exitg2) && (k + 1 < 625)) {
          if (e_state[k] == 0U) {
            k++;
          } else {
            isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!isvalid) {
        for (k = 0; k < 37; k++) {
          b_u[k] = c_u[k];
        }

        b_y = NULL;
        m = emlrtCreateCharArray(2, &iv[0]);
        emlrtInitCharArrayR2013a(&st, 37, m, &b_u[0]);
        emlrtAssign(&b_y, m);
        for (k = 0; k < 37; k++) {
          b_u[k] = c_u[k];
        }

        c_y = NULL;
        m = emlrtCreateCharArray(2, &iv1[0]);
        emlrtInitCharArrayR2013a(&st, 37, m, &b_u[0]);
        emlrtAssign(&c_y, m);
        b_st.site = &dw_emlrtRSI;
        error(&b_st, b_y, getString(&b_st, b_message(&b_st, c_y, &ic_emlrtMCI),
               &ic_emlrtMCI), &ic_emlrtMCI);
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return 1.1102230246251565E-16 * ((real_T)mti * 6.7108864E+7 + (real_T)y);
}

static void xzlascl(real_T cfrom, real_T cto, real_T A[64])
{
  __m128d r;
  real_T cfrom1;
  real_T cfromc;
  real_T cto1;
  real_T ctoc;
  real_T mul;
  int32_T i;
  int32_T j;
  int32_T offset;
  boolean_T notdone;
  cfromc = cfrom;
  ctoc = cto;
  notdone = true;
  while (notdone) {
    cfrom1 = cfromc * 2.0041683600089728E-292;
    cto1 = ctoc / 4.9896007738368E+291;
    if ((muDoubleScalarAbs(cfrom1) > muDoubleScalarAbs(ctoc)) && (ctoc != 0.0))
    {
      mul = 2.0041683600089728E-292;
      cfromc = cfrom1;
    } else if (muDoubleScalarAbs(cto1) > muDoubleScalarAbs(cfromc)) {
      mul = 4.9896007738368E+291;
      ctoc = cto1;
    } else {
      mul = ctoc / cfromc;
      notdone = false;
    }

    for (j = 0; j < 8; j++) {
      offset = (j << 3) - 1;
      for (i = 0; i <= 6; i += 2) {
        r = _mm_loadu_pd(&A[(offset + i) + 1]);
        _mm_storeu_pd(&A[(offset + i) + 1], _mm_mul_pd(r, _mm_set1_pd(mul)));
      }
    }
  }
}

static void c_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[64],
                     int32_T ic0, real_T work[8])
{
  real_T c;
  int32_T b_i;
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ix;
  int32_T jy;
  int32_T lastc;
  int32_T lastv;
  boolean_T exitg2;
  if (tau != 0.0) {
    lastv = m;
    i = (iv0 + m) - 2;
    while ((lastv > 0) && (C[i] == 0.0)) {
      lastv--;
      i--;
    }

    lastc = n;
    exitg2 = false;
    while ((!exitg2) && (lastc > 0)) {
      i = ic0 + ((lastc - 1) << 3);
      ia = i;
      do {
        exitg1 = 0;
        if (ia <= (i + lastv) - 1) {
          if (C[ia - 1] != 0.0) {
            exitg1 = 1;
          } else {
            ia++;
          }
        } else {
          lastc--;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }
  } else {
    lastv = 0;
    lastc = 0;
  }

  if (lastv > 0) {
    if (lastc != 0) {
      b_i = (uint8_T)lastc;
      for (i = 0; i < b_i; i++) {
        work[i] = 0.0;
      }

      i = 0;
      b_i = ic0 + ((lastc - 1) << 3);
      for (jy = ic0; jy <= b_i; jy += 8) {
        ix = iv0 - 1;
        c = 0.0;
        i1 = jy + lastv;
        for (ia = jy; ia < i1; ia++) {
          c += C[ia - 1] * C[ix];
          ix++;
        }

        work[i] += c;
        i++;
      }
    }

    if (!(-tau == 0.0)) {
      i = ic0;
      jy = 0;
      b_i = (uint8_T)lastc;
      for (lastc = 0; lastc < b_i; lastc++) {
        if (work[jy] != 0.0) {
          c = work[jy] * -tau;
          ix = iv0 - 1;
          i1 = lastv + i;
          for (ia = i; ia < i1; ia++) {
            C[ia - 1] += C[ix] * c;
            ix++;
          }
        }

        jy++;
        i += 8;
      }
    }
  }
}

static void b_xzlascl(real_T cfrom, real_T cto, real_T A[8])
{
  __m128d r;
  real_T cfrom1;
  real_T cfromc;
  real_T cto1;
  real_T ctoc;
  real_T mul;
  int32_T i;
  int32_T j;
  boolean_T notdone;
  cfromc = cfrom;
  ctoc = cto;
  notdone = true;
  while (notdone) {
    cfrom1 = cfromc * 2.0041683600089728E-292;
    cto1 = ctoc / 4.9896007738368E+291;
    if ((muDoubleScalarAbs(cfrom1) > muDoubleScalarAbs(ctoc)) && (ctoc != 0.0))
    {
      mul = 2.0041683600089728E-292;
      cfromc = cfrom1;
    } else if (muDoubleScalarAbs(cto1) > muDoubleScalarAbs(cfromc)) {
      mul = 4.9896007738368E+291;
      ctoc = cto1;
    } else {
      mul = ctoc / cfromc;
      notdone = false;
    }

    for (j = 0; j < 1; j++) {
      for (i = 0; i <= 6; i += 2) {
        r = _mm_loadu_pd(&A[i]);
        _mm_storeu_pd(&A[i], _mm_mul_pd(r, _mm_set1_pd(mul)));
      }
    }
  }
}

static void xzggbal(real_T A[64], real_T B[64], int32_T *ilo, int32_T *ihi,
                    int32_T rscale[8])
{
  real_T atmp;
  int32_T exitg1;
  int32_T exitg2;
  int32_T i;
  int32_T ii;
  int32_T j;
  int32_T jj;
  int32_T nzcount;
  boolean_T exitg3;
  boolean_T exitg4;
  boolean_T found;
  for (i = 0; i < 8; i++) {
    rscale[i] = 1;
  }

  *ilo = 1;
  *ihi = 8;
  do {
    exitg2 = 0;
    i = -1;
    j = -1;
    found = false;
    ii = *ihi;
    exitg3 = false;
    while ((!exitg3) && (ii > 0)) {
      nzcount = 0;
      i = ii - 1;
      j = *ihi - 1;
      jj = 1;
      exitg4 = false;
      while ((!exitg4) && (jj - 1 <= (uint8_T)*ihi - 1)) {
        if ((A[(ii + ((jj - 1) << 3)) - 1] != 0.0) || (B[(ii + ((jj - 1) << 3))
             - 1] != 0.0)) {
          if (nzcount == 0) {
            j = jj - 1;
            nzcount = 1;
            jj++;
          } else {
            nzcount = 2;
            exitg4 = true;
          }
        } else {
          jj++;
        }
      }

      if (nzcount < 2) {
        found = true;
        exitg3 = true;
      } else {
        ii--;
      }
    }

    if (!found) {
      exitg2 = 2;
    } else {
      if (i + 1 != *ihi) {
        for (ii = 0; ii < 8; ii++) {
          atmp = A[i + (ii << 3)];
          A[i + (ii << 3)] = A[(*ihi + (ii << 3)) - 1];
          A[(*ihi + (ii << 3)) - 1] = atmp;
          atmp = B[i + (ii << 3)];
          B[i + (ii << 3)] = B[(*ihi + (ii << 3)) - 1];
          B[(*ihi + (ii << 3)) - 1] = atmp;
        }
      }

      if (j + 1 != *ihi) {
        for (ii = 0; ii < *ihi; ii++) {
          atmp = A[ii + (j << 3)];
          A[ii + (j << 3)] = A[ii + ((*ihi - 1) << 3)];
          A[ii + ((*ihi - 1) << 3)] = atmp;
          atmp = B[ii + (j << 3)];
          B[ii + (j << 3)] = B[ii + ((*ihi - 1) << 3)];
          B[ii + ((*ihi - 1) << 3)] = atmp;
        }
      }

      rscale[*ihi - 1] = j + 1;
      (*ihi)--;
      if (*ihi == 1) {
        rscale[0] = 1;
        exitg2 = 1;
      }
    }
  } while (exitg2 == 0);

  if (exitg2 == 1) {
  } else {
    do {
      exitg1 = 0;
      i = -1;
      j = -1;
      found = false;
      jj = *ilo;
      exitg3 = false;
      while ((!exitg3) && (jj <= *ihi)) {
        nzcount = 0;
        i = *ihi - 1;
        j = jj - 1;
        ii = *ilo;
        exitg4 = false;
        while ((!exitg4) && (ii <= *ihi)) {
          if ((A[(ii + ((jj - 1) << 3)) - 1] != 0.0) || (B[(ii + ((jj - 1) << 3))
               - 1] != 0.0)) {
            if (nzcount == 0) {
              i = ii - 1;
              nzcount = 1;
              ii++;
            } else {
              nzcount = 2;
              exitg4 = true;
            }
          } else {
            ii++;
          }
        }

        if (nzcount < 2) {
          found = true;
          exitg3 = true;
        } else {
          jj++;
        }
      }

      if (!found) {
        exitg1 = 1;
      } else {
        if (i + 1 != *ilo) {
          for (ii = *ilo; ii < 9; ii++) {
            atmp = A[i + ((ii - 1) << 3)];
            A[i + ((ii - 1) << 3)] = A[(*ilo + ((ii - 1) << 3)) - 1];
            A[(*ilo + ((ii - 1) << 3)) - 1] = atmp;
          }

          for (ii = *ilo; ii < 9; ii++) {
            atmp = B[i + ((ii - 1) << 3)];
            B[i + ((ii - 1) << 3)] = B[(*ilo + ((ii - 1) << 3)) - 1];
            B[(*ilo + ((ii - 1) << 3)) - 1] = atmp;
          }
        }

        if (j + 1 != *ilo) {
          for (ii = 0; ii < *ihi; ii++) {
            atmp = A[ii + (j << 3)];
            A[ii + (j << 3)] = A[ii + ((*ilo - 1) << 3)];
            A[ii + ((*ilo - 1) << 3)] = atmp;
            atmp = B[ii + (j << 3)];
            B[ii + (j << 3)] = B[ii + ((*ilo - 1) << 3)];
            B[ii + ((*ilo - 1) << 3)] = atmp;
          }
        }

        rscale[*ilo - 1] = j + 1;
        (*ilo)++;
        if (*ilo == *ihi) {
          rscale[*ilo - 1] = *ilo;
          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

static void xzgeqr2(real_T A[64], int32_T ijmin, int32_T imax, real_T tau[8])
{
  __m128d r;
  real_T b_A[64];
  real_T work[8];
  real_T atmp;
  real_T tautmp;
  real_T xnorm;
  int32_T b_i;
  int32_T i;
  int32_T iA0;
  int32_T iAii;
  int32_T iSubdiag;
  int32_T k;
  int32_T knt;
  int32_T scalarLB;
  int32_T subdiaglen;
  int32_T vectorUB;
  for (i = 0; i < 8; i++) {
    work[i] = 0.0;
    tau[i] = 0.0;
  }

  iA0 = ijmin + ((ijmin - 1) << 3);
  for (i = ijmin; i <= imax; i++) {
    subdiaglen = (imax - i) - 1;
    iAii = (iA0 + (i - ijmin) * 9) - 1;
    if (i < 8) {
      iSubdiag = iAii + 2;
    } else {
      iSubdiag = iAii + 1;
    }

    memcpy(&b_A[0], &A[0], sizeof(real_T) << 6);
    atmp = A[iAii];
    tautmp = 0.0;
    if (subdiaglen + 2 > 0) {
      xnorm = c_xnrm2(subdiaglen + 1, A, iSubdiag);
      if (xnorm != 0.0) {
        xnorm = muDoubleScalarHypot(A[iAii], xnorm);
        if (A[iAii] >= 0.0) {
          xnorm = -xnorm;
        }

        if (muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) {
          knt = -1;
          do {
            knt++;
            b_i = iSubdiag + subdiaglen;
            scalarLB = ((b_i - iSubdiag) + 1) / 2 * 2 + iSubdiag;
            vectorUB = scalarLB - 2;
            for (k = iSubdiag; k <= vectorUB; k += 2) {
              r = _mm_loadu_pd(&b_A[k - 1]);
              _mm_storeu_pd(&b_A[k - 1], _mm_mul_pd(_mm_set1_pd
                (9.9792015476736E+291), r));
            }

            for (k = scalarLB; k <= b_i; k++) {
              b_A[k - 1] *= 9.9792015476736E+291;
            }

            xnorm *= 9.9792015476736E+291;
            atmp *= 9.9792015476736E+291;
          } while ((muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) && (knt
                    + 1 < 20));

          xnorm = muDoubleScalarHypot(atmp, c_xnrm2(subdiaglen + 1, b_A,
            iSubdiag));
          if (atmp >= 0.0) {
            xnorm = -xnorm;
          }

          tautmp = (xnorm - atmp) / xnorm;
          atmp = 1.0 / (atmp - xnorm);
          b_i = iSubdiag + subdiaglen;
          scalarLB = ((b_i - iSubdiag) + 1) / 2 * 2 + iSubdiag;
          vectorUB = scalarLB - 2;
          for (k = iSubdiag; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&b_A[k - 1]);
            _mm_storeu_pd(&b_A[k - 1], _mm_mul_pd(_mm_set1_pd(atmp), r));
          }

          for (k = scalarLB; k <= b_i; k++) {
            b_A[k - 1] *= atmp;
          }

          for (k = 0; k <= knt; k++) {
            xnorm *= 1.0020841800044864E-292;
          }

          atmp = xnorm;
        } else {
          tautmp = (xnorm - A[iAii]) / xnorm;
          atmp = 1.0 / (A[iAii] - xnorm);
          memcpy(&b_A[0], &A[0], sizeof(real_T) << 6);
          b_i = iSubdiag + subdiaglen;
          scalarLB = ((b_i - iSubdiag) + 1) / 2 * 2 + iSubdiag;
          vectorUB = scalarLB - 2;
          for (k = iSubdiag; k <= vectorUB; k += 2) {
            r = _mm_loadu_pd(&b_A[k - 1]);
            _mm_storeu_pd(&b_A[k - 1], _mm_mul_pd(_mm_set1_pd(atmp), r));
          }

          for (k = scalarLB; k <= b_i; k++) {
            b_A[k - 1] *= atmp;
          }

          atmp = xnorm;
        }
      }
    }

    memcpy(&A[0], &b_A[0], sizeof(real_T) << 6);
    A[iAii] = atmp;
    tau[i - ijmin] = tautmp;
    if (i < 8) {
      atmp = A[iAii];
      A[iAii] = 1.0;
      c_xzlarf(subdiaglen + 2, 8 - i, iAii + 1, tautmp, A, iAii + 9, work);
      A[iAii] = atmp;
    }
  }
}

static void xzgghrd(const emlrtStack *sp, int32_T ilo, int32_T ihi, real_T A[64],
                    real_T B[64], real_T Z[64])
{
  __m128d r;
  __m128d r1;
  __m128d r2;
  __m128d r3;
  emlrtStack st;
  real_T c;
  real_T s;
  real_T stemp;
  int32_T j;
  int32_T jcol;
  int32_T jrow;
  st.prev = sp;
  st.tls = sp->tls;
  for (jcol = 0; jcol < 64; jcol++) {
    Z[jcol] = 0.0;
  }

  for (jcol = 0; jcol < 8; jcol++) {
    Z[jcol + (jcol << 3)] = 1.0;
  }

  for (jcol = ilo; jcol < ihi; jcol++) {
    for (jrow = jcol + 1; jrow <= ihi; jrow++) {
      B[(jrow + ((jcol - 1) << 3)) - 1] = 0.0;
    }
  }

  if (ihi >= ilo + 2) {
    for (jcol = ilo - 1; jcol + 1 < ihi - 1; jcol++) {
      for (jrow = ihi - 1; jrow + 1 > jcol + 2; jrow--) {
        st.site = &uo_emlrtRSI;
        xzlartg(&st, A[(jrow + (jcol << 3)) - 1], A[jrow + (jcol << 3)], &c, &s,
                &stemp);
        A[(jrow + (jcol << 3)) - 1] = stemp;
        A[jrow + (jcol << 3)] = 0.0;
        for (j = jcol + 2; j < 9; j++) {
          stemp = c * A[(jrow + ((j - 1) << 3)) - 1] + s * A[jrow + ((j - 1) <<
            3)];
          A[jrow + ((j - 1) << 3)] = c * A[jrow + ((j - 1) << 3)] - s * A[(jrow
            + ((j - 1) << 3)) - 1];
          A[(jrow + ((j - 1) << 3)) - 1] = stemp;
        }

        for (j = jrow; j < 9; j++) {
          stemp = c * B[(jrow + ((j - 1) << 3)) - 1] + s * B[jrow + ((j - 1) <<
            3)];
          B[jrow + ((j - 1) << 3)] = c * B[jrow + ((j - 1) << 3)] - s * B[(jrow
            + ((j - 1) << 3)) - 1];
          B[(jrow + ((j - 1) << 3)) - 1] = stemp;
        }

        st.site = &vo_emlrtRSI;
        xzlartg(&st, B[jrow + (jrow << 3)], B[jrow + ((jrow - 1) << 3)], &c, &s,
                &stemp);
        B[jrow + (jrow << 3)] = stemp;
        B[jrow + ((jrow - 1) << 3)] = 0.0;
        for (j = 1; j <= jrow; j++) {
          stemp = c * B[(j + (jrow << 3)) - 1] + s * B[(j + ((jrow - 1) << 3)) -
            1];
          B[(j + ((jrow - 1) << 3)) - 1] = c * B[(j + ((jrow - 1) << 3)) - 1] -
            s * B[(j + (jrow << 3)) - 1];
          B[(j + (jrow << 3)) - 1] = stemp;
        }

        for (j = 1; j <= ihi; j++) {
          stemp = c * A[(j + (jrow << 3)) - 1] + s * A[(j + ((jrow - 1) << 3)) -
            1];
          A[(j + ((jrow - 1) << 3)) - 1] = c * A[(j + ((jrow - 1) << 3)) - 1] -
            s * A[(j + (jrow << 3)) - 1];
          A[(j + (jrow << 3)) - 1] = stemp;
        }

        for (j = 0; j <= 6; j += 2) {
          r = _mm_loadu_pd(&Z[j + (jrow << 3)]);
          r1 = _mm_loadu_pd(&Z[j + ((jrow - 1) << 3)]);
          r2 = _mm_loadu_pd(&Z[j + ((jrow - 1) << 3)]);
          r3 = _mm_loadu_pd(&Z[j + (jrow << 3)]);
          _mm_storeu_pd(&Z[j + ((jrow - 1) << 3)], _mm_sub_pd(_mm_mul_pd
            (_mm_set1_pd(c), r2), _mm_mul_pd(_mm_set1_pd(s), r3)));
          _mm_storeu_pd(&Z[j + (jrow << 3)], _mm_add_pd(_mm_mul_pd(_mm_set1_pd(c),
            r), _mm_mul_pd(_mm_set1_pd(s), r1)));
        }
      }
    }
  }
}

static void xdhgeqz(const emlrtStack *sp, real_T h[64], real_T t[64], int32_T
                    ilo, int32_T ihi, real_T z[64], int32_T *info, real_T
                    alphar[8], real_T alphai[8], real_T beta[8])
{
  __m128d r;
  __m128d r1;
  __m128d r2;
  __m128d r3;
  emlrtStack st;
  real_T v[3];
  real_T ad11l;
  real_T ad21l;
  real_T ad22;
  real_T anorm;
  real_T ascale;
  real_T b11;
  real_T b22;
  real_T b_atol;
  real_T bnorm;
  real_T bscale;
  real_T btol;
  real_T eshift;
  real_T s1;
  real_T temp;
  real_T temp2;
  real_T tempr;
  real_T u12;
  real_T wi;
  real_T wr;
  int32_T exitg1;
  int32_T ifirst;
  int32_T iiter;
  int32_T ilast;
  int32_T istart;
  int32_T ix0;
  int32_T iy0;
  int32_T jch;
  int32_T jiter;
  int32_T maxit;
  boolean_T converged;
  boolean_T exitg2;
  boolean_T goto110;
  boolean_T goto70;
  boolean_T goto80;
  boolean_T guard1;
  boolean_T guard2;
  boolean_T guard3;
  boolean_T ilazro;
  st.prev = sp;
  st.tls = sp->tls;
  *info = 0;
  st.site = &wo_emlrtRSI;
  anorm = xzlanhs(&st, h, ilo, ihi);
  st.site = &xo_emlrtRSI;
  bnorm = xzlanhs(&st, t, ilo, ihi);
  b_atol = maximum2(2.2250738585072014E-308, 2.2204460492503131E-16 * anorm);
  btol = maximum2(2.2250738585072014E-308, 2.2204460492503131E-16 * bnorm);
  ascale = 1.0 / maximum2(2.2250738585072014E-308, anorm);
  bscale = 1.0 / maximum2(2.2250738585072014E-308, bnorm);
  converged = false;
  for (iy0 = ihi + 1; iy0 < 9; iy0++) {
    if (t[(iy0 + ((iy0 - 1) << 3)) - 1] < 0.0) {
      ix0 = (uint8_T)iy0;
      for (jch = 0; jch < ix0; jch++) {
        h[jch + ((iy0 - 1) << 3)] = -h[jch + ((iy0 - 1) << 3)];
        t[jch + ((iy0 - 1) << 3)] = -t[jch + ((iy0 - 1) << 3)];
      }

      for (jch = 0; jch < 8; jch++) {
        z[jch + ((iy0 - 1) << 3)] = -z[jch + ((iy0 - 1) << 3)];
      }
    }

    alphar[iy0 - 1] = h[(iy0 + ((iy0 - 1) << 3)) - 1];
    alphai[iy0 - 1] = 0.0;
    beta[iy0 - 1] = t[(iy0 + ((iy0 - 1) << 3)) - 1];
  }

  guard1 = false;
  guard2 = false;
  if (ihi >= ilo) {
    ifirst = ilo;
    istart = ilo;
    ilast = ihi - 1;
    iiter = 0;
    eshift = 0.0;
    maxit = 30 * ((ihi - ilo) + 1);
    jiter = 0;
    do {
      exitg1 = 0;
      if (jiter <= maxit - 1) {
        goto80 = false;
        goto70 = false;
        goto110 = false;
        if (ilast + 1 == ilo) {
          goto80 = true;
        } else if (muDoubleScalarAbs(h[ilast + ((ilast - 1) << 3)]) <= maximum2
                   (2.2250738585072014E-308, 2.2204460492503131E-16 *
                    (muDoubleScalarAbs(h[ilast + (ilast << 3)]) +
                     muDoubleScalarAbs(h[(ilast + ((ilast - 1) << 3)) - 1])))) {
          h[ilast + ((ilast - 1) << 3)] = 0.0;
          goto80 = true;
        } else if (muDoubleScalarAbs(t[ilast + (ilast << 3)]) <= btol) {
          t[ilast + (ilast << 3)] = 0.0;
          goto70 = true;
        } else {
          iy0 = ilast - 1;
          guard3 = false;
          exitg2 = false;
          while ((!exitg2) && (iy0 + 1 >= ilo)) {
            if (iy0 + 1 == ilo) {
              ilazro = true;
            } else if (muDoubleScalarAbs(h[iy0 + ((iy0 - 1) << 3)]) <= maximum2
                       (2.2250738585072014E-308, 2.2204460492503131E-16 *
                        (muDoubleScalarAbs(h[iy0 + (iy0 << 3)]) +
                         muDoubleScalarAbs(h[(iy0 + ((iy0 - 1) << 3)) - 1])))) {
              h[iy0 + ((iy0 - 1) << 3)] = 0.0;
              ilazro = true;
            } else {
              ilazro = false;
            }

            if (muDoubleScalarAbs(t[iy0 + (iy0 << 3)]) < btol) {
              t[iy0 + (iy0 << 3)] = 0.0;
              goto70 = false;
              if (!ilazro) {
                temp = muDoubleScalarAbs(h[iy0 + ((iy0 - 1) << 3)]);
                temp2 = muDoubleScalarAbs(h[iy0 + (iy0 << 3)]);
                tempr = maximum2(temp, temp2);
                if ((tempr < 1.0) && (tempr != 0.0)) {
                  temp /= tempr;
                  temp2 /= tempr;
                }

                goto70 = (temp * (ascale * muDoubleScalarAbs(h[(iy0 + (iy0 << 3))
                            + 1])) <= temp2 * (ascale * b_atol));
                if (goto70) {
                  guard3 = true;
                } else {
                  for (jch = iy0 + 1; jch < ilast + 1; jch++) {
                    st.site = &ap_emlrtRSI;
                    xzlartg(&st, t[(jch + (jch << 3)) - 1], t[jch + (jch << 3)],
                            &bnorm, &ad22, &anorm);
                    t[(jch + (jch << 3)) - 1] = anorm;
                    t[jch + (jch << 3)] = 0.0;
                    if (jch < 7) {
                      ix0 = ((jch + 1) << 3) + jch;
                      xrot(7 - jch, t, ix0, ix0 + 1, bnorm, ad22);
                    }

                    ix0 = ((jch - 2) << 3) + jch;
                    xrot(10 - jch, h, ix0, ix0 + 1, bnorm, ad22);
                    st.site = &bp_emlrtRSI;
                    xzlartg(&st, h[jch + ((jch - 1) << 3)], h[jch + ((jch - 2) <<
                             3)], &bnorm, &ad22, &anorm);
                    h[jch + ((jch - 1) << 3)] = anorm;
                    h[jch + ((jch - 2) << 3)] = 0.0;
                    ix0 = ((jch - 1) << 3) + 1;
                    iy0 = ((jch - 2) << 3) + 1;
                    b_xrot(jch, h, ix0, iy0, bnorm, ad22);
                    b_xrot(jch - 1, t, ix0, iy0, bnorm, ad22);
                    c_xrot(z, ((jch - 1) << 3) + 1, ((jch - 2) << 3) + 1, bnorm,
                           ad22);
                  }

                  goto70 = true;
                }
              } else {
                guard3 = true;
              }

              exitg2 = true;
            } else if (ilazro) {
              ifirst = iy0 + 1;
              goto110 = true;
              exitg2 = true;
            } else {
              iy0--;
              guard3 = false;
            }
          }

          if (guard3) {
            jch = iy0 + 1;
            exitg2 = false;
            while ((!exitg2) && (jch < ilast + 1)) {
              st.site = &yo_emlrtRSI;
              xzlartg(&st, h[(jch + ((jch - 1) << 3)) - 1], h[jch + ((jch - 1) <<
                       3)], &bnorm, &ad22, &anorm);
              h[(jch + ((jch - 1) << 3)) - 1] = anorm;
              h[jch + ((jch - 1) << 3)] = 0.0;
              ix0 = (jch << 3) + jch;
              xrot(8 - jch, h, ix0, ix0 + 1, bnorm, ad22);
              xrot(8 - jch, t, ix0, ix0 + 1, bnorm, ad22);
              if (goto70) {
                h[(jch + ((jch - 2) << 3)) - 1] *= bnorm;
              }

              goto70 = false;
              if (muDoubleScalarAbs(t[jch + (jch << 3)]) >= btol) {
                if (jch + 1 >= ilast + 1) {
                  goto80 = true;
                } else {
                  ifirst = jch + 1;
                  goto110 = true;
                }

                exitg2 = true;
              } else {
                t[jch + (jch << 3)] = 0.0;
                jch++;
              }
            }

            if (goto80 || goto110) {
              goto70 = true;
            } else {
              goto70 = false;
            }

            goto70 = !goto70;
          }
        }

        if (goto70 || goto80 || goto110) {
          if (goto70) {
            st.site = &cp_emlrtRSI;
            xzlartg(&st, h[ilast + (ilast << 3)], h[ilast + ((ilast - 1) << 3)],
                    &bnorm, &ad22, &anorm);
            h[ilast + (ilast << 3)] = anorm;
            h[ilast + ((ilast - 1) << 3)] = 0.0;
            ix0 = (ilast << 3) + 1;
            iy0 = ((ilast - 1) << 3) + 1;
            b_xrot(ilast, h, ix0, iy0, bnorm, ad22);
            b_xrot(ilast, t, ix0, iy0, bnorm, ad22);
            c_xrot(z, (ilast << 3) + 1, ((ilast - 1) << 3) + 1, bnorm, ad22);
            goto80 = true;
          }

          if (goto80) {
            if (t[ilast + (ilast << 3)] < 0.0) {
              jch = (ilast + 1) / 2 * 2 + 1;
              ix0 = jch - 2;
              for (iy0 = 1; iy0 <= ix0; iy0 += 2) {
                r = _mm_loadu_pd(&h[(iy0 + (ilast << 3)) - 1]);
                _mm_storeu_pd(&h[(iy0 + (ilast << 3)) - 1], _mm_mul_pd(r,
                  _mm_set1_pd(-1.0)));
                r = _mm_loadu_pd(&t[(iy0 + (ilast << 3)) - 1]);
                _mm_storeu_pd(&t[(iy0 + (ilast << 3)) - 1], _mm_mul_pd(r,
                  _mm_set1_pd(-1.0)));
              }

              for (iy0 = jch; iy0 <= ilast + 1; iy0++) {
                h[(iy0 + (ilast << 3)) - 1] = -h[(iy0 + (ilast << 3)) - 1];
                t[(iy0 + (ilast << 3)) - 1] = -t[(iy0 + (ilast << 3)) - 1];
              }

              for (iy0 = 0; iy0 <= 6; iy0 += 2) {
                r = _mm_loadu_pd(&z[iy0 + (ilast << 3)]);
                _mm_storeu_pd(&z[iy0 + (ilast << 3)], _mm_mul_pd(r, _mm_set1_pd(
                  -1.0)));
              }
            }

            alphar[ilast] = h[ilast + (ilast << 3)];
            alphai[ilast] = 0.0;
            beta[ilast] = t[ilast + (ilast << 3)];
            ilast--;
            if (ilast + 1 < ilo) {
              converged = true;
              guard2 = true;
              exitg1 = 1;
            } else {
              iiter = 0;
              eshift = 0.0;
              jiter++;
            }
          } else {
            iiter++;
            goto70 = false;
            if (iiter - div_nzp_s32(iiter, 10) * 10 == 0) {
              if ((real_T)maxit * 2.2250738585072014E-308 * muDoubleScalarAbs
                  (h[ilast + ((ilast - 1) << 3)]) < muDoubleScalarAbs(t[(ilast +
                    ((ilast - 1) << 3)) - 1])) {
                eshift = h[ilast + ((ilast - 1) << 3)] / t[(ilast + ((ilast - 1)
                  << 3)) - 1];
              } else {
                eshift += 1.0 / (2.2250738585072014E-308 * (real_T)maxit);
              }

              s1 = 1.0;
              wr = eshift;
            } else {
              jch = ((ilast - 1) << 3) + ilast;
              st.site = &dp_emlrtRSI;
              xdlag2(&st, h, jch, t, jch, 2.2250738585072014E-306, &s1, &anorm,
                     &wr, &bnorm, &wi);
              if (muDoubleScalarAbs(wr / s1 * t[ilast + (ilast << 3)] - h[ilast
                                    + (ilast << 3)]) > muDoubleScalarAbs(bnorm /
                   anorm * t[ilast + (ilast << 3)] - h[ilast + (ilast << 3)])) {
                wr = bnorm;
                s1 = anorm;
              }

              goto70 = (wi != 0.0);
            }

            if (!goto70) {
              temp = minimum2(ascale, 1.0) * 2.2471164185778949E+307;
              if (s1 > temp) {
                anorm = temp / s1;
              } else {
                anorm = 1.0;
              }

              temp = minimum2(bscale, 1.0) * 2.2471164185778949E+307;
              if (muDoubleScalarAbs(wr) > temp) {
                anorm = minimum2(anorm, temp / muDoubleScalarAbs(wr));
              }

              s1 *= anorm;
              wr *= anorm;
              iy0 = ilast - 1;
              goto70 = false;
              exitg2 = false;
              while ((!exitg2) && (iy0 + 1 > ifirst)) {
                istart = iy0 + 1;
                temp = muDoubleScalarAbs(s1 * h[iy0 + ((iy0 - 1) << 3)]);
                temp2 = muDoubleScalarAbs(s1 * h[iy0 + (iy0 << 3)] - wr * t[iy0
                  + (iy0 << 3)]);
                tempr = maximum2(temp, temp2);
                if ((tempr < 1.0) && (tempr != 0.0)) {
                  temp /= tempr;
                  temp2 /= tempr;
                }

                if (muDoubleScalarAbs(ascale * h[(iy0 + (iy0 << 3)) + 1] * temp)
                    <= ascale * b_atol * temp2) {
                  goto70 = true;
                  exitg2 = true;
                } else {
                  iy0--;
                }
              }

              if (!goto70) {
                istart = ifirst;
              }

              st.site = &ep_emlrtRSI;
              b_xzlartg(&st, s1 * h[(istart + ((istart - 1) << 3)) - 1] - wr *
                        t[(istart + ((istart - 1) << 3)) - 1], s1 * h[istart +
                        ((istart - 1) << 3)], &bnorm, &ad22);
              for (iy0 = istart; iy0 <= ilast; iy0++) {
                if (iy0 > istart) {
                  st.site = &fp_emlrtRSI;
                  xzlartg(&st, h[(iy0 + ((iy0 - 2) << 3)) - 1], h[iy0 + ((iy0 -
                            2) << 3)], &bnorm, &ad22, &anorm);
                  h[(iy0 + ((iy0 - 2) << 3)) - 1] = anorm;
                  h[iy0 + ((iy0 - 2) << 3)] = 0.0;
                }

                for (jch = iy0; jch < 9; jch++) {
                  temp = bnorm * h[(iy0 + ((jch - 1) << 3)) - 1] + ad22 * h[iy0
                    + ((jch - 1) << 3)];
                  h[iy0 + ((jch - 1) << 3)] = -ad22 * h[(iy0 + ((jch - 1) << 3))
                    - 1] + bnorm * h[iy0 + ((jch - 1) << 3)];
                  h[(iy0 + ((jch - 1) << 3)) - 1] = temp;
                  temp2 = bnorm * t[(iy0 + ((jch - 1) << 3)) - 1] + ad22 * t[iy0
                    + ((jch - 1) << 3)];
                  t[iy0 + ((jch - 1) << 3)] = -ad22 * t[(iy0 + ((jch - 1) << 3))
                    - 1] + bnorm * t[iy0 + ((jch - 1) << 3)];
                  t[(iy0 + ((jch - 1) << 3)) - 1] = temp2;
                }

                st.site = &gp_emlrtRSI;
                xzlartg(&st, t[iy0 + (iy0 << 3)], t[iy0 + ((iy0 - 1) << 3)],
                        &bnorm, &ad22, &anorm);
                t[iy0 + (iy0 << 3)] = anorm;
                t[iy0 + ((iy0 - 1) << 3)] = 0.0;
                ix0 = b_minimum2(iy0 + 2, ilast + 1);
                for (jch = 1; jch <= ix0; jch++) {
                  temp = bnorm * h[(jch + (iy0 << 3)) - 1] + ad22 * h[(jch +
                    ((iy0 - 1) << 3)) - 1];
                  h[(jch + ((iy0 - 1) << 3)) - 1] = -ad22 * h[(jch + (iy0 << 3))
                    - 1] + bnorm * h[(jch + ((iy0 - 1) << 3)) - 1];
                  h[(jch + (iy0 << 3)) - 1] = temp;
                }

                for (jch = 1; jch <= iy0; jch++) {
                  temp = bnorm * t[(jch + (iy0 << 3)) - 1] + ad22 * t[(jch +
                    ((iy0 - 1) << 3)) - 1];
                  t[(jch + ((iy0 - 1) << 3)) - 1] = -ad22 * t[(jch + (iy0 << 3))
                    - 1] + bnorm * t[(jch + ((iy0 - 1) << 3)) - 1];
                  t[(jch + (iy0 << 3)) - 1] = temp;
                }

                for (jch = 0; jch < 8; jch++) {
                  temp = bnorm * z[jch + (iy0 << 3)] + ad22 * z[jch + ((iy0 - 1)
                    << 3)];
                  z[jch + ((iy0 - 1) << 3)] = -ad22 * z[jch + (iy0 << 3)] +
                    bnorm * z[jch + ((iy0 - 1) << 3)];
                  z[jch + (iy0 << 3)] = temp;
                }
              }

              jiter++;
            } else if (ifirst + 1 == ilast + 1) {
              st.site = &hp_emlrtRSI;
              xdlasv2(&st, t[(ilast + ((ilast - 1) << 3)) - 1], t[(ilast +
                       (ilast << 3)) - 1], t[ilast + (ilast << 3)], &b22, &b11,
                      &ad22, &u12, &anorm, &bnorm);
              if (b11 < 0.0) {
                u12 = -u12;
                ad22 = -ad22;
                b11 = -b11;
                b22 = -b22;
              }

              jch = ((ilast - 1) << 3) + ilast;
              xrot(9 - ifirst, h, jch, jch + 1, bnorm, anorm);
              b_xrot(ilast + 1, h, ((ilast - 1) << 3) + 1, (ilast << 3) + 1, u12,
                     ad22);
              if (ilast + 1 < 8) {
                jch = ((ilast + 1) << 3) + ilast;
                xrot(7 - ilast, t, jch, jch + 1, bnorm, anorm);
              }

              if (ilast > 1) {
                b_xrot(ifirst - 1, t, ((ilast - 1) << 3) + 1, (ilast << 3) + 1,
                       u12, ad22);
              }

              c_xrot(z, ((ilast - 1) << 3) + 1, (ilast << 3) + 1, u12, ad22);
              t[(ilast + ((ilast - 1) << 3)) - 1] = b11;
              t[(ilast + (ilast << 3)) - 1] = 0.0;
              t[ilast + ((ilast - 1) << 3)] = 0.0;
              t[ilast + (ilast << 3)] = b22;
              if (b22 < 0.0) {
                jch = (ilast + 1) / 2 * 2 + 1;
                ix0 = jch - 2;
                for (iy0 = 1; iy0 <= ix0; iy0 += 2) {
                  r = _mm_loadu_pd(&h[(iy0 + (ilast << 3)) - 1]);
                  _mm_storeu_pd(&h[(iy0 + (ilast << 3)) - 1], _mm_mul_pd(r,
                    _mm_set1_pd(-1.0)));
                  r = _mm_loadu_pd(&t[(iy0 + (ilast << 3)) - 1]);
                  _mm_storeu_pd(&t[(iy0 + (ilast << 3)) - 1], _mm_mul_pd(r,
                    _mm_set1_pd(-1.0)));
                }

                for (iy0 = jch; iy0 <= ilast + 1; iy0++) {
                  h[(iy0 + (ilast << 3)) - 1] = -h[(iy0 + (ilast << 3)) - 1];
                  t[(iy0 + (ilast << 3)) - 1] = -t[(iy0 + (ilast << 3)) - 1];
                }

                for (iy0 = 0; iy0 <= 6; iy0 += 2) {
                  r = _mm_loadu_pd(&z[iy0 + (ilast << 3)]);
                  _mm_storeu_pd(&z[iy0 + (ilast << 3)], _mm_mul_pd(r,
                    _mm_set1_pd(-1.0)));
                }

                b22 = -b22;
              }

              jch = ((ilast - 1) << 3) + ilast;
              st.site = &ip_emlrtRSI;
              xdlag2(&st, h, jch, t, jch, 2.2250738585072014E-306, &s1, &temp,
                     &wr, &temp2, &wi);
              if (wi == 0.0) {
                jiter++;
              } else {
                eshift = 1.0 / s1;
                ad22 = s1 * h[(ilast + ((ilast - 1) << 3)) - 1] - wr * b11;
                ad11l = -wi * b11;
                anorm = s1 * h[(ilast + (ilast << 3)) - 1];
                ad21l = s1 * h[ilast + ((ilast - 1) << 3)];
                bnorm = s1 * h[ilast + (ilast << 3)] - wr * b22;
                u12 = -wi * b22;
                if ((muDoubleScalarAbs(ad22) + muDoubleScalarAbs(ad11l)) +
                    muDoubleScalarAbs(anorm) > (muDoubleScalarAbs(ad21l) +
                     muDoubleScalarAbs(bnorm)) + muDoubleScalarAbs(u12)) {
                  st.site = &jp_emlrtRSI;
                  u12 = xdlapy3(&st, anorm, ad22, ad11l);
                  temp = anorm / u12;
                  temp2 = -ad22 / u12;
                  ad11l = -ad11l / u12;
                } else {
                  temp = muDoubleScalarHypot(bnorm, u12);
                  if (temp <= 2.2250738585072014E-308) {
                    temp = 0.0;
                    temp2 = 1.0;
                    ad11l = 0.0;
                  } else {
                    tempr = bnorm / temp;
                    anorm = u12 / temp;
                    u12 = muDoubleScalarHypot(temp, ad21l);
                    temp /= u12;
                    temp2 = -ad21l * tempr / u12;
                    ad11l = ad21l * anorm / u12;
                  }
                }

                if (s1 * (((muDoubleScalarAbs(h[(ilast + ((ilast - 1) << 3)) - 1])
                            + muDoubleScalarAbs(h[(ilast + (ilast << 3)) - 1]))
                           + muDoubleScalarAbs(h[ilast + ((ilast - 1) << 3)])) +
                          muDoubleScalarAbs(h[ilast + (ilast << 3)])) >
                    (muDoubleScalarAbs(wr) + muDoubleScalarAbs(wi)) *
                    (muDoubleScalarAbs(b11) + b22)) {
                  ad21l = temp * b11;
                  bnorm = temp2 * b22;
                  anorm = -ad11l * b22;
                } else {
                  anorm = temp * h[(ilast + ((ilast - 1) << 3)) - 1] + temp2 *
                    h[(ilast + (ilast << 3)) - 1];
                  bnorm = ad11l * h[(ilast + (ilast << 3)) - 1];
                  ad22 = temp * h[ilast + ((ilast - 1) << 3)] + temp2 * h[ilast
                    + (ilast << 3)];
                  u12 = ad11l * h[ilast + (ilast << 3)];
                  ad21l = muDoubleScalarHypot(anorm, bnorm);
                  if (ad21l <= 2.2250738585072014E-308) {
                    ad21l = 0.0;
                    bnorm = 1.0;
                    anorm = 0.0;
                  } else {
                    tempr = anorm / ad21l;
                    anorm = bnorm / ad21l;
                    bnorm = tempr * ad22 + anorm * u12;
                    anorm = anorm * ad22 - tempr * u12;
                  }
                }

                st.site = &kp_emlrtRSI;
                u12 = xdlapy3(&st, ad21l, bnorm, anorm);
                ad21l /= u12;
                bnorm /= u12;
                anorm /= u12;
                tempr = bnorm * temp2 - anorm * ad11l;
                anorm = bnorm * ad11l + anorm * temp2;
                bnorm = muDoubleScalarHypot(ad21l * temp * b11 + tempr * b22,
                  anorm * b22);
                anorm = muDoubleScalarHypot(ad21l * temp * b22 + tempr * b11,
                  -anorm * b11);
                beta[ilast - 1] = bnorm;
                beta[ilast] = anorm;
                alphar[ilast - 1] = wr * bnorm * eshift;
                alphai[ilast - 1] = wi * bnorm * eshift;
                alphar[ilast] = wr * anorm * eshift;
                alphai[ilast] = -(wi * anorm) * eshift;
                ilast = ifirst - 2;
                if (ifirst - 1 < ilo) {
                  converged = true;
                  guard2 = true;
                  exitg1 = 1;
                } else {
                  iiter = 0;
                  eshift = 0.0;
                  jiter++;
                }
              }
            } else {
              anorm = ascale * h[(ilast + ((ilast - 1) << 3)) - 1] / (bscale *
                t[(ilast + ((ilast - 1) << 3)) - 1]);
              bnorm = ascale * h[ilast + ((ilast - 1) << 3)] / (bscale * t
                [(ilast + ((ilast - 1) << 3)) - 1]);
              ad22 = ascale * h[ilast + (ilast << 3)] / (bscale * t[ilast +
                (ilast << 3)]);
              u12 = t[(ilast + (ilast << 3)) - 1] / t[ilast + (ilast << 3)];
              ad11l = ascale * h[(ifirst + ((ifirst - 1) << 3)) - 1] / (bscale *
                t[(ifirst + ((ifirst - 1) << 3)) - 1]);
              ad21l = ascale * h[ifirst + ((ifirst - 1) << 3)] / (bscale * t
                [(ifirst + ((ifirst - 1) << 3)) - 1]);
              temp2 = t[(ifirst + (ifirst << 3)) - 1] / t[ifirst + (ifirst << 3)];
              v[0] = (((anorm - ad11l) * (ad22 - ad11l) - ascale * h[(ilast +
                        (ilast << 3)) - 1] / (bscale * t[ilast + (ilast << 3)]) *
                       bnorm) + bnorm * u12 * ad11l) + (ascale * h[(ifirst +
                (ifirst << 3)) - 1] / (bscale * t[ifirst + (ifirst << 3)]) -
                ad11l * temp2) * ad21l;
              v[1] = (((((ascale * h[ifirst + (ifirst << 3)] / (bscale *
                t[ifirst + (ifirst << 3)]) - ad11l) - ad21l * temp2) - (anorm -
                         ad11l)) - (ad22 - ad11l)) + bnorm * u12) * ad21l;
              v[2] = ascale * h[(ifirst + (ifirst << 3)) + 1] / (bscale *
                t[ifirst + (ifirst << 3)]) * ad21l;
              istart = ifirst;
              anorm = v[0];
              bnorm = b_xzlarfg(&anorm, v);
              for (iy0 = ifirst; iy0 < ilast; iy0++) {
                if (iy0 > ifirst) {
                  v[0] = h[(iy0 + ((iy0 - 2) << 3)) - 1];
                  v[1] = h[iy0 + ((iy0 - 2) << 3)];
                  v[2] = h[(iy0 + ((iy0 - 2) << 3)) + 1];
                  anorm = h[(iy0 + ((iy0 - 2) << 3)) - 1];
                  bnorm = b_xzlarfg(&anorm, v);
                  h[(iy0 + ((iy0 - 2) << 3)) - 1] = anorm;
                  h[iy0 + ((iy0 - 2) << 3)] = 0.0;
                  h[(iy0 + ((iy0 - 2) << 3)) + 1] = 0.0;
                }

                for (jch = iy0; jch < 9; jch++) {
                  temp = bnorm * ((h[(iy0 + ((jch - 1) << 3)) - 1] + v[1] *
                                   h[iy0 + ((jch - 1) << 3)]) + v[2] * h[(iy0 +
                    ((jch - 1) << 3)) + 1]);
                  h[(iy0 + ((jch - 1) << 3)) - 1] -= temp;
                  h[iy0 + ((jch - 1) << 3)] -= temp * v[1];
                  h[(iy0 + ((jch - 1) << 3)) + 1] -= temp * v[2];
                  temp2 = bnorm * ((t[(iy0 + ((jch - 1) << 3)) - 1] + v[1] *
                                    t[iy0 + ((jch - 1) << 3)]) + v[2] * t[(iy0 +
                    ((jch - 1) << 3)) + 1]);
                  t[(iy0 + ((jch - 1) << 3)) - 1] -= temp2;
                  t[iy0 + ((jch - 1) << 3)] -= temp2 * v[1];
                  t[(iy0 + ((jch - 1) << 3)) + 1] -= temp2 * v[2];
                }

                goto70 = false;
                temp = maximum2(muDoubleScalarAbs(t[iy0 + (iy0 << 3)]),
                                muDoubleScalarAbs(t[iy0 + ((iy0 + 1) << 3)]));
                temp2 = maximum2(muDoubleScalarAbs(t[(iy0 + (iy0 << 3)) + 1]),
                                 muDoubleScalarAbs(t[(iy0 + ((iy0 + 1) << 3)) +
                  1]));
                if (maximum2(temp, temp2) < 2.2250738585072014E-308) {
                  anorm = 0.0;
                  ad21l = 1.0;
                  ad11l = 0.0;
                } else {
                  if (temp >= temp2) {
                    bnorm = t[iy0 + (iy0 << 3)];
                    anorm = t[(iy0 + (iy0 << 3)) + 1];
                    u12 = t[iy0 + ((iy0 + 1) << 3)];
                    ad22 = t[(iy0 + ((iy0 + 1) << 3)) + 1];
                    ad21l = t[iy0 + ((iy0 - 1) << 3)];
                    ad11l = t[(iy0 + ((iy0 - 1) << 3)) + 1];
                  } else {
                    anorm = t[iy0 + (iy0 << 3)];
                    bnorm = t[(iy0 + (iy0 << 3)) + 1];
                    ad22 = t[iy0 + ((iy0 + 1) << 3)];
                    u12 = t[(iy0 + ((iy0 + 1) << 3)) + 1];
                    ad11l = t[iy0 + ((iy0 - 1) << 3)];
                    ad21l = t[(iy0 + ((iy0 - 1) << 3)) + 1];
                  }

                  if (muDoubleScalarAbs(u12) > muDoubleScalarAbs(bnorm)) {
                    goto70 = true;
                    temp = u12;
                    temp2 = ad22;
                    u12 = bnorm;
                    ad22 = anorm;
                    bnorm = temp;
                    anorm = temp2;
                  }

                  temp = anorm / bnorm;
                  ad11l -= temp * ad21l;
                  ad22 -= temp * u12;
                  anorm = 1.0;
                  if (muDoubleScalarAbs(ad22) < 2.2250738585072014E-308) {
                    anorm = 0.0;
                    ad11l = 1.0;
                    ad21l = -u12 / bnorm;
                  } else {
                    if (muDoubleScalarAbs(ad22) < muDoubleScalarAbs(ad11l)) {
                      anorm = muDoubleScalarAbs(ad22 / ad11l);
                    }

                    if (muDoubleScalarAbs(bnorm) < muDoubleScalarAbs(ad21l)) {
                      anorm = minimum2(anorm, muDoubleScalarAbs(bnorm / ad21l));
                    }

                    ad11l = anorm * ad11l / ad22;
                    ad21l = (anorm * ad21l - u12 * ad11l) / bnorm;
                  }
                }

                if (goto70) {
                  temp = ad11l;
                  ad11l = ad21l;
                  ad21l = temp;
                }

                u12 = (anorm * anorm + ad21l * ad21l) + ad11l * ad11l;
                st.site = &lp_emlrtRSI;
                d_sqrt(&st, &u12);
                bnorm = anorm / u12 + 1.0;
                anorm = -1.0 / (anorm + u12);
                v[1] = anorm * ad21l;
                v[2] = anorm * ad11l;
                ix0 = iy0 + 3;
                jch = ilast + 1;
                ix0 = (uint8_T)muIntScalarMin_sint32(ix0, jch);
                for (jch = 0; jch < ix0; jch++) {
                  temp = bnorm * ((h[jch + ((iy0 - 1) << 3)] + v[1] * h[jch +
                                   (iy0 << 3)]) + v[2] * h[jch + ((iy0 + 1) << 3)]);
                  h[jch + ((iy0 - 1) << 3)] -= temp;
                  h[jch + (iy0 << 3)] -= temp * v[1];
                  h[jch + ((iy0 + 1) << 3)] -= temp * v[2];
                }

                ix0 = (uint8_T)(iy0 + 2);
                for (jch = 0; jch < ix0; jch++) {
                  temp = bnorm * ((t[jch + ((iy0 - 1) << 3)] + v[1] * t[jch +
                                   (iy0 << 3)]) + v[2] * t[jch + ((iy0 + 1) << 3)]);
                  t[jch + ((iy0 - 1) << 3)] -= temp;
                  t[jch + (iy0 << 3)] -= temp * v[1];
                  t[jch + ((iy0 + 1) << 3)] -= temp * v[2];
                }

                for (jch = 0; jch <= 6; jch += 2) {
                  r = _mm_loadu_pd(&z[jch + (iy0 << 3)]);
                  r1 = _mm_loadu_pd(&z[jch + ((iy0 - 1) << 3)]);
                  r2 = _mm_loadu_pd(&z[jch + ((iy0 + 1) << 3)]);
                  r = _mm_mul_pd(_mm_set1_pd(bnorm), _mm_add_pd(_mm_add_pd(r1,
                    _mm_mul_pd(_mm_set1_pd(v[1]), r)), _mm_mul_pd(_mm_set1_pd(v
                    [2]), r2)));
                  r1 = _mm_loadu_pd(&z[jch + ((iy0 - 1) << 3)]);
                  _mm_storeu_pd(&z[jch + ((iy0 - 1) << 3)], _mm_sub_pd(r1, r));
                  r1 = _mm_loadu_pd(&z[jch + (iy0 << 3)]);
                  _mm_storeu_pd(&z[jch + (iy0 << 3)], _mm_sub_pd(r1, _mm_mul_pd
                    (r, _mm_set1_pd(v[1]))));
                  r1 = _mm_loadu_pd(&z[jch + ((iy0 + 1) << 3)]);
                  _mm_storeu_pd(&z[jch + ((iy0 + 1) << 3)], _mm_sub_pd(r1,
                    _mm_mul_pd(r, _mm_set1_pd(v[2]))));
                }

                t[iy0 + ((iy0 - 1) << 3)] = 0.0;
                t[(iy0 + ((iy0 - 1) << 3)) + 1] = 0.0;
              }

              st.site = &mp_emlrtRSI;
              xzlartg(&st, h[(ilast + ((ilast - 2) << 3)) - 1], h[ilast +
                      ((ilast - 2) << 3)], &bnorm, &ad22, &anorm);
              h[(ilast + ((ilast - 2) << 3)) - 1] = anorm;
              h[ilast + ((ilast - 2) << 3)] = 0.0;
              for (jch = ilast; jch < 9; jch++) {
                temp = bnorm * h[(ilast + ((jch - 1) << 3)) - 1] + ad22 *
                  h[ilast + ((jch - 1) << 3)];
                h[ilast + ((jch - 1) << 3)] = -ad22 * h[(ilast + ((jch - 1) << 3))
                  - 1] + bnorm * h[ilast + ((jch - 1) << 3)];
                h[(ilast + ((jch - 1) << 3)) - 1] = temp;
                temp2 = bnorm * t[(ilast + ((jch - 1) << 3)) - 1] + ad22 *
                  t[ilast + ((jch - 1) << 3)];
                t[ilast + ((jch - 1) << 3)] = -ad22 * t[(ilast + ((jch - 1) << 3))
                  - 1] + bnorm * t[ilast + ((jch - 1) << 3)];
                t[(ilast + ((jch - 1) << 3)) - 1] = temp2;
              }

              st.site = &np_emlrtRSI;
              xzlartg(&st, t[ilast + (ilast << 3)], t[ilast + ((ilast - 1) << 3)],
                      &bnorm, &ad22, &anorm);
              t[ilast + (ilast << 3)] = anorm;
              t[ilast + ((ilast - 1) << 3)] = 0.0;
              ix0 = (uint8_T)(ilast + 1);
              for (jch = 0; jch < ix0; jch++) {
                temp = bnorm * h[jch + (ilast << 3)] + ad22 * h[jch + ((ilast -
                  1) << 3)];
                h[jch + ((ilast - 1) << 3)] = -ad22 * h[jch + (ilast << 3)] +
                  bnorm * h[jch + ((ilast - 1) << 3)];
                h[jch + (ilast << 3)] = temp;
              }

              ix0 = (uint8_T)ilast;
              for (jch = 0; jch < ix0; jch++) {
                temp = bnorm * t[jch + (ilast << 3)] + ad22 * t[jch + ((ilast -
                  1) << 3)];
                t[jch + ((ilast - 1) << 3)] = -ad22 * t[jch + (ilast << 3)] +
                  bnorm * t[jch + ((ilast - 1) << 3)];
                t[jch + (ilast << 3)] = temp;
              }

              for (jch = 0; jch <= 6; jch += 2) {
                r = _mm_loadu_pd(&z[jch + (ilast << 3)]);
                r1 = _mm_loadu_pd(&z[jch + ((ilast - 1) << 3)]);
                r2 = _mm_loadu_pd(&z[jch + (ilast << 3)]);
                r3 = _mm_loadu_pd(&z[jch + ((ilast - 1) << 3)]);
                _mm_storeu_pd(&z[jch + ((ilast - 1) << 3)], _mm_add_pd
                              (_mm_mul_pd(_mm_set1_pd(-ad22), r2), _mm_mul_pd
                               (_mm_set1_pd(bnorm), r3)));
                _mm_storeu_pd(&z[jch + (ilast << 3)], _mm_add_pd(_mm_mul_pd
                  (_mm_set1_pd(bnorm), r), _mm_mul_pd(_mm_set1_pd(ad22), r1)));
              }

              jiter++;
            }
          }
        } else {
          *info = 9;
          for (jch = 0; jch < 8; jch++) {
            alphar[jch] = rtNaN;
            alphai[jch] = rtNaN;
            beta[jch] = rtNaN;
          }

          for (ix0 = 0; ix0 < 64; ix0++) {
            z[ix0] = rtNaN;
          }

          exitg1 = 1;
        }
      } else {
        guard2 = true;
        exitg1 = 1;
      }
    } while (exitg1 == 0);
  } else {
    guard1 = true;
  }

  if (guard2) {
    if (!converged) {
      *info = ilast + 1;
      ix0 = (uint8_T)(ilast + 1);
      for (jch = 0; jch < ix0; jch++) {
        alphar[jch] = rtNaN;
        alphai[jch] = rtNaN;
        beta[jch] = rtNaN;
      }

      for (ix0 = 0; ix0 < 64; ix0++) {
        z[ix0] = rtNaN;
      }
    } else {
      guard1 = true;
    }
  }

  if (guard1) {
    ix0 = (uint8_T)(ilo - 1);
    for (iy0 = 0; iy0 < ix0; iy0++) {
      if (t[iy0 + (iy0 << 3)] < 0.0) {
        for (jch = 0; jch <= iy0; jch++) {
          h[jch + (iy0 << 3)] = -h[jch + (iy0 << 3)];
          t[jch + (iy0 << 3)] = -t[jch + (iy0 << 3)];
        }

        for (jch = 0; jch < 8; jch++) {
          z[jch + (iy0 << 3)] = -z[jch + (iy0 << 3)];
        }
      }

      alphar[iy0] = h[iy0 + (iy0 << 3)];
      alphai[iy0] = 0.0;
      beta[iy0] = t[iy0 + (iy0 << 3)];
    }
  }
}

static void xrot(int32_T n, real_T x[64], int32_T ix0, int32_T iy0, real_T c,
                 real_T s)
{
  real_T temp;
  int32_T i;
  int32_T ix;
  int32_T iy;
  int32_T k;
  ix = ix0 - 1;
  iy = iy0 - 1;
  i = (uint8_T)n;
  for (k = 0; k < i; k++) {
    temp = c * x[ix] + s * x[iy];
    x[iy] = c * x[iy] - s * x[ix];
    x[ix] = temp;
    iy += 8;
    ix += 8;
  }
}

static void b_xrot(int32_T n, real_T x[64], int32_T ix0, int32_T iy0, real_T c,
                   real_T s)
{
  real_T temp;
  int32_T i;
  int32_T ix;
  int32_T iy;
  int32_T k;
  if (n >= 1) {
    ix = ix0 - 1;
    iy = iy0 - 1;
    i = (uint8_T)n;
    for (k = 0; k < i; k++) {
      temp = c * x[ix] + s * x[iy];
      x[iy] = c * x[iy] - s * x[ix];
      x[ix] = temp;
      iy++;
      ix++;
    }
  }
}

static void c_xrot(real_T x[64], int32_T ix0, int32_T iy0, real_T c, real_T s)
{
  real_T temp;
  int32_T ix;
  int32_T iy;
  int32_T k;
  ix = ix0 - 1;
  iy = iy0 - 1;
  for (k = 0; k < 8; k++) {
    temp = c * x[ix] + s * x[iy];
    x[iy] = c * x[iy] - s * x[ix];
    x[ix] = temp;
    iy++;
    ix++;
  }
}

static real_T b_xzlarfg(real_T *alpha1, real_T x[3])
{
  __m128d r;
  real_T absxk;
  real_T scale;
  real_T t;
  real_T tau;
  real_T xnorm;
  int32_T k;
  int32_T knt;
  tau = 0.0;
  xnorm = 0.0;
  scale = 3.3121686421112381E-170;
  for (k = 0; k < 2; k++) {
    absxk = muDoubleScalarAbs(x[k + 1]);
    if (absxk > scale) {
      t = scale / absxk;
      xnorm = xnorm * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      xnorm += t * t;
    }
  }

  xnorm = scale * muDoubleScalarSqrt(xnorm);
  if (xnorm != 0.0) {
    xnorm = muDoubleScalarHypot(*alpha1, xnorm);
    if (*alpha1 >= 0.0) {
      xnorm = -xnorm;
    }

    if (muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) {
      knt = -1;
      do {
        knt++;
        for (k = 0; k <= 0; k += 2) {
          r = _mm_loadu_pd(&x[1]);
          _mm_storeu_pd(&x[1], _mm_mul_pd(_mm_set1_pd(9.9792015476736E+291), r));
        }

        xnorm *= 9.9792015476736E+291;
        *alpha1 *= 9.9792015476736E+291;
      } while ((muDoubleScalarAbs(xnorm) < 1.0020841800044864E-292) && (knt + 1 <
                20));

      xnorm = 0.0;
      scale = 3.3121686421112381E-170;
      for (k = 0; k < 2; k++) {
        absxk = muDoubleScalarAbs(x[k + 1]);
        if (absxk > scale) {
          t = scale / absxk;
          xnorm = xnorm * t * t + 1.0;
          scale = absxk;
        } else {
          t = absxk / scale;
          xnorm += t * t;
        }
      }

      xnorm = scale * muDoubleScalarSqrt(xnorm);
      xnorm = muDoubleScalarHypot(*alpha1, xnorm);
      if (*alpha1 >= 0.0) {
        xnorm = -xnorm;
      }

      tau = (xnorm - *alpha1) / xnorm;
      *alpha1 = 1.0 / (*alpha1 - xnorm);
      for (k = 0; k <= 0; k += 2) {
        r = _mm_loadu_pd(&x[1]);
        _mm_storeu_pd(&x[1], _mm_mul_pd(_mm_set1_pd(*alpha1), r));
      }

      for (k = 0; k <= knt; k++) {
        xnorm *= 1.0020841800044864E-292;
      }

      *alpha1 = xnorm;
    } else {
      tau = (xnorm - *alpha1) / xnorm;
      *alpha1 = 1.0 / (*alpha1 - xnorm);
      for (k = 0; k <= 0; k += 2) {
        r = _mm_loadu_pd(&x[1]);
        _mm_storeu_pd(&x[1], _mm_mul_pd(_mm_set1_pd(*alpha1), r));
      }

      *alpha1 = xnorm;
    }
  }

  return tau;
}

static int32_T xdtgevc(const emlrtStack *sp, real_T s[64], real_T p[64], real_T
  vr[64])
{
  __m128d r;
  __m128d r1;
  __m128d r2;
  emlrtStack st;
  real_T work[48];
  real_T e_sum[4];
  real_T f_sum[4];
  real_T bdiag[2];
  real_T acoef;
  real_T acoefa;
  real_T anorm;
  real_T ascale;
  real_T b_bdiag;
  real_T bcoefa;
  real_T bcoefi;
  real_T bcoefr;
  real_T bnorm;
  real_T bscale;
  real_T cimaga;
  real_T cimagb;
  real_T creala;
  real_T crealb;
  real_T scale;
  real_T temp;
  real_T temp2;
  real_T temp2i;
  real_T xmax;
  int32_T b_i;
  int32_T i;
  int32_T ieig;
  int32_T iend;
  int32_T info;
  int32_T j;
  int32_T ja;
  int32_T je;
  int32_T jr;
  int32_T jw;
  int32_T na;
  int32_T nw;
  int32_T offset2;
  boolean_T exitg1;
  boolean_T guard1;
  boolean_T guard2;
  boolean_T il2by2;
  boolean_T ilcplx;
  boolean_T lsb;
  st.prev = sp;
  st.tls = sp->tls;
  info = 0;
  for (i = 0; i < 2; i++) {
    bdiag[i] = 0.0;
  }

  for (b_i = 0; b_i < 4; b_i++) {
    e_sum[b_i] = 0.0;
  }

  anorm = muDoubleScalarAbs(s[0]) + muDoubleScalarAbs(s[1]);
  bnorm = muDoubleScalarAbs(p[0]);
  work[0] = 0.0;
  work[8] = 0.0;
  for (j = 0; j < 7; j++) {
    temp = 0.0;
    temp2 = 0.0;
    if (s[(j + (j << 3)) + 1] == 0.0) {
      iend = j + 1;
    } else {
      iend = j;
    }

    for (i = 0; i < iend; i++) {
      temp += muDoubleScalarAbs(s[i + ((j + 1) << 3)]);
      temp2 += muDoubleScalarAbs(p[i + ((j + 1) << 3)]);
    }

    work[j + 1] = temp;
    work[j + 9] = temp2;
    b_i = j + 3;
    b_i = muIntScalarMin_sint32(b_i, 8);
    for (i = iend + 1; i <= b_i; i++) {
      temp += muDoubleScalarAbs(s[(i + ((j + 1) << 3)) - 1]);
      temp2 += muDoubleScalarAbs(p[(i + ((j + 1) << 3)) - 1]);
    }

    anorm = maximum2(anorm, temp);
    bnorm = maximum2(bnorm, temp2);
  }

  ascale = 1.0 / maximum2(anorm, 2.2250738585072014E-308);
  bscale = 1.0 / maximum2(bnorm, 2.2250738585072014E-308);
  ieig = 8;
  ilcplx = false;
  je = 7;
  exitg1 = false;
  while ((!exitg1) && (je + 1 > 0)) {
    guard1 = false;
    guard2 = false;
    if (ilcplx) {
      ilcplx = false;
      je--;
    } else {
      nw = 1;
      if ((je + 1 > 1) && (s[je + ((je - 1) << 3)] != 0.0)) {
        ilcplx = true;
        nw = 2;
        guard2 = true;
      } else if ((muDoubleScalarAbs(s[je + (je << 3)]) <=
                  2.2250738585072014E-308) && (muDoubleScalarAbs(p[je + (je << 3)])
                  <= 2.2250738585072014E-308)) {
        ieig--;
        for (jr = 0; jr < 8; jr++) {
          vr[jr + (ieig << 3)] = 0.0;
        }

        vr[ieig + (ieig << 3)] = 1.0;
        je--;
      } else {
        guard2 = true;
      }
    }

    if (guard2) {
      for (jw = 0; jw < nw; jw++) {
        iend = (jw + 2) << 3;
        for (jr = 0; jr < 8; jr++) {
          work[iend + jr] = 0.0;
        }
      }

      if (!ilcplx) {
        temp = 1.0 / maximum2(2.2250738585072014E-308, maximum2
                              (muDoubleScalarAbs(s[je + (je << 3)]) * ascale,
          muDoubleScalarAbs(p[je + (je << 3)]) * bscale));
        temp2i = temp * s[je + (je << 3)] * ascale;
        temp2 = temp * p[je + (je << 3)] * bscale;
        acoef = temp2 * ascale;
        bcoefr = temp2i * bscale;
        bcoefi = 0.0;
        scale = 1.0;
        if ((muDoubleScalarAbs(temp2) >= 2.2250738585072014E-308) &&
            (muDoubleScalarAbs(acoef) < 8.0166734400358911E-292)) {
          il2by2 = true;
        } else {
          il2by2 = false;
        }

        if ((muDoubleScalarAbs(temp2i) >= 2.2250738585072014E-308) &&
            (muDoubleScalarAbs(bcoefr) < 8.0166734400358911E-292)) {
          lsb = true;
        } else {
          lsb = false;
        }

        if (il2by2) {
          scale = 8.0166734400358911E-292 / muDoubleScalarAbs(temp2) * minimum2
            (anorm, 1.2474001934592E+291);
        }

        if (lsb) {
          scale = maximum2(scale, 8.0166734400358911E-292 / muDoubleScalarAbs
                           (temp2i) * minimum2(bnorm, 1.2474001934592E+291));
        }

        if (il2by2 || lsb) {
          scale = minimum2(scale, 1.0 / (2.2250738585072014E-308 * maximum2(1.0,
            maximum2(muDoubleScalarAbs(acoef), muDoubleScalarAbs(bcoefr)))));
          if (il2by2) {
            acoef = ascale * (scale * temp2);
          } else {
            acoef *= scale;
          }

          if (lsb) {
            bcoefr = bscale * (scale * temp2i);
          } else {
            bcoefr *= scale;
          }
        }

        acoefa = muDoubleScalarAbs(acoef);
        bcoefa = muDoubleScalarAbs(bcoefr);
        work[je + 16] = 1.0;
        xmax = 1.0;
        i = je / 2 * 2;
        offset2 = i - 2;
        for (jr = 0; jr <= offset2; jr += 2) {
          r = _mm_loadu_pd(&p[jr + (je << 3)]);
          r1 = _mm_loadu_pd(&s[jr + (je << 3)]);
          _mm_storeu_pd(&work[jr + 16], _mm_sub_pd(_mm_mul_pd(_mm_set1_pd(bcoefr),
            r), _mm_mul_pd(_mm_set1_pd(acoef), r1)));
        }

        for (jr = i; jr < je; jr++) {
          work[jr + 16] = bcoefr * p[jr + (je << 3)] - acoef * s[jr + (je << 3)];
        }

        guard1 = true;
      } else {
        iend = ((je - 1) << 3) + je;
        st.site = &xp_emlrtRSI;
        xdlag2(&st, s, iend, p, iend, 2.2250738585072014E-306, &acoef, &temp,
               &bcoefr, &temp2, &bcoefi);
        if (bcoefi == 0.0) {
          info = je;
          exitg1 = true;
        } else {
          acoefa = muDoubleScalarAbs(acoef);
          bcoefa = muDoubleScalarAbs(bcoefr) + muDoubleScalarAbs(bcoefi);
          scale = 1.0;
          if ((acoefa * 2.2204460492503131E-16 < 2.2250738585072014E-308) &&
              (acoefa >= 2.2250738585072014E-308)) {
            scale = 1.0020841800044864E-292 / acoefa;
          }

          if ((bcoefa * 2.2204460492503131E-16 < 2.2250738585072014E-308) &&
              (bcoefa >= 2.2250738585072014E-308)) {
            scale = maximum2(scale, 1.0020841800044864E-292 / bcoefa);
          }

          if (2.2250738585072014E-308 * acoefa > ascale) {
            scale = ascale / (2.2250738585072014E-308 * acoefa);
          }

          if (2.2250738585072014E-308 * bcoefa > bscale) {
            scale = minimum2(scale, bscale / (2.2250738585072014E-308 * bcoefa));
          }

          if (scale != 1.0) {
            acoef *= scale;
            acoefa = muDoubleScalarAbs(acoef);
            bcoefr *= scale;
            bcoefi *= scale;
            bcoefa = muDoubleScalarAbs(bcoefr) + muDoubleScalarAbs(bcoefi);
          }

          temp = acoef * s[je + ((je - 1) << 3)];
          temp2 = acoef * s[je + (je << 3)] - bcoefr * p[je + (je << 3)];
          temp2i = -bcoefi * p[je + (je << 3)];
          if (muDoubleScalarAbs(temp) >= muDoubleScalarAbs(temp2) +
              muDoubleScalarAbs(temp2i)) {
            work[je + 16] = 1.0;
            work[je + 24] = 0.0;
            work[je + 15] = -temp2 / temp;
            work[je + 23] = -temp2i / temp;
          } else {
            work[je + 15] = 1.0;
            work[je + 23] = 0.0;
            temp = acoef * s[(je + (je << 3)) - 1];
            work[je + 16] = (bcoefr * p[(je + ((je - 1) << 3)) - 1] - acoef * s
                             [(je + ((je - 1) << 3)) - 1]) / temp;
            work[je + 24] = bcoefi * p[(je + ((je - 1) << 3)) - 1] / temp;
          }

          xmax = maximum2(muDoubleScalarAbs(work[je + 16]) + muDoubleScalarAbs
                          (work[je + 24]), muDoubleScalarAbs(work[je + 15]) +
                          muDoubleScalarAbs(work[je + 23]));
          creala = acoef * work[je + 15];
          cimaga = acoef * work[je + 23];
          crealb = bcoefr * work[je + 15] - bcoefi * work[je + 23];
          cimagb = bcoefi * work[je + 15] + bcoefr * work[je + 23];
          temp2 = acoef * work[je + 16];
          temp2i = acoef * work[je + 24];
          scale = bcoefr * work[je + 16] - bcoefi * work[je + 24];
          temp = bcoefi * work[je + 16] + bcoefr * work[je + 24];
          b_i = je - 2;
          for (jr = 0; jr <= b_i; jr++) {
            work[jr + 16] = ((-creala * s[jr + ((je - 1) << 3)] + crealb * p[jr
                              + ((je - 1) << 3)]) - temp2 * s[jr + (je << 3)]) +
              scale * p[jr + (je << 3)];
            work[jr + 24] = ((-cimaga * s[jr + ((je - 1) << 3)] + cimagb * p[jr
                              + ((je - 1) << 3)]) - temp2i * s[jr + (je << 3)])
              + temp * p[jr + (je << 3)];
          }

          guard1 = true;
        }
      }
    }

    if (guard1) {
      temp2i = maximum2(2.2250738585072014E-308, maximum2(2.2204460492503131E-16
        * acoefa * anorm, 2.2204460492503131E-16 * bcoefa * bnorm));
      il2by2 = false;
      b_i = (je - nw) + 1;
      for (j = b_i; j >= 1; j--) {
        b_bdiag = bdiag[1];
        if ((!il2by2) && (j > 1) && (s[(j + ((j - 2) << 3)) - 1] != 0.0)) {
          il2by2 = true;
        } else {
          if (il2by2) {
            na = 2;
            b_bdiag = p[j + (j << 3)];
          } else {
            na = 1;
          }

          for (iend = 0; iend < 4; iend++) {
            f_sum[iend] = e_sum[iend];
          }

          st.site = &yp_emlrtRSI;
          xdlaln2(na, nw, temp2i, acoef, s, ((j - 1) << 3) + j, p[(j + ((j - 1) <<
                    3)) - 1], b_bdiag, work, j + 16, bcoefr, bcoefi, f_sum,
                  &scale, &temp);
          for (iend = 0; iend < 4; iend++) {
            e_sum[iend] = f_sum[iend];
          }

          if (scale < 1.0) {
            for (jw = 0; jw < nw; jw++) {
              iend = ((jw + 2) << 3) - 1;
              i = (je + 1) / 2 * 2;
              offset2 = i - 2;
              for (jr = 0; jr <= offset2; jr += 2) {
                r = _mm_loadu_pd(&work[(iend + jr) + 1]);
                _mm_storeu_pd(&work[(iend + jr) + 1], _mm_mul_pd(_mm_set1_pd
                  (scale), r));
              }

              for (jr = i; jr <= je; jr++) {
                work[(iend + jr) + 1] *= scale;
              }
            }
          }

          xmax = maximum2(scale * xmax, temp);
          for (jw = 0; jw < nw; jw++) {
            iend = (((jw + 2) << 3) + j) - 2;
            for (ja = 0; ja < na; ja++) {
              work[(iend + ja) + 1] = f_sum[ja + (jw << 1)];
            }
          }

          if (j > 1) {
            temp2 = 1.0 / maximum2(1.0, xmax);
            temp = acoefa * work[j - 1] + bcoefa * work[j + 7];
            if (il2by2) {
              temp = maximum2(temp, acoefa * work[j] + bcoefa * work[j + 8]);
            }

            temp = maximum2(temp, maximum2(acoefa, bcoefa));
            if (temp > 5.6177910464447372E+306 * temp2) {
              for (jw = 0; jw < nw; jw++) {
                iend = ((jw + 2) << 3) - 1;
                i = (je + 1) / 2 * 2;
                offset2 = i - 2;
                for (jr = 0; jr <= offset2; jr += 2) {
                  r = _mm_loadu_pd(&work[(iend + jr) + 1]);
                  _mm_storeu_pd(&work[(iend + jr) + 1], _mm_mul_pd(_mm_set1_pd
                    (temp2), r));
                }

                for (jr = i; jr <= je; jr++) {
                  work[(iend + jr) + 1] *= temp2;
                }
              }

              xmax *= temp2;
            }

            for (ja = 0; ja < na; ja++) {
              if (ilcplx) {
                creala = acoef * work[(j + ja) + 15];
                cimaga = acoef * work[(j + ja) + 23];
                crealb = bcoefr * work[(j + ja) + 15] - bcoefi * work[(j + ja) +
                  23];
                cimagb = bcoefi * work[(j + ja) + 15] + bcoefr * work[(j + ja) +
                  23];
                iend = j - 2;
                for (jr = 0; jr <= iend; jr++) {
                  work[jr + 16] = (work[jr + 16] - creala * s[jr + (((j + ja) -
                    1) << 3)]) + crealb * p[jr + (((j + ja) - 1) << 3)];
                  work[jr + 24] = (work[jr + 24] - cimaga * s[jr + (((j + ja) -
                    1) << 3)]) + cimagb * p[jr + (((j + ja) - 1) << 3)];
                }
              } else {
                creala = acoef * work[(j + ja) + 15];
                crealb = bcoefr * work[(j + ja) + 15];
                iend = j - 2;
                i = (j - 1) / 2 * 2;
                offset2 = i - 2;
                for (jr = 0; jr <= offset2; jr += 2) {
                  r = _mm_loadu_pd(&s[jr + (((j + ja) - 1) << 3)]);
                  r1 = _mm_loadu_pd(&work[jr + 16]);
                  r2 = _mm_loadu_pd(&p[jr + (((j + ja) - 1) << 3)]);
                  _mm_storeu_pd(&work[jr + 16], _mm_add_pd(_mm_sub_pd(r1,
                    _mm_mul_pd(_mm_set1_pd(creala), r)), _mm_mul_pd(_mm_set1_pd
                    (crealb), r2)));
                }

                for (jr = i; jr <= iend; jr++) {
                  work[jr + 16] = (work[jr + 16] - creala * s[jr + (((j + ja) -
                    1) << 3)]) + crealb * p[jr + (((j + ja) - 1) << 3)];
                }
              }
            }
          }

          il2by2 = false;
        }

        bdiag[1] = b_bdiag;
      }

      ieig -= nw;
      for (jw = 0; jw < nw; jw++) {
        i = ((jw + 4) << 3) - 1;
        offset2 = ((jw + 2) << 3) - 1;
        iend = (jw + 2) << 3;
        for (jr = 0; jr < 8; jr++) {
          work[(i + jr) + 1] = work[iend] * vr[jr];
        }

        for (iend = 2; iend <= je + 1; iend++) {
          for (jr = 0; jr < 8; jr++) {
            work[(i + jr) + 1] += work[offset2 + iend] * vr[jr + ((iend - 1) <<
              3)];
          }
        }
      }

      for (jw = 0; jw < nw; jw++) {
        memcpy(&vr[(jw + ieig) << 3], &work[(jw + 4) << 3], sizeof(real_T) << 3);
      }

      xmax = 0.0;
      if (ilcplx) {
        for (j = 0; j < 8; j++) {
          xmax = maximum2(xmax, muDoubleScalarAbs(vr[j + (ieig << 3)]) +
                          muDoubleScalarAbs(vr[j + ((ieig + 1) << 3)]));
        }
      } else {
        for (j = 0; j < 8; j++) {
          xmax = maximum2(xmax, muDoubleScalarAbs(vr[j + (ieig << 3)]));
        }
      }

      if (xmax > 2.2250738585072014E-308) {
        temp2 = 1.0 / xmax;
        for (jw = 0; jw < nw; jw++) {
          for (jr = 0; jr < 8; jr++) {
            vr[jr + ((ieig + jw) << 3)] *= temp2;
          }
        }
      }

      je--;
    }
  }

  return info;
}

static void xdlaln2(int32_T na, int32_T nw, real_T smin, real_T ca, real_T A[64],
                    int32_T ia0, real_T d1, real_T d2, real_T B[48], int32_T ib0,
                    real_T wr, real_T wi, real_T X[4], real_T *scale, real_T
                    *xnorm)
{
  static int8_T ipivot[16] = { 1, 2, 3, 4, 2, 1, 4, 3, 3, 4, 1, 2, 4, 3, 2, 1 };

  real_T ci[4];
  real_T cr[4];
  real_T bi1;
  real_T br1;
  real_T cmax;
  real_T cr21;
  real_T cr22;
  real_T lr21;
  real_T smini;
  real_T temp;
  real_T ui11r;
  real_T ui12;
  real_T ui12s;
  real_T ur11r;
  real_T ur12;
  real_T ur12s;
  real_T ur22;
  int32_T icmax;
  int32_T j;
  smini = muDoubleScalarMax(smin, 4.4501477170144028E-308);
  *scale = 1.0;
  if (na == 1) {
    if (nw == 1) {
      cr22 = ca * A[ia0 - 1] - wr * d1;
      temp = muDoubleScalarAbs(cr22);
      if (temp < smini) {
        cr22 = smini;
        temp = smini;
      }

      cr21 = muDoubleScalarAbs(B[ib0 - 1]);
      if ((temp < 1.0) && (cr21 > 1.0) && (cr21 > 2.2471164185778949E+307 * temp))
      {
        *scale = 1.0 / cr21;
      }

      X[0] = B[ib0 - 1] * *scale / cr22;
      *xnorm = muDoubleScalarAbs(X[0]);
    } else {
      cr22 = ca * A[ia0 - 1] - wr * d1;
      ui12 = -wi * d1;
      temp = muDoubleScalarAbs(cr22) + muDoubleScalarAbs(ui12);
      if (temp < smini) {
        cr22 = smini;
        ui12 = 0.0;
        temp = smini;
      }

      cr21 = muDoubleScalarAbs(B[ib0 - 1]) + muDoubleScalarAbs(B[ib0 + 7]);
      if ((temp < 1.0) && (cr21 > 1.0) && (cr21 > 2.2471164185778949E+307 * temp))
      {
        *scale = 1.0 / cr21;
      }

      xdladiv(*scale * B[ib0 - 1], *scale * B[ib0 + 7], cr22, ui12, &cr21, &temp);
      X[0] = cr21;
      X[2] = temp;
      *xnorm = muDoubleScalarAbs(cr21) + muDoubleScalarAbs(temp);
    }
  } else {
    cr[0] = ca * A[ia0 - 1] - wr * d1;
    cr[3] = ca * A[ia0 + 8] - wr * d2;
    cr[1] = ca * A[ia0];
    cr[2] = ca * A[ia0 + 7];
    if (nw == 1) {
      cmax = 0.0;
      icmax = 0;
      for (j = 0; j < 4; j++) {
        cr21 = cr[j];
        if (muDoubleScalarAbs(cr21) > cmax) {
          cmax = muDoubleScalarAbs(cr21);
          icmax = j + 1;
        }
      }

      if (cmax < smini) {
        cr21 = muDoubleScalarMax(muDoubleScalarAbs(B[ib0 - 1]),
          muDoubleScalarAbs(B[ib0]));
        if ((smini < 1.0) && (cr21 > 1.0) && (cr21 > 2.2471164185778949E+307 *
             smini)) {
          *scale = 1.0 / cr21;
        }

        temp = *scale / smini;
        X[0] = temp * B[ib0 - 1];
        X[1] = temp * B[ib0];
        *xnorm = temp * cr21;
      } else {
        ur12 = cr[ipivot[((icmax - 1) << 2) + 2] - 1];
        ur11r = 1.0 / cr[icmax - 1];
        lr21 = ur11r * cr[ipivot[((icmax - 1) << 2) + 1] - 1];
        ur22 = cr[ipivot[((icmax - 1) << 2) + 3] - 1] - ur12 * lr21;
        if (muDoubleScalarAbs(ur22) < smini) {
          ur22 = smini;
        }

        if ((icmax == 2) || (icmax == 4)) {
          br1 = B[ib0];
          smini = B[ib0 - 1];
        } else {
          br1 = B[ib0 - 1];
          smini = B[ib0];
        }

        smini -= lr21 * br1;
        temp = muDoubleScalarMax(muDoubleScalarAbs(br1 * (ur22 * ur11r)),
          muDoubleScalarAbs(smini));
        if ((temp > 1.0) && (muDoubleScalarAbs(ur22) < 1.0) && (temp >=
             2.2471164185778949E+307 * muDoubleScalarAbs(ur22))) {
          *scale = 1.0 / temp;
        }

        ui12 = smini * *scale / ur22;
        cr22 = *scale * br1 * ur11r - ui12 * (ur11r * ur12);
        if ((icmax == 3) || (icmax == 4)) {
          X[0] = ui12;
          X[1] = cr22;
        } else {
          X[0] = cr22;
          X[1] = ui12;
        }

        *xnorm = muDoubleScalarMax(muDoubleScalarAbs(cr22), muDoubleScalarAbs
          (ui12));
        if ((*xnorm > 1.0) && (cmax > 1.0) && (*xnorm > 2.2471164185778949E+307 /
             cmax)) {
          temp = cmax / 2.2471164185778949E+307;
          X[0] *= temp;
          X[1] *= temp;
          *xnorm *= temp;
          *scale *= temp;
        }
      }
    } else {
      ci[0] = -wi * d1;
      ci[1] = 0.0;
      ci[2] = 0.0;
      ci[3] = -wi * d2;
      cmax = 0.0;
      icmax = -1;
      for (j = 0; j < 4; j++) {
        temp = muDoubleScalarAbs(cr[j]) + muDoubleScalarAbs(ci[j]);
        if (temp > cmax) {
          cmax = temp;
          icmax = j;
        }
      }

      if (cmax < smini) {
        cr21 = muDoubleScalarMax(muDoubleScalarAbs(B[ib0 - 1]) +
          muDoubleScalarAbs(B[ib0 + 7]), muDoubleScalarAbs(B[ib0]) +
          muDoubleScalarAbs(B[ib0 + 8]));
        if ((smini < 1.0) && (cr21 > 1.0) && (cr21 > 2.2471164185778949E+307 *
             smini)) {
          *scale = 1.0 / cr21;
        }

        temp = *scale / smini;
        X[0] = temp * B[ib0 - 1];
        X[1] = temp * B[ib0];
        X[2] = temp * B[ib0 + 7];
        X[3] = temp * B[ib0 + 8];
        *xnorm = temp * cr21;
      } else {
        cr21 = cr[ipivot[(icmax << 2) + 1] - 1];
        ur12 = cr[ipivot[(icmax << 2) + 2] - 1];
        ui12 = ci[ipivot[(icmax << 2) + 2] - 1];
        cr22 = cr[ipivot[(icmax << 2) + 3] - 1];
        if ((icmax + 1 == 1) || (icmax + 1 == 4)) {
          if (muDoubleScalarAbs(cr[icmax]) > muDoubleScalarAbs(ci[icmax])) {
            temp = ci[icmax] / cr[icmax];
            ur11r = 1.0 / (cr[icmax] * (temp * temp + 1.0));
            ui11r = -temp * ur11r;
          } else {
            temp = cr[icmax] / ci[icmax];
            ui11r = -1.0 / (ci[icmax] * (temp * temp + 1.0));
            ur11r = -temp * ui11r;
          }

          lr21 = cr21 * ur11r;
          temp = cr21 * ui11r;
          ur12s = ur12 * ur11r;
          ui12s = ur12 * ui11r;
          ur22 = cr22 - ur12 * lr21;
          ur12 = ci[ipivot[(icmax << 2) + 3] - 1] - ur12 * temp;
        } else {
          ur11r = 1.0 / cr[icmax];
          ui11r = 0.0;
          lr21 = cr21 * ur11r;
          temp = ci[ipivot[(icmax << 2) + 1] - 1] * ur11r;
          ur12s = ur12 * ur11r;
          ui12s = ui12 * ur11r;
          ur22 = (cr22 - ur12 * lr21) + ui12 * temp;
          ur12 = -ur12 * temp - ui12 * lr21;
        }

        cr21 = muDoubleScalarAbs(ur22) + muDoubleScalarAbs(ur12);
        if (cr21 < smini) {
          ur22 = smini;
          ur12 = 0.0;
        }

        if ((icmax + 1 == 2) || (icmax + 1 == 4)) {
          smini = B[ib0 - 1];
          br1 = B[ib0];
          cr22 = B[ib0 + 7];
          bi1 = B[ib0 + 8];
        } else {
          br1 = B[ib0 - 1];
          smini = B[ib0];
          bi1 = B[ib0 + 7];
          cr22 = B[ib0 + 8];
        }

        smini = (smini - lr21 * br1) + temp * bi1;
        cr22 = (cr22 - temp * br1) - lr21 * bi1;
        temp = muDoubleScalarMax((muDoubleScalarAbs(br1) + muDoubleScalarAbs(bi1))
          * (cr21 * (muDoubleScalarAbs(ur11r) + muDoubleScalarAbs(ui11r))),
          muDoubleScalarAbs(smini) + muDoubleScalarAbs(cr22));
        if ((temp > 1.0) && (cr21 < 1.0) && (temp >= 2.2471164185778949E+307 *
             cr21)) {
          *scale = 1.0 / temp;
          br1 *= *scale;
          bi1 *= *scale;
          smini *= *scale;
          cr22 *= *scale;
        }

        xdladiv(smini, cr22, ur22, ur12, &ui12, &temp);
        cr22 = ((ur11r * br1 - ui11r * bi1) - ur12s * ui12) + ui12s * temp;
        cr21 = ((ui11r * br1 + ur11r * bi1) - ui12s * ui12) - ur12s * temp;
        if ((icmax + 1 == 3) || (icmax + 1 == 4)) {
          X[0] = ui12;
          X[1] = cr22;
          X[2] = temp;
          X[3] = cr21;
        } else {
          X[0] = cr22;
          X[1] = ui12;
          X[2] = cr21;
          X[3] = temp;
        }

        *xnorm = muDoubleScalarMax(muDoubleScalarAbs(cr22) + muDoubleScalarAbs
          (cr21), muDoubleScalarAbs(ui12) + muDoubleScalarAbs(temp));
        if ((*xnorm > 1.0) && (cmax > 1.0) && (*xnorm > 2.2471164185778949E+307 /
             cmax)) {
          temp = cmax / 2.2471164185778949E+307;
          X[0] *= temp;
          X[1] *= temp;
          X[2] *= temp;
          X[3] *= temp;
          *xnorm *= temp;
          *scale *= temp;
        }
      }
    }
  }
}

static void d_sort(real_T x[8], int32_T idx[8])
{
  real_T xwork[8];
  real_T x4[4];
  int32_T iwork[8];
  int32_T perm[4];
  int32_T i;
  int32_T i3;
  int32_T i4;
  int32_T ib;
  int32_T k;
  int32_T nNaNs;
  int32_T quartetOffset;
  int8_T idx4[4];
  for (i = 0; i < 8; i++) {
    idx[i] = 0;
  }

  for (i = 0; i < 4; i++) {
    x4[i] = 0.0;
    idx4[i] = 0;
  }

  nNaNs = 0;
  ib = 0;
  for (k = 0; k < 8; k++) {
    if (muDoubleScalarIsNaN(x[k])) {
      idx[7 - nNaNs] = k + 1;
      xwork[7 - nNaNs] = x[k];
      nNaNs++;
    } else {
      ib++;
      idx4[ib - 1] = (int8_T)(k + 1);
      x4[ib - 1] = x[k];
      if (ib == 4) {
        quartetOffset = k - nNaNs;
        if (x4[0] >= x4[1]) {
          i = 1;
          ib = 2;
        } else {
          i = 2;
          ib = 1;
        }

        if (x4[2] >= x4[3]) {
          i3 = 3;
          i4 = 4;
        } else {
          i3 = 4;
          i4 = 3;
        }

        if (x4[i - 1] >= x4[i3 - 1]) {
          if (x4[ib - 1] >= x4[i3 - 1]) {
            perm[0] = i;
            perm[1] = ib;
            perm[2] = i3;
            perm[3] = i4;
          } else if (x4[ib - 1] >= x4[i4 - 1]) {
            perm[0] = i;
            perm[1] = i3;
            perm[2] = ib;
            perm[3] = i4;
          } else {
            perm[0] = i;
            perm[1] = i3;
            perm[2] = i4;
            perm[3] = ib;
          }
        } else if (x4[i - 1] >= x4[i4 - 1]) {
          if (x4[ib - 1] >= x4[i4 - 1]) {
            perm[0] = i3;
            perm[1] = i;
            perm[2] = ib;
            perm[3] = i4;
          } else {
            perm[0] = i3;
            perm[1] = i;
            perm[2] = i4;
            perm[3] = ib;
          }
        } else {
          perm[0] = i3;
          perm[1] = i4;
          perm[2] = i;
          perm[3] = ib;
        }

        idx[quartetOffset - 3] = idx4[perm[0] - 1];
        idx[quartetOffset - 2] = idx4[perm[1] - 1];
        idx[quartetOffset - 1] = idx4[perm[2] - 1];
        idx[quartetOffset] = idx4[perm[3] - 1];
        x[quartetOffset - 3] = x4[perm[0] - 1];
        x[quartetOffset - 2] = x4[perm[1] - 1];
        x[quartetOffset - 1] = x4[perm[2] - 1];
        x[quartetOffset] = x4[perm[3] - 1];
        ib = 0;
      }
    }
  }

  if (ib > 0) {
    for (i = 0; i < 4; i++) {
      perm[i] = 0;
    }

    if (ib == 1) {
      perm[0] = 1;
    } else if (ib == 2) {
      if (x4[0] >= x4[1]) {
        perm[0] = 1;
        perm[1] = 2;
      } else {
        perm[0] = 2;
        perm[1] = 1;
      }
    } else if (x4[0] >= x4[1]) {
      if (x4[1] >= x4[2]) {
        perm[0] = 1;
        perm[1] = 2;
        perm[2] = 3;
      } else if (x4[0] >= x4[2]) {
        perm[0] = 1;
        perm[1] = 3;
        perm[2] = 2;
      } else {
        perm[0] = 3;
        perm[1] = 1;
        perm[2] = 2;
      }
    } else if (x4[0] >= x4[2]) {
      perm[0] = 2;
      perm[1] = 1;
      perm[2] = 3;
    } else if (x4[1] >= x4[2]) {
      perm[0] = 2;
      perm[1] = 3;
      perm[2] = 1;
    } else {
      perm[0] = 3;
      perm[1] = 2;
      perm[2] = 1;
    }

    quartetOffset = (uint8_T)ib;
    for (k = 0; k < quartetOffset; k++) {
      i = perm[k];
      idx[((k - nNaNs) - ib) + 8] = idx4[i - 1];
      x[((k - nNaNs) - ib) + 8] = x4[i - 1];
    }
  }

  i = (nNaNs >> 1) + 8;
  for (k = 0; k <= i - 9; k++) {
    quartetOffset = idx[(k - nNaNs) + 8];
    idx[(k - nNaNs) + 8] = idx[7 - k];
    idx[7 - k] = quartetOffset;
    x[(k - nNaNs) + 8] = xwork[7 - k];
    x[7 - k] = xwork[(k - nNaNs) + 8];
  }

  if (((uint32_T)nNaNs & 1U) != 0U) {
    x[i - nNaNs] = xwork[i - nNaNs];
  }

  for (i = 0; i < 8; i++) {
    iwork[i] = 0;
  }

  ib = 8 - nNaNs;
  if (8 - nNaNs > 1) {
    for (i = 0; i < 8; i++) {
      iwork[i] = 0;
    }

    i = (8 - nNaNs) >> 2;
    quartetOffset = 4;
    while (i > 1) {
      for (k = 0; k < 1; k++) {
        b_merge(idx, x, 0, quartetOffset, quartetOffset, iwork, xwork);
      }

      quartetOffset <<= 1;
      i = 1;
    }

    if (8 - nNaNs > quartetOffset) {
      b_merge(idx, x, 0, quartetOffset, 8 - (nNaNs + quartetOffset), iwork,
              xwork);
    }
  }

  if ((nNaNs > 0) && (8 - nNaNs > 0)) {
    for (k = 0; k < nNaNs; k++) {
      xwork[k] = x[(k - nNaNs) + 8];
      iwork[k] = idx[(k - nNaNs) + 8];
    }

    for (k = ib; k >= 1; k--) {
      x[(nNaNs + k) - 1] = x[k - 1];
      idx[(nNaNs + k) - 1] = idx[k - 1];
    }

    memcpy(&x[0], &xwork[0], (uint32_T)nNaNs * sizeof(real_T));
    memcpy(&idx[0], &iwork[0], (uint32_T)nNaNs * sizeof(int32_T));
  }
}

static void b_merge(int32_T idx[8], real_T x[8], int32_T offset, int32_T np,
                    int32_T nq, int32_T iwork[8], real_T xwork[8])
{
  int32_T exitg1;
  int32_T iout;
  int32_T n;
  int32_T p;
  int32_T qend;
  if (nq != 0) {
    n = np + nq;
    for (qend = 0; qend < n; qend++) {
      iwork[qend] = idx[offset + qend];
      xwork[qend] = x[offset + qend];
    }

    p = 0;
    n = np;
    qend = np + nq;
    iout = offset - 1;
    do {
      exitg1 = 0;
      iout++;
      if (xwork[p] >= xwork[n]) {
        idx[iout] = iwork[p];
        x[iout] = xwork[p];
        if (p + 1 < np) {
          p++;
        } else {
          exitg1 = 1;
        }
      } else {
        idx[iout] = iwork[n];
        x[iout] = xwork[n];
        if (n + 1 < qend) {
          n++;
        } else {
          n = iout - p;
          for (qend = p + 1; qend <= np; qend++) {
            idx[n + qend] = iwork[qend - 1];
            x[n + qend] = xwork[qend - 1];
          }

          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

static void xgetrf(creal_T A[16], int32_T ipiv[4], int32_T *info)
{
  static int32_T offsets[4] = { 0, 1, 2, 3 };

  real_T ai;
  real_T ar;
  real_T bi;
  real_T br;
  real_T brm;
  real_T re;
  real_T s;
  real_T smax;
  int32_T b_j;
  int32_T c;
  int32_T i;
  int32_T ijA;
  int32_T ix;
  int32_T iy;
  int32_T j;
  int32_T jy;
  int32_T k;
  for (i = 0; i <= 0; i += 4) {
    _mm_storeu_si128((__m128i *)&ipiv[0], _mm_add_epi32(_mm_set1_epi32(1),
      _mm_add_epi32(_mm_set1_epi32(0), _mm_loadu_si128((const __m128i *)
      &offsets[0]))));
  }

  *info = 0;
  for (j = 0; j < 3; j++) {
    c = j * 5;
    iy = 5 - j;
    jy = 1;
    ix = c;
    smax = muDoubleScalarAbs(A[c].re) + muDoubleScalarAbs(A[c].im);
    for (k = 2; k < iy; k++) {
      ix++;
      s = muDoubleScalarAbs(A[ix].re) + muDoubleScalarAbs(A[ix].im);
      if (s > smax) {
        jy = k;
        smax = s;
      }
    }

    if ((A[(c + jy) - 1].re != 0.0) || (A[(c + jy) - 1].im != 0.0)) {
      if (jy - 1 != 0) {
        ipiv[j] = j + jy;
        ix = j;
        iy = (j + jy) - 1;
        for (k = 0; k < 4; k++) {
          smax = A[ix].re;
          s = A[ix].im;
          A[ix].re = A[iy].re;
          A[ix].im = A[iy].im;
          A[iy].re = smax;
          A[iy].im = s;
          ix += 4;
          iy += 4;
        }
      }

      i = c - j;
      for (iy = c + 2; iy <= i + 4; iy++) {
        ar = A[iy - 1].re;
        ai = A[iy - 1].im;
        br = A[c].re;
        bi = A[c].im;
        if (bi == 0.0) {
          if (ai == 0.0) {
            re = ar / br;
            smax = 0.0;
          } else if (ar == 0.0) {
            re = 0.0;
            smax = ai / br;
          } else {
            re = ar / br;
            smax = ai / br;
          }
        } else if (br == 0.0) {
          if (ar == 0.0) {
            re = ai / bi;
            smax = 0.0;
          } else if (ai == 0.0) {
            re = 0.0;
            smax = -(ar / bi);
          } else {
            re = ai / bi;
            smax = -(ar / bi);
          }
        } else {
          brm = muDoubleScalarAbs(br);
          smax = muDoubleScalarAbs(bi);
          if (brm > smax) {
            s = bi / br;
            smax = br + s * bi;
            re = (ar + s * ai) / smax;
            smax = (ai - s * ar) / smax;
          } else if (smax == brm) {
            if (br > 0.0) {
              s = 0.5;
            } else {
              s = -0.5;
            }

            if (bi > 0.0) {
              smax = 0.5;
            } else {
              smax = -0.5;
            }

            re = (ar * s + ai * smax) / brm;
            smax = (ai * s - ar * smax) / brm;
          } else {
            s = br / bi;
            smax = bi + s * br;
            re = (s * ar + ai) / smax;
            smax = (s * ai - ar) / smax;
          }
        }

        A[iy - 1].re = re;
        A[iy - 1].im = smax;
      }
    } else {
      *info = j + 1;
    }

    iy = c;
    jy = c + 4;
    i = 2 - j;
    for (b_j = 0; b_j <= i; b_j++) {
      if ((A[jy].re != 0.0) || (A[jy].im != 0.0)) {
        smax = -A[jy].re - A[jy].im * 0.0;
        s = A[jy].re * 0.0 - A[jy].im;
        ix = c;
        k = iy - j;
        for (ijA = iy + 6; ijA <= k + 8; ijA++) {
          br = A[ix + 1].re * s + A[ix + 1].im * smax;
          A[ijA - 1].re += A[ix + 1].re * smax - A[ix + 1].im * s;
          A[ijA - 1].im += br;
          ix++;
        }
      }

      jy += 4;
      iy += 4;
    }
  }

  if ((*info == 0) && ((!(A[15].re != 0.0)) && (!(A[15].im != 0.0)))) {
    *info = 4;
  }
}

static void c_xzlascl(real_T cfrom, real_T cto, real_T A[16])
{
  __m128d r;
  real_T cfrom1;
  real_T cfromc;
  real_T cto1;
  real_T ctoc;
  real_T mul;
  int32_T i;
  int32_T j;
  int32_T offset;
  boolean_T notdone;
  cfromc = cfrom;
  ctoc = cto;
  notdone = true;
  while (notdone) {
    cfrom1 = cfromc * 2.0041683600089728E-292;
    cto1 = ctoc / 4.9896007738368E+291;
    if ((muDoubleScalarAbs(cfrom1) > muDoubleScalarAbs(ctoc)) && (ctoc != 0.0))
    {
      mul = 2.0041683600089728E-292;
      cfromc = cfrom1;
    } else if (muDoubleScalarAbs(cto1) > muDoubleScalarAbs(cfromc)) {
      mul = 4.9896007738368E+291;
      ctoc = cto1;
    } else {
      mul = ctoc / cfromc;
      notdone = false;
    }

    for (j = 0; j < 4; j++) {
      offset = (j << 2) - 1;
      for (i = 0; i <= 2; i += 2) {
        r = _mm_loadu_pd(&A[(offset + i) + 1]);
        _mm_storeu_pd(&A[(offset + i) + 1], _mm_mul_pd(r, _mm_set1_pd(mul)));
      }
    }
  }
}

static void xscal(int32_T n, real_T a, real_T x[16], int32_T ix0)
{
  __m128d r;
  int32_T i;
  int32_T k;
  int32_T scalarLB;
  int32_T vectorUB;
  i = ix0 + n;
  scalarLB = (i - ix0) / 2 * 2 + ix0;
  vectorUB = scalarLB - 2;
  for (k = ix0; k <= vectorUB; k += 2) {
    r = _mm_loadu_pd(&x[k - 1]);
    _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(a), r));
  }

  for (k = scalarLB; k < i; k++) {
    x[k - 1] *= a;
  }
}

static void d_xzlarf(int32_T m, int32_T n, int32_T iv0, real_T tau, real_T C[16],
                     int32_T ic0, real_T work[4])
{
  real_T c;
  int32_T b_i;
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ix;
  int32_T jy;
  int32_T lastc;
  int32_T lastv;
  boolean_T exitg2;
  if (tau != 0.0) {
    lastv = m;
    i = (iv0 + m) - 2;
    while ((lastv > 0) && (C[i] == 0.0)) {
      lastv--;
      i--;
    }

    lastc = n;
    exitg2 = false;
    while ((!exitg2) && (lastc > 0)) {
      i = ic0 + ((lastc - 1) << 2);
      ia = i;
      do {
        exitg1 = 0;
        if (ia <= (i + lastv) - 1) {
          if (C[ia - 1] != 0.0) {
            exitg1 = 1;
          } else {
            ia++;
          }
        } else {
          lastc--;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }
  } else {
    lastv = 0;
    lastc = 0;
  }

  if (lastv > 0) {
    if (lastc != 0) {
      b_i = (uint8_T)lastc;
      for (i = 0; i < b_i; i++) {
        work[i] = 0.0;
      }

      i = 0;
      b_i = ic0 + ((lastc - 1) << 2);
      for (jy = ic0; jy <= b_i; jy += 4) {
        ix = iv0 - 1;
        c = 0.0;
        i1 = jy + lastv;
        for (ia = jy; ia < i1; ia++) {
          c += C[ia - 1] * C[ix];
          ix++;
        }

        work[i] += c;
        i++;
      }
    }

    if (!(-tau == 0.0)) {
      i = ic0;
      jy = 0;
      b_i = (uint8_T)lastc;
      for (lastc = 0; lastc < b_i; lastc++) {
        if (work[jy] != 0.0) {
          c = work[jy] * -tau;
          ix = iv0 - 1;
          i1 = lastv + i;
          for (ia = i; ia < i1; ia++) {
            C[ia - 1] += C[ix] * c;
            ix++;
          }
        }

        jy++;
        i += 4;
      }
    }
  }
}

static void d_xzlascl(real_T cfrom, real_T cto, real_T A[4])
{
  __m128d r;
  real_T cfrom1;
  real_T cfromc;
  real_T cto1;
  real_T ctoc;
  real_T mul;
  int32_T i;
  int32_T j;
  boolean_T notdone;
  cfromc = cfrom;
  ctoc = cto;
  notdone = true;
  while (notdone) {
    cfrom1 = cfromc * 2.0041683600089728E-292;
    cto1 = ctoc / 4.9896007738368E+291;
    if ((muDoubleScalarAbs(cfrom1) > muDoubleScalarAbs(ctoc)) && (ctoc != 0.0))
    {
      mul = 2.0041683600089728E-292;
      cfromc = cfrom1;
    } else if (muDoubleScalarAbs(cto1) > muDoubleScalarAbs(cfromc)) {
      mul = 4.9896007738368E+291;
      ctoc = cto1;
    } else {
      mul = ctoc / cfromc;
      notdone = false;
    }

    for (j = 0; j < 1; j++) {
      for (i = 0; i <= 2; i += 2) {
        r = _mm_loadu_pd(&A[i]);
        _mm_storeu_pd(&A[i], _mm_mul_pd(r, _mm_set1_pd(mul)));
      }
    }
  }
}

static void xswap(real_T x[16], int32_T ix0, int32_T iy0)
{
  real_T temp;
  int32_T ix;
  int32_T iy;
  int32_T k;
  ix = ix0 - 1;
  iy = iy0 - 1;
  for (k = 0; k < 4; k++) {
    temp = x[ix];
    x[ix] = x[iy];
    x[iy] = temp;
    ix++;
    iy++;
  }
}

static void e_xzlarf(int32_T n, int32_T iv0, real_T tau, real_T C[16], int32_T
                     ic0, real_T work[4])
{
  real_T temp;
  int32_T b_i;
  int32_T exitg1;
  int32_T i;
  int32_T i1;
  int32_T ia;
  int32_T ix;
  int32_T jy;
  int32_T lastc;
  int32_T lastv;
  boolean_T exitg2;
  if (tau != 0.0) {
    lastv = n;
    i = (iv0 + n) - 2;
    while ((lastv > 0) && (C[i] == 0.0)) {
      lastv--;
      i--;
    }

    lastc = 4;
    exitg2 = false;
    while ((!exitg2) && (lastc > 0)) {
      i = (ic0 + lastc) - 1;
      ia = i;
      do {
        exitg1 = 0;
        if (ia <= i + ((lastv - 1) << 2)) {
          if (C[ia - 1] != 0.0) {
            exitg1 = 1;
          } else {
            ia += 4;
          }
        } else {
          lastc--;
          exitg1 = 2;
        }
      } while (exitg1 == 0);

      if (exitg1 == 1) {
        exitg2 = true;
      }
    }
  } else {
    lastv = 0;
    lastc = 0;
  }

  if (lastv > 0) {
    if (lastc != 0) {
      for (i = 0; i < lastc; i++) {
        work[i] = 0.0;
      }

      ix = iv0 - 1;
      b_i = ic0 + ((lastv - 1) << 2);
      for (jy = ic0; jy <= b_i; jy += 4) {
        i = 0;
        i1 = jy + lastc;
        for (ia = jy; ia < i1; ia++) {
          work[i] += C[ia - 1] * C[ix];
          i++;
        }

        ix++;
      }
    }

    if (!(-tau == 0.0)) {
      i = ic0;
      jy = iv0 - 1;
      b_i = (uint8_T)lastv;
      for (ia = 0; ia < b_i; ia++) {
        if (C[jy] != 0.0) {
          temp = C[jy] * -tau;
          ix = 0;
          i1 = lastc + i;
          for (lastv = i; lastv < i1; lastv++) {
            C[lastv - 1] += work[ix] * temp;
            ix++;
          }
        }

        jy++;
        i += 4;
      }
    }
  }
}

static int32_T b_xhseqr(const emlrtStack *sp, real_T h[16], real_T z[16])
{
  __m128d r;
  emlrtStack b_st;
  emlrtStack c_st;
  emlrtStack st;
  real_T v[3];
  real_T bb;
  real_T cs;
  real_T h12;
  real_T h22;
  real_T rt1r;
  real_T rt2r;
  real_T s;
  real_T sn;
  real_T tr;
  real_T tst;
  int32_T b_k;
  int32_T c_k;
  int32_T i;
  int32_T ih;
  int32_T info;
  int32_T its;
  int32_T k;
  int32_T kdefl;
  int32_T l;
  int32_T m;
  int32_T nr;
  boolean_T converged;
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T exitg3;
  st.prev = sp;
  st.tls = sp->tls;
  st.site = &mq_emlrtRSI;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;
  b_st.site = &nq_emlrtRSI;
  info = 0;
  for (nr = 0; nr < 1; nr++) {
    h[2] = 0.0;
    h[3] = 0.0;
  }

  h[7] = 0.0;
  kdefl = 0;
  i = 3;
  exitg1 = false;
  while ((!exitg1) && (i + 1 >= 1)) {
    l = 1;
    converged = false;
    its = 0;
    exitg2 = false;
    while ((!exitg2) && (its < 301)) {
      k = i;
      exitg3 = false;
      while ((!exitg3) && ((k + 1 > l) && (!(muDoubleScalarAbs(h[k + ((k - 1) <<
                  2)]) <= 4.0083367200179456E-292)))) {
        tst = muDoubleScalarAbs(h[(k + ((k - 1) << 2)) - 1]) + muDoubleScalarAbs
          (h[k + (k << 2)]);
        if (tst == 0.0) {
          if (k - 1 >= 1) {
            tst = muDoubleScalarAbs(h[(k + ((k - 2) << 2)) - 1]);
          }

          if (k + 2 <= 4) {
            tst += muDoubleScalarAbs(h[(k + (k << 2)) + 1]);
          }
        }

        if (muDoubleScalarAbs(h[k + ((k - 1) << 2)]) <= 2.2204460492503131E-16 *
            tst) {
          tst = muDoubleScalarMax(muDoubleScalarAbs(h[k + (k << 2)]),
            muDoubleScalarAbs(h[(k + ((k - 1) << 2)) - 1] - h[k + (k << 2)]));
          bb = muDoubleScalarMin(muDoubleScalarAbs(h[k + (k << 2)]),
            muDoubleScalarAbs(h[(k + ((k - 1) << 2)) - 1] - h[k + (k << 2)]));
          s = tst + bb;
          if (muDoubleScalarMin(muDoubleScalarAbs(h[k + ((k - 1) << 2)]),
                                muDoubleScalarAbs(h[(k + (k << 2)) - 1])) *
              (muDoubleScalarMax(muDoubleScalarAbs(h[k + ((k - 1) << 2)]),
                                 muDoubleScalarAbs(h[(k + (k << 2)) - 1])) / s) <=
              muDoubleScalarMax(4.0083367200179456E-292, 2.2204460492503131E-16 *
                                (bb * (tst / s)))) {
            exitg3 = true;
          } else {
            k--;
          }
        } else {
          k--;
        }
      }

      l = k + 1;
      if (k + 1 > 1) {
        h[k + ((k - 1) << 2)] = 0.0;
      }

      if (k + 1 >= i) {
        converged = true;
        exitg2 = true;
      } else {
        kdefl++;
        if (kdefl - div_nzp_s32(kdefl, 20) * 20 == 0) {
          s = muDoubleScalarAbs(h[i + ((i - 1) << 2)]) + muDoubleScalarAbs(h[(i
            + ((i - 2) << 2)) - 1]);
          tst = 0.75 * s + h[i + (i << 2)];
          h12 = -0.4375 * s;
          bb = s;
          h22 = tst;
        } else if (kdefl - div_nzp_s32(kdefl, 10) * 10 == 0) {
          s = muDoubleScalarAbs(h[(k + (k << 2)) + 1]) + muDoubleScalarAbs(h[(k
            + ((k + 1) << 2)) + 2]);
          tst = 0.75 * s + h[k + (k << 2)];
          h12 = -0.4375 * s;
          bb = s;
          h22 = tst;
        } else {
          tst = h[(i + ((i - 1) << 2)) - 1];
          bb = h[i + ((i - 1) << 2)];
          h12 = h[(i + (i << 2)) - 1];
          h22 = h[i + (i << 2)];
        }

        s = ((muDoubleScalarAbs(tst) + muDoubleScalarAbs(h12)) +
             muDoubleScalarAbs(bb)) + muDoubleScalarAbs(h22);
        if (s == 0.0) {
          rt1r = 0.0;
          tst = 0.0;
          rt2r = 0.0;
          bb = 0.0;
        } else {
          tst /= s;
          bb /= s;
          h12 /= s;
          h22 /= s;
          tr = (tst + h22) / 2.0;
          tst = (tst - tr) * (h22 - tr) - h12 * bb;
          bb = muDoubleScalarAbs(tst);
          c_st.site = &ej_emlrtRSI;
          d_sqrt(&c_st, &bb);
          if (tst >= 0.0) {
            rt1r = tr * s;
            rt2r = rt1r;
            tst = bb * s;
            bb = -tst;
          } else {
            rt1r = tr + bb;
            rt2r = tr - bb;
            if (muDoubleScalarAbs(rt1r - h22) <= muDoubleScalarAbs(rt2r - h22))
            {
              rt1r *= s;
              rt2r = rt1r;
            } else {
              rt2r *= s;
              rt1r = rt2r;
            }

            tst = 0.0;
            bb = 0.0;
          }
        }

        m = i - 2;
        exitg3 = false;
        while ((!exitg3) && (m + 1 >= k + 1)) {
          s = (muDoubleScalarAbs(h[m + (m << 2)] - rt2r) + muDoubleScalarAbs(bb))
            + muDoubleScalarAbs(h[(m + (m << 2)) + 1]);
          h12 = h[(m + (m << 2)) + 1] / s;
          v[0] = (h12 * h[m + ((m + 1) << 2)] + (h[m + (m << 2)] - rt1r) * ((h[m
                    + (m << 2)] - rt2r) / s)) - tst * (bb / s);
          v[1] = h12 * (((h[m + (m << 2)] + h[(m + ((m + 1) << 2)) + 1]) - rt1r)
                        - rt2r);
          v[2] = h12 * h[(m + ((m + 1) << 2)) + 2];
          s = (muDoubleScalarAbs(v[0]) + muDoubleScalarAbs(v[1])) +
            muDoubleScalarAbs(v[2]);
          for (b_k = 0; b_k <= 0; b_k += 2) {
            r = _mm_loadu_pd(&v[0]);
            _mm_storeu_pd(&v[0], _mm_div_pd(r, _mm_set1_pd(s)));
          }

          for (b_k = 2; b_k < 3; b_k++) {
            v[2] /= s;
          }

          if ((m + 1 == k + 1) || (muDoubleScalarAbs(h[m]) * (muDoubleScalarAbs
                (v[1]) + muDoubleScalarAbs(v[2])) <= 2.2204460492503131E-16 *
               muDoubleScalarAbs(v[0]) * ((muDoubleScalarAbs(h[0]) +
                 muDoubleScalarAbs(h[m + (m << 2)])) + muDoubleScalarAbs(h[(m +
                  ((m + 1) << 2)) + 1])))) {
            exitg3 = true;
          } else {
            m--;
          }
        }

        for (c_k = m + 1; c_k <= i; c_k++) {
          ih = (i - c_k) + 2;
          nr = muIntScalarMin_sint32(3, ih);
          if (c_k > m + 1) {
            ih = (((c_k - 2) << 2) + c_k) - 2;
            for (b_k = 0; b_k < nr; b_k++) {
              v[b_k] = h[(ih + b_k) + 1];
            }
          }

          tst = v[0];
          rt1r = xzlarfg(nr, &tst, v);
          if (c_k > m + 1) {
            h[(c_k + ((c_k - 2) << 2)) - 1] = tst;
            h[c_k + ((c_k - 2) << 2)] = 0.0;
            if (c_k < i) {
              h[c_k + 1] = 0.0;
            }
          } else if (m + 1 > k + 1) {
            h[c_k - 1] *= 1.0 - rt1r;
          }

          tst = v[1];
          bb = rt1r * v[1];
          if (nr == 3) {
            rt2r = v[2];
            tr = rt1r * v[2];
            for (nr = c_k; nr < 5; nr++) {
              h12 = (h[(c_k + ((nr - 1) << 2)) - 1] + tst * h[c_k + ((nr - 1) <<
                      2)]) + rt2r * h[(c_k + ((nr - 1) << 2)) + 1];
              h[(c_k + ((nr - 1) << 2)) - 1] -= h12 * rt1r;
              h[c_k + ((nr - 1) << 2)] -= h12 * bb;
              h[(c_k + ((nr - 1) << 2)) + 1] -= h12 * tr;
            }

            ih = c_k + 3;
            nr = i + 1;
            b_k = muIntScalarMin_sint32(ih, nr);
            for (nr = 0; nr < b_k; nr++) {
              h12 = (h[nr + ((c_k - 1) << 2)] + tst * h[nr + (c_k << 2)]) + rt2r
                * h[nr + ((c_k + 1) << 2)];
              h[nr + ((c_k - 1) << 2)] -= h12 * rt1r;
              h[nr + (c_k << 2)] -= h12 * bb;
              h[nr + ((c_k + 1) << 2)] -= h12 * tr;
            }

            for (nr = 0; nr < 4; nr++) {
              h12 = (z[nr + ((c_k - 1) << 2)] + tst * z[nr + (c_k << 2)]) + rt2r
                * z[nr + ((c_k + 1) << 2)];
              z[nr + ((c_k - 1) << 2)] -= h12 * rt1r;
              z[nr + (c_k << 2)] -= h12 * bb;
              z[nr + ((c_k + 1) << 2)] -= h12 * tr;
            }
          } else if (nr == 2) {
            for (nr = c_k; nr < 5; nr++) {
              h12 = h[(c_k + ((nr - 1) << 2)) - 1] + tst * h[c_k + ((nr - 1) <<
                2)];
              h[(c_k + ((nr - 1) << 2)) - 1] -= h12 * rt1r;
              h[c_k + ((nr - 1) << 2)] -= h12 * bb;
            }

            for (nr = 0; nr <= i; nr++) {
              h12 = h[nr + ((c_k - 1) << 2)] + tst * h[nr + (c_k << 2)];
              h[nr + ((c_k - 1) << 2)] -= h12 * rt1r;
              h[nr + (c_k << 2)] -= h12 * bb;
            }

            for (nr = 0; nr < 4; nr++) {
              h12 = z[nr + ((c_k - 1) << 2)] + tst * z[nr + (c_k << 2)];
              z[nr + ((c_k - 1) << 2)] -= h12 * rt1r;
              z[nr + (c_k << 2)] -= h12 * bb;
            }
          }
        }

        its++;
      }
    }

    if (!converged) {
      info = i + 1;
      exitg1 = true;
    } else {
      if ((l != i + 1) && (l == i)) {
        tst = h[(i + ((i - 1) << 2)) - 1];
        bb = h[(i + (i << 2)) - 1];
        h12 = h[i + ((i - 1) << 2)];
        rt2r = h[i + (i << 2)];
        c_st.site = &dj_emlrtRSI;
        xdlanv2(&c_st, &tst, &bb, &h12, &rt2r, &tr, &rt1r, &h22, &s, &cs, &sn);
        h[(i + ((i - 1) << 2)) - 1] = tst;
        h[(i + (i << 2)) - 1] = bb;
        h[i + ((i - 1) << 2)] = h12;
        h[i + (i << 2)] = rt2r;
        if (i + 1 < 4) {
          nr = (((i + 1) << 2) + i) - 1;
          ih = ((i + 1) << 2) + i;
          b_k = 2 - i;
          for (k = 0; k <= b_k; k++) {
            tst = cs * h[nr] + sn * h[ih];
            h[ih] = cs * h[ih] - sn * h[nr];
            h[nr] = tst;
            ih += 4;
            nr += 4;
          }
        }

        if (i - 1 >= 1) {
          nr = (i - 1) << 2;
          ih = i << 2;
          b_k = (uint8_T)(i - 1);
          for (k = 0; k < b_k; k++) {
            tst = cs * h[nr] + sn * h[ih];
            h[ih] = cs * h[ih] - sn * h[nr];
            h[nr] = tst;
            ih++;
            nr++;
          }
        }

        nr = (i - 1) << 2;
        ih = i << 2;
        for (k = 0; k < 4; k++) {
          tst = cs * z[nr] + sn * z[ih];
          z[ih] = cs * z[ih] - sn * z[nr];
          z[nr] = tst;
          ih++;
          nr++;
        }
      }

      kdefl = 0;
      i = l - 2;
    }
  }

  for (nr = 0; nr < 2; nr++) {
    for (i = nr + 3; i < 5; i++) {
      h[(i + (nr << 2)) - 1] = 0.0;
    }
  }

  return info;
}

static void b_xscal(real_T a, real_T x[16], int32_T ix0)
{
  __m128d r;
  int32_T k;
  int32_T scalarLB;
  int32_T vectorUB;
  scalarLB = ix0 + 4;
  vectorUB = scalarLB - 2;
  for (k = ix0; k <= vectorUB; k += 2) {
    r = _mm_loadu_pd(&x[k - 1]);
    _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(a), r));
  }

  for (k = scalarLB; k <= ix0 + 3; k++) {
    x[k - 1] *= a;
  }
}

static void d_xrot(real_T x[16], int32_T ix0, int32_T iy0, real_T c, real_T s)
{
  real_T temp;
  int32_T ix;
  int32_T iy;
  int32_T k;
  ix = ix0 - 1;
  iy = iy0 - 1;
  for (k = 0; k < 4; k++) {
    temp = c * x[ix] + s * x[iy];
    x[iy] = c * x[iy] - s * x[ix];
    x[ix] = temp;
    iy++;
    ix++;
  }
}

static void xaxpy(int32_T n, real_T a, int32_T ix0, real_T y[16], int32_T iy0)
{
  int32_T ix;
  int32_T iy;
  int32_T k;
  if (!(a == 0.0)) {
    ix = ix0;
    iy = iy0 - 1;
    for (k = 0; k < n; k++) {
      y[iy] += a * y[ix - 1];
      ix++;
      iy++;
    }
  }
}

static void c_xscal(int32_T n, real_T a, real_T x[4], int32_T ix0)
{
  __m128d r;
  int32_T i;
  int32_T k;
  int32_T scalarLB;
  int32_T vectorUB;
  i = ix0 + n;
  scalarLB = (i - ix0) / 2 * 2 + ix0;
  vectorUB = scalarLB - 2;
  for (k = ix0; k <= vectorUB; k += 2) {
    r = _mm_loadu_pd(&x[k - 1]);
    _mm_storeu_pd(&x[k - 1], _mm_mul_pd(_mm_set1_pd(a), r));
  }

  for (k = scalarLB; k < i; k++) {
    x[k - 1] *= a;
  }
}

static void b_xaxpy(int32_T n, real_T a, real_T x[16], int32_T ix0, real_T y[4],
                    int32_T iy0)
{
  int32_T ix;
  int32_T iy;
  int32_T k;
  if (!(a == 0.0)) {
    ix = ix0;
    iy = iy0 - 1;
    for (k = 0; k < n; k++) {
      y[iy] += a * x[ix - 1];
      ix++;
      iy++;
    }
  }
}

static void c_xaxpy(int32_T n, real_T a, real_T x[4], int32_T ix0, real_T y[16],
                    int32_T iy0)
{
  int32_T ix;
  int32_T iy;
  int32_T k;
  if (!(a == 0.0)) {
    ix = ix0;
    iy = iy0 - 1;
    for (k = 0; k < n; k++) {
      y[iy] += a * x[ix - 1];
      ix++;
      iy++;
    }
  }
}

static void skipNaNs(const emlrtStack *sp, int32_T *k, coder_array_real_T *xv,
                     coder_array_real_T *yv, int32_T nx)
{
  static const int32_T iv[2] = { 1, 31 };

  static const int32_T iv1[2] = { 1, 31 };

  static char_T b_u[31] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'L',
    'o', 'o', 'p', 'D', 'e', 'f' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[31];
  boolean_T exitg1;
  boolean_T isnanxv;
  st.prev = sp;
  st.tls = sp->tls;
  exitg1 = false;
  while ((!exitg1) && (*k <= nx)) {
    isnanxv = muDoubleScalarIsNaN(xv->vector.data[*k - 1]);
    if ((int32_T)isnanxv != (int32_T)muDoubleScalarIsNaN(yv->vector.data[*k - 1]))
    {
      for (i = 0; i < 31; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 31, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 31; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 31, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &cw_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &kc_emlrtMCI),
             &kc_emlrtMCI), &kc_emlrtMCI);
    }

    if (!isnanxv) {
      exitg1 = true;
    } else {
      (*k)++;
    }
  }
}

static void b_merge_block(int32_T idx_data[], int32_T idx_size[2], real_T
  x_data[], int32_T x_size[2], int32_T offset, int32_T n, int32_T preSortLevel,
  int32_T iwork_data[], real_T xwork_data[], int32_T b_idx_data[], int32_T
  b_idx_size[2], real_T b_x_data[], int32_T b_x_size[2])
{
  real_T c_x_data[500];
  int32_T c_idx_data[500];
  int32_T c_idx_size[2];
  int32_T c_x_size[2];
  int32_T bLen;
  int32_T nPairs;
  int32_T nTail;
  int32_T tailOffset;
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  if (x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)x_size[1] * sizeof(real_T));
  }

  b_idx_size[0] = 1;
  b_idx_size[1] = idx_size[1];
  if (idx_size[1] - 1 >= 0) {
    memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof(int32_T));
  }

  nPairs = n >> preSortLevel;
  bLen = 1 << preSortLevel;
  while (nPairs > 1) {
    if (((uint32_T)nPairs & 1U) != 0U) {
      nPairs--;
      tailOffset = bLen * nPairs;
      nTail = n - tailOffset;
      if (nTail > bLen) {
        c_merge(b_idx_data, b_idx_size, b_x_data, b_x_size, offset + tailOffset,
                bLen, nTail - bLen, iwork_data, xwork_data, c_idx_data,
                c_idx_size, c_x_data, c_x_size);
        b_idx_size[0] = 1;
        b_idx_size[1] = c_idx_size[1];
        if (c_idx_size[1] - 1 >= 0) {
          memcpy(&b_idx_data[0], &c_idx_data[0], (uint32_T)c_idx_size[1] *
                 sizeof(int32_T));
        }

        b_x_size[0] = 1;
        b_x_size[1] = c_x_size[1];
        if (c_x_size[1] - 1 >= 0) {
          memcpy(&b_x_data[0], &c_x_data[0], (uint32_T)c_x_size[1] * sizeof
                 (real_T));
        }
      }
    }

    tailOffset = bLen << 1;
    nPairs >>= 1;
    for (nTail = 0; nTail < nPairs; nTail++) {
      c_merge(b_idx_data, b_idx_size, b_x_data, b_x_size, offset + nTail *
              tailOffset, bLen, bLen, iwork_data, xwork_data, c_idx_data,
              c_idx_size, c_x_data, c_x_size);
      b_idx_size[0] = 1;
      b_idx_size[1] = c_idx_size[1];
      if (c_idx_size[1] - 1 >= 0) {
        memcpy(&b_idx_data[0], &c_idx_data[0], (uint32_T)c_idx_size[1] * sizeof
               (int32_T));
      }

      b_x_size[0] = 1;
      b_x_size[1] = c_x_size[1];
      if (c_x_size[1] - 1 >= 0) {
        memcpy(&b_x_data[0], &c_x_data[0], (uint32_T)c_x_size[1] * sizeof(real_T));
      }
    }

    bLen = tailOffset;
  }

  if (n > bLen) {
    c_merge(b_idx_data, b_idx_size, b_x_data, b_x_size, offset, bLen, n - bLen,
            iwork_data, xwork_data, c_idx_data, c_idx_size, c_x_data, c_x_size);
    b_idx_size[0] = 1;
    b_idx_size[1] = c_idx_size[1];
    if (c_idx_size[1] - 1 >= 0) {
      memcpy(&b_idx_data[0], &c_idx_data[0], (uint32_T)c_idx_size[1] * sizeof
             (int32_T));
    }

    b_x_size[0] = 1;
    b_x_size[1] = c_x_size[1];
    if (c_x_size[1] - 1 >= 0) {
      memcpy(&b_x_data[0], &c_x_data[0], (uint32_T)c_x_size[1] * sizeof(real_T));
    }
  }
}

static void c_merge(int32_T idx_data[], int32_T idx_size[2], real_T x_data[],
                    int32_T x_size[2], int32_T offset, int32_T np, int32_T nq,
                    int32_T iwork_data[], real_T xwork_data[], int32_T
                    b_idx_data[], int32_T b_idx_size[2], real_T b_x_data[],
                    int32_T b_x_size[2])
{
  int32_T exitg1;
  int32_T iout;
  int32_T n;
  int32_T p;
  int32_T qend;
  b_x_size[0] = 1;
  b_x_size[1] = x_size[1];
  if (x_size[1] - 1 >= 0) {
    memcpy(&b_x_data[0], &x_data[0], (uint32_T)x_size[1] * sizeof(real_T));
  }

  b_idx_size[0] = 1;
  b_idx_size[1] = idx_size[1];
  if (idx_size[1] - 1 >= 0) {
    memcpy(&b_idx_data[0], &idx_data[0], (uint32_T)idx_size[1] * sizeof(int32_T));
  }

  if (nq != 0) {
    n = np + nq;
    for (qend = 0; qend < n; qend++) {
      iwork_data[qend] = b_idx_data[offset + qend];
      xwork_data[qend] = b_x_data[offset + qend];
    }

    p = 0;
    n = np;
    qend = np + nq;
    iout = offset - 1;
    do {
      exitg1 = 0;
      iout++;
      if (xwork_data[p] <= xwork_data[n]) {
        b_idx_data[iout] = iwork_data[p];
        b_x_data[iout] = xwork_data[p];
        if (p + 1 < np) {
          p++;
        } else {
          exitg1 = 1;
        }
      } else {
        b_idx_data[iout] = iwork_data[n];
        b_x_data[iout] = xwork_data[n];
        if (n + 1 < qend) {
          n++;
        } else {
          n = iout - p;
          for (qend = p + 1; qend <= np; qend++) {
            b_idx_data[n + qend] = iwork_data[qend - 1];
            b_x_data[n + qend] = xwork_data[qend - 1];
          }

          exitg1 = 1;
        }
      }
    } while (exitg1 == 0);
  }
}

static void b_skipNaNs(const emlrtStack *sp, int32_T *k, real_T xv_data[],
  real_T yv_data[], int32_T nx)
{
  static const int32_T iv[2] = { 1, 31 };

  static const int32_T iv1[2] = { 1, 31 };

  static char_T b_u[31] = { 'M', 'A', 'T', 'L', 'A', 'B', ':', 'i', 'n', 'p',
    'o', 'l', 'y', 'g', 'o', 'n', ':', 'I', 'n', 'v', 'a', 'l', 'i', 'd', 'L',
    'o', 'o', 'p', 'D', 'e', 'f' };

  emlrtStack st;
  const mxArray *b_y;
  const mxArray *m;
  const mxArray *y;
  int32_T i;
  char_T u[31];
  boolean_T exitg1;
  boolean_T isnanxv;
  st.prev = sp;
  st.tls = sp->tls;
  exitg1 = false;
  while ((!exitg1) && (*k <= nx)) {
    isnanxv = muDoubleScalarIsNaN(xv_data[*k - 1]);
    if ((int32_T)isnanxv != (int32_T)muDoubleScalarIsNaN(yv_data[*k - 1])) {
      for (i = 0; i < 31; i++) {
        u[i] = b_u[i];
      }

      y = NULL;
      m = emlrtCreateCharArray(2, &iv[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 31, m, &u[0]);
      emlrtAssign(&y, m);
      for (i = 0; i < 31; i++) {
        u[i] = b_u[i];
      }

      b_y = NULL;
      m = emlrtCreateCharArray(2, &iv1[0]);
      emlrtInitCharArrayR2013a((emlrtConstCTX)sp, 31, m, &u[0]);
      emlrtAssign(&b_y, m);
      st.site = &cw_emlrtRSI;
      error(&st, y, getString(&st, b_message(&st, b_y, &kc_emlrtMCI),
             &kc_emlrtMCI), &kc_emlrtMCI);
    }

    if (!isnanxv) {
      exitg1 = true;
    } else {
      (*k)++;
    }
  }
}

static void d_exp(creal_T *x)
{
  real_T r;
  if (x->re == 0.0) {
    x->re = muDoubleScalarCos(x->im);
    x->im = muDoubleScalarSin(x->im);
  } else if (x->im == 0.0) {
    x->re = muDoubleScalarExp(x->re);
    x->im = 0.0;
  } else if (muDoubleScalarIsInf(x->im) && muDoubleScalarIsInf(x->re) && (x->re <
              0.0)) {
    x->re = 0.0;
    x->im = 0.0;
  } else {
    r = muDoubleScalarExp(x->re / 2.0);
    x->re = r * (r * muDoubleScalarCos(x->im));
    x->im = r * (r * muDoubleScalarSin(x->im));
  }
}

static void findA(const emlrtStack *sp, real_T *a, real_T c, real_T d)
{
  emlrtStack b_st;
  emlrtStack st;
  creal_T a1;
  creal_T dc;
  creal_T dc1;
  creal_T drsfa;
  creal_T fa2;
  creal_T r;
  creal_T rsfa;
  creal_T s;
  real_T a2_im;
  real_T a2_re;
  real_T aneg;
  real_T aold;
  real_T apos;
  real_T b_a;
  real_T b_d;
  real_T bim;
  real_T brm;
  real_T da2_im;
  real_T da2_re;
  real_T drsfa_im;
  real_T eneg;
  real_T epos;
  real_T fa_im;
  real_T fa_re;
  real_T im;
  real_T re;
  real_T rs_im;
  real_T rs_re;
  int32_T iter;
  boolean_T exitg1;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  apos = rtNaN;
  aneg = rtNaN;
  epos = rtInf;
  eneg = rtMinusInf;
  aold = 0.0;
  iter = 0;
  exitg1 = false;
  while ((!exitg1) && (muDoubleScalarAbs((*a - aold) / *a) >
                       2.2204460492503131E-15)) {
    b_a = d - *a;
    if (muDoubleScalarAbs(b_a * b_a / (4.0 * *a)) < 62.831853071795862) {
      a1.re = 2.0 * *a / 3.1415926535897931;
      a1.im = 0.0;
      e_sqrt(&a1);
      dc.re = 6.2831853071795862 * *a;
      dc.im = 0.0;
      e_sqrt(&dc);
      aold = d - *a;
      if (dc.im == 0.0) {
        a2_re = aold / dc.re;
        a2_im = 0.0;
      } else if (dc.re == 0.0) {
        if (aold == 0.0) {
          a2_re = 0.0 / dc.im;
          a2_im = 0.0;
        } else {
          a2_re = 0.0;
          a2_im = -(aold / dc.im);
        }
      } else {
        brm = muDoubleScalarAbs(dc.re);
        bim = muDoubleScalarAbs(dc.im);
        if (brm > bim) {
          bim = dc.im / dc.re;
          b_d = dc.re + bim * dc.im;
          a2_re = (aold + bim * 0.0) / b_d;
          a2_im = (0.0 - bim * aold) / b_d;
        } else if (bim == brm) {
          if (dc.re > 0.0) {
            bim = 0.5;
          } else {
            bim = -0.5;
          }

          if (dc.im > 0.0) {
            b_d = 0.5;
          } else {
            b_d = -0.5;
          }

          a2_re = (aold * bim + 0.0 * b_d) / brm;
          a2_im = (0.0 * bim - aold * b_d) / brm;
        } else {
          bim = dc.re / dc.im;
          b_d = dc.im + bim * dc.re;
          a2_re = bim * aold / b_d;
          a2_im = (bim * 0.0 - aold) / b_d;
        }
      }

      st.site = &yt_emlrtRSI;
      b_st.site = &cu_emlrtRSI;
      dc = fresnelr(&b_st, a1.re + a2_re);
      b_st.site = &cu_emlrtRSI;
      dc1 = fresnelr(&b_st, -(a1.im + a2_im));
      st.site = &au_emlrtRSI;
      b_st.site = &cu_emlrtRSI;
      fa2 = fresnelr(&b_st, a2_re);
      b_st.site = &cu_emlrtRSI;
      rsfa = fresnelr(&b_st, -a2_im);
      fa_re = (dc.re + (0.0 * dc1.re - (-dc1.im))) - (fa2.re + (0.0 * rsfa.re -
        (-rsfa.im)));
      fa_im = (dc.im + (0.0 * -dc1.im + dc1.re)) - (fa2.im + (0.0 * -rsfa.im +
        rsfa.re));
      s.re = 3.1415926535897931 / (2.0 * *a);
      s.im = 0.0;
      e_sqrt(&s);
      b_a = d - *a;
      r.re = (c - b_a * b_a / (4.0 * *a)) * 0.0;
      r.im = c - b_a * b_a / (4.0 * *a);
      d_exp(&r);
      rs_re = s.re * r.re - s.im * r.im;
      rs_im = s.re * r.im + s.im * r.re;
      rsfa.im = rs_re * fa_im + rs_im * fa_re;
      dc.re = 6.2831853071795862 * *a;
      dc.im = 0.0;
      e_sqrt(&dc);
      dc1.re = 6.2831853071795862 * *a;
      dc1.im = 0.0;
      e_sqrt(&dc1);
      dc = e_power(dc);
      if (dc.im == 0.0) {
        re = -3.1415926535897931 / dc.re;
        im = 0.0;
      } else if (dc.re == 0.0) {
        re = 0.0;
        im = -(-3.1415926535897931 / dc.im);
      } else {
        brm = muDoubleScalarAbs(dc.re);
        bim = muDoubleScalarAbs(dc.im);
        if (brm > bim) {
          bim = dc.im / dc.re;
          b_d = dc.re + bim * dc.im;
          re = (bim * 0.0 - 3.1415926535897931) / b_d;
          im = (0.0 - bim * -3.1415926535897931) / b_d;
        } else if (bim == brm) {
          if (dc.re > 0.0) {
            bim = 0.5;
          } else {
            bim = -0.5;
          }

          if (dc.im > 0.0) {
            b_d = 0.5;
          } else {
            b_d = -0.5;
          }

          re = (-3.1415926535897931 * bim + 0.0 * b_d) / brm;
          im = (0.0 * bim - -3.1415926535897931 * b_d) / brm;
        } else {
          bim = dc.re / dc.im;
          b_d = dc.im + bim * dc.re;
          re = bim * -3.1415926535897931 / b_d;
          im = (bim * 0.0 - -3.1415926535897931) / b_d;
        }
      }

      if (dc1.im == 0.0) {
        da2_im = 1.0 / dc1.re;
        b_d = 0.0;
      } else if (dc1.re == 0.0) {
        da2_im = 0.0;
        b_d = -(1.0 / dc1.im);
      } else {
        brm = muDoubleScalarAbs(dc1.re);
        bim = muDoubleScalarAbs(dc1.im);
        if (brm > bim) {
          bim = dc1.im / dc1.re;
          b_d = dc1.re + bim * dc1.im;
          da2_im = (bim * 0.0 + 1.0) / b_d;
          b_d = (0.0 - bim) / b_d;
        } else if (bim == brm) {
          if (dc1.re > 0.0) {
            bim = 0.5;
          } else {
            bim = -0.5;
          }

          if (dc1.im > 0.0) {
            b_d = 0.5;
          } else {
            b_d = -0.5;
          }

          da2_im = (bim + 0.0 * b_d) / brm;
          b_d = (0.0 * bim - b_d) / brm;
        } else {
          bim = dc1.re / dc1.im;
          b_d = dc1.im + bim * dc1.re;
          da2_im = bim / b_d;
          b_d = (bim * 0.0 - 1.0) / b_d;
        }
      }

      da2_re = (d - *a) * re - da2_im;
      da2_im = (d - *a) * im - b_d;
      drsfa.re = a1.re + a2_re;
      drsfa.im = a1.im + a2_im;
      b_a = d - *a;
      brm = drsfa.re * drsfa.re - drsfa.im * drsfa.im;
      drsfa_im = drsfa.re * drsfa.im + drsfa.im * drsfa.re;
      dc.re = 0.0 * brm - 1.5707963267948966 * drsfa_im;
      dc.im = 0.0 * drsfa_im + 1.5707963267948966 * brm;
      d_exp(&dc);
      dc1.re = 6.2831853071795862 * *a;
      dc1.im = 0.0;
      e_sqrt(&dc1);
      aold = a2_re * a2_re - a2_im * a2_im;
      a2_im = a2_re * a2_im + a2_im * a2_re;
      drsfa.re = 0.0 * aold - 1.5707963267948966 * a2_im;
      drsfa.im = 0.0 * a2_im + 1.5707963267948966 * aold;
      d_exp(&drsfa);
      fa2.re = 3.1415926535897931 / (2.0 * *a);
      fa2.im = 0.0;
      e_sqrt(&fa2);
      if (dc1.im == 0.0) {
        re = 1.0 / dc1.re;
        im = 0.0;
      } else if (dc1.re == 0.0) {
        re = 0.0;
        im = -(1.0 / dc1.im);
      } else {
        brm = muDoubleScalarAbs(dc1.re);
        bim = muDoubleScalarAbs(dc1.im);
        if (brm > bim) {
          bim = dc1.im / dc1.re;
          b_d = dc1.re + bim * dc1.im;
          re = (bim * 0.0 + 1.0) / b_d;
          im = (0.0 - bim) / b_d;
        } else if (bim == brm) {
          if (dc1.re > 0.0) {
            bim = 0.5;
          } else {
            bim = -0.5;
          }

          if (dc1.im > 0.0) {
            b_d = 0.5;
          } else {
            b_d = -0.5;
          }

          re = (bim + 0.0 * b_d) / brm;
          im = (0.0 * bim - b_d) / brm;
        } else {
          bim = dc1.re / dc1.im;
          b_d = dc1.im + bim * dc1.re;
          re = bim / b_d;
          im = (bim * 0.0 - 1.0) / b_d;
        }
      }

      re += da2_re;
      im += da2_im;
      brm = drsfa.re * da2_re - drsfa.im * da2_im;
      drsfa_im = drsfa.re * da2_im + drsfa.im * da2_re;
      da2_im = (b_a * b_a * -muDoubleScalarPower(4.0 * *a, -2.0) * 4.0 - 1.0 /
                (4.0 * *a) * 2.0 * (d - *a)) * 0.0;
      b_d = -(b_a * b_a * -muDoubleScalarPower(4.0 * *a, -2.0) * 4.0 - 1.0 /
              (4.0 * *a) * 2.0 * (d - *a));
      aold = r.re * da2_im - r.im * b_d;
      bim = r.re * b_d + r.im * da2_im;
      dc1 = e_power(fa2);
      if (-dc1.im == 0.0) {
        da2_im = -dc1.re / 3.1415926535897931;
        b_d = 0.0;
      } else if (-dc1.re == 0.0) {
        da2_im = 0.0;
        b_d = -dc1.im / 3.1415926535897931;
      } else {
        da2_im = -dc1.re / 3.1415926535897931;
        b_d = -dc1.im / 3.1415926535897931;
      }

      drsfa.im = (rs_re * (muDoubleScalarSign(*a) * ((dc.re * im + dc.im * re) -
        drsfa_im)) + rs_im * (muDoubleScalarSign(*a) * ((dc.re * re - dc.im * im)
        - brm))) + (fa_re * ((s.re * bim + s.im * aold) + (r.re * b_d + r.im *
        da2_im)) + fa_im * ((s.re * aold - s.im * bim) + (r.re * da2_im - r.im *
        b_d)));
    } else {
      st.site = &bu_emlrtRSI;
      rsfa = fresnelg(&st, 2.0 * *a, d - *a, c);
      drsfa = dfresnelgsma1(2.0 * *a, d, c);
    }

    if (rsfa.im == 0.0) {
      exitg1 = true;
    } else {
      if ((rsfa.im > 0.0) && (epos > rsfa.im)) {
        epos = rsfa.im;
        apos = *a;
        aold = *a;
        *a -= rsfa.im / drsfa.im;
      } else if ((rsfa.im < 0.0) && (eneg < rsfa.im)) {
        eneg = rsfa.im;
        aneg = *a;
        aold = *a;
        *a -= rsfa.im / drsfa.im;
      } else if (muDoubleScalarIsNaN(apos)) {
        aold = aneg;
        *a = 2.0 * *a - aneg;
      } else if (muDoubleScalarIsNaN(aneg)) {
        aold = apos;
        *a = 2.0 * *a - apos;
      } else {
        aold = *a;
        *a = (apos + aneg) / 2.0;
      }

      iter++;
      if (iter > 50) {
        exitg1 = true;
      }
    }
  }
}

static void e_sqrt(creal_T *x)
{
  real_T absxi;
  real_T absxr;
  real_T xi;
  real_T xr;
  xr = x->re;
  xi = x->im;
  if (xi == 0.0) {
    if (xr < 0.0) {
      absxr = 0.0;
      absxi = muDoubleScalarSqrt(-xr);
    } else {
      absxr = muDoubleScalarSqrt(xr);
      absxi = 0.0;
    }
  } else if (xr == 0.0) {
    if (xi < 0.0) {
      absxr = muDoubleScalarSqrt(-xi / 2.0);
      absxi = -absxr;
    } else {
      absxr = muDoubleScalarSqrt(xi / 2.0);
      absxi = absxr;
    }
  } else if (muDoubleScalarIsNaN(xr)) {
    absxr = rtNaN;
    absxi = rtNaN;
  } else if (muDoubleScalarIsNaN(xi)) {
    absxr = rtNaN;
    absxi = rtNaN;
  } else if (muDoubleScalarIsInf(xi)) {
    absxr = muDoubleScalarAbs(xi);
    absxi = xi;
  } else if (muDoubleScalarIsInf(xr)) {
    if (xr < 0.0) {
      absxr = 0.0;
      absxi = xi * -xr;
    } else {
      absxr = xr;
      absxi = 0.0;
    }
  } else {
    absxr = muDoubleScalarAbs(xr);
    absxi = muDoubleScalarAbs(xi);
    if ((absxr > 4.4942328371557893E+307) || (absxi > 4.4942328371557893E+307))
    {
      absxr *= 0.5;
      absxi *= 0.5;
      absxi = muDoubleScalarHypot(absxr, absxi);
      if (absxi > absxr) {
        absxr = muDoubleScalarSqrt(absxi) * muDoubleScalarSqrt(absxr / absxi +
          1.0);
      } else {
        absxr = muDoubleScalarSqrt(absxi) * 1.4142135623730951;
      }
    } else {
      absxr = muDoubleScalarSqrt((muDoubleScalarHypot(absxr, absxi) + absxr) *
        0.5);
    }

    if (xr > 0.0) {
      absxi = 0.5 * (xi / absxr);
    } else {
      if (xi < 0.0) {
        absxi = -absxr;
      } else {
        absxi = absxr;
      }

      absxr = 0.5 * (xi / absxi);
    }
  }

  x->re = absxr;
  x->im = absxi;
}

static void binary_expand_op(real_T in1_data[], int32_T in1_size[2], real_T in2
  [2], int32_T in3_size[2], real_T in4_data[], int32_T in4_size[2])
{
  real_T in2_data[2];
  int32_T aux_1_1;
  int32_T i;
  int32_T i1;
  int32_T in2_size_idx_1;
  int32_T loop_ub;
  int32_T stride_1_1;
  if (in4_size[1] == 1) {
    in2_size_idx_1 = in3_size[1];
  } else {
    in2_size_idx_1 = in4_size[1];
  }

  stride_1_1 = (in4_size[1] != 1);
  aux_1_1 = 0;
  if (in4_size[1] == 1) {
    loop_ub = in3_size[1];
  } else {
    loop_ub = in4_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 2; i1++) {
      in2_data[i1 + (i << 1)] = in2[i1] + in4_data[i1 + (aux_1_1 << 1)];
    }

    aux_1_1 += stride_1_1;
  }

  in1_size[0] = 2;
  in1_size[1] = in2_size_idx_1;
  for (i = 0; i < in2_size_idx_1; i++) {
    for (i1 = 0; i1 < 2; i1++) {
      in1_data[i1 + (i << 1)] = in2_data[i1 + (i << 1)];
    }
  }
}

static void binary_expand_op_1(real_T in1_data[], int32_T in1_size[2], real_T
  in2[2], int32_T in3_size[2], real_T in4, int32_T in5_size[2])
{
  real_T d;
  int32_T in3[2];
  int32_T in5[2];
  int32_T i;
  int32_T loop_ub;
  d = b_sumColumnB(in2);
  for (i = 0; i < 2; i++) {
    in3[i] = in3_size[i];
  }

  for (i = 0; i < 2; i++) {
    in5[i] = in5_size[i];
  }

  in1_size[0] = 1;
  if (in5[1] == 1) {
    in1_size[1] = in3[1];
  } else {
    in1_size[1] = in5[1];
  }

  if (in5[1] == 1) {
    loop_ub = in3[1];
  } else {
    loop_ub = in5[1];
  }

  for (i = 0; i < loop_ub; i++) {
    in1_data[i] = d / in4;
  }
}

static void rdivide(real_T in1_data[], int32_T in1_size[2], real_T in2_data[],
                    int32_T in2_size[2])
{
  real_T b_in1_data[212];
  int32_T aux_0_0;
  int32_T aux_1_0;
  int32_T i;
  int32_T i1;
  int32_T in1_size_idx_0;
  int32_T loop_ub;
  int32_T stride_0_0;
  int32_T stride_1_0;
  if (in2_size[0] == 1) {
    in1_size_idx_0 = in1_size[0];
  } else {
    in1_size_idx_0 = in2_size[0];
  }

  stride_0_0 = (in1_size[0] != 1);
  stride_1_0 = (in2_size[0] != 1);
  for (i = 0; i < 2; i++) {
    aux_0_0 = 0;
    aux_1_0 = 0;
    if (in2_size[0] == 1) {
      loop_ub = in1_size[0];
    } else {
      loop_ub = in2_size[0];
    }

    for (i1 = 0; i1 < loop_ub; i1++) {
      b_in1_data[i1 + in1_size_idx_0 * i] = in1_data[aux_0_0 + in1_size[0] * i] /
        in2_data[aux_1_0 + in2_size[0] * i];
      aux_1_0 += stride_1_0;
      aux_0_0 += stride_0_0;
    }
  }

  in1_size[0] = in1_size_idx_0;
  in1_size[1] = 2;
  for (i = 0; i < 2; i++) {
    for (i1 = 0; i1 < in1_size_idx_0; i1++) {
      in1_data[i1 + in1_size[0] * i] = b_in1_data[i1 + in1_size_idx_0 * i];
    }
  }
}

static void binary_expand_op_2(coder_array_real_T_2D *in1, coder_array_real_T_3D
  *in2, real_T in3_data[], int32_T in3_size[4])
{
  coder_array_real_T_2D d_in2;
  int32_T aux_1_1;
  int32_T b_in2;
  int32_T c_in2;
  int32_T i;
  int32_T i1;
  int32_T in3;
  int32_T loop_ub;
  b_in2 = in2->size[1];
  c_in2 = in2->size[2];
  in3 = in3_size[3];
  i = b_in2 * c_in2;
  loop_ub = 6 * in3;
  array_real_T_2D_Constructor(&d_in2);
  if (loop_ub == 1) {
    i1 = i;
  } else {
    i1 = loop_ub;
  }

  array_real_T_2D_SetSize(&d_in2, 3, i1);
  b_in2 = (i != 1);
  c_in2 = (loop_ub != 1);
  in3 = 0;
  aux_1_1 = 0;
  if (loop_ub == 1) {
    loop_ub = i;
  }

  for (i = 0; i < loop_ub; i++) {
    for (i1 = 0; i1 < 3; i1++) {
      d_in2.vector.data[i1 + 3 * i] = in2->vector.data[i1 + 3 * in3] *
        in3_data[i1 + 3 * aux_1_1];
    }

    aux_1_1 += c_in2;
    in3 += b_in2;
  }

  d_sum(&d_in2, in1);
  array_real_T_2D_Destructor(&d_in2);
}

static void binary_expand_op_7(real_T in1_data[], int32_T in1_size[1], real_T
  in2_data[], int32_T in2_size[2], real_T in3_data[], int32_T in3_size[2])
{
  real_T b_in2_data[100];
  int32_T aux_0_0;
  int32_T aux_1_0;
  int32_T in2;
  int32_T in2_size_idx_0;
  int32_T in3;
  int32_T stride_0_0;
  int32_T stride_1_0;
  in2 = in2_size[0];
  in3 = in3_size[0];
  if (in3 == 1) {
    in2_size_idx_0 = in2;
  } else {
    in2_size_idx_0 = in3;
  }

  stride_0_0 = (in2 != 1);
  stride_1_0 = (in3 != 1);
  aux_0_0 = 0;
  aux_1_0 = 0;
  if (in3 == 1) {
    in3 = in2;
  }

  for (in2 = 0; in2 < in3; in2++) {
    b_in2_data[in2] = in2_data[aux_0_0 + in2_size[0]] / in3_data[aux_1_0 +
      (in3_size[0] << 1)];
    aux_1_0 += stride_1_0;
    aux_0_0 += stride_0_0;
  }

  in1_size[0] = in2_size_idx_0;
  for (in2 = 0; in2 < in2_size_idx_0; in2++) {
    in1_data[in2] = b_in2_data[in2];
  }
}

static void minus(creal_T in1_data[], int32_T in1_size[2], creal_T in2_data[],
                  int32_T in2_size[2], creal_T in3_data[], int32_T in3_size[2])
{
  creal_T b_in2_data[100];
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T i;
  int32_T in2_size_idx_1;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;
  if (in3_size[1] == 1) {
    in2_size_idx_1 = in2_size[1];
  } else {
    in2_size_idx_1 = in3_size[1];
  }

  stride_0_1 = (in2_size[1] != 1);
  stride_1_1 = (in3_size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in3_size[1] == 1) {
    loop_ub = in2_size[1];
  } else {
    loop_ub = in3_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    b_in2_data[i].re = in2_data[aux_0_1].re - in3_data[aux_1_1].re;
    b_in2_data[i].im = in2_data[aux_0_1].im - in3_data[aux_1_1].im;
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1_size[0] = 1;
  in1_size[1] = in2_size_idx_1;
  for (i = 0; i < in2_size_idx_1; i++) {
    in1_data[i].re = b_in2_data[i].re;
    in1_data[i].im = b_in2_data[i].im;
  }
}

static void binary_expand_op_8(real_T in1_data[], int32_T in1_size[2], real_T
  in2_data[], int32_T in2_size[2])
{
  real_T b_in1_data[100];
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T i;
  int32_T in1_size_idx_1;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;
  if (in2_size[1] == 1) {
    in1_size_idx_1 = in1_size[1];
  } else {
    in1_size_idx_1 = in2_size[1];
  }

  stride_0_1 = (in1_size[1] != 1);
  stride_1_1 = (in2_size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in2_size[1] == 1) {
    loop_ub = in1_size[1];
  } else {
    loop_ub = in2_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    b_in1_data[i] = in1_data[aux_0_1] - in2_data[aux_1_1];
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1_size[0] = 1;
  in1_size[1] = in1_size_idx_1;
  for (i = 0; i < in1_size_idx_1; i++) {
    in1_data[i] = b_in1_data[i];
  }
}

static void b_rdivide(real_T in1_data[], int32_T in1_size[2], real_T in2_data[],
                      int32_T in2_size[2])
{
  real_T b_in1_data[2100];
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T i;
  int32_T in1_size_idx_1;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;
  if (in2_size[1] == 1) {
    in1_size_idx_1 = in1_size[1];
  } else {
    in1_size_idx_1 = in2_size[1];
  }

  stride_0_1 = (in1_size[1] != 1);
  stride_1_1 = (in2_size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in2_size[1] == 1) {
    loop_ub = in1_size[1];
  } else {
    loop_ub = in2_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    b_in1_data[i] = in1_data[aux_0_1] / in2_data[aux_1_1];
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1_size[0] = 1;
  in1_size[1] = in1_size_idx_1;
  for (i = 0; i < in1_size_idx_1; i++) {
    in1_data[i] = b_in1_data[i];
  }
}

static void binary_expand_op_9(real_T in1_data[], int32_T in1_size[2], cuint8_T
  in2, creal_T in3_data[], int32_T in3_size[2], real_T in4_data[], int32_T
  in4_size[2], real_T in5)
{
  real_T in2_data[2100];
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T i;
  int32_T in2_size_idx_1;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;
  if (in4_size[1] == 1) {
    in2_size_idx_1 = in3_size[1];
  } else {
    in2_size_idx_1 = in4_size[1];
  }

  stride_0_1 = (in3_size[1] != 1);
  stride_1_1 = (in4_size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in4_size[1] == 1) {
    loop_ub = in3_size[1];
  } else {
    loop_ub = in4_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    in2_data[i] = (real_T)in2.re - in3_data[aux_0_1].re * (in4_data[aux_1_1] +
      in5);
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1_size[0] = 1;
  in1_size[1] = in2_size_idx_1;
  for (i = 0; i < in2_size_idx_1; i++) {
    in1_data[i] = in2_data[i];
  }
}

static void times(creal_T in1_data[], int32_T in1_size[2], creal_T in2_data[],
                  int32_T in2_size[2])
{
  creal_T b_in1_data[100];
  int32_T aux_0_1;
  int32_T aux_1_1;
  int32_T i;
  int32_T in1_size_idx_1;
  int32_T loop_ub;
  int32_T stride_0_1;
  int32_T stride_1_1;
  if (in2_size[1] == 1) {
    in1_size_idx_1 = in1_size[1];
  } else {
    in1_size_idx_1 = in2_size[1];
  }

  stride_0_1 = (in1_size[1] != 1);
  stride_1_1 = (in2_size[1] != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  if (in2_size[1] == 1) {
    loop_ub = in1_size[1];
  } else {
    loop_ub = in2_size[1];
  }

  for (i = 0; i < loop_ub; i++) {
    b_in1_data[i].re = in1_data[aux_0_1].re * in2_data[aux_1_1].re -
      in1_data[aux_0_1].im * in2_data[aux_1_1].im;
    b_in1_data[i].im = in1_data[aux_0_1].re * in2_data[aux_1_1].im +
      in1_data[aux_0_1].im * in2_data[aux_1_1].re;
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1_size[0] = 1;
  in1_size[1] = in1_size_idx_1;
  for (i = 0; i < in1_size_idx_1; i++) {
    in1_data[i].re = b_in1_data[i].re;
    in1_data[i].im = b_in1_data[i].im;
  }
}

static void array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray, int32_T size0, int32_T size1)
{
  b_vision_internal_codegen_cameraIntrinsicsArray *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (b_vision_internal_codegen_cameraIntrinsicsArray *)emlrtMallocMex
      (sizeof(b_vision_internal_codegen_cameraIntrinsicsArray) * (uint32_T)
       newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof
             (b_vision_internal_codegen_cameraIntrinsicsArray) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_real_T_2D_SetSize(coder_array_real_T_2D *coderArray, int32_T
  size0, int32_T size1)
{
  real_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (real_T *)emlrtMallocMex(sizeof(real_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(real_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_char_T_2D_SetSize(coder_array_char_T_2D *coderArray, int32_T
  size0, int32_T size1)
{
  int32_T newCapacity;
  int32_T newNumel;
  char_T *newData;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (char_T *)emlrtMallocMex(sizeof(char_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(char_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_BusLaneBoundary_2D_SetSiz(coder_array_BusLaneBoundary_2D
  *coderArray, int32_T size0, int32_T size1)
{
  BusLaneBoundary *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (BusLaneBoundary *)emlrtMallocMex(sizeof(BusLaneBoundary) *
      (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(BusLaneBoundary) *
             (uint32_T)coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_s_CP1nqD0d6aDeTm14G2mGp_S(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray, int32_T size0)
{
  s_CP1nqD0d6aDeTm14G2mGp *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  newNumel = coderArray->size[0];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (s_CP1nqD0d6aDeTm14G2mGp *)emlrtMallocMex(sizeof
      (s_CP1nqD0d6aDeTm14G2mGp) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(s_CP1nqD0d6aDeTm14G2mGp) *
             (uint32_T)coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  for (newCapacity = coderArray->vector.numel; newCapacity < newNumel;
       newCapacity++) {
    array_s_CP1nqD0d6aDeTm14G2mGp_C(&coderArray->vector.data[newCapacity]);
  }

  coderArray->vector.numel = newNumel;
}

static void array_s_CP1nqD0d6aDeTm14G2mGp_C(s_CP1nqD0d6aDeTm14G2mGp *pStruct)
{
  array_real_T_100x3_Constructor(&pStruct->Coordinates);
}

static void array_real_T_100x3_Constructor(coder_array_real_T_100x3 *pArray)
{
  pArray->size[0] = 0;
  pArray->size[1] = 0;
}

static void array_real_T_3D_SetSize(coder_array_real_T_3D *coderArray, int32_T
  size0, int32_T size1, int32_T size2)
{
  real_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  coderArray->size[2] = size2;
  newNumel = coderArray->size[0] * coderArray->size[1] * coderArray->size[2];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (real_T *)emlrtMallocMex(sizeof(real_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(real_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_real_T_4D_SetSize(coder_array_real_T_4D *coderArray, int32_T
  size0, int32_T size1, int32_T size2, int32_T size3)
{
  real_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  coderArray->size[2] = size2;
  coderArray->size[3] = size3;
  newNumel = coderArray->size[0] * coderArray->size[1] * coderArray->size[2] *
    coderArray->size[3];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (real_T *)emlrtMallocMex(sizeof(real_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(real_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_boolean_T_SetSize(coder_array_boolean_T *coderArray, int32_T
  size0)
{
  int32_T newCapacity;
  int32_T newNumel;
  boolean_T *newData;
  coderArray->size[0] = size0;
  newNumel = coderArray->size[0];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (boolean_T *)emlrtMallocMex(sizeof(boolean_T) * (uint32_T)
      newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(boolean_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_boolean_T_2D_SetSize(coder_array_boolean_T_2D *coderArray,
  int32_T size0, int32_T size1)
{
  int32_T newCapacity;
  int32_T newNumel;
  boolean_T *newData;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (boolean_T *)emlrtMallocMex(sizeof(boolean_T) * (uint32_T)
      newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(boolean_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_int32_T_SetSize(coder_array_int32_T *coderArray, int32_T size0)
{
  int32_T newCapacity;
  int32_T newNumel;
  int32_T *newData;
  coderArray->size[0] = size0;
  newNumel = coderArray->size[0];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (int32_T *)emlrtMallocMex(sizeof(int32_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(int32_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_int32_T_2D_SetSize(coder_array_int32_T_2D *coderArray, int32_T
  size0, int32_T size1)
{
  int32_T newCapacity;
  int32_T newNumel;
  int32_T *newData;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (int32_T *)emlrtMallocMex(sizeof(int32_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(int32_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_real_T_SetSize(coder_array_real_T *coderArray, int32_T size0)
{
  real_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  newNumel = coderArray->size[0];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (real_T *)emlrtMallocMex(sizeof(real_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(real_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_creal_T_SetSize(coder_array_creal_T *coderArray, int32_T size0)
{
  creal_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  newNumel = coderArray->size[0];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (creal_T *)emlrtMallocMex(sizeof(creal_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(creal_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_creal_T_2D_SetSize(coder_array_creal_T_2D *coderArray, int32_T
  size0, int32_T size1)
{
  creal_T *newData;
  int32_T newCapacity;
  int32_T newNumel;
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  newNumel = coderArray->size[0] * coderArray->size[1];
  if (newNumel > coderArray->vector.allocated) {
    newCapacity = coderArray->vector.allocated;
    if (newCapacity < 16) {
      newCapacity = 16;
    }

    while (newCapacity < newNumel) {
      if (newCapacity > 1073741823) {
        newCapacity = MAX_int32_T;
      } else {
        newCapacity <<= 1;
      }
    }

    newData = (creal_T *)emlrtMallocMex(sizeof(creal_T) * (uint32_T)newCapacity);
    if (coderArray->vector.data != NULL) {
      memcpy(newData, coderArray->vector.data, sizeof(creal_T) * (uint32_T)
             coderArray->vector.numel);
      if (coderArray->vector.owner) {
        emlrtFreeMex(coderArray->vector.data);
      }
    }

    coderArray->vector.data = newData;
    coderArray->vector.allocated = newCapacity;
    coderArray->vector.owner = true;
  }

  coderArray->vector.numel = newNumel;
}

static void array_cameraIntrinsics_Construc(cameraIntrinsics *pStruct)
{
  b_array_vision_internal_codegen_c(&pStruct->cameraIntrinsicsArrayData);
}

static void b_array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray)
{
  coderArray->vector.data = (b_vision_internal_codegen_cameraIntrinsicsArray *)
    NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void c_array_vision_internal_codegen_c(coder_array_vision_internal_cod
  *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data !=
       (b_vision_internal_codegen_cameraIntrinsicsArray *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_cameraIntrinsics_Destruct(cameraIntrinsics *pStruct)
{
  c_array_vision_internal_codegen_c(&pStruct->cameraIntrinsicsArrayData);
}

static void array_real_T_2D_Reserve(coder_array_real_T_2D *coderArray, int32_T
  b_numel)
{
  int32_T size0;
  int32_T size1;
  size0 = coderArray->size[0];
  size1 = coderArray->size[1];
  array_real_T_2D_SetSize(coderArray, 1, b_numel);
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
}

static void array_real_T_2D_Constructor(coder_array_real_T_2D *coderArray)
{
  coderArray->vector.data = (real_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_real_T_2D_Destructor(coder_array_real_T_2D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (real_T *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void b_array_s_CP1nqD0d6aDeTm14G2mGp_C(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray)
{
  coderArray->vector.data = (s_CP1nqD0d6aDeTm14G2mGp *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
}

static void array_s_CP1nqD0d6aDeTm14G2mGp_D(coder_array_s_CP1nqD0d6aDeTm14G
  *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data !=
       (s_CP1nqD0d6aDeTm14G2mGp *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_matlabshared_scenario_Sen
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *pStruct)
{
  array_char_T_2D_Constructor(&pStruct->UniqueID);
}

static void array_char_T_2D_Constructor(coder_array_char_T_2D *coderArray)
{
  coderArray->vector.data = (char_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_char_T_2D_Destructor(coder_array_char_T_2D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (char_T *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void b_array_matlabshared_scenario_Sen
  (matlabshared_scenario_SensorSimulation_coder_SensorSimCoder *pStruct)
{
  array_char_T_2D_Destructor(&pStruct->UniqueID);
}

static void array_BusLaneBoundary_2D_Constr(coder_array_BusLaneBoundary_2D
  *coderArray)
{
  coderArray->vector.data = (BusLaneBoundary *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_BusLaneBoundary_2D_Destru(coder_array_BusLaneBoundary_2D
  *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (BusLaneBoundary *)
       NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_real_T_3D_Reserve(coder_array_real_T_3D *coderArray, int32_T
  b_numel)
{
  int32_T size0;
  int32_T size1;
  int32_T size2;
  size0 = coderArray->size[0];
  size1 = coderArray->size[1];
  size2 = coderArray->size[2];
  array_real_T_3D_SetSize(coderArray, 1, 1, b_numel);
  coderArray->size[0] = size0;
  coderArray->size[1] = size1;
  coderArray->size[2] = size2;
}

static void array_real_T_3D_Constructor(coder_array_real_T_3D *coderArray)
{
  coderArray->vector.data = (real_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
  coderArray->size[2] = 0;
}

static void array_real_T_4D_Constructor(coder_array_real_T_4D *coderArray)
{
  coderArray->vector.data = (real_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
  coderArray->size[2] = 0;
  coderArray->size[3] = 0;
}

static void array_real_T_3D_Destructor(coder_array_real_T_3D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (real_T *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_real_T_4D_Destructor(coder_array_real_T_4D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (real_T *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_boolean_T_Reserve(coder_array_boolean_T *coderArray, int32_T
  b_numel)
{
  int32_T size0;
  size0 = coderArray->size[0];
  array_boolean_T_SetSize(coderArray, b_numel);
  coderArray->size[0] = size0;
}

static void array_boolean_T_2D_Constructor(coder_array_boolean_T_2D *coderArray)
{
  coderArray->vector.data = (boolean_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_boolean_T_Constructor(coder_array_boolean_T *coderArray)
{
  coderArray->vector.data = (boolean_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
}

static void array_boolean_T_2D_Destructor(coder_array_boolean_T_2D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (boolean_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_boolean_T_Destructor(coder_array_boolean_T *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (boolean_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_int32_T_Constructor(coder_array_int32_T *coderArray)
{
  coderArray->vector.data = (int32_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
}

static void array_int32_T_Destructor(coder_array_int32_T *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (int32_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_int32_T_2D_Constructor(coder_array_int32_T_2D *coderArray)
{
  coderArray->vector.data = (int32_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_real_T_Constructor(coder_array_real_T *coderArray)
{
  coderArray->vector.data = (real_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
}

static void array_int32_T_2D_Destructor(coder_array_int32_T_2D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (int32_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_real_T_Destructor(coder_array_real_T *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (real_T *)NULL)) {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_creal_T_2D_Constructor(coder_array_creal_T_2D *coderArray)
{
  coderArray->vector.data = (creal_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
  coderArray->size[1] = 0;
}

static void array_creal_T_Constructor(coder_array_creal_T *coderArray)
{
  coderArray->vector.data = (creal_T *)NULL;
  coderArray->vector.numel = 0;
  coderArray->vector.allocated = 0;
  coderArray->vector.owner = true;
  coderArray->size[0] = 0;
}

static void array_creal_T_2D_Destructor(coder_array_creal_T_2D *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (creal_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static void array_creal_T_Destructor(coder_array_creal_T *coderArray)
{
  if (coderArray->vector.owner && (coderArray->vector.data != (creal_T *)NULL))
  {
    emlrtFreeMex(coderArray->vector.data);
  }
}

static int32_T div_nzp_s32_floor(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  uint32_T absDenominator;
  uint32_T absNumerator;
  uint32_T tempAbsQuotient;
  boolean_T quotientNeedsNegation;
  if (numerator < 0) {
    absNumerator = ~(uint32_T)numerator + 1U;
  } else {
    absNumerator = (uint32_T)numerator;
  }

  if (denominator < 0) {
    absDenominator = ~(uint32_T)denominator + 1U;
  } else {
    absDenominator = (uint32_T)denominator;
  }

  quotientNeedsNegation = ((numerator < 0) != (denominator < 0));
  tempAbsQuotient = absNumerator / absDenominator;
  if (quotientNeedsNegation) {
    absNumerator %= absDenominator;
    if (absNumerator > 0U) {
      tempAbsQuotient++;
    }
  }

  if (quotientNeedsNegation) {
    quotient = -(int32_T)tempAbsQuotient;
  } else {
    quotient = (int32_T)tempAbsQuotient;
  }

  return quotient;
}

static int32_T div_s32(const emlrtStack *sp, int32_T numerator, int32_T
  denominator)
{
  int32_T quotient;
  uint32_T absDenominator;
  uint32_T absNumerator;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }

    emlrtDivisionByZeroWarningOrError2018b(NULL, (emlrtConstCTX)sp);
  } else {
    if (numerator < 0) {
      absNumerator = ~(uint32_T)numerator + 1U;
    } else {
      absNumerator = (uint32_T)numerator;
    }

    if (denominator < 0) {
      absDenominator = ~(uint32_T)denominator + 1U;
    } else {
      absDenominator = (uint32_T)denominator;
    }

    absNumerator /= absDenominator;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -(int32_T)absNumerator;
    } else {
      quotient = (int32_T)absNumerator;
    }
  }

  return quotient;
}

static int32_T div_nzp_s32(int32_T numerator, int32_T denominator)
{
  int32_T quotient;
  uint32_T absDenominator;
  uint32_T absNumerator;
  if (numerator < 0) {
    absNumerator = ~(uint32_T)numerator + 1U;
  } else {
    absNumerator = (uint32_T)numerator;
  }

  if (denominator < 0) {
    absDenominator = ~(uint32_T)denominator + 1U;
  } else {
    absDenominator = (uint32_T)denominator;
  }

  absNumerator /= absDenominator;
  if ((numerator < 0) != (denominator < 0)) {
    quotient = -(int32_T)absNumerator;
  } else {
    quotient = (int32_T)absNumerator;
  }

  return quotient;
}

static void init_simulink_io_address(InstanceStruct_bMSBvimYBF1JK60KEX336
  *moduleInstance)
{
  moduleInstance->emlrtRootTLSGlobal = (void *)cgxertGetEMLRTCtx
    (moduleInstance->S);
  moduleInstance->u0 = (BusWorldToVehicleActors *)cgxertGetInputPortSignal
    (moduleInstance->S, 0);
  moduleInstance->u1 = (BusLaneBoundaries *)cgxertGetInputPortSignal
    (moduleInstance->S, 1);
  moduleInstance->b_y0 = (BusObjectDetections1 *)cgxertGetOutputPortSignal
    (moduleInstance->S, 0);
  moduleInstance->b_y1 = (BusLaneDetections1 *)cgxertGetOutputPortSignal
    (moduleInstance->S, 1);
}

/* CGXE Glue Code */
static void mdlOutputs_bMSBvimYBF1JK60KEX336(SimStruct *S, int_T tid)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_outputs(moduleInstance);
}

static void mdlInitialize_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_initialize(moduleInstance);
}

static void mdlUpdate_bMSBvimYBF1JK60KEX336(SimStruct *S, int_T tid)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_update(moduleInstance);
}

static void mdlDerivatives_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_derivative(moduleInstance);
}

static void mdlTerminate_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_terminate(moduleInstance);
  free((void *)moduleInstance);
}

static void mdlEnable_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_enable(moduleInstance);
}

static void mdlDisable_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)cgxertGetRuntimeInstance(S);
  cgxe_mdl_disable(moduleInstance);
}

static void mdlStart_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
  InstanceStruct_bMSBvimYBF1JK60KEX336 *moduleInstance =
    (InstanceStruct_bMSBvimYBF1JK60KEX336 *)calloc(1, sizeof
    (InstanceStruct_bMSBvimYBF1JK60KEX336));
  moduleInstance->S = S;
  cgxertSetRuntimeInstance(S, (void *)moduleInstance);
  ssSetmdlOutputs(S, mdlOutputs_bMSBvimYBF1JK60KEX336);
  ssSetmdlInitializeConditions(S, mdlInitialize_bMSBvimYBF1JK60KEX336);
  ssSetmdlUpdate(S, mdlUpdate_bMSBvimYBF1JK60KEX336);
  ssSetmdlDerivatives(S, mdlDerivatives_bMSBvimYBF1JK60KEX336);
  ssSetmdlTerminate(S, mdlTerminate_bMSBvimYBF1JK60KEX336);
  ssSetmdlEnable(S, mdlEnable_bMSBvimYBF1JK60KEX336);
  ssSetmdlDisable(S, mdlDisable_bMSBvimYBF1JK60KEX336);
  cgxe_mdl_start(moduleInstance);

  {
    uint_T options = ssGetOptions(S);
    options |= SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE;
    ssSetOptions(S, options);
  }
}

static void mdlProcessParameters_bMSBvimYBF1JK60KEX336(SimStruct *S)
{
}

void method_dispatcher_bMSBvimYBF1JK60KEX336(SimStruct *S, int_T method, void
  *data)
{
  switch (method) {
   case SS_CALL_MDL_START:
    mdlStart_bMSBvimYBF1JK60KEX336(S);
    break;

   case SS_CALL_MDL_PROCESS_PARAMETERS:
    mdlProcessParameters_bMSBvimYBF1JK60KEX336(S);
    break;

   default:
    /* Unhandled method */
    /*
       sf_mex_error_message("Stateflow Internal Error:\n"
       "Error calling method dispatcher for module: bMSBvimYBF1JK60KEX336.\n"
       "Can't handle method %d.\n", method);
     */
    break;
  }
}

mxArray *cgxe_bMSBvimYBF1JK60KEX336_BuildInfoUpdate(void)
{
  mxArray * mxBIArgs;
  mxArray * elem_1;
  mxArray * elem_2;
  mxArray * elem_3;
  mxArray * elem_4;
  mxArray * elem_5;
  mxArray * elem_6;
  mxArray * elem_7;
  mxArray * elem_8;
  mxArray * elem_9;
  mxArray * elem_10;
  mxArray * elem_11;
  mxArray * elem_12;
  mxArray * elem_13;
  mxArray * elem_14;
  mxArray * elem_15;
  mxArray * elem_16;
  mxArray * elem_17;
  mxArray * elem_18;
  mxArray * elem_19;
  mxArray * elem_20;
  mxArray * elem_21;
  mxArray * elem_22;
  mxArray * elem_23;
  mxArray * elem_24;
  mxArray * elem_25;
  mxArray * elem_26;
  mxArray * elem_27;
  mxArray * elem_28;
  mxArray * elem_29;
  mxArray * elem_30;
  mxBIArgs = mxCreateCellMatrix(1,3);
  elem_1 = mxCreateCellMatrix(1,6);
  elem_2 = mxCreateCellMatrix(0,0);
  mxSetCell(elem_1,0,elem_2);
  elem_3 = mxCreateCellMatrix(1,4);
  elem_4 = mxCreateString("addIncludeFiles");
  mxSetCell(elem_3,0,elem_4);
  elem_5 = mxCreateCellMatrix(1,4);
  elem_6 = mxCreateString("SSFCodeGenGatewayFcn.hpp");
  mxSetCell(elem_5,0,elem_6);
  elem_7 = mxCreateString("blas.h");
  mxSetCell(elem_5,1,elem_7);
  elem_8 = mxCreateString("lapacke.h");
  mxSetCell(elem_5,2,elem_8);
  elem_9 = mxCreateString("polygonBoolean.h");
  mxSetCell(elem_5,3,elem_9);
  mxSetCell(elem_3,1,elem_5);
  elem_10 = mxCreateCellMatrix(1,4);
  elem_11 = mxCreateString("");
  mxSetCell(elem_10,0,elem_11);
  elem_12 = mxCreateString("");
  mxSetCell(elem_10,1,elem_12);
  elem_13 = mxCreateString("");
  mxSetCell(elem_10,2,elem_13);
  elem_14 = mxCreateString("");
  mxSetCell(elem_10,3,elem_14);
  mxSetCell(elem_3,2,elem_10);
  elem_15 = mxCreateCellMatrix(1,4);
  elem_16 = mxCreateString("");
  mxSetCell(elem_15,0,elem_16);
  elem_17 = mxCreateString("");
  mxSetCell(elem_15,1,elem_17);
  elem_18 = mxCreateString("");
  mxSetCell(elem_15,2,elem_18);
  elem_19 = mxCreateString("");
  mxSetCell(elem_15,3,elem_19);
  mxSetCell(elem_3,3,elem_15);
  mxSetCell(elem_1,1,elem_3);
  elem_20 = mxCreateCellMatrix(0,0);
  mxSetCell(elem_1,2,elem_20);
  elem_21 = mxCreateCellMatrix(0,0);
  mxSetCell(elem_1,3,elem_21);
  elem_22 = mxCreateCellMatrix(0,0);
  mxSetCell(elem_1,4,elem_22);
  elem_23 = mxCreateCellMatrix(0,0);
  mxSetCell(elem_1,5,elem_23);
  mxSetCell(mxBIArgs,0,elem_1);
  elem_24 = mxCreateCellMatrix(1,5);
  elem_25 = mxCreateString("coder.internal.blas.BLASApi");
  mxSetCell(elem_24,0,elem_25);
  elem_26 = mxCreateString(
    "matlabshared.scenario.SensorSimulation.coder.SensorSimCoder");
  mxSetCell(elem_24,1,elem_26);
  elem_27 = mxCreateString(
    "matlabshared.scenario.SensorSimulation.coder.SensorSimCoderUtils");
  mxSetCell(elem_24,2,elem_27);
  elem_28 = mxCreateString("coder.internal.lapack.LAPACKApi");
  mxSetCell(elem_24,3,elem_28);
  elem_29 = mxCreateString(
    "matlabshared.tracking.internal.fusion.PolygonBooleanAPI");
  mxSetCell(elem_24,4,elem_29);
  mxSetCell(mxBIArgs,1,elem_24);
  elem_30 = mxCreateCellMatrix(1,0);
  mxSetCell(mxBIArgs,2,elem_30);
  return mxBIArgs;
}

mxArray *cgxe_bMSBvimYBF1JK60KEX336_fallback_info(void)
{
  const char* fallbackInfoFields[] = { "fallbackType", "incompatiableSymbol" };

  mxArray* fallbackInfoStruct = mxCreateStructMatrix(1, 1, 2, fallbackInfoFields);
  mxArray* fallbackType = mxCreateString("thirdPartyLibs");
  mxArray* incompatibleSymbol = mxCreateString(
    "matlabshared.scenario.SensorSimulation.coder.SensorSimCoder");
  mxSetFieldByNumber(fallbackInfoStruct, 0, 0, fallbackType);
  mxSetFieldByNumber(fallbackInfoStruct, 0, 1, incompatibleSymbol);
  return fallbackInfoStruct;
}
